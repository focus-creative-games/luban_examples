
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

pub mod login;

use super::*;
use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum DemoEnum {
    NONE = 0,
    ///aa
    A = 1,
    ///bb
    B = 2,
    ///cc
    C = 4,
    ///dd
    D = 5,
    Any = 6,
}

impl From<i32> for DemoEnum {
    fn from(value: i32) -> Self {
        match value { 
            0 => DemoEnum::NONE,
            1 => DemoEnum::A,
            2 => DemoEnum::B,
            4 => DemoEnum::C,
            5 => DemoEnum::D,
            6 => DemoEnum::Any,
            _ => panic!("Invalid value for DemoEnum:{}", value),
        }
    }
}

bitflags::bitflags!{    
    #[derive(Debug, Hash, Eq, PartialEq)]
    pub struct DemoFlag : u32 {
        const A = 1;
        const B = 2;
        const C = 4;
        const D = 8;
    }
}
#[derive(Debug)]
pub struct TestExcelBean1 {
    /// 最高品质
    pub x1: i32,
    /// 黑色的
    pub x2: String,
    /// 蓝色的
    pub x3: i32,
    /// 最差品质
    pub x4: f32,
}

impl TestExcelBean1{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestExcelBean1, LubanError> {
        let x1 = buf.read_int();
        let x2 = buf.read_string();
        let x3 = buf.read_int();
        let x4 = buf.read_float();
        
        Ok(TestExcelBean1 { x1, x2, x3, x4, })
    }

    pub const __ID__: i32 = -1738345160;
}

#[derive(Debug)]
pub struct DemoType2 {
    pub x4: i32,
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub x8_0: i16,
    pub x8: i32,
    pub x9: i64,
    pub x10: String,
    pub x12: crate::test::DemoType1,
    pub x13: crate::test::DemoEnum,
    pub x14: std::sync::Arc<AbstractBase>,
    pub s1: String,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k5: std::collections::HashSet<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k15: Vec<std::sync::Arc<AbstractBase>>,
}

impl DemoType2{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoType2, LubanError> {
        let x4 = buf.read_int();
        let x1 = buf.read_bool();
        let x2 = buf.read_byte();
        let x3 = buf.read_short();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x7 = buf.read_double();
        let x8_0 = buf.read_short();
        let x8 = buf.read_int();
        let x9 = buf.read_long();
        let x10 = buf.read_string();
        let x12 = crate::test::DemoType1::new(&mut buf)?;
        let x13 = buf.read_int().into();
        let x14 = crate::test::DemoDynamic::new(&mut buf)?;
        let s1 = buf.read_string();
        let t1 = buf.read_ulong();
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k5 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoE2::new(&mut buf)?); } _e0 };
        let k15 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoDynamic::new(&mut buf)?); } _e0 };
        
        Ok(DemoType2 { x4, x1, x2, x3, x5, x6, x7, x8_0, x8, x9, x10, x12, x13, x14, s1, t1, k1, k2, k5, k8, k9, k15, })
    }

    pub const __ID__: i32 = -367048295;
}

#[derive(Debug)]
pub struct DemoType1 {
    pub x1: i32,
}

impl DemoType1{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoType1, LubanError> {
        let x1 = buf.read_int();
        
        Ok(DemoType1 { x1, })
    }

    pub const __ID__: i32 = -367048296;
}

#[derive(Debug)]
pub struct DemoDynamic {
    pub x1: i32,
}

impl DemoDynamic {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::DemoD2::__ID__ => Ok(std::sync::Arc::new(crate::test::DemoD2::new(buf)?)),
            crate::test::DemoE1::__ID__ => Ok(std::sync::Arc::new(crate::test::DemoE1::new(buf)?)),
            crate::test::login::RoleInfo::__ID__ => Ok(std::sync::Arc::new(crate::test::login::RoleInfo::new(buf)?)),
            crate::test::DemoD5::__ID__ => Ok(std::sync::Arc::new(crate::test::DemoD5::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoDynamic:{}", type_id)))
        }
    }
}

pub trait TDemoDynamic {
    fn get_x1(&self) -> &i32;
}

impl crate::test::TDemoDynamic for crate::test::DemoD2 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl crate::test::TDemoDynamic for crate::test::DemoE1 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl crate::test::TDemoDynamic for crate::test::login::RoleInfo {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl crate::test::TDemoDynamic for crate::test::DemoD5 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TDemoDynamic> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TDemoDynamic, LubanError> {
        let base: Result<&crate::test::DemoD2, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::DemoE1, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::login::RoleInfo, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::DemoD5, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for DemoDynamic")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoD2 {
    pub x1: i32,
    pub x2: i32,
}

impl DemoD2{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoD2, LubanError> {
        let x1 = buf.read_int();
        let x2 = buf.read_int();
        
        Ok(DemoD2 { x1, x2, })
    }

    pub const __ID__: i32 = -2138341747;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoD3 {
    pub x1: i32,
    pub x3: i32,
}

impl DemoD3 {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::DemoE1::__ID__ => Ok(std::sync::Arc::new(crate::test::DemoE1::new(buf)?)),
            crate::test::login::RoleInfo::__ID__ => Ok(std::sync::Arc::new(crate::test::login::RoleInfo::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoD3:{}", type_id)))
        }
    }
}

pub trait TDemoD3 {
    fn get_x1(&self) -> &i32;
    fn get_x3(&self) -> &i32;
}

impl crate::test::TDemoD3 for crate::test::DemoE1 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
    fn get_x3(&self) -> &i32 {
        &self.x3
    }
}

impl crate::test::TDemoD3 for crate::test::login::RoleInfo {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
    fn get_x3(&self) -> &i32 {
        &self.x3
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TDemoD3> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TDemoD3, LubanError> {
        let base: Result<&crate::test::DemoE1, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::login::RoleInfo, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for DemoD3")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoE1 {
    pub x1: i32,
    pub x3: i32,
    pub x4: i32,
}

impl DemoE1{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoE1, LubanError> {
        let x1 = buf.read_int();
        let x3 = buf.read_int();
        let x4 = buf.read_int();
        
        Ok(DemoE1 { x1, x3, x4, })
    }

    pub const __ID__: i32 = -2138341717;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoD5 {
    pub x1: i32,
    pub time: crate::test::DateTimeRange,
}

impl DemoD5{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoD5, LubanError> {
        let x1 = buf.read_int();
        let time = crate::test::DateTimeRange::new(&mut buf)?;
        
        Ok(DemoD5 { x1, time, })
    }

    pub const __ID__: i32 = -2138341744;
}

#[derive(Debug)]
pub struct DateTimeRange {
    pub start_time: u64,
    pub end_time: u64,
}

impl DateTimeRange{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DateTimeRange, LubanError> {
        let start_time = buf.read_ulong();
        let end_time = buf.read_ulong();
        
        Ok(DateTimeRange { start_time, end_time, })
    }

    pub const __ID__: i32 = 495315430;
}

#[derive(Debug)]
pub struct DemoE2 {
    pub y1: Option<i32>,
    pub y2: bool,
}

impl DemoE2{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoE2, LubanError> {
        let mut y1 = if buf.read_bool() { Some(buf.read_int()) } else { None };
        let y2 = buf.read_bool();
        
        Ok(DemoE2 { y1, y2, })
    }

    pub const __ID__: i32 = -2138341716;
}

#[derive(Debug)]
pub struct DemoSingletonType {
    pub id: i32,
    pub name: String,
    pub date: std::sync::Arc<AbstractBase>,
}

impl DemoSingletonType{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoSingletonType, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let date = crate::test::DemoDynamic::new(&mut buf)?;
        
        Ok(DemoSingletonType { id, name, date, })
    }

    pub const __ID__: i32 = 539196998;
}

#[derive(Debug)]
pub struct NotIndexList {
    pub x: i32,
    pub y: i32,
}

impl NotIndexList{
    pub fn new(mut buf: &mut ByteBuf) -> Result<NotIndexList, LubanError> {
        let x = buf.read_int();
        let y = buf.read_int();
        
        Ok(NotIndexList { x, y, })
    }

    pub const __ID__: i32 = -50446599;
}

#[derive(Debug)]
pub struct MultiUnionIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiUnionIndexList{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MultiUnionIndexList, LubanError> {
        let id1 = buf.read_int();
        let id2 = buf.read_long();
        let id3 = buf.read_string();
        let num = buf.read_int();
        let desc = buf.read_string();
        
        Ok(MultiUnionIndexList { id1, id2, id3, num, desc, })
    }

    pub const __ID__: i32 = 1966847134;
}

#[derive(Debug)]
pub struct MultiIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiIndexList{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MultiIndexList, LubanError> {
        let id1 = buf.read_int();
        let id2 = buf.read_long();
        let id3 = buf.read_string();
        let num = buf.read_int();
        let desc = buf.read_string();
        
        Ok(MultiIndexList { id1, id2, id3, num, desc, })
    }

    pub const __ID__: i32 = 2016237651;
}

#[derive(Debug)]
pub struct MultiRowRecord {
    pub id: i32,
    pub name: String,
    pub one_rows: Vec<crate::test::MultiRowType1>,
    pub multi_rows1: Vec<crate::test::MultiRowType1>,
    pub multi_rows2: Vec<crate::test::MultiRowType1>,
    pub multi_rows4: std::collections::HashMap<i32, crate::test::MultiRowType2>,
    pub multi_rows5: Vec<crate::test::MultiRowType3>,
    pub multi_rows6: std::collections::HashMap<i32, crate::test::MultiRowType2>,
    pub multi_rows7: std::collections::HashMap<i32, i32>,
}

impl MultiRowRecord{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MultiRowRecord, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let one_rows = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        let multi_rows1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        let multi_rows2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        let multi_rows4 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = crate::test::MultiRowType2::new(&mut buf)?; _e0.insert(_k0, _v0);} _e0 };
        let multi_rows5 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType3::new(&mut buf)?); } _e0 };
        let multi_rows6 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = crate::test::MultiRowType2::new(&mut buf)?; _e0.insert(_k0, _v0);} _e0 };
        let multi_rows7 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        
        Ok(MultiRowRecord { id, name, one_rows, multi_rows1, multi_rows2, multi_rows4, multi_rows5, multi_rows6, multi_rows7, })
    }

    pub const __ID__: i32 = -501249394;
}

#[derive(Debug)]
pub struct MultiRowType1 {
    pub id: i32,
    pub x: i32,
}

impl MultiRowType1{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MultiRowType1, LubanError> {
        let id = buf.read_int();
        let x = buf.read_int();
        
        Ok(MultiRowType1 { id, x, })
    }

    pub const __ID__: i32 = 540474970;
}

#[derive(Debug)]
pub struct MultiRowType2 {
    pub id: i32,
    pub x: i32,
    pub y: f32,
}

impl MultiRowType2{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MultiRowType2, LubanError> {
        let id = buf.read_int();
        let x = buf.read_int();
        let y = buf.read_float();
        
        Ok(MultiRowType2 { id, x, y, })
    }

    pub const __ID__: i32 = 540474971;
}

#[derive(Debug)]
pub struct MultiRowType3 {
    pub id: i32,
    pub items: Vec<crate::test::MultiRowType1>,
}

impl MultiRowType3{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MultiRowType3, LubanError> {
        let id = buf.read_int();
        let items = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        
        Ok(MultiRowType3 { id, items, })
    }

    pub const __ID__: i32 = 540474972;
}

#[derive(Debug)]
pub struct TestMultiColumn {
    pub id: i32,
    pub a: crate::test::Foo,
    pub b: crate::test::Foo,
    pub c: crate::test::Foo,
}

impl TestMultiColumn{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestMultiColumn, LubanError> {
        let id = buf.read_int();
        let a = crate::test::Foo::new(&mut buf)?;
        let b = crate::test::Foo::new(&mut buf)?;
        let c = crate::test::Foo::new(&mut buf)?;
        
        Ok(TestMultiColumn { id, a, b, c, })
    }

    pub const __ID__: i32 = -294473599;
}

#[derive(Debug)]
pub struct Foo {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
}

impl Foo{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Foo, LubanError> {
        let y1 = buf.read_int();
        let y2 = buf.read_int();
        let y3 = buf.read_int();
        
        Ok(Foo { y1, y2, y3, })
    }

    pub const __ID__: i32 = -1147950774;
}

#[derive(Debug)]
pub struct MultiRowTitle {
    pub id: i32,
    pub name: String,
    pub x1: crate::test::H1,
    pub x2_0: Option<crate::test::H2>,
    pub x2: Vec<crate::test::H2>,
    pub x3: Vec<crate::test::H2>,
    pub x4: Vec<crate::test::H2>,
}

impl MultiRowTitle{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MultiRowTitle, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let x1 = crate::test::H1::new(&mut buf)?;
        let mut x2_0 = if buf.read_bool() { Some(crate::test::H2::new(&mut buf)?) } else { None };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::H2::new(&mut buf)?); } _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::H2::new(&mut buf)?); } _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::H2::new(&mut buf)?); } _e0 };
        
        Ok(MultiRowTitle { id, name, x1, x2_0, x2, x3, x4, })
    }

    pub const __ID__: i32 = 540002427;
}

#[derive(Debug)]
pub struct H1 {
    pub y2: crate::test::H2,
    pub y3: i32,
}

impl H1{
    pub fn new(mut buf: &mut ByteBuf) -> Result<H1, LubanError> {
        let y2 = crate::test::H2::new(&mut buf)?;
        let y3 = buf.read_int();
        
        Ok(H1 { y2, y3, })
    }

    pub const __ID__: i32 = -1422503995;
}

#[derive(Debug)]
pub struct H2 {
    pub z2: i32,
    pub z3: i32,
}

impl H2{
    pub fn new(mut buf: &mut ByteBuf) -> Result<H2, LubanError> {
        let z2 = buf.read_int();
        let z3 = buf.read_int();
        
        Ok(H2 { z2, z3, })
    }

    pub const __ID__: i32 = -1422503994;
}

#[derive(Debug)]
pub struct TestNull {
    pub id: i32,
    pub x1: Option<i32>,
    pub x2: Option<crate::test::DemoEnum>,
    pub x3: Option<crate::test::DemoType1>,
    pub x4: Option<std::sync::Arc<AbstractBase>>,
    pub s1: Option<String>,
    pub s2: Option<String>,
}

impl TestNull{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestNull, LubanError> {
        let id = buf.read_int();
        let mut x1 = if buf.read_bool() { Some(buf.read_int()) } else { None };
        let mut x2 = if buf.read_bool() { Some(buf.read_int().into()) } else { None };
        let mut x3 = if buf.read_bool() { Some(crate::test::DemoType1::new(&mut buf)?) } else { None };
        let mut x4 = if buf.read_bool() { Some(crate::test::DemoDynamic::new(&mut buf)?) } else { None };
        let mut s1 = if buf.read_bool() { Some(buf.read_string()) } else { None };
        let mut s2 = if buf.read_bool() { Some(buf.read_string()) } else { None };
        
        Ok(TestNull { id, x1, x2, x3, x4, s1, s2, })
    }

    pub const __ID__: i32 = 339868469;
}

#[derive(Debug)]
pub struct DemoPrimitiveTypesTable {
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x4: i32,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub s1: String,
    pub s2: String,
    pub v2: crate::vec2,
    pub v3: crate::vec3,
    pub v4: crate::vec4,
    pub t1: u64,
}

impl DemoPrimitiveTypesTable{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoPrimitiveTypesTable, LubanError> {
        let x1 = buf.read_bool();
        let x2 = buf.read_byte();
        let x3 = buf.read_short();
        let x4 = buf.read_int();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x7 = buf.read_double();
        let s1 = buf.read_string();
        let s2 = buf.read_string();
        let v2 = crate::vec2::new(&mut buf)?;
        let v3 = crate::vec3::new(&mut buf)?;
        let v4 = crate::vec4::new(&mut buf)?;
        let t1 = buf.read_ulong();
        
        Ok(DemoPrimitiveTypesTable { x1, x2, x3, x4, x5, x6, x7, s1, s2, v2, v3, v4, t1, })
    }

    pub const __ID__: i32 = -370934083;
}

#[derive(Debug)]
pub struct TestString {
    pub id: String,
    pub s1: String,
    pub s2: String,
    pub cs1: crate::test::CompactString,
    pub cs2: crate::test::CompactString,
}

impl TestString{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestString, LubanError> {
        let id = buf.read_string();
        let s1 = buf.read_string();
        let s2 = buf.read_string();
        let cs1 = crate::test::CompactString::new(&mut buf)?;
        let cs2 = crate::test::CompactString::new(&mut buf)?;
        
        Ok(TestString { id, s1, s2, cs1, cs2, })
    }

    pub const __ID__: i32 = 338485823;
}

#[derive(Debug)]
pub struct CompactString {
    pub id: i32,
    pub s2: String,
    pub s3: String,
}

impl CompactString{
    pub fn new(mut buf: &mut ByteBuf) -> Result<CompactString, LubanError> {
        let id = buf.read_int();
        let s2 = buf.read_string();
        let s3 = buf.read_string();
        
        Ok(CompactString { id, s2, s3, })
    }

    pub const __ID__: i32 = 1968089240;
}

#[derive(Debug)]
pub struct DemoGroup {
    pub id: i32,
    pub x1: i32,
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub x5: crate::test::InnerGroup,
}

impl DemoGroup{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DemoGroup, LubanError> {
        let id = buf.read_int();
        let x1 = buf.read_int();
        let x2 = buf.read_int();
        let x3 = buf.read_int();
        let x4 = buf.read_int();
        let x5 = crate::test::InnerGroup::new(&mut buf)?;
        
        Ok(DemoGroup { id, x1, x2, x3, x4, x5, })
    }

    pub const __ID__: i32 = -379263008;
}

#[derive(Debug)]
pub struct InnerGroup {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
    pub y4: i32,
}

impl InnerGroup{
    pub fn new(mut buf: &mut ByteBuf) -> Result<InnerGroup, LubanError> {
        let y1 = buf.read_int();
        let y2 = buf.read_int();
        let y3 = buf.read_int();
        let y4 = buf.read_int();
        
        Ok(InnerGroup { y1, y2, y3, y4, })
    }

    pub const __ID__: i32 = -587873083;
}

#[derive(Debug)]
pub struct TestGlobal {
    pub unlock_equip: i32,
    pub unlock_hero: i32,
}

impl TestGlobal{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestGlobal, LubanError> {
        let unlock_equip = buf.read_int();
        let unlock_hero = buf.read_int();
        
        Ok(TestGlobal { unlock_equip, unlock_hero, })
    }

    pub const __ID__: i32 = -12548655;
}

#[derive(Debug)]
pub struct TestBeRef {
    pub id: i32,
    pub count: i32,
}

impl TestBeRef{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestBeRef, LubanError> {
        let id = buf.read_int();
        let count = buf.read_int();
        
        Ok(TestBeRef { id, count, })
    }

    pub const __ID__: i32 = 1934403938;
}

#[derive(Debug)]
pub struct TestRef {
    pub id: i32,
    pub x1: i32,
    pub x1_2: i32,
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub a1: Vec<i32>,
    pub a2: Vec<i32>,
    pub b1: Vec<i32>,
    pub b2: Vec<i32>,
    pub c1: std::collections::HashSet<i32>,
    pub c2: std::collections::HashSet<i32>,
    pub d1: std::collections::HashMap<i32, i32>,
    pub d2: std::collections::HashMap<i32, i32>,
    pub e1: i32,
    pub e2: i64,
    pub e3: String,
    pub f1: i32,
    pub f2: i64,
    pub f3: String,
    pub s1: std::sync::Arc<AbstractBase>,
}

impl TestRef{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestRef, LubanError> {
        let id = buf.read_int();
        let x1 = buf.read_int();
        let x1_2 = buf.read_int();
        let x2 = buf.read_int();
        let x3 = buf.read_int();
        let x4 = buf.read_int();
        let a1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let a2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let c1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let c2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let d1 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let d2 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let e1 = buf.read_int();
        let e2 = buf.read_long();
        let e3 = buf.read_string();
        let f1 = buf.read_int();
        let f2 = buf.read_long();
        let f3 = buf.read_string();
        let s1 = crate::test::RefDynamicBase::new(&mut buf)?;
        
        Ok(TestRef { id, x1, x1_2, x2, x3, x4, a1, a2, b1, b2, c1, c2, d1, d2, e1, e2, e3, f1, f2, f3, s1, })
    }

    pub const __ID__: i32 = -543222491;
}

#[derive(Debug)]
pub struct RefDynamicBase {
    pub x: i32,
}

impl RefDynamicBase {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::RefBean::__ID__ => Ok(std::sync::Arc::new(crate::test::RefBean::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for RefDynamicBase:{}", type_id)))
        }
    }
}

pub trait TRefDynamicBase {
    fn get_x(&self) -> &i32;
}

impl crate::test::TRefDynamicBase for crate::test::RefBean {
    fn get_x(&self) -> &i32 {
        &self.x
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TRefDynamicBase> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TRefDynamicBase, LubanError> {
        let base: Result<&crate::test::RefBean, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for RefDynamicBase")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct RefBean {
    pub x: i32,
    pub arr: Vec<i32>,
}

impl RefBean{
    pub fn new(mut buf: &mut ByteBuf) -> Result<RefBean, LubanError> {
        let x = buf.read_int();
        let arr = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        
        Ok(RefBean { x, arr, })
    }

    pub const __ID__: i32 = 1963260263;
}

#[derive(Debug)]
pub struct TestSize {
    pub id: i32,
    pub x1: Vec<i32>,
    pub x2: Vec<i32>,
    pub x3: std::collections::HashSet<i32>,
    pub x4: std::collections::HashMap<i32, i32>,
}

impl TestSize{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestSize, LubanError> {
        let id = buf.read_int();
        let x1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        
        Ok(TestSize { id, x1, x2, x3, x4, })
    }

    pub const __ID__: i32 = 340006319;
}

#[derive(Debug)]
pub struct TestSet {
    pub id: i32,
    pub x0: String,
    pub x1: Vec<i32>,
    pub x2: Vec<i64>,
    pub x3: Vec<String>,
    pub x4: Vec<crate::test::DemoEnum>,
}

impl TestSet{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestSet, LubanError> {
        let id = buf.read_int();
        let x0 = buf.read_string();
        let x1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_long()); } _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_string()); } _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int().into()); } _e0 };
        
        Ok(TestSet { id, x0, x1, x2, x3, x4, })
    }

    pub const __ID__: i32 = -543221516;
}

#[derive(Debug)]
pub struct DetectEncoding {
    pub id: i32,
    pub name: String,
}

impl DetectEncoding{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DetectEncoding, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        
        Ok(DetectEncoding { id, name, })
    }

    pub const __ID__: i32 = -1154609646;
}

#[derive(Debug)]
pub struct ItemBase {
    pub id: i32,
    pub name: String,
    pub desc: String,
}

impl ItemBase {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::Item::__ID__ => Ok(std::sync::Arc::new(crate::test::Item::new(buf)?)),
            crate::test::Equipment::__ID__ => Ok(std::sync::Arc::new(crate::test::Equipment::new(buf)?)),
            crate::test::Decorator::__ID__ => Ok(std::sync::Arc::new(crate::test::Decorator::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for ItemBase:{}", type_id)))
        }
    }
}

pub trait TItemBase {
    fn get_id(&self) -> &i32;
    fn get_name(&self) -> &String;
    fn get_desc(&self) -> &String;
}

impl crate::test::TItemBase for crate::test::Item {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_name(&self) -> &String {
        &self.name
    }
    fn get_desc(&self) -> &String {
        &self.desc
    }
}

impl crate::test::TItemBase for crate::test::Equipment {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_name(&self) -> &String {
        &self.name
    }
    fn get_desc(&self) -> &String {
        &self.desc
    }
}

impl crate::test::TItemBase for crate::test::Decorator {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_name(&self) -> &String {
        &self.name
    }
    fn get_desc(&self) -> &String {
        &self.desc
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TItemBase> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TItemBase, LubanError> {
        let base: Result<&crate::test::Item, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::Equipment, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::Decorator, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for ItemBase")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Item {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub num: i32,
    pub price: i32,
}

impl Item{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Item, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let num = buf.read_int();
        let price = buf.read_int();
        
        Ok(Item { id, name, desc, num, price, })
    }

    pub const __ID__: i32 = -1226641649;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Equipment {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub attr: crate::test::DemoEnum,
    pub value: i32,
}

impl Equipment{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Equipment, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let attr = buf.read_int().into();
        let value = buf.read_int();
        
        Ok(Equipment { id, name, desc, attr, value, })
    }

    pub const __ID__: i32 = -76837102;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Decorator {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub duration: i32,
}

impl Decorator{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Decorator, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let duration = buf.read_int();
        
        Ok(Decorator { id, name, desc, duration, })
    }

    pub const __ID__: i32 = -625155649;
}

#[derive(Debug)]
pub struct TestIndex {
    pub id: i32,
    pub eles: Vec<crate::test::DemoType1>,
}

impl TestIndex{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestIndex, LubanError> {
        let id = buf.read_int();
        let eles = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoType1::new(&mut buf)?); } _e0 };
        
        Ok(TestIndex { id, eles, })
    }

    pub const __ID__: i32 = 1941154020;
}

#[derive(Debug)]
pub struct TestMap {
    pub id: i32,
    pub x1: std::collections::HashMap<i32, i32>,
    pub x2: std::collections::HashMap<i64, i32>,
    pub x3: std::collections::HashMap<String, i32>,
    pub x4: std::collections::HashMap<crate::test::DemoEnum, i32>,
}

impl TestMap{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestMap, LubanError> {
        let id = buf.read_int();
        let x1 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_long(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_string(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int().into(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        
        Ok(TestMap { id, x1, x2, x3, x4, })
    }

    pub const __ID__: i32 = -543227410;
}

#[derive(Debug)]
pub struct ExcelFromJson {
    pub x4: i32,
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub s1: String,
    pub s2: String,
    pub t1: u64,
    pub x12: crate::test::DemoType1,
    pub x13: crate::test::DemoEnum,
    pub x14: std::sync::Arc<AbstractBase>,
    pub k1: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k15: Vec<std::sync::Arc<AbstractBase>>,
}

impl ExcelFromJson{
    pub fn new(mut buf: &mut ByteBuf) -> Result<ExcelFromJson, LubanError> {
        let x4 = buf.read_int();
        let x1 = buf.read_bool();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let s1 = buf.read_string();
        let s2 = buf.read_string();
        let t1 = buf.read_ulong();
        let x12 = crate::test::DemoType1::new(&mut buf)?;
        let x13 = buf.read_int().into();
        let x14 = crate::test::DemoDynamic::new(&mut buf)?;
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoE2::new(&mut buf)?); } _e0 };
        let k15 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoDynamic::new(&mut buf)?); } _e0 };
        
        Ok(ExcelFromJson { x4, x1, x5, x6, s1, s2, t1, x12, x13, x14, k1, k8, k9, k15, })
    }

    pub const __ID__: i32 = -1485706483;
}

#[derive(Debug)]
pub struct CompositeJsonTable1 {
    pub id: i32,
    pub x: String,
}

impl CompositeJsonTable1{
    pub fn new(mut buf: &mut ByteBuf) -> Result<CompositeJsonTable1, LubanError> {
        let id = buf.read_int();
        let x = buf.read_string();
        
        Ok(CompositeJsonTable1 { id, x, })
    }

    pub const __ID__: i32 = 1566207894;
}

#[derive(Debug)]
pub struct CompositeJsonTable2 {
    pub id: i32,
    pub y: i32,
}

impl CompositeJsonTable2{
    pub fn new(mut buf: &mut ByteBuf) -> Result<CompositeJsonTable2, LubanError> {
        let id = buf.read_int();
        let y = buf.read_int();
        
        Ok(CompositeJsonTable2 { id, y, })
    }

    pub const __ID__: i32 = 1566207895;
}

#[derive(Debug)]
pub struct CompositeJsonTable3 {
    pub a: i32,
    pub b: i32,
}

impl CompositeJsonTable3{
    pub fn new(mut buf: &mut ByteBuf) -> Result<CompositeJsonTable3, LubanError> {
        let a = buf.read_int();
        let b = buf.read_int();
        
        Ok(CompositeJsonTable3 { a, b, })
    }

    pub const __ID__: i32 = 1566207896;
}

#[derive(Debug)]
pub struct ExcelFromJsonMultiRow {
    pub id: i32,
    pub x: i32,
    pub items: Vec<crate::test::TestRow>,
}

impl ExcelFromJsonMultiRow{
    pub fn new(mut buf: &mut ByteBuf) -> Result<ExcelFromJsonMultiRow, LubanError> {
        let id = buf.read_int();
        let x = buf.read_int();
        let items = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::TestRow::new(&mut buf)?); } _e0 };
        
        Ok(ExcelFromJsonMultiRow { id, x, items, })
    }

    pub const __ID__: i32 = 715335694;
}

#[derive(Debug)]
pub struct TestRow {
    pub x: i32,
    pub y: bool,
    pub z: String,
    pub a: crate::test::Test3,
    pub b: Vec<i32>,
}

impl TestRow{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestRow, LubanError> {
        let x = buf.read_int();
        let y = buf.read_bool();
        let z = buf.read_string();
        let a = crate::test::Test3::new(&mut buf)?;
        let b = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        
        Ok(TestRow { x, y, z, a, b, })
    }

    pub const __ID__: i32 = -543222164;
}

#[derive(Debug)]
pub struct Test3 {
    pub x: i32,
    pub y: i32,
}

impl Test3{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Test3, LubanError> {
        let x = buf.read_int();
        let y = buf.read_int();
        
        Ok(Test3 { x, y, })
    }

    pub const __ID__: i32 = 638540133;
}

#[derive(Debug)]
pub struct TestScriptableObject {
    pub id: i32,
    pub desc: String,
    pub rate: f32,
    pub num: i32,
    pub v2: crate::vec2,
    pub v3: crate::vec3,
    pub v4: crate::vec4,
}

impl TestScriptableObject{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestScriptableObject, LubanError> {
        let id = buf.read_int();
        let desc = buf.read_string();
        let rate = buf.read_float();
        let num = buf.read_int();
        let v2 = crate::vec2::new(&mut buf)?;
        let v3 = crate::vec3::new(&mut buf)?;
        let v4 = crate::vec4::new(&mut buf)?;
        
        Ok(TestScriptableObject { id, desc, rate, num, v2, v3, v4, })
    }

    pub const __ID__: i32 = -1896814350;
}

#[derive(Debug)]
pub struct Path {
    pub id: i32,
    pub res: String,
}

impl Path{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Path, LubanError> {
        let id = buf.read_int();
        let res = buf.read_string();
        
        Ok(Path { id, res, })
    }

    pub const __ID__: i32 = -1226450911;
}

#[derive(Debug)]
pub struct TestMapper {
    pub id: i32,
    pub audio_type: crate::AudioType,
    pub v2: crate::vec2,
}

impl TestMapper{
    pub fn new(mut buf: &mut ByteBuf) -> Result<TestMapper, LubanError> {
        let id = buf.read_int();
        let audio_type = buf.read_int().into();
        let v2 = crate::vec2::new(&mut buf)?;
        
        Ok(TestMapper { id, audio_type, v2, })
    }

    pub const __ID__: i32 = 149110895;
}

#[derive(Debug)]
pub struct Shape {
}

impl Shape {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::Circle::__ID__ => Ok(std::sync::Arc::new(crate::test::Circle::new(buf)?)),
            crate::test2::Rectangle::__ID__ => Ok(std::sync::Arc::new(crate::test2::Rectangle::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Shape:{}", type_id)))
        }
    }
}

pub trait TShape {
}

impl crate::test::TShape for crate::test::Circle {
}

impl crate::test::TShape for crate::test2::Rectangle {
}

impl<'a> GetBase<'a, &'a dyn crate::test::TShape> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TShape, LubanError> {
        let base: Result<&crate::test::Circle, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test2::Rectangle, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Circle {
    /// 半径
    pub radius: f32,
}

impl Circle{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Circle, LubanError> {
        let radius = buf.read_float();
        
        Ok(Circle { radius, })
    }

    pub const __ID__: i32 = 2131829196;
}


#[derive(Debug)]
pub struct TbFullTypes {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>>,
}

impl TbFullTypes {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbFullTypes>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoType2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoType2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbFullTypes { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbFullTypes {
    type Output = std::sync::Arc<crate::test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbSingleton {
    pub data: crate::test::DemoSingletonType,
}

impl TbSingleton {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbSingleton>, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::DemoSingletonType::new(&mut buf)?;
        Ok(std::sync::Arc::new(TbSingleton { data }))
    }
}


#[derive(Debug)]
pub struct TbNotIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::NotIndexList>>,
}

impl TbNotIndexList {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbNotIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::NotIndexList>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::NotIndexList::new(&mut buf)?);
            data_list.push(row.clone());
        }

    Ok(std::sync::Arc::new(TbNotIndexList { 
            data_list,
        }))
    }

}


#[derive(Debug)]
pub struct TbMultiUnionIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>>,
    pub data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<crate::test::MultiUnionIndexList>>,
}

impl TbMultiUnionIndexList {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiUnionIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiUnionIndexList::new(&mut buf)?);
            data_list.push(row.clone());
        }
        let mut data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<crate::test::MultiUnionIndexList>> = Default::default();
        for x in &data_list {
            data_map_union.insert((x.id1, x.id2, x.id3.clone()), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiUnionIndexList { 
            data_list,
            data_map_union,
        }))
    }

    pub fn get(&self, key: &(i32, i64, String)) -> Option<std::sync::Arc<crate::test::MultiUnionIndexList>> {
        self.data_map_union.get(key).map(|x| x.clone())
    }
}


#[derive(Debug)]
pub struct TbMultiIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id1: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id2: std::collections::HashMap<i64, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id3: std::collections::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>>,
}

impl TbMultiIndexList {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiIndexList::new(&mut buf)?);
            data_list.push(row.clone());
        }
        let mut data_map_id1: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id2: std::collections::HashMap<i64, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id3: std::collections::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        for x in &data_list {
            data_map_id1.insert(x.id1.clone(), x.clone());
            data_map_id2.insert(x.id2.clone(), x.clone());
            data_map_id3.insert(x.id3.clone(), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiIndexList { 
            data_list,
            data_map_id1,
            data_map_id2,
            data_map_id3,
        }))
    }

    pub fn get_by_id1(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id1.get(key).map(|x| x.clone())
    }
    pub fn get_by_id2(&self, key: &i64) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id2.get(key).map(|x| x.clone())
    }
    pub fn get_by_id3(&self, key: &String) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id3.get(key).map(|x| x.clone())
    }
}


#[derive(Debug)]
pub struct TbDataFromMisc {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>>,
}

impl TbDataFromMisc {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDataFromMisc>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoType2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoType2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDataFromMisc { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDataFromMisc {
    type Output = std::sync::Arc<crate::test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowRecord {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiRowRecord>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowRecord>>,
}

impl TbMultiRowRecord {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiRowRecord>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowRecord>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiRowRecord>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiRowRecord::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowRecord { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiRowRecord>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbMultiRowRecord {
    type Output = std::sync::Arc<crate::test::MultiRowRecord>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMultiColumn {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMultiColumn>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMultiColumn>>,
}

impl TbTestMultiColumn {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestMultiColumn>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMultiColumn>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMultiColumn>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestMultiColumn::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMultiColumn { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMultiColumn>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestMultiColumn {
    type Output = std::sync::Arc<crate::test::TestMultiColumn>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowTitle {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiRowTitle>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowTitle>>,
}

impl TbMultiRowTitle {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiRowTitle>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowTitle>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiRowTitle>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiRowTitle::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowTitle { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiRowTitle>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbMultiRowTitle {
    type Output = std::sync::Arc<crate::test::MultiRowTitle>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestNull {
    pub data_list: Vec<std::sync::Arc<crate::test::TestNull>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestNull>>,
}

impl TbTestNull {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestNull>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestNull>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestNull>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestNull::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestNull { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestNull>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestNull {
    type Output = std::sync::Arc<crate::test::TestNull>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoPrimitive {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoPrimitiveTypesTable>>,
}

impl TbDemoPrimitive {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoPrimitive>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoPrimitiveTypesTable::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoPrimitive { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoPrimitive {
    type Output = std::sync::Arc<crate::test::DemoPrimitiveTypesTable>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestString {
    pub data_list: Vec<std::sync::Arc<crate::test::TestString>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::test::TestString>>,
}

impl TbTestString {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestString>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<crate::test::TestString>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestString>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestString::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestString { data_map, data_list }))
    }

    pub fn get(&self, key: &String) -> Option<std::sync::Arc<crate::test::TestString>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<String> for TbTestString {
    type Output = std::sync::Arc<crate::test::TestString>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_C {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_C {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup_C>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_C { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup_C {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_S {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_S {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup_S>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_S { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup_S {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_E {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_E {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup_E>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_E { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup_E {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestGlobal {
    pub data: crate::test::TestGlobal,
}

impl TbTestGlobal {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestGlobal>, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::TestGlobal::new(&mut buf)?;
        Ok(std::sync::Arc::new(TbTestGlobal { data }))
    }
}


#[derive(Debug)]
pub struct TbTestBeRef {
    pub data_list: Vec<std::sync::Arc<crate::test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>>,
}

impl TbTestBeRef {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestBeRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestBeRef>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestBeRef::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestBeRef {
    type Output = std::sync::Arc<crate::test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestBeRef2 {
    pub data_list: Vec<std::sync::Arc<crate::test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>>,
}

impl TbTestBeRef2 {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestBeRef2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestBeRef>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestBeRef::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestBeRef2 {
    type Output = std::sync::Arc<crate::test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestRef {
    pub data_list: Vec<std::sync::Arc<crate::test::TestRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRef>>,
}

impl TbTestRef {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestRef>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestRef::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestRef {
    type Output = std::sync::Arc<crate::test::TestRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSize {
    pub data_list: Vec<std::sync::Arc<crate::test::TestSize>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSize>>,
}

impl TbTestSize {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestSize>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSize>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestSize>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestSize::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSize { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestSize>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestSize {
    type Output = std::sync::Arc<crate::test::TestSize>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSet {
    pub data_list: Vec<std::sync::Arc<crate::test::TestSet>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSet>>,
}

impl TbTestSet {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestSet>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSet>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestSet>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestSet::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSet { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestSet>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestSet {
    type Output = std::sync::Arc<crate::test::TestSet>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDetectCsvEncoding {
    pub data_list: Vec<std::sync::Arc<crate::test::DetectEncoding>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DetectEncoding>>,
}

impl TbDetectCsvEncoding {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDetectCsvEncoding>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DetectEncoding>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DetectEncoding>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DetectEncoding::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDetectCsvEncoding { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DetectEncoding>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDetectCsvEncoding {
    type Output = std::sync::Arc<crate::test::DetectEncoding>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbItem2 {
    pub data_list: Vec<std::sync::Arc<AbstractBase>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<AbstractBase>>,
}

impl TbItem2 {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbItem2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<AbstractBase>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<AbstractBase>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = crate::test::ItemBase::new(&mut buf)?;
            data_list.push(row.clone());
            let key = <AbstractBase as GetBase<&dyn crate::test::TItemBase>>::get_base(std::ops::Deref::deref(&row))?;
            data_map.insert(key.get_id().clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbItem2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<AbstractBase>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbItem2 {
    type Output = std::sync::Arc<AbstractBase>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestIndex {
    pub data_list: Vec<std::sync::Arc<crate::test::TestIndex>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestIndex>>,
}

impl TbTestIndex {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestIndex>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestIndex>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestIndex>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestIndex::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestIndex { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestIndex>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestIndex {
    type Output = std::sync::Arc<crate::test::TestIndex>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMap {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMap>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMap>>,
}

impl TbTestMap {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestMap>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMap>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMap>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestMap::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMap { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMap>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestMap {
    type Output = std::sync::Arc<crate::test::TestMap>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbExcelFromJson {
    pub data_list: Vec<std::sync::Arc<crate::test::ExcelFromJson>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJson>>,
}

impl TbExcelFromJson {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbExcelFromJson>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJson>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::ExcelFromJson>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::ExcelFromJson::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJson { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::ExcelFromJson>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbExcelFromJson {
    type Output = std::sync::Arc<crate::test::ExcelFromJson>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable1 {
    pub data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable1>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable1>>,
}

impl TbCompositeJsonTable1 {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbCompositeJsonTable1>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable1>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable1>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::CompositeJsonTable1::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable1 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::CompositeJsonTable1>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable1 {
    type Output = std::sync::Arc<crate::test::CompositeJsonTable1>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable2 {
    pub data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable2>>,
}

impl TbCompositeJsonTable2 {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbCompositeJsonTable2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::CompositeJsonTable2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::CompositeJsonTable2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable2 {
    type Output = std::sync::Arc<crate::test::CompositeJsonTable2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable3 {
    pub data: crate::test::CompositeJsonTable3,
}

impl TbCompositeJsonTable3 {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbCompositeJsonTable3>, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::CompositeJsonTable3::new(&mut buf)?;
        Ok(std::sync::Arc::new(TbCompositeJsonTable3 { data }))
    }
}


#[derive(Debug)]
pub struct TbExcelFromJsonMultiRow {
    pub data_list: Vec<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJsonMultiRow>>,
}

impl TbExcelFromJsonMultiRow {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbExcelFromJsonMultiRow>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::ExcelFromJsonMultiRow::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJsonMultiRow { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbExcelFromJsonMultiRow {
    type Output = std::sync::Arc<crate::test::ExcelFromJsonMultiRow>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestScriptableObject {
    pub data_list: Vec<std::sync::Arc<crate::test::TestScriptableObject>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestScriptableObject>>,
}

impl TbTestScriptableObject {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestScriptableObject>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestScriptableObject>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestScriptableObject>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestScriptableObject::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestScriptableObject { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestScriptableObject>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestScriptableObject {
    type Output = std::sync::Arc<crate::test::TestScriptableObject>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbPath {
    pub data_list: Vec<std::sync::Arc<crate::test::Path>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::Path>>,
}

impl TbPath {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbPath>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::Path>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::Path>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::Path::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbPath { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::Path>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbPath {
    type Output = std::sync::Arc<crate::test::Path>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMapper {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMapper>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMapper>>,
}

impl TbTestMapper {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestMapper>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMapper>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMapper>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestMapper::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMapper { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMapper>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestMapper {
    type Output = std::sync::Arc<crate::test::TestMapper>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDefineFromExcel2 {
    pub data_list: Vec<std::sync::Arc<crate::DefineFromExcel2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::DefineFromExcel2>>,
}

impl TbDefineFromExcel2 {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDefineFromExcel2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::DefineFromExcel2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::DefineFromExcel2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::DefineFromExcel2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDefineFromExcel2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::DefineFromExcel2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDefineFromExcel2 {
    type Output = std::sync::Arc<crate::DefineFromExcel2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


