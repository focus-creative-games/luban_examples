
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::*;

#[derive(Debug)]
pub struct GlobalConfig {
    /// 背包容量
    pub x1: i32,
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub x5: i32,
    pub x6: i32,
    pub x7: Vec<i32>,
}

impl GlobalConfig{
    pub fn new(mut buf: &mut ByteBuf) -> Result<GlobalConfig, LubanError> {
        let x1 = buf.read_int();
        let x2 = buf.read_int();
        let x3 = buf.read_int();
        let x4 = buf.read_int();
        let x5 = buf.read_int();
        let x6 = buf.read_int();
        let x7 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        
        Ok(GlobalConfig { x1, x2, x3, x4, x5, x6, x7, })
    }

    pub const __ID__: i32 = -848234488;
}


#[derive(Debug)]
pub struct TbGlobalConfig {
    pub data: crate::common::GlobalConfig,
}

impl TbGlobalConfig {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbGlobalConfig>, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::common::GlobalConfig::new(&mut buf)?;
        Ok(std::sync::Arc::new(TbGlobalConfig { data }))
    }
}


