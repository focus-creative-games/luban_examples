
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS1 = 8,
    ENUM1 = 9,
    OBJECT = 10,
}

impl From<i32> for EKeyType {
    fn from(value: i32) -> Self {
        match value { 
            1 => EKeyType::BOOL,
            2 => EKeyType::INT,
            3 => EKeyType::FLOAT,
            4 => EKeyType::STRING,
            5 => EKeyType::VECTOR,
            6 => EKeyType::ROTATOR,
            7 => EKeyType::NAME,
            8 => EKeyType::CLASS1,
            9 => EKeyType::ENUM1,
            10 => EKeyType::OBJECT,
            _ => panic!("Invalid value for EKeyType:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}

impl From<i32> for EFlowAbortMode {
    fn from(value: i32) -> Self {
        match value { 
            0 => EFlowAbortMode::NONE,
            1 => EFlowAbortMode::LOWER_PRIORITY,
            2 => EFlowAbortMode::SELF,
            3 => EFlowAbortMode::BOTH,
            _ => panic!("Invalid value for EFlowAbortMode:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}

impl From<i32> for ENotifyObserverMode {
    fn from(value: i32) -> Self {
        match value { 
            0 => ENotifyObserverMode::ON_VALUE_CHANGE,
            1 => ENotifyObserverMode::ON_RESULT_CHANGE,
            _ => panic!("Invalid value for ENotifyObserverMode:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}

impl From<i32> for EOperator {
    fn from(value: i32) -> Self {
        match value { 
            0 => EOperator::IS_EQUAL_TO,
            1 => EOperator::IS_NOT_EQUAL_TO,
            2 => EOperator::IS_LESS_THAN,
            3 => EOperator::IS_LESS_THAN_OR_EQUAL_TO,
            4 => EOperator::IS_GREAT_THAN,
            5 => EOperator::IS_GREAT_THAN_OR_EQUAL_TO,
            6 => EOperator::CONTAINS,
            7 => EOperator::NOT_CONTAINS,
            _ => panic!("Invalid value for EOperator:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}

impl From<i32> for EFinishMode {
    fn from(value: i32) -> Self {
        match value { 
            0 => EFinishMode::IMMEDIATE,
            1 => EFinishMode::DELAYED,
            _ => panic!("Invalid value for EFinishMode:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct Blackboard {
    pub name: String,
    pub desc: String,
    pub parent_name: String,
    pub keys: Vec<crate::ai::BlackboardKey>,
}

impl Blackboard{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Blackboard, LubanError> {
        let name = buf.read_string();
        let desc = buf.read_string();
        let parent_name = buf.read_string();
        let keys = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::BlackboardKey::new(&mut buf)?); } _e0 };
        
        Ok(Blackboard { name, desc, parent_name, keys, })
    }

    pub const __ID__: i32 = 1576193005;
}

#[derive(Debug)]
pub struct BlackboardKey {
    pub name: String,
    pub desc: String,
    pub is_static: bool,
    pub key_type: crate::ai::EKeyType,
    pub type_class_name: String,
}

impl BlackboardKey{
    pub fn new(mut buf: &mut ByteBuf) -> Result<BlackboardKey, LubanError> {
        let name = buf.read_string();
        let desc = buf.read_string();
        let is_static = buf.read_bool();
        let key_type = buf.read_int().into();
        let type_class_name = buf.read_string();
        
        Ok(BlackboardKey { name, desc, is_static, key_type, type_class_name, })
    }

    pub const __ID__: i32 = -511559886;
}

#[derive(Debug)]
pub struct BehaviorTree {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub blackboard_id: String,
    pub root: std::sync::Arc<AbstractBase>,
}

impl BehaviorTree{
    pub fn new(mut buf: &mut ByteBuf) -> Result<BehaviorTree, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let blackboard_id = buf.read_string();
        let root = crate::ai::ComposeNode::new(&mut buf)?;
        
        Ok(BehaviorTree { id, name, desc, blackboard_id, root, })
    }

    pub const __ID__: i32 = 159552822;
}

#[derive(Debug)]
pub struct Node {
    pub id: i32,
    pub node_name: String,
}

impl Node {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::UeSetDefaultFocus::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeSetDefaultFocus::new(buf)?)),
            crate::ai::ExecuteTimeStatistic::__ID__ => Ok(std::sync::Arc::new(crate::ai::ExecuteTimeStatistic::new(buf)?)),
            crate::ai::ChooseTarget::__ID__ => Ok(std::sync::Arc::new(crate::ai::ChooseTarget::new(buf)?)),
            crate::ai::KeepFaceTarget::__ID__ => Ok(std::sync::Arc::new(crate::ai::KeepFaceTarget::new(buf)?)),
            crate::ai::GetOwnerPlayer::__ID__ => Ok(std::sync::Arc::new(crate::ai::GetOwnerPlayer::new(buf)?)),
            crate::ai::UpdateDailyBehaviorProps::__ID__ => Ok(std::sync::Arc::new(crate::ai::UpdateDailyBehaviorProps::new(buf)?)),
            crate::ai::UeLoop::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeLoop::new(buf)?)),
            crate::ai::UeCooldown::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeCooldown::new(buf)?)),
            crate::ai::UeTimeLimit::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeTimeLimit::new(buf)?)),
            crate::ai::UeBlackboard::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeBlackboard::new(buf)?)),
            crate::ai::UeForceSuccess::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeForceSuccess::new(buf)?)),
            crate::ai::IsAtLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::IsAtLocation::new(buf)?)),
            crate::ai::DistanceLessThan::__ID__ => Ok(std::sync::Arc::new(crate::ai::DistanceLessThan::new(buf)?)),
            crate::ai::Sequence::__ID__ => Ok(std::sync::Arc::new(crate::ai::Sequence::new(buf)?)),
            crate::ai::Selector::__ID__ => Ok(std::sync::Arc::new(crate::ai::Selector::new(buf)?)),
            crate::ai::SimpleParallel::__ID__ => Ok(std::sync::Arc::new(crate::ai::SimpleParallel::new(buf)?)),
            crate::ai::UeWait::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeWait::new(buf)?)),
            crate::ai::UeWaitBlackboardTime::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(buf)?)),
            crate::ai::MoveToTarget::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToTarget::new(buf)?)),
            crate::ai::ChooseSkill::__ID__ => Ok(std::sync::Arc::new(crate::ai::ChooseSkill::new(buf)?)),
            crate::ai::MoveToRandomLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(buf)?)),
            crate::ai::MoveToLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToLocation::new(buf)?)),
            crate::ai::DebugPrint::__ID__ => Ok(std::sync::Arc::new(crate::ai::DebugPrint::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Node:{}", type_id)))
        }
    }
}

pub trait TNode {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
}

impl crate::ai::TNode for crate::ai::UeSetDefaultFocus {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::ExecuteTimeStatistic {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::ChooseTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::KeepFaceTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::GetOwnerPlayer {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UpdateDailyBehaviorProps {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeLoop {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeCooldown {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeTimeLimit {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeBlackboard {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeForceSuccess {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::IsAtLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::DistanceLessThan {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::Sequence {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::Selector {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::SimpleParallel {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeWait {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeWaitBlackboardTime {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::MoveToTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::ChooseSkill {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::MoveToRandomLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::MoveToLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::DebugPrint {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TNode> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TNode, LubanError> {
        let base: Result<&crate::ai::UeSetDefaultFocus, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ExecuteTimeStatistic, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::KeepFaceTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::GetOwnerPlayer, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UpdateDailyBehaviorProps, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeLoop, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeCooldown, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeTimeLimit, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeBlackboard, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeForceSuccess, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IsAtLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DistanceLessThan, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Sequence, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Selector, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::SimpleParallel, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWait, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWaitBlackboardTime, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseSkill, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToRandomLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DebugPrint, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Node")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Service {
    pub id: i32,
    pub node_name: String,
}

impl Service {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::UeSetDefaultFocus::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeSetDefaultFocus::new(buf)?)),
            crate::ai::ExecuteTimeStatistic::__ID__ => Ok(std::sync::Arc::new(crate::ai::ExecuteTimeStatistic::new(buf)?)),
            crate::ai::ChooseTarget::__ID__ => Ok(std::sync::Arc::new(crate::ai::ChooseTarget::new(buf)?)),
            crate::ai::KeepFaceTarget::__ID__ => Ok(std::sync::Arc::new(crate::ai::KeepFaceTarget::new(buf)?)),
            crate::ai::GetOwnerPlayer::__ID__ => Ok(std::sync::Arc::new(crate::ai::GetOwnerPlayer::new(buf)?)),
            crate::ai::UpdateDailyBehaviorProps::__ID__ => Ok(std::sync::Arc::new(crate::ai::UpdateDailyBehaviorProps::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Service:{}", type_id)))
        }
    }
}

pub trait TService {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
}

impl crate::ai::TService for crate::ai::UeSetDefaultFocus {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::ExecuteTimeStatistic {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::ChooseTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::KeepFaceTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::GetOwnerPlayer {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::UpdateDailyBehaviorProps {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TService> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TService, LubanError> {
        let base: Result<&crate::ai::UeSetDefaultFocus, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ExecuteTimeStatistic, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::KeepFaceTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::GetOwnerPlayer, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UpdateDailyBehaviorProps, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Service")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeSetDefaultFocus {
    pub id: i32,
    pub node_name: String,
    pub keyboard_key: String,
}

impl UeSetDefaultFocus{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeSetDefaultFocus, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let keyboard_key = buf.read_string();
        
        Ok(UeSetDefaultFocus { id, node_name, keyboard_key, })
    }

    pub const __ID__: i32 = 1812449155;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ExecuteTimeStatistic {
    pub id: i32,
    pub node_name: String,
}

impl ExecuteTimeStatistic{
    pub fn new(mut buf: &mut ByteBuf) -> Result<ExecuteTimeStatistic, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        
        Ok(ExecuteTimeStatistic { id, node_name, })
    }

    pub const __ID__: i32 = 990693812;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ChooseTarget {
    pub id: i32,
    pub node_name: String,
    pub result_target_key: String,
}

impl ChooseTarget{
    pub fn new(mut buf: &mut ByteBuf) -> Result<ChooseTarget, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let result_target_key = buf.read_string();
        
        Ok(ChooseTarget { id, node_name, result_target_key, })
    }

    pub const __ID__: i32 = 1601247918;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct KeepFaceTarget {
    pub id: i32,
    pub node_name: String,
    pub target_actor_key: String,
}

impl KeepFaceTarget{
    pub fn new(mut buf: &mut ByteBuf) -> Result<KeepFaceTarget, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let target_actor_key = buf.read_string();
        
        Ok(KeepFaceTarget { id, node_name, target_actor_key, })
    }

    pub const __ID__: i32 = 1195270745;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct GetOwnerPlayer {
    pub id: i32,
    pub node_name: String,
    pub player_actor_key: String,
}

impl GetOwnerPlayer{
    pub fn new(mut buf: &mut ByteBuf) -> Result<GetOwnerPlayer, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let player_actor_key = buf.read_string();
        
        Ok(GetOwnerPlayer { id, node_name, player_actor_key, })
    }

    pub const __ID__: i32 = -999247644;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UpdateDailyBehaviorProps {
    pub id: i32,
    pub node_name: String,
    pub satiety_key: String,
    pub energy_key: String,
    pub mood_key: String,
    pub satiety_lower_threshold_key: String,
    pub satiety_upper_threshold_key: String,
    pub energy_lower_threshold_key: String,
    pub energy_upper_threshold_key: String,
    pub mood_lower_threshold_key: String,
    pub mood_upper_threshold_key: String,
}

impl UpdateDailyBehaviorProps{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UpdateDailyBehaviorProps, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let satiety_key = buf.read_string();
        let energy_key = buf.read_string();
        let mood_key = buf.read_string();
        let satiety_lower_threshold_key = buf.read_string();
        let satiety_upper_threshold_key = buf.read_string();
        let energy_lower_threshold_key = buf.read_string();
        let energy_upper_threshold_key = buf.read_string();
        let mood_lower_threshold_key = buf.read_string();
        let mood_upper_threshold_key = buf.read_string();
        
        Ok(UpdateDailyBehaviorProps { id, node_name, satiety_key, energy_key, mood_key, satiety_lower_threshold_key, satiety_upper_threshold_key, energy_lower_threshold_key, energy_upper_threshold_key, mood_lower_threshold_key, mood_upper_threshold_key, })
    }

    pub const __ID__: i32 = -61887372;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Decorator {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
}

impl Decorator {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::UeLoop::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeLoop::new(buf)?)),
            crate::ai::UeCooldown::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeCooldown::new(buf)?)),
            crate::ai::UeTimeLimit::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeTimeLimit::new(buf)?)),
            crate::ai::UeBlackboard::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeBlackboard::new(buf)?)),
            crate::ai::UeForceSuccess::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeForceSuccess::new(buf)?)),
            crate::ai::IsAtLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::IsAtLocation::new(buf)?)),
            crate::ai::DistanceLessThan::__ID__ => Ok(std::sync::Arc::new(crate::ai::DistanceLessThan::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Decorator:{}", type_id)))
        }
    }
}

pub trait TDecorator {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode;
}

impl crate::ai::TDecorator for crate::ai::UeLoop {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeCooldown {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeTimeLimit {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeBlackboard {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeForceSuccess {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::IsAtLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::DistanceLessThan {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TDecorator> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TDecorator, LubanError> {
        let base: Result<&crate::ai::UeLoop, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeCooldown, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeTimeLimit, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeBlackboard, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeForceSuccess, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IsAtLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DistanceLessThan, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Decorator")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeLoop {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub num_loops: i32,
    pub infinite_loop: bool,
    pub infinite_loop_timeout_time: f32,
}

impl UeLoop{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeLoop, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = buf.read_int().into();
        let num_loops = buf.read_int();
        let infinite_loop = buf.read_bool();
        let infinite_loop_timeout_time = buf.read_float();
        
        Ok(UeLoop { id, node_name, flow_abort_mode, num_loops, infinite_loop, infinite_loop_timeout_time, })
    }

    pub const __ID__: i32 = -513308166;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeCooldown {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub cooldown_time: f32,
}

impl UeCooldown{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeCooldown, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = buf.read_int().into();
        let cooldown_time = buf.read_float();
        
        Ok(UeCooldown { id, node_name, flow_abort_mode, cooldown_time, })
    }

    pub const __ID__: i32 = -951439423;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeTimeLimit {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub limit_time: f32,
}

impl UeTimeLimit{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeTimeLimit, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = buf.read_int().into();
        let limit_time = buf.read_float();
        
        Ok(UeTimeLimit { id, node_name, flow_abort_mode, limit_time, })
    }

    pub const __ID__: i32 = 338469720;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeBlackboard {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub notify_observer: crate::ai::ENotifyObserverMode,
    pub blackboard_key: String,
    pub key_query: std::sync::Arc<AbstractBase>,
}

impl UeBlackboard{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeBlackboard, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = buf.read_int().into();
        let notify_observer = buf.read_int().into();
        let blackboard_key = buf.read_string();
        let key_query = crate::ai::KeyQueryOperator::new(&mut buf)?;
        
        Ok(UeBlackboard { id, node_name, flow_abort_mode, notify_observer, blackboard_key, key_query, })
    }

    pub const __ID__: i32 = -315297507;
}

#[derive(Debug)]
pub struct KeyQueryOperator {
}

impl KeyQueryOperator {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::IsSet2::__ID__ => Ok(std::sync::Arc::new(crate::ai::IsSet2::new(buf)?)),
            crate::ai::IsNotSet::__ID__ => Ok(std::sync::Arc::new(crate::ai::IsNotSet::new(buf)?)),
            crate::ai::BinaryOperator::__ID__ => Ok(std::sync::Arc::new(crate::ai::BinaryOperator::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyQueryOperator:{}", type_id)))
        }
    }
}

pub trait TKeyQueryOperator {
}

impl crate::ai::TKeyQueryOperator for crate::ai::IsSet2 {
}

impl crate::ai::TKeyQueryOperator for crate::ai::IsNotSet {
}

impl crate::ai::TKeyQueryOperator for crate::ai::BinaryOperator {
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TKeyQueryOperator> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TKeyQueryOperator, LubanError> {
        let base: Result<&crate::ai::IsSet2, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IsNotSet, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::BinaryOperator, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for KeyQueryOperator")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IsSet2 {
}

impl IsSet2{
    pub fn new(mut buf: &mut ByteBuf) -> Result<IsSet2, LubanError> {
        
        Ok(IsSet2 { })
    }

    pub const __ID__: i32 = -843729664;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IsNotSet {
}

impl IsNotSet{
    pub fn new(mut buf: &mut ByteBuf) -> Result<IsNotSet, LubanError> {
        
        Ok(IsNotSet { })
    }

    pub const __ID__: i32 = 790736255;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct BinaryOperator {
    pub oper: crate::ai::EOperator,
    pub data: std::sync::Arc<AbstractBase>,
}

impl BinaryOperator{
    pub fn new(mut buf: &mut ByteBuf) -> Result<BinaryOperator, LubanError> {
        let oper = buf.read_int().into();
        let data = crate::ai::KeyData::new(&mut buf)?;
        
        Ok(BinaryOperator { oper, data, })
    }

    pub const __ID__: i32 = -979891605;
}

#[derive(Debug)]
pub struct KeyData {
}

impl KeyData {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::FloatKeyData::__ID__ => Ok(std::sync::Arc::new(crate::ai::FloatKeyData::new(buf)?)),
            crate::ai::IntKeyData::__ID__ => Ok(std::sync::Arc::new(crate::ai::IntKeyData::new(buf)?)),
            crate::ai::StringKeyData::__ID__ => Ok(std::sync::Arc::new(crate::ai::StringKeyData::new(buf)?)),
            crate::ai::BlackboardKeyData::__ID__ => Ok(std::sync::Arc::new(crate::ai::BlackboardKeyData::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyData:{}", type_id)))
        }
    }
}

pub trait TKeyData {
}

impl crate::ai::TKeyData for crate::ai::FloatKeyData {
}

impl crate::ai::TKeyData for crate::ai::IntKeyData {
}

impl crate::ai::TKeyData for crate::ai::StringKeyData {
}

impl crate::ai::TKeyData for crate::ai::BlackboardKeyData {
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TKeyData> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TKeyData, LubanError> {
        let base: Result<&crate::ai::FloatKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IntKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::StringKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::BlackboardKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for KeyData")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct FloatKeyData {
    pub value: f32,
}

impl FloatKeyData{
    pub fn new(mut buf: &mut ByteBuf) -> Result<FloatKeyData, LubanError> {
        let value = buf.read_float();
        
        Ok(FloatKeyData { value, })
    }

    pub const __ID__: i32 = -719747885;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IntKeyData {
    pub value: i32,
}

impl IntKeyData{
    pub fn new(mut buf: &mut ByteBuf) -> Result<IntKeyData, LubanError> {
        let value = buf.read_int();
        
        Ok(IntKeyData { value, })
    }

    pub const __ID__: i32 = -342751904;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct StringKeyData {
    pub value: String,
}

impl StringKeyData{
    pub fn new(mut buf: &mut ByteBuf) -> Result<StringKeyData, LubanError> {
        let value = buf.read_string();
        
        Ok(StringKeyData { value, })
    }

    pub const __ID__: i32 = -307888654;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct BlackboardKeyData {
    pub value: String,
}

impl BlackboardKeyData{
    pub fn new(mut buf: &mut ByteBuf) -> Result<BlackboardKeyData, LubanError> {
        let value = buf.read_string();
        
        Ok(BlackboardKeyData { value, })
    }

    pub const __ID__: i32 = 1517269500;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeForceSuccess {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
}

impl UeForceSuccess{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeForceSuccess, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = buf.read_int().into();
        
        Ok(UeForceSuccess { id, node_name, flow_abort_mode, })
    }

    pub const __ID__: i32 = 195054574;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IsAtLocation {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub acceptable_radius: f32,
    pub keyboard_key: String,
    pub inverse_condition: bool,
}

impl IsAtLocation{
    pub fn new(mut buf: &mut ByteBuf) -> Result<IsAtLocation, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = buf.read_int().into();
        let acceptable_radius = buf.read_float();
        let keyboard_key = buf.read_string();
        let inverse_condition = buf.read_bool();
        
        Ok(IsAtLocation { id, node_name, flow_abort_mode, acceptable_radius, keyboard_key, inverse_condition, })
    }

    pub const __ID__: i32 = 1255972344;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DistanceLessThan {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub actor1_key: String,
    pub actor2_key: String,
    pub distance: f32,
    pub reverse_result: bool,
}

impl DistanceLessThan{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DistanceLessThan, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = buf.read_int().into();
        let actor1_key = buf.read_string();
        let actor2_key = buf.read_string();
        let distance = buf.read_float();
        let reverse_result = buf.read_bool();
        
        Ok(DistanceLessThan { id, node_name, flow_abort_mode, actor1_key, actor2_key, distance, reverse_result, })
    }

    pub const __ID__: i32 = -1207170283;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct FlowNode {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
}

impl FlowNode {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::Sequence::__ID__ => Ok(std::sync::Arc::new(crate::ai::Sequence::new(buf)?)),
            crate::ai::Selector::__ID__ => Ok(std::sync::Arc::new(crate::ai::Selector::new(buf)?)),
            crate::ai::SimpleParallel::__ID__ => Ok(std::sync::Arc::new(crate::ai::SimpleParallel::new(buf)?)),
            crate::ai::UeWait::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeWait::new(buf)?)),
            crate::ai::UeWaitBlackboardTime::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(buf)?)),
            crate::ai::MoveToTarget::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToTarget::new(buf)?)),
            crate::ai::ChooseSkill::__ID__ => Ok(std::sync::Arc::new(crate::ai::ChooseSkill::new(buf)?)),
            crate::ai::MoveToRandomLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(buf)?)),
            crate::ai::MoveToLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToLocation::new(buf)?)),
            crate::ai::DebugPrint::__ID__ => Ok(std::sync::Arc::new(crate::ai::DebugPrint::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for FlowNode:{}", type_id)))
        }
    }
}

pub trait TFlowNode {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
}

impl crate::ai::TFlowNode for crate::ai::Sequence {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::Selector {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::SimpleParallel {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::UeWait {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::UeWaitBlackboardTime {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::MoveToTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::ChooseSkill {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::MoveToRandomLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::MoveToLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::DebugPrint {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TFlowNode> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TFlowNode, LubanError> {
        let base: Result<&crate::ai::Sequence, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Selector, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::SimpleParallel, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWait, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWaitBlackboardTime, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseSkill, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToRandomLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DebugPrint, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for FlowNode")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ComposeNode {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
}

impl ComposeNode {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::Sequence::__ID__ => Ok(std::sync::Arc::new(crate::ai::Sequence::new(buf)?)),
            crate::ai::Selector::__ID__ => Ok(std::sync::Arc::new(crate::ai::Selector::new(buf)?)),
            crate::ai::SimpleParallel::__ID__ => Ok(std::sync::Arc::new(crate::ai::SimpleParallel::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for ComposeNode:{}", type_id)))
        }
    }
}

pub trait TComposeNode {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
}

impl crate::ai::TComposeNode for crate::ai::Sequence {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TComposeNode for crate::ai::Selector {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TComposeNode for crate::ai::SimpleParallel {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TComposeNode> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TComposeNode, LubanError> {
        let base: Result<&crate::ai::Sequence, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Selector, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::SimpleParallel, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for ComposeNode")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Sequence {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub children: Vec<std::sync::Arc<AbstractBase>>,
}

impl Sequence{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Sequence, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let children = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::FlowNode::new(&mut buf)?); } _e0 };
        
        Ok(Sequence { id, node_name, decorators, services, children, })
    }

    pub const __ID__: i32 = -1789006105;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Selector {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub children: Vec<std::sync::Arc<AbstractBase>>,
}

impl Selector{
    pub fn new(mut buf: &mut ByteBuf) -> Result<Selector, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let children = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::FlowNode::new(&mut buf)?); } _e0 };
        
        Ok(Selector { id, node_name, decorators, services, children, })
    }

    pub const __ID__: i32 = -1946981627;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct SimpleParallel {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub finish_mode: crate::ai::EFinishMode,
    pub main_task: std::sync::Arc<AbstractBase>,
    pub background_node: std::sync::Arc<AbstractBase>,
}

impl SimpleParallel{
    pub fn new(mut buf: &mut ByteBuf) -> Result<SimpleParallel, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let finish_mode = buf.read_int().into();
        let main_task = crate::ai::Task::new(&mut buf)?;
        let background_node = crate::ai::FlowNode::new(&mut buf)?;
        
        Ok(SimpleParallel { id, node_name, decorators, services, finish_mode, main_task, background_node, })
    }

    pub const __ID__: i32 = -1952582529;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Task {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
}

impl Task {
    pub fn new(mut buf: &mut ByteBuf) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::ai::UeWait::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeWait::new(buf)?)),
            crate::ai::UeWaitBlackboardTime::__ID__ => Ok(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(buf)?)),
            crate::ai::MoveToTarget::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToTarget::new(buf)?)),
            crate::ai::ChooseSkill::__ID__ => Ok(std::sync::Arc::new(crate::ai::ChooseSkill::new(buf)?)),
            crate::ai::MoveToRandomLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(buf)?)),
            crate::ai::MoveToLocation::__ID__ => Ok(std::sync::Arc::new(crate::ai::MoveToLocation::new(buf)?)),
            crate::ai::DebugPrint::__ID__ => Ok(std::sync::Arc::new(crate::ai::DebugPrint::new(buf)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Task:{}", type_id)))
        }
    }
}

pub trait TTask {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_ignore_restart_self(&self) -> &bool;
}

impl crate::ai::TTask for crate::ai::UeWait {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::UeWaitBlackboardTime {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::MoveToTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::ChooseSkill {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::MoveToRandomLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::MoveToLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::DebugPrint {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TTask> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TTask, LubanError> {
        let base: Result<&crate::ai::UeWait, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWaitBlackboardTime, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseSkill, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToRandomLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DebugPrint, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Task")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeWait {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub wait_time: f32,
    pub random_deviation: f32,
}

impl UeWait{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeWait, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let wait_time = buf.read_float();
        let random_deviation = buf.read_float();
        
        Ok(UeWait { id, node_name, decorators, services, ignore_restart_self, wait_time, random_deviation, })
    }

    pub const __ID__: i32 = -512994101;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeWaitBlackboardTime {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub blackboard_key: String,
}

impl UeWaitBlackboardTime{
    pub fn new(mut buf: &mut ByteBuf) -> Result<UeWaitBlackboardTime, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let blackboard_key = buf.read_string();
        
        Ok(UeWaitBlackboardTime { id, node_name, decorators, services, ignore_restart_self, blackboard_key, })
    }

    pub const __ID__: i32 = 1215378271;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct MoveToTarget {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub acceptable_radius: f32,
}

impl MoveToTarget{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MoveToTarget, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let target_actor_key = buf.read_string();
        let acceptable_radius = buf.read_float();
        
        Ok(MoveToTarget { id, node_name, decorators, services, ignore_restart_self, target_actor_key, acceptable_radius, })
    }

    pub const __ID__: i32 = 514987779;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ChooseSkill {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub result_skill_id_key: String,
}

impl ChooseSkill{
    pub fn new(mut buf: &mut ByteBuf) -> Result<ChooseSkill, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let target_actor_key = buf.read_string();
        let result_skill_id_key = buf.read_string();
        
        Ok(ChooseSkill { id, node_name, decorators, services, ignore_restart_self, target_actor_key, result_skill_id_key, })
    }

    pub const __ID__: i32 = -918812268;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct MoveToRandomLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub origin_position_key: String,
    pub radius: f32,
}

impl MoveToRandomLocation{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MoveToRandomLocation, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let origin_position_key = buf.read_string();
        let radius = buf.read_float();
        
        Ok(MoveToRandomLocation { id, node_name, decorators, services, ignore_restart_self, origin_position_key, radius, })
    }

    pub const __ID__: i32 = -2140042998;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct MoveToLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub acceptable_radius: f32,
}

impl MoveToLocation{
    pub fn new(mut buf: &mut ByteBuf) -> Result<MoveToLocation, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let acceptable_radius = buf.read_float();
        
        Ok(MoveToLocation { id, node_name, decorators, services, ignore_restart_self, acceptable_radius, })
    }

    pub const __ID__: i32 = -969953113;
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DebugPrint {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub text: String,
}

impl DebugPrint{
    pub fn new(mut buf: &mut ByteBuf) -> Result<DebugPrint, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let text = buf.read_string();
        
        Ok(DebugPrint { id, node_name, decorators, services, ignore_restart_self, text, })
    }

    pub const __ID__: i32 = 1357409728;
}


#[derive(Debug)]
pub struct TbBlackboard {
    pub data_list: Vec<std::sync::Arc<crate::ai::Blackboard>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::ai::Blackboard>>,
}

impl TbBlackboard {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbBlackboard>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<crate::ai::Blackboard>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::ai::Blackboard>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::ai::Blackboard::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.name.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBlackboard { data_map, data_list }))
    }

    pub fn get(&self, key: &String) -> Option<std::sync::Arc<crate::ai::Blackboard>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<String> for TbBlackboard {
    type Output = std::sync::Arc<crate::ai::Blackboard>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbBehaviorTree {
    pub data_list: Vec<std::sync::Arc<crate::ai::BehaviorTree>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::ai::BehaviorTree>>,
}

impl TbBehaviorTree {
    pub fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbBehaviorTree>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::ai::BehaviorTree>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::ai::BehaviorTree>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::ai::BehaviorTree::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBehaviorTree { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::ai::BehaviorTree>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbBehaviorTree {
    type Output = std::sync::Arc<crate::ai::BehaviorTree>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


