// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_schema_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_schema_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_schema_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_schema_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_schema_2eproto;
namespace cfg {
class AiBehaviorTree;
struct AiBehaviorTreeDefaultTypeInternal;
extern AiBehaviorTreeDefaultTypeInternal _AiBehaviorTree_default_instance_;
class AiBinaryOperator;
struct AiBinaryOperatorDefaultTypeInternal;
extern AiBinaryOperatorDefaultTypeInternal _AiBinaryOperator_default_instance_;
class AiBlackboard;
struct AiBlackboardDefaultTypeInternal;
extern AiBlackboardDefaultTypeInternal _AiBlackboard_default_instance_;
class AiBlackboardKey;
struct AiBlackboardKeyDefaultTypeInternal;
extern AiBlackboardKeyDefaultTypeInternal _AiBlackboardKey_default_instance_;
class AiBlackboardKeyData;
struct AiBlackboardKeyDataDefaultTypeInternal;
extern AiBlackboardKeyDataDefaultTypeInternal _AiBlackboardKeyData_default_instance_;
class AiChooseSkill;
struct AiChooseSkillDefaultTypeInternal;
extern AiChooseSkillDefaultTypeInternal _AiChooseSkill_default_instance_;
class AiChooseTarget;
struct AiChooseTargetDefaultTypeInternal;
extern AiChooseTargetDefaultTypeInternal _AiChooseTarget_default_instance_;
class AiComposeNode;
struct AiComposeNodeDefaultTypeInternal;
extern AiComposeNodeDefaultTypeInternal _AiComposeNode_default_instance_;
class AiDebugPrint;
struct AiDebugPrintDefaultTypeInternal;
extern AiDebugPrintDefaultTypeInternal _AiDebugPrint_default_instance_;
class AiDecorator;
struct AiDecoratorDefaultTypeInternal;
extern AiDecoratorDefaultTypeInternal _AiDecorator_default_instance_;
class AiDistanceLessThan;
struct AiDistanceLessThanDefaultTypeInternal;
extern AiDistanceLessThanDefaultTypeInternal _AiDistanceLessThan_default_instance_;
class AiExecuteTimeStatistic;
struct AiExecuteTimeStatisticDefaultTypeInternal;
extern AiExecuteTimeStatisticDefaultTypeInternal _AiExecuteTimeStatistic_default_instance_;
class AiFloatKeyData;
struct AiFloatKeyDataDefaultTypeInternal;
extern AiFloatKeyDataDefaultTypeInternal _AiFloatKeyData_default_instance_;
class AiFlowNode;
struct AiFlowNodeDefaultTypeInternal;
extern AiFlowNodeDefaultTypeInternal _AiFlowNode_default_instance_;
class AiGetOwnerPlayer;
struct AiGetOwnerPlayerDefaultTypeInternal;
extern AiGetOwnerPlayerDefaultTypeInternal _AiGetOwnerPlayer_default_instance_;
class AiIntKeyData;
struct AiIntKeyDataDefaultTypeInternal;
extern AiIntKeyDataDefaultTypeInternal _AiIntKeyData_default_instance_;
class AiIsAtLocation;
struct AiIsAtLocationDefaultTypeInternal;
extern AiIsAtLocationDefaultTypeInternal _AiIsAtLocation_default_instance_;
class AiIsNotSet;
struct AiIsNotSetDefaultTypeInternal;
extern AiIsNotSetDefaultTypeInternal _AiIsNotSet_default_instance_;
class AiIsSet;
struct AiIsSetDefaultTypeInternal;
extern AiIsSetDefaultTypeInternal _AiIsSet_default_instance_;
class AiKeepFaceTarget;
struct AiKeepFaceTargetDefaultTypeInternal;
extern AiKeepFaceTargetDefaultTypeInternal _AiKeepFaceTarget_default_instance_;
class AiKeyData;
struct AiKeyDataDefaultTypeInternal;
extern AiKeyDataDefaultTypeInternal _AiKeyData_default_instance_;
class AiKeyQueryOperator;
struct AiKeyQueryOperatorDefaultTypeInternal;
extern AiKeyQueryOperatorDefaultTypeInternal _AiKeyQueryOperator_default_instance_;
class AiMoveToLocation;
struct AiMoveToLocationDefaultTypeInternal;
extern AiMoveToLocationDefaultTypeInternal _AiMoveToLocation_default_instance_;
class AiMoveToRandomLocation;
struct AiMoveToRandomLocationDefaultTypeInternal;
extern AiMoveToRandomLocationDefaultTypeInternal _AiMoveToRandomLocation_default_instance_;
class AiMoveToTarget;
struct AiMoveToTargetDefaultTypeInternal;
extern AiMoveToTargetDefaultTypeInternal _AiMoveToTarget_default_instance_;
class AiNode;
struct AiNodeDefaultTypeInternal;
extern AiNodeDefaultTypeInternal _AiNode_default_instance_;
class AiSelector;
struct AiSelectorDefaultTypeInternal;
extern AiSelectorDefaultTypeInternal _AiSelector_default_instance_;
class AiSequence;
struct AiSequenceDefaultTypeInternal;
extern AiSequenceDefaultTypeInternal _AiSequence_default_instance_;
class AiService;
struct AiServiceDefaultTypeInternal;
extern AiServiceDefaultTypeInternal _AiService_default_instance_;
class AiSimpleParallel;
struct AiSimpleParallelDefaultTypeInternal;
extern AiSimpleParallelDefaultTypeInternal _AiSimpleParallel_default_instance_;
class AiStringKeyData;
struct AiStringKeyDataDefaultTypeInternal;
extern AiStringKeyDataDefaultTypeInternal _AiStringKeyData_default_instance_;
class AiTask;
struct AiTaskDefaultTypeInternal;
extern AiTaskDefaultTypeInternal _AiTask_default_instance_;
class AiTbBehaviorTree;
struct AiTbBehaviorTreeDefaultTypeInternal;
extern AiTbBehaviorTreeDefaultTypeInternal _AiTbBehaviorTree_default_instance_;
class AiTbBlackboard;
struct AiTbBlackboardDefaultTypeInternal;
extern AiTbBlackboardDefaultTypeInternal _AiTbBlackboard_default_instance_;
class AiUeBlackboard;
struct AiUeBlackboardDefaultTypeInternal;
extern AiUeBlackboardDefaultTypeInternal _AiUeBlackboard_default_instance_;
class AiUeCooldown;
struct AiUeCooldownDefaultTypeInternal;
extern AiUeCooldownDefaultTypeInternal _AiUeCooldown_default_instance_;
class AiUeForceSuccess;
struct AiUeForceSuccessDefaultTypeInternal;
extern AiUeForceSuccessDefaultTypeInternal _AiUeForceSuccess_default_instance_;
class AiUeLoop;
struct AiUeLoopDefaultTypeInternal;
extern AiUeLoopDefaultTypeInternal _AiUeLoop_default_instance_;
class AiUeSetDefaultFocus;
struct AiUeSetDefaultFocusDefaultTypeInternal;
extern AiUeSetDefaultFocusDefaultTypeInternal _AiUeSetDefaultFocus_default_instance_;
class AiUeTimeLimit;
struct AiUeTimeLimitDefaultTypeInternal;
extern AiUeTimeLimitDefaultTypeInternal _AiUeTimeLimit_default_instance_;
class AiUeWait;
struct AiUeWaitDefaultTypeInternal;
extern AiUeWaitDefaultTypeInternal _AiUeWait_default_instance_;
class AiUeWaitBlackboardTime;
struct AiUeWaitBlackboardTimeDefaultTypeInternal;
extern AiUeWaitBlackboardTimeDefaultTypeInternal _AiUeWaitBlackboardTime_default_instance_;
class AiUpdateDailyBehaviorProps;
struct AiUpdateDailyBehaviorPropsDefaultTypeInternal;
extern AiUpdateDailyBehaviorPropsDefaultTypeInternal _AiUpdateDailyBehaviorProps_default_instance_;
class CommonGlobalConfig;
struct CommonGlobalConfigDefaultTypeInternal;
extern CommonGlobalConfigDefaultTypeInternal _CommonGlobalConfig_default_instance_;
class CommonTbGlobalConfig;
struct CommonTbGlobalConfigDefaultTypeInternal;
extern CommonTbGlobalConfigDefaultTypeInternal _CommonTbGlobalConfig_default_instance_;
class DefineFromExcel2;
struct DefineFromExcel2DefaultTypeInternal;
extern DefineFromExcel2DefaultTypeInternal _DefineFromExcel2_default_instance_;
class DefineFromExcel2_K8Entry_DoNotUse;
struct DefineFromExcel2_K8Entry_DoNotUseDefaultTypeInternal;
extern DefineFromExcel2_K8Entry_DoNotUseDefaultTypeInternal _DefineFromExcel2_K8Entry_DoNotUse_default_instance_;
class ItemItem;
struct ItemItemDefaultTypeInternal;
extern ItemItemDefaultTypeInternal _ItemItem_default_instance_;
class ItemTbItem;
struct ItemTbItemDefaultTypeInternal;
extern ItemTbItemDefaultTypeInternal _ItemTbItem_default_instance_;
class L10nL10NDemo;
struct L10nL10NDemoDefaultTypeInternal;
extern L10nL10NDemoDefaultTypeInternal _L10nL10NDemo_default_instance_;
class L10nPatchDemo;
struct L10nPatchDemoDefaultTypeInternal;
extern L10nPatchDemoDefaultTypeInternal _L10nPatchDemo_default_instance_;
class L10nTbL10NDemo;
struct L10nTbL10NDemoDefaultTypeInternal;
extern L10nTbL10NDemoDefaultTypeInternal _L10nTbL10NDemo_default_instance_;
class L10nTbPatchDemo;
struct L10nTbPatchDemoDefaultTypeInternal;
extern L10nTbPatchDemoDefaultTypeInternal _L10nTbPatchDemo_default_instance_;
class TagTbTestTag;
struct TagTbTestTagDefaultTypeInternal;
extern TagTbTestTagDefaultTypeInternal _TagTbTestTag_default_instance_;
class TagTestTag;
struct TagTestTagDefaultTypeInternal;
extern TagTestTagDefaultTypeInternal _TagTestTag_default_instance_;
class Test2Rectangle;
struct Test2RectangleDefaultTypeInternal;
extern Test2RectangleDefaultTypeInternal _Test2Rectangle_default_instance_;
class TestCircle;
struct TestCircleDefaultTypeInternal;
extern TestCircleDefaultTypeInternal _TestCircle_default_instance_;
class TestCompactString;
struct TestCompactStringDefaultTypeInternal;
extern TestCompactStringDefaultTypeInternal _TestCompactString_default_instance_;
class TestCompositeJsonTable1;
struct TestCompositeJsonTable1DefaultTypeInternal;
extern TestCompositeJsonTable1DefaultTypeInternal _TestCompositeJsonTable1_default_instance_;
class TestCompositeJsonTable2;
struct TestCompositeJsonTable2DefaultTypeInternal;
extern TestCompositeJsonTable2DefaultTypeInternal _TestCompositeJsonTable2_default_instance_;
class TestCompositeJsonTable3;
struct TestCompositeJsonTable3DefaultTypeInternal;
extern TestCompositeJsonTable3DefaultTypeInternal _TestCompositeJsonTable3_default_instance_;
class TestDateTimeRange;
struct TestDateTimeRangeDefaultTypeInternal;
extern TestDateTimeRangeDefaultTypeInternal _TestDateTimeRange_default_instance_;
class TestDecorator;
struct TestDecoratorDefaultTypeInternal;
extern TestDecoratorDefaultTypeInternal _TestDecorator_default_instance_;
class TestDemoD2;
struct TestDemoD2DefaultTypeInternal;
extern TestDemoD2DefaultTypeInternal _TestDemoD2_default_instance_;
class TestDemoD3;
struct TestDemoD3DefaultTypeInternal;
extern TestDemoD3DefaultTypeInternal _TestDemoD3_default_instance_;
class TestDemoD5;
struct TestDemoD5DefaultTypeInternal;
extern TestDemoD5DefaultTypeInternal _TestDemoD5_default_instance_;
class TestDemoDynamic;
struct TestDemoDynamicDefaultTypeInternal;
extern TestDemoDynamicDefaultTypeInternal _TestDemoDynamic_default_instance_;
class TestDemoE1;
struct TestDemoE1DefaultTypeInternal;
extern TestDemoE1DefaultTypeInternal _TestDemoE1_default_instance_;
class TestDemoE2;
struct TestDemoE2DefaultTypeInternal;
extern TestDemoE2DefaultTypeInternal _TestDemoE2_default_instance_;
class TestDemoGroup;
struct TestDemoGroupDefaultTypeInternal;
extern TestDemoGroupDefaultTypeInternal _TestDemoGroup_default_instance_;
class TestDemoPrimitiveTypesTable;
struct TestDemoPrimitiveTypesTableDefaultTypeInternal;
extern TestDemoPrimitiveTypesTableDefaultTypeInternal _TestDemoPrimitiveTypesTable_default_instance_;
class TestDemoSingletonType;
struct TestDemoSingletonTypeDefaultTypeInternal;
extern TestDemoSingletonTypeDefaultTypeInternal _TestDemoSingletonType_default_instance_;
class TestDemoType1;
struct TestDemoType1DefaultTypeInternal;
extern TestDemoType1DefaultTypeInternal _TestDemoType1_default_instance_;
class TestDemoType2;
struct TestDemoType2DefaultTypeInternal;
extern TestDemoType2DefaultTypeInternal _TestDemoType2_default_instance_;
class TestDemoType2_K8Entry_DoNotUse;
struct TestDemoType2_K8Entry_DoNotUseDefaultTypeInternal;
extern TestDemoType2_K8Entry_DoNotUseDefaultTypeInternal _TestDemoType2_K8Entry_DoNotUse_default_instance_;
class TestDetectEncoding;
struct TestDetectEncodingDefaultTypeInternal;
extern TestDetectEncodingDefaultTypeInternal _TestDetectEncoding_default_instance_;
class TestEquipment;
struct TestEquipmentDefaultTypeInternal;
extern TestEquipmentDefaultTypeInternal _TestEquipment_default_instance_;
class TestExcelFromJson;
struct TestExcelFromJsonDefaultTypeInternal;
extern TestExcelFromJsonDefaultTypeInternal _TestExcelFromJson_default_instance_;
class TestExcelFromJsonMultiRow;
struct TestExcelFromJsonMultiRowDefaultTypeInternal;
extern TestExcelFromJsonMultiRowDefaultTypeInternal _TestExcelFromJsonMultiRow_default_instance_;
class TestExcelFromJson_K8Entry_DoNotUse;
struct TestExcelFromJson_K8Entry_DoNotUseDefaultTypeInternal;
extern TestExcelFromJson_K8Entry_DoNotUseDefaultTypeInternal _TestExcelFromJson_K8Entry_DoNotUse_default_instance_;
class TestFoo;
struct TestFooDefaultTypeInternal;
extern TestFooDefaultTypeInternal _TestFoo_default_instance_;
class TestH1;
struct TestH1DefaultTypeInternal;
extern TestH1DefaultTypeInternal _TestH1_default_instance_;
class TestH2;
struct TestH2DefaultTypeInternal;
extern TestH2DefaultTypeInternal _TestH2_default_instance_;
class TestInnerGroup;
struct TestInnerGroupDefaultTypeInternal;
extern TestInnerGroupDefaultTypeInternal _TestInnerGroup_default_instance_;
class TestItem;
struct TestItemDefaultTypeInternal;
extern TestItemDefaultTypeInternal _TestItem_default_instance_;
class TestItemBase;
struct TestItemBaseDefaultTypeInternal;
extern TestItemBaseDefaultTypeInternal _TestItemBase_default_instance_;
class TestLoginRoleInfo;
struct TestLoginRoleInfoDefaultTypeInternal;
extern TestLoginRoleInfoDefaultTypeInternal _TestLoginRoleInfo_default_instance_;
class TestMultiIndexList;
struct TestMultiIndexListDefaultTypeInternal;
extern TestMultiIndexListDefaultTypeInternal _TestMultiIndexList_default_instance_;
class TestMultiRowRecord;
struct TestMultiRowRecordDefaultTypeInternal;
extern TestMultiRowRecordDefaultTypeInternal _TestMultiRowRecord_default_instance_;
class TestMultiRowRecord_MultiRows4Entry_DoNotUse;
struct TestMultiRowRecord_MultiRows4Entry_DoNotUseDefaultTypeInternal;
extern TestMultiRowRecord_MultiRows4Entry_DoNotUseDefaultTypeInternal _TestMultiRowRecord_MultiRows4Entry_DoNotUse_default_instance_;
class TestMultiRowRecord_MultiRows6Entry_DoNotUse;
struct TestMultiRowRecord_MultiRows6Entry_DoNotUseDefaultTypeInternal;
extern TestMultiRowRecord_MultiRows6Entry_DoNotUseDefaultTypeInternal _TestMultiRowRecord_MultiRows6Entry_DoNotUse_default_instance_;
class TestMultiRowRecord_MultiRows7Entry_DoNotUse;
struct TestMultiRowRecord_MultiRows7Entry_DoNotUseDefaultTypeInternal;
extern TestMultiRowRecord_MultiRows7Entry_DoNotUseDefaultTypeInternal _TestMultiRowRecord_MultiRows7Entry_DoNotUse_default_instance_;
class TestMultiRowTitle;
struct TestMultiRowTitleDefaultTypeInternal;
extern TestMultiRowTitleDefaultTypeInternal _TestMultiRowTitle_default_instance_;
class TestMultiRowType1;
struct TestMultiRowType1DefaultTypeInternal;
extern TestMultiRowType1DefaultTypeInternal _TestMultiRowType1_default_instance_;
class TestMultiRowType2;
struct TestMultiRowType2DefaultTypeInternal;
extern TestMultiRowType2DefaultTypeInternal _TestMultiRowType2_default_instance_;
class TestMultiRowType3;
struct TestMultiRowType3DefaultTypeInternal;
extern TestMultiRowType3DefaultTypeInternal _TestMultiRowType3_default_instance_;
class TestMultiUnionIndexList;
struct TestMultiUnionIndexListDefaultTypeInternal;
extern TestMultiUnionIndexListDefaultTypeInternal _TestMultiUnionIndexList_default_instance_;
class TestNotIndexList;
struct TestNotIndexListDefaultTypeInternal;
extern TestNotIndexListDefaultTypeInternal _TestNotIndexList_default_instance_;
class TestRefBean;
struct TestRefBeanDefaultTypeInternal;
extern TestRefBeanDefaultTypeInternal _TestRefBean_default_instance_;
class TestRefDynamicBase;
struct TestRefDynamicBaseDefaultTypeInternal;
extern TestRefDynamicBaseDefaultTypeInternal _TestRefDynamicBase_default_instance_;
class TestShape;
struct TestShapeDefaultTypeInternal;
extern TestShapeDefaultTypeInternal _TestShape_default_instance_;
class TestTbCompositeJsonTable1;
struct TestTbCompositeJsonTable1DefaultTypeInternal;
extern TestTbCompositeJsonTable1DefaultTypeInternal _TestTbCompositeJsonTable1_default_instance_;
class TestTbCompositeJsonTable2;
struct TestTbCompositeJsonTable2DefaultTypeInternal;
extern TestTbCompositeJsonTable2DefaultTypeInternal _TestTbCompositeJsonTable2_default_instance_;
class TestTbCompositeJsonTable3;
struct TestTbCompositeJsonTable3DefaultTypeInternal;
extern TestTbCompositeJsonTable3DefaultTypeInternal _TestTbCompositeJsonTable3_default_instance_;
class TestTbDataFromMisc;
struct TestTbDataFromMiscDefaultTypeInternal;
extern TestTbDataFromMiscDefaultTypeInternal _TestTbDataFromMisc_default_instance_;
class TestTbDefineFromExcel2;
struct TestTbDefineFromExcel2DefaultTypeInternal;
extern TestTbDefineFromExcel2DefaultTypeInternal _TestTbDefineFromExcel2_default_instance_;
class TestTbDemoGroup;
struct TestTbDemoGroupDefaultTypeInternal;
extern TestTbDemoGroupDefaultTypeInternal _TestTbDemoGroup_default_instance_;
class TestTbDemoPrimitive;
struct TestTbDemoPrimitiveDefaultTypeInternal;
extern TestTbDemoPrimitiveDefaultTypeInternal _TestTbDemoPrimitive_default_instance_;
class TestTbDetectCsvEncoding;
struct TestTbDetectCsvEncodingDefaultTypeInternal;
extern TestTbDetectCsvEncodingDefaultTypeInternal _TestTbDetectCsvEncoding_default_instance_;
class TestTbExcelFromJson;
struct TestTbExcelFromJsonDefaultTypeInternal;
extern TestTbExcelFromJsonDefaultTypeInternal _TestTbExcelFromJson_default_instance_;
class TestTbExcelFromJsonMultiRow;
struct TestTbExcelFromJsonMultiRowDefaultTypeInternal;
extern TestTbExcelFromJsonMultiRowDefaultTypeInternal _TestTbExcelFromJsonMultiRow_default_instance_;
class TestTbFullTypes;
struct TestTbFullTypesDefaultTypeInternal;
extern TestTbFullTypesDefaultTypeInternal _TestTbFullTypes_default_instance_;
class TestTbItem2;
struct TestTbItem2DefaultTypeInternal;
extern TestTbItem2DefaultTypeInternal _TestTbItem2_default_instance_;
class TestTbMultiIndexList;
struct TestTbMultiIndexListDefaultTypeInternal;
extern TestTbMultiIndexListDefaultTypeInternal _TestTbMultiIndexList_default_instance_;
class TestTbMultiRowRecord;
struct TestTbMultiRowRecordDefaultTypeInternal;
extern TestTbMultiRowRecordDefaultTypeInternal _TestTbMultiRowRecord_default_instance_;
class TestTbMultiRowTitle;
struct TestTbMultiRowTitleDefaultTypeInternal;
extern TestTbMultiRowTitleDefaultTypeInternal _TestTbMultiRowTitle_default_instance_;
class TestTbMultiUnionIndexList;
struct TestTbMultiUnionIndexListDefaultTypeInternal;
extern TestTbMultiUnionIndexListDefaultTypeInternal _TestTbMultiUnionIndexList_default_instance_;
class TestTbNotIndexList;
struct TestTbNotIndexListDefaultTypeInternal;
extern TestTbNotIndexListDefaultTypeInternal _TestTbNotIndexList_default_instance_;
class TestTbSingleton;
struct TestTbSingletonDefaultTypeInternal;
extern TestTbSingletonDefaultTypeInternal _TestTbSingleton_default_instance_;
class TestTbTestBeRef;
struct TestTbTestBeRefDefaultTypeInternal;
extern TestTbTestBeRefDefaultTypeInternal _TestTbTestBeRef_default_instance_;
class TestTbTestBeRef2;
struct TestTbTestBeRef2DefaultTypeInternal;
extern TestTbTestBeRef2DefaultTypeInternal _TestTbTestBeRef2_default_instance_;
class TestTbTestGlobal;
struct TestTbTestGlobalDefaultTypeInternal;
extern TestTbTestGlobalDefaultTypeInternal _TestTbTestGlobal_default_instance_;
class TestTbTestIndex;
struct TestTbTestIndexDefaultTypeInternal;
extern TestTbTestIndexDefaultTypeInternal _TestTbTestIndex_default_instance_;
class TestTbTestMap;
struct TestTbTestMapDefaultTypeInternal;
extern TestTbTestMapDefaultTypeInternal _TestTbTestMap_default_instance_;
class TestTbTestMapper;
struct TestTbTestMapperDefaultTypeInternal;
extern TestTbTestMapperDefaultTypeInternal _TestTbTestMapper_default_instance_;
class TestTbTestMultiColumn;
struct TestTbTestMultiColumnDefaultTypeInternal;
extern TestTbTestMultiColumnDefaultTypeInternal _TestTbTestMultiColumn_default_instance_;
class TestTbTestNull;
struct TestTbTestNullDefaultTypeInternal;
extern TestTbTestNullDefaultTypeInternal _TestTbTestNull_default_instance_;
class TestTbTestRef;
struct TestTbTestRefDefaultTypeInternal;
extern TestTbTestRefDefaultTypeInternal _TestTbTestRef_default_instance_;
class TestTbTestScriptableObject;
struct TestTbTestScriptableObjectDefaultTypeInternal;
extern TestTbTestScriptableObjectDefaultTypeInternal _TestTbTestScriptableObject_default_instance_;
class TestTbTestSet;
struct TestTbTestSetDefaultTypeInternal;
extern TestTbTestSetDefaultTypeInternal _TestTbTestSet_default_instance_;
class TestTbTestSize;
struct TestTbTestSizeDefaultTypeInternal;
extern TestTbTestSizeDefaultTypeInternal _TestTbTestSize_default_instance_;
class TestTbTestString;
struct TestTbTestStringDefaultTypeInternal;
extern TestTbTestStringDefaultTypeInternal _TestTbTestString_default_instance_;
class TestTest3;
struct TestTest3DefaultTypeInternal;
extern TestTest3DefaultTypeInternal _TestTest3_default_instance_;
class TestTestBeRef;
struct TestTestBeRefDefaultTypeInternal;
extern TestTestBeRefDefaultTypeInternal _TestTestBeRef_default_instance_;
class TestTestGlobal;
struct TestTestGlobalDefaultTypeInternal;
extern TestTestGlobalDefaultTypeInternal _TestTestGlobal_default_instance_;
class TestTestIndex;
struct TestTestIndexDefaultTypeInternal;
extern TestTestIndexDefaultTypeInternal _TestTestIndex_default_instance_;
class TestTestMap;
struct TestTestMapDefaultTypeInternal;
extern TestTestMapDefaultTypeInternal _TestTestMap_default_instance_;
class TestTestMap_X1Entry_DoNotUse;
struct TestTestMap_X1Entry_DoNotUseDefaultTypeInternal;
extern TestTestMap_X1Entry_DoNotUseDefaultTypeInternal _TestTestMap_X1Entry_DoNotUse_default_instance_;
class TestTestMap_X2Entry_DoNotUse;
struct TestTestMap_X2Entry_DoNotUseDefaultTypeInternal;
extern TestTestMap_X2Entry_DoNotUseDefaultTypeInternal _TestTestMap_X2Entry_DoNotUse_default_instance_;
class TestTestMap_X3Entry_DoNotUse;
struct TestTestMap_X3Entry_DoNotUseDefaultTypeInternal;
extern TestTestMap_X3Entry_DoNotUseDefaultTypeInternal _TestTestMap_X3Entry_DoNotUse_default_instance_;
class TestTestMap_X4Entry_DoNotUse;
struct TestTestMap_X4Entry_DoNotUseDefaultTypeInternal;
extern TestTestMap_X4Entry_DoNotUseDefaultTypeInternal _TestTestMap_X4Entry_DoNotUse_default_instance_;
class TestTestMapper;
struct TestTestMapperDefaultTypeInternal;
extern TestTestMapperDefaultTypeInternal _TestTestMapper_default_instance_;
class TestTestMultiColumn;
struct TestTestMultiColumnDefaultTypeInternal;
extern TestTestMultiColumnDefaultTypeInternal _TestTestMultiColumn_default_instance_;
class TestTestNull;
struct TestTestNullDefaultTypeInternal;
extern TestTestNullDefaultTypeInternal _TestTestNull_default_instance_;
class TestTestRef;
struct TestTestRefDefaultTypeInternal;
extern TestTestRefDefaultTypeInternal _TestTestRef_default_instance_;
class TestTestRef_D1Entry_DoNotUse;
struct TestTestRef_D1Entry_DoNotUseDefaultTypeInternal;
extern TestTestRef_D1Entry_DoNotUseDefaultTypeInternal _TestTestRef_D1Entry_DoNotUse_default_instance_;
class TestTestRef_D2Entry_DoNotUse;
struct TestTestRef_D2Entry_DoNotUseDefaultTypeInternal;
extern TestTestRef_D2Entry_DoNotUseDefaultTypeInternal _TestTestRef_D2Entry_DoNotUse_default_instance_;
class TestTestRow;
struct TestTestRowDefaultTypeInternal;
extern TestTestRowDefaultTypeInternal _TestTestRow_default_instance_;
class TestTestScriptableObject;
struct TestTestScriptableObjectDefaultTypeInternal;
extern TestTestScriptableObjectDefaultTypeInternal _TestTestScriptableObject_default_instance_;
class TestTestSet;
struct TestTestSetDefaultTypeInternal;
extern TestTestSetDefaultTypeInternal _TestTestSet_default_instance_;
class TestTestSize;
struct TestTestSizeDefaultTypeInternal;
extern TestTestSizeDefaultTypeInternal _TestTestSize_default_instance_;
class TestTestSize_X4Entry_DoNotUse;
struct TestTestSize_X4Entry_DoNotUseDefaultTypeInternal;
extern TestTestSize_X4Entry_DoNotUseDefaultTypeInternal _TestTestSize_X4Entry_DoNotUse_default_instance_;
class TestTestString;
struct TestTestStringDefaultTypeInternal;
extern TestTestStringDefaultTypeInternal _TestTestString_default_instance_;
class vec2;
struct vec2DefaultTypeInternal;
extern vec2DefaultTypeInternal _vec2_default_instance_;
class vec3;
struct vec3DefaultTypeInternal;
extern vec3DefaultTypeInternal _vec3_default_instance_;
class vec4;
struct vec4DefaultTypeInternal;
extern vec4DefaultTypeInternal _vec4_default_instance_;
}  // namespace cfg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cfg {
enum AiEExecutor : int {
  AiEExecutor_CLIENT = 0,
  AiEExecutor_SERVER = 1,
  AiEExecutor_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AiEExecutor_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AiEExecutor_IsValid(int value);
extern const uint32_t AiEExecutor_internal_data_[];
constexpr AiEExecutor AiEExecutor_MIN = static_cast<AiEExecutor>(0);
constexpr AiEExecutor AiEExecutor_MAX = static_cast<AiEExecutor>(1);
constexpr int AiEExecutor_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AiEExecutor_descriptor();
template <typename T>
const std::string& AiEExecutor_Name(T value) {
  static_assert(std::is_same<T, AiEExecutor>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AiEExecutor_Name().");
  return AiEExecutor_Name(static_cast<AiEExecutor>(value));
}
template <>
inline const std::string& AiEExecutor_Name(AiEExecutor value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AiEExecutor_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AiEExecutor_Parse(absl::string_view name, AiEExecutor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AiEExecutor>(
      AiEExecutor_descriptor(), name, value);
}
enum AiEKeyType : int {
  AiEKeyType_None = 0,
  AiEKeyType_BOOL = 1,
  AiEKeyType_INT = 2,
  AiEKeyType_FLOAT = 3,
  AiEKeyType_STRING = 4,
  AiEKeyType_VECTOR = 5,
  AiEKeyType_ROTATOR = 6,
  AiEKeyType_NAME = 7,
  AiEKeyType_CLASS = 8,
  AiEKeyType_ENUM = 9,
  AiEKeyType_OBJECT = 10,
  AiEKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AiEKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AiEKeyType_IsValid(int value);
extern const uint32_t AiEKeyType_internal_data_[];
constexpr AiEKeyType AiEKeyType_MIN = static_cast<AiEKeyType>(0);
constexpr AiEKeyType AiEKeyType_MAX = static_cast<AiEKeyType>(10);
constexpr int AiEKeyType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
AiEKeyType_descriptor();
template <typename T>
const std::string& AiEKeyType_Name(T value) {
  static_assert(std::is_same<T, AiEKeyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AiEKeyType_Name().");
  return AiEKeyType_Name(static_cast<AiEKeyType>(value));
}
template <>
inline const std::string& AiEKeyType_Name(AiEKeyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AiEKeyType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool AiEKeyType_Parse(absl::string_view name, AiEKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AiEKeyType>(
      AiEKeyType_descriptor(), name, value);
}
enum AiEFlowAbortMode : int {
  AiEFlowAbortMode_NONE = 0,
  AiEFlowAbortMode_LOWER_PRIORITY = 1,
  AiEFlowAbortMode_SELF = 2,
  AiEFlowAbortMode_BOTH = 3,
  AiEFlowAbortMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AiEFlowAbortMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AiEFlowAbortMode_IsValid(int value);
extern const uint32_t AiEFlowAbortMode_internal_data_[];
constexpr AiEFlowAbortMode AiEFlowAbortMode_MIN = static_cast<AiEFlowAbortMode>(0);
constexpr AiEFlowAbortMode AiEFlowAbortMode_MAX = static_cast<AiEFlowAbortMode>(3);
constexpr int AiEFlowAbortMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AiEFlowAbortMode_descriptor();
template <typename T>
const std::string& AiEFlowAbortMode_Name(T value) {
  static_assert(std::is_same<T, AiEFlowAbortMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AiEFlowAbortMode_Name().");
  return AiEFlowAbortMode_Name(static_cast<AiEFlowAbortMode>(value));
}
template <>
inline const std::string& AiEFlowAbortMode_Name(AiEFlowAbortMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AiEFlowAbortMode_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AiEFlowAbortMode_Parse(absl::string_view name, AiEFlowAbortMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AiEFlowAbortMode>(
      AiEFlowAbortMode_descriptor(), name, value);
}
enum AiEFinishMode : int {
  AiEFinishMode_IMMEDIATE = 0,
  AiEFinishMode_DELAYED = 1,
  AiEFinishMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AiEFinishMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AiEFinishMode_IsValid(int value);
extern const uint32_t AiEFinishMode_internal_data_[];
constexpr AiEFinishMode AiEFinishMode_MIN = static_cast<AiEFinishMode>(0);
constexpr AiEFinishMode AiEFinishMode_MAX = static_cast<AiEFinishMode>(1);
constexpr int AiEFinishMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AiEFinishMode_descriptor();
template <typename T>
const std::string& AiEFinishMode_Name(T value) {
  static_assert(std::is_same<T, AiEFinishMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AiEFinishMode_Name().");
  return AiEFinishMode_Name(static_cast<AiEFinishMode>(value));
}
template <>
inline const std::string& AiEFinishMode_Name(AiEFinishMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AiEFinishMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AiEFinishMode_Parse(absl::string_view name, AiEFinishMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AiEFinishMode>(
      AiEFinishMode_descriptor(), name, value);
}
enum AiENotifyObserverMode : int {
  AiENotifyObserverMode_ON_VALUE_CHANGE = 0,
  AiENotifyObserverMode_ON_RESULT_CHANGE = 1,
  AiENotifyObserverMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AiENotifyObserverMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AiENotifyObserverMode_IsValid(int value);
extern const uint32_t AiENotifyObserverMode_internal_data_[];
constexpr AiENotifyObserverMode AiENotifyObserverMode_MIN = static_cast<AiENotifyObserverMode>(0);
constexpr AiENotifyObserverMode AiENotifyObserverMode_MAX = static_cast<AiENotifyObserverMode>(1);
constexpr int AiENotifyObserverMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AiENotifyObserverMode_descriptor();
template <typename T>
const std::string& AiENotifyObserverMode_Name(T value) {
  static_assert(std::is_same<T, AiENotifyObserverMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AiENotifyObserverMode_Name().");
  return AiENotifyObserverMode_Name(static_cast<AiENotifyObserverMode>(value));
}
template <>
inline const std::string& AiENotifyObserverMode_Name(AiENotifyObserverMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AiENotifyObserverMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AiENotifyObserverMode_Parse(absl::string_view name, AiENotifyObserverMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AiENotifyObserverMode>(
      AiENotifyObserverMode_descriptor(), name, value);
}
enum AiEOperator : int {
  AiEOperator_IS_EQUAL_TO = 0,
  AiEOperator_IS_NOT_EQUAL_TO = 1,
  AiEOperator_IS_LESS_THAN = 2,
  AiEOperator_IS_LESS_THAN_OR_EQUAL_TO = 3,
  AiEOperator_IS_GREAT_THAN = 4,
  AiEOperator_IS_GREAT_THAN_OR_EQUAL_TO = 5,
  AiEOperator_CONTAINS = 6,
  AiEOperator_NOT_CONTAINS = 7,
  AiEOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AiEOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AiEOperator_IsValid(int value);
extern const uint32_t AiEOperator_internal_data_[];
constexpr AiEOperator AiEOperator_MIN = static_cast<AiEOperator>(0);
constexpr AiEOperator AiEOperator_MAX = static_cast<AiEOperator>(7);
constexpr int AiEOperator_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
AiEOperator_descriptor();
template <typename T>
const std::string& AiEOperator_Name(T value) {
  static_assert(std::is_same<T, AiEOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AiEOperator_Name().");
  return AiEOperator_Name(static_cast<AiEOperator>(value));
}
template <>
inline const std::string& AiEOperator_Name(AiEOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AiEOperator_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool AiEOperator_Parse(absl::string_view name, AiEOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AiEOperator>(
      AiEOperator_descriptor(), name, value);
}
enum AudioType : int {
  AudioType_UNKNOWN = 0,
  AudioType_ACC = 1,
  AudioType_AIFF = 2,
  AudioType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AudioType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AudioType_IsValid(int value);
extern const uint32_t AudioType_internal_data_[];
constexpr AudioType AudioType_MIN = static_cast<AudioType>(0);
constexpr AudioType AudioType_MAX = static_cast<AudioType>(2);
constexpr int AudioType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AudioType_descriptor();
template <typename T>
const std::string& AudioType_Name(T value) {
  static_assert(std::is_same<T, AudioType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AudioType_Name().");
  return AudioType_Name(static_cast<AudioType>(value));
}
template <>
inline const std::string& AudioType_Name(AudioType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AudioType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AudioType_Parse(absl::string_view name, AudioType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioType>(
      AudioType_descriptor(), name, value);
}
enum CommonEBoolOperator : int {
  CommonEBoolOperator_AND = 0,
  CommonEBoolOperator_OR = 1,
  CommonEBoolOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommonEBoolOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommonEBoolOperator_IsValid(int value);
extern const uint32_t CommonEBoolOperator_internal_data_[];
constexpr CommonEBoolOperator CommonEBoolOperator_MIN = static_cast<CommonEBoolOperator>(0);
constexpr CommonEBoolOperator CommonEBoolOperator_MAX = static_cast<CommonEBoolOperator>(1);
constexpr int CommonEBoolOperator_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
CommonEBoolOperator_descriptor();
template <typename T>
const std::string& CommonEBoolOperator_Name(T value) {
  static_assert(std::is_same<T, CommonEBoolOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CommonEBoolOperator_Name().");
  return CommonEBoolOperator_Name(static_cast<CommonEBoolOperator>(value));
}
template <>
inline const std::string& CommonEBoolOperator_Name(CommonEBoolOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommonEBoolOperator_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool CommonEBoolOperator_Parse(absl::string_view name, CommonEBoolOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonEBoolOperator>(
      CommonEBoolOperator_descriptor(), name, value);
}
enum ItemEItemQuality : int {
  ItemEItemQuality_WHITE = 0,
  ItemEItemQuality_GREEN = 1,
  ItemEItemQuality_BLUE = 2,
  ItemEItemQuality_PURPLE = 3,
  ItemEItemQuality_GOLDEN = 4,
  ItemEItemQuality_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEItemQuality_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEItemQuality_IsValid(int value);
extern const uint32_t ItemEItemQuality_internal_data_[];
constexpr ItemEItemQuality ItemEItemQuality_MIN = static_cast<ItemEItemQuality>(0);
constexpr ItemEItemQuality ItemEItemQuality_MAX = static_cast<ItemEItemQuality>(4);
constexpr int ItemEItemQuality_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEItemQuality_descriptor();
template <typename T>
const std::string& ItemEItemQuality_Name(T value) {
  static_assert(std::is_same<T, ItemEItemQuality>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEItemQuality_Name().");
  return ItemEItemQuality_Name(static_cast<ItemEItemQuality>(value));
}
template <>
inline const std::string& ItemEItemQuality_Name(ItemEItemQuality value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemEItemQuality_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ItemEItemQuality_Parse(absl::string_view name, ItemEItemQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEItemQuality>(
      ItemEItemQuality_descriptor(), name, value);
}
enum ItemECurrencyType : int {
  ItemECurrencyType_None = 0,
  ItemECurrencyType_DIAMOND = 1,
  ItemECurrencyType_GOLD = 2,
  ItemECurrencyType_SILVER = 3,
  ItemECurrencyType_EXP = 4,
  ItemECurrencyType_POWER_POINT = 5,
  ItemECurrencyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemECurrencyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemECurrencyType_IsValid(int value);
extern const uint32_t ItemECurrencyType_internal_data_[];
constexpr ItemECurrencyType ItemECurrencyType_MIN = static_cast<ItemECurrencyType>(0);
constexpr ItemECurrencyType ItemECurrencyType_MAX = static_cast<ItemECurrencyType>(5);
constexpr int ItemECurrencyType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ItemECurrencyType_descriptor();
template <typename T>
const std::string& ItemECurrencyType_Name(T value) {
  static_assert(std::is_same<T, ItemECurrencyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemECurrencyType_Name().");
  return ItemECurrencyType_Name(static_cast<ItemECurrencyType>(value));
}
template <>
inline const std::string& ItemECurrencyType_Name(ItemECurrencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemECurrencyType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ItemECurrencyType_Parse(absl::string_view name, ItemECurrencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemECurrencyType>(
      ItemECurrencyType_descriptor(), name, value);
}
enum ItemEMajorType : int {
  ItemEMajorType_None = 0,
  ItemEMajorType_CURRENCY = 1,
  ItemEMajorType_CLOTH = 2,
  ItemEMajorType_QUEST = 3,
  ItemEMajorType_CONSUMABLES = 4,
  ItemEMajorType_TREASURE_BOX = 5,
  ItemEMajorType_ACHIEVEMENT_AND_TITLE = 6,
  ItemEMajorType_HEAD_FRAME = 7,
  ItemEMajorType_VOICE = 8,
  ItemEMajorType_ACTION = 9,
  ItemEMajorType_EXPANSION = 10,
  ItemEMajorType_MATERIAL = 11,
  ItemEMajorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEMajorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEMajorType_IsValid(int value);
extern const uint32_t ItemEMajorType_internal_data_[];
constexpr ItemEMajorType ItemEMajorType_MIN = static_cast<ItemEMajorType>(0);
constexpr ItemEMajorType ItemEMajorType_MAX = static_cast<ItemEMajorType>(11);
constexpr int ItemEMajorType_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEMajorType_descriptor();
template <typename T>
const std::string& ItemEMajorType_Name(T value) {
  static_assert(std::is_same<T, ItemEMajorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEMajorType_Name().");
  return ItemEMajorType_Name(static_cast<ItemEMajorType>(value));
}
template <>
inline const std::string& ItemEMajorType_Name(ItemEMajorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemEMajorType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool ItemEMajorType_Parse(absl::string_view name, ItemEMajorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEMajorType>(
      ItemEMajorType_descriptor(), name, value);
}
enum ItemEMinorType : int {
  ItemEMinorType_None = 0,
  ItemEMinorType_DIAMOND = 101,
  ItemEMinorType_GOLD = 102,
  ItemEMinorType_SILVER = 103,
  ItemEMinorType_EXP = 104,
  ItemEMinorType_POWER_POINT = 105,
  ItemEMinorType_HAIR_STYLE = 210,
  ItemEMinorType_COAT = 220,
  ItemEMinorType_UPPER_JACKET = 230,
  ItemEMinorType_TROUSERS = 241,
  ItemEMinorType_SKIRT = 242,
  ItemEMinorType_SOCKS = 250,
  ItemEMinorType_SHOES = 260,
  ItemEMinorType_HAIR_ACCESSORY = 271,
  ItemEMinorType_HAT = 272,
  ItemEMinorType_EARRING = 273,
  ItemEMinorType_NECKLACE = 274,
  ItemEMinorType_BRACELET = 275,
  ItemEMinorType_HAIR_CLASP = 276,
  ItemEMinorType_GLOVE = 277,
  ItemEMinorType_HANDHELD_OBJECT = 278,
  ItemEMinorType_SPECIAL = 279,
  ItemEMinorType_BASE_COSMETIC = 281,
  ItemEMinorType_EYEBROW_COSMETIC = 282,
  ItemEMinorType_EYELASH = 283,
  ItemEMinorType_COSMETIC_CONTACT_LENSES = 284,
  ItemEMinorType_LIP_COSMETIC = 285,
  ItemEMinorType_SKIN_COLOR = 286,
  ItemEMinorType_ONE_PIECE_DRESS = 290,
  ItemEMinorType_SWITCH_CLOTHES_SCENE = 291,
  ItemEMinorType_QUEST = 301,
  ItemEMinorType_CAST = 401,
  ItemEMinorType_SWORD = 421,
  ItemEMinorType_BOW_ARROW = 422,
  ItemEMinorType_WANDS = 423,
  ItemEMinorType_SPECIAL_TOOL = 424,
  ItemEMinorType_FOOD = 403,
  ItemEMinorType_TREASURE_BOX = 501,
  ItemEMinorType_KEY = 502,
  ItemEMinorType_MULTI_CHOOSE_TREASURE_BOX = 503,
  ItemEMinorType_ACHIEVEMENT = 601,
  ItemEMinorType_TITLE = 602,
  ItemEMinorType_AVATAR_FRAME = 701,
  ItemEMinorType_VOICE = 801,
  ItemEMinorType_IDLE_POSE = 901,
  ItemEMinorType_PHOTO_POSE = 902,
  ItemEMinorType_BAG = 1001,
  ItemEMinorType_FRIEND_CAPACITY = 1002,
  ItemEMinorType_CONSTRUCTION_MATERIAL = 1101,
  ItemEMinorType_DESIGN_DRAWING = 1102,
  ItemEMinorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEMinorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEMinorType_IsValid(int value);
extern const uint32_t ItemEMinorType_internal_data_[];
constexpr ItemEMinorType ItemEMinorType_MIN = static_cast<ItemEMinorType>(0);
constexpr ItemEMinorType ItemEMinorType_MAX = static_cast<ItemEMinorType>(1102);
constexpr int ItemEMinorType_ARRAYSIZE = 1102 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEMinorType_descriptor();
template <typename T>
const std::string& ItemEMinorType_Name(T value) {
  static_assert(std::is_same<T, ItemEMinorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEMinorType_Name().");
  return ::google::protobuf::internal::NameOfEnum(ItemEMinorType_descriptor(), value);
}
inline bool ItemEMinorType_Parse(absl::string_view name, ItemEMinorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEMinorType>(
      ItemEMinorType_descriptor(), name, value);
}
enum ItemEClothersStarQualityType : int {
  ItemEClothersStarQualityType_None = 0,
  ItemEClothersStarQualityType_ONE = 1,
  ItemEClothersStarQualityType_TWO = 2,
  ItemEClothersStarQualityType_THREE = 3,
  ItemEClothersStarQualityType_FOUR = 4,
  ItemEClothersStarQualityType_FIVE = 5,
  ItemEClothersStarQualityType_SIX = 6,
  ItemEClothersStarQualityType_SEVEN = 7,
  ItemEClothersStarQualityType_EIGHT = 8,
  ItemEClothersStarQualityType_NINE = 9,
  ItemEClothersStarQualityType_TEN = 10,
  ItemEClothersStarQualityType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEClothersStarQualityType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEClothersStarQualityType_IsValid(int value);
extern const uint32_t ItemEClothersStarQualityType_internal_data_[];
constexpr ItemEClothersStarQualityType ItemEClothersStarQualityType_MIN = static_cast<ItemEClothersStarQualityType>(0);
constexpr ItemEClothersStarQualityType ItemEClothersStarQualityType_MAX = static_cast<ItemEClothersStarQualityType>(10);
constexpr int ItemEClothersStarQualityType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEClothersStarQualityType_descriptor();
template <typename T>
const std::string& ItemEClothersStarQualityType_Name(T value) {
  static_assert(std::is_same<T, ItemEClothersStarQualityType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEClothersStarQualityType_Name().");
  return ItemEClothersStarQualityType_Name(static_cast<ItemEClothersStarQualityType>(value));
}
template <>
inline const std::string& ItemEClothersStarQualityType_Name(ItemEClothersStarQualityType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemEClothersStarQualityType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool ItemEClothersStarQualityType_Parse(absl::string_view name, ItemEClothersStarQualityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEClothersStarQualityType>(
      ItemEClothersStarQualityType_descriptor(), name, value);
}
enum ItemEClothersTag : int {
  ItemEClothersTag_None = 0,
  ItemEClothersTag_FANG_SHAI = 1,
  ItemEClothersTag_WU_ZHE = 2,
  ItemEClothersTag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEClothersTag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEClothersTag_IsValid(int value);
extern const uint32_t ItemEClothersTag_internal_data_[];
constexpr ItemEClothersTag ItemEClothersTag_MIN = static_cast<ItemEClothersTag>(0);
constexpr ItemEClothersTag ItemEClothersTag_MAX = static_cast<ItemEClothersTag>(2);
constexpr int ItemEClothersTag_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEClothersTag_descriptor();
template <typename T>
const std::string& ItemEClothersTag_Name(T value) {
  static_assert(std::is_same<T, ItemEClothersTag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEClothersTag_Name().");
  return ItemEClothersTag_Name(static_cast<ItemEClothersTag>(value));
}
template <>
inline const std::string& ItemEClothersTag_Name(ItemEClothersTag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemEClothersTag_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ItemEClothersTag_Parse(absl::string_view name, ItemEClothersTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEClothersTag>(
      ItemEClothersTag_descriptor(), name, value);
}
enum ItemEUseType : int {
  ItemEUseType_MANUAL = 0,
  ItemEUseType_AUTO = 1,
  ItemEUseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEUseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEUseType_IsValid(int value);
extern const uint32_t ItemEUseType_internal_data_[];
constexpr ItemEUseType ItemEUseType_MIN = static_cast<ItemEUseType>(0);
constexpr ItemEUseType ItemEUseType_MAX = static_cast<ItemEUseType>(1);
constexpr int ItemEUseType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEUseType_descriptor();
template <typename T>
const std::string& ItemEUseType_Name(T value) {
  static_assert(std::is_same<T, ItemEUseType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEUseType_Name().");
  return ItemEUseType_Name(static_cast<ItemEUseType>(value));
}
template <>
inline const std::string& ItemEUseType_Name(ItemEUseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemEUseType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ItemEUseType_Parse(absl::string_view name, ItemEUseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEUseType>(
      ItemEUseType_descriptor(), name, value);
}
enum ItemEClothesHidePartType : int {
  ItemEClothesHidePartType_CHEST = 0,
  ItemEClothesHidePartType_HEAD = 1,
  ItemEClothesHidePartType_SPINE_UPPER = 2,
  ItemEClothesHidePartType_SPINE_LOWER = 3,
  ItemEClothesHidePartType_HIP = 4,
  ItemEClothesHidePartType_LEG_UPPER = 5,
  ItemEClothesHidePartType_LEG_MIDDLE = 6,
  ItemEClothesHidePartType_LEG_LOWER = 7,
  ItemEClothesHidePartType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEClothesHidePartType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEClothesHidePartType_IsValid(int value);
extern const uint32_t ItemEClothesHidePartType_internal_data_[];
constexpr ItemEClothesHidePartType ItemEClothesHidePartType_MIN = static_cast<ItemEClothesHidePartType>(0);
constexpr ItemEClothesHidePartType ItemEClothesHidePartType_MAX = static_cast<ItemEClothesHidePartType>(7);
constexpr int ItemEClothesHidePartType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEClothesHidePartType_descriptor();
template <typename T>
const std::string& ItemEClothesHidePartType_Name(T value) {
  static_assert(std::is_same<T, ItemEClothesHidePartType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEClothesHidePartType_Name().");
  return ItemEClothesHidePartType_Name(static_cast<ItemEClothesHidePartType>(value));
}
template <>
inline const std::string& ItemEClothesHidePartType_Name(ItemEClothesHidePartType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemEClothesHidePartType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool ItemEClothesHidePartType_Parse(absl::string_view name, ItemEClothesHidePartType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEClothesHidePartType>(
      ItemEClothesHidePartType_descriptor(), name, value);
}
enum ItemEClothesPropertyType : int {
  ItemEClothesPropertyType_None = 0,
  ItemEClothesPropertyType_JIAN_YUE = 1,
  ItemEClothesPropertyType_HUA_LI = 2,
  ItemEClothesPropertyType_KE_AI = 3,
  ItemEClothesPropertyType_CHENG_SHU = 4,
  ItemEClothesPropertyType_HUO_PO = 5,
  ItemEClothesPropertyType_YOU_YA = 6,
  ItemEClothesPropertyType_QING_CHUN = 7,
  ItemEClothesPropertyType_XING_GAN = 8,
  ItemEClothesPropertyType_QING_LIANG = 9,
  ItemEClothesPropertyType_BAO_NUAN = 10,
  ItemEClothesPropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemEClothesPropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemEClothesPropertyType_IsValid(int value);
extern const uint32_t ItemEClothesPropertyType_internal_data_[];
constexpr ItemEClothesPropertyType ItemEClothesPropertyType_MIN = static_cast<ItemEClothesPropertyType>(0);
constexpr ItemEClothesPropertyType ItemEClothesPropertyType_MAX = static_cast<ItemEClothesPropertyType>(10);
constexpr int ItemEClothesPropertyType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
ItemEClothesPropertyType_descriptor();
template <typename T>
const std::string& ItemEClothesPropertyType_Name(T value) {
  static_assert(std::is_same<T, ItemEClothesPropertyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemEClothesPropertyType_Name().");
  return ItemEClothesPropertyType_Name(static_cast<ItemEClothesPropertyType>(value));
}
template <>
inline const std::string& ItemEClothesPropertyType_Name(ItemEClothesPropertyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemEClothesPropertyType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool ItemEClothesPropertyType_Parse(absl::string_view name, ItemEClothesPropertyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemEClothesPropertyType>(
      ItemEClothesPropertyType_descriptor(), name, value);
}
enum TestDemoEnum : int {
  TestDemoEnum_NONE = 0,
  TestDemoEnum_A = 1,
  TestDemoEnum_B = 2,
  TestDemoEnum_C = 4,
  TestDemoEnum_D = 5,
  TestDemoEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestDemoEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestDemoEnum_IsValid(int value);
extern const uint32_t TestDemoEnum_internal_data_[];
constexpr TestDemoEnum TestDemoEnum_MIN = static_cast<TestDemoEnum>(0);
constexpr TestDemoEnum TestDemoEnum_MAX = static_cast<TestDemoEnum>(5);
constexpr int TestDemoEnum_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TestDemoEnum_descriptor();
template <typename T>
const std::string& TestDemoEnum_Name(T value) {
  static_assert(std::is_same<T, TestDemoEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestDemoEnum_Name().");
  return TestDemoEnum_Name(static_cast<TestDemoEnum>(value));
}
template <>
inline const std::string& TestDemoEnum_Name(TestDemoEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestDemoEnum_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TestDemoEnum_Parse(absl::string_view name, TestDemoEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestDemoEnum>(
      TestDemoEnum_descriptor(), name, value);
}
enum TestDemoFlag : int {
  TestDemoEnum_None = 0,
  TestDemoFlag_A = 1,
  TestDemoFlag_B = 2,
  TestDemoFlag_C = 4,
  TestDemoFlag_D = 8,
  TestDemoFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestDemoFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestDemoFlag_IsValid(int value);
extern const uint32_t TestDemoFlag_internal_data_[];
constexpr TestDemoFlag TestDemoFlag_MIN = static_cast<TestDemoFlag>(0);
constexpr TestDemoFlag TestDemoFlag_MAX = static_cast<TestDemoFlag>(8);
constexpr int TestDemoFlag_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
TestDemoFlag_descriptor();
template <typename T>
const std::string& TestDemoFlag_Name(T value) {
  static_assert(std::is_same<T, TestDemoFlag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestDemoFlag_Name().");
  return TestDemoFlag_Name(static_cast<TestDemoFlag>(value));
}
template <>
inline const std::string& TestDemoFlag_Name(TestDemoFlag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestDemoFlag_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool TestDemoFlag_Parse(absl::string_view name, TestDemoFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestDemoFlag>(
      TestDemoFlag_descriptor(), name, value);
}
enum TestETestUeType : int {
  TestETestUeType_WHITE = 0,
  TestETestUeType_BLACK = 1,
  TestETestUeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestETestUeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestETestUeType_IsValid(int value);
extern const uint32_t TestETestUeType_internal_data_[];
constexpr TestETestUeType TestETestUeType_MIN = static_cast<TestETestUeType>(0);
constexpr TestETestUeType TestETestUeType_MAX = static_cast<TestETestUeType>(1);
constexpr int TestETestUeType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
TestETestUeType_descriptor();
template <typename T>
const std::string& TestETestUeType_Name(T value) {
  static_assert(std::is_same<T, TestETestUeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestETestUeType_Name().");
  return TestETestUeType_Name(static_cast<TestETestUeType>(value));
}
template <>
inline const std::string& TestETestUeType_Name(TestETestUeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestETestUeType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool TestETestUeType_Parse(absl::string_view name, TestETestUeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestETestUeType>(
      TestETestUeType_descriptor(), name, value);
}
enum TestETestEmptyEnum : int {
  TestETestEmptyEnum_EMPTY_PLACEHOLDER = 0,
  TestETestEmptyEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestETestEmptyEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestETestEmptyEnum_IsValid(int value);
extern const uint32_t TestETestEmptyEnum_internal_data_[];
constexpr TestETestEmptyEnum TestETestEmptyEnum_MIN = static_cast<TestETestEmptyEnum>(0);
constexpr TestETestEmptyEnum TestETestEmptyEnum_MAX = static_cast<TestETestEmptyEnum>(0);
constexpr int TestETestEmptyEnum_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
TestETestEmptyEnum_descriptor();
template <typename T>
const std::string& TestETestEmptyEnum_Name(T value) {
  static_assert(std::is_same<T, TestETestEmptyEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestETestEmptyEnum_Name().");
  return TestETestEmptyEnum_Name(static_cast<TestETestEmptyEnum>(value));
}
template <>
inline const std::string& TestETestEmptyEnum_Name(TestETestEmptyEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestETestEmptyEnum_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool TestETestEmptyEnum_Parse(absl::string_view name, TestETestEmptyEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestETestEmptyEnum>(
      TestETestEmptyEnum_descriptor(), name, value);
}
enum TestETestEmptyEnum2 : int {
  TestETestEmptyEnum2_None = 0,
  TestETestEmptyEnum2_SMALL_THAN_256 = 255,
  TestETestEmptyEnum2_X_256 = 256,
  TestETestEmptyEnum2_X_257 = 257,
  TestETestEmptyEnum2_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestETestEmptyEnum2_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestETestEmptyEnum2_IsValid(int value);
extern const uint32_t TestETestEmptyEnum2_internal_data_[];
constexpr TestETestEmptyEnum2 TestETestEmptyEnum2_MIN = static_cast<TestETestEmptyEnum2>(0);
constexpr TestETestEmptyEnum2 TestETestEmptyEnum2_MAX = static_cast<TestETestEmptyEnum2>(257);
constexpr int TestETestEmptyEnum2_ARRAYSIZE = 257 + 1;
const ::google::protobuf::EnumDescriptor*
TestETestEmptyEnum2_descriptor();
template <typename T>
const std::string& TestETestEmptyEnum2_Name(T value) {
  static_assert(std::is_same<T, TestETestEmptyEnum2>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestETestEmptyEnum2_Name().");
  return ::google::protobuf::internal::NameOfEnum(TestETestEmptyEnum2_descriptor(), value);
}
inline bool TestETestEmptyEnum2_Parse(absl::string_view name, TestETestEmptyEnum2* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestETestEmptyEnum2>(
      TestETestEmptyEnum2_descriptor(), name, value);
}
enum TestETestQuality : int {
  TestETestQuality_None = 0,
  TestETestQuality_A = 1,
  TestETestQuality_B = 2,
  TestETestQuality_C = 3,
  TestETestQuality_D = 4,
  TestETestQuality_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestETestQuality_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestETestQuality_IsValid(int value);
extern const uint32_t TestETestQuality_internal_data_[];
constexpr TestETestQuality TestETestQuality_MIN = static_cast<TestETestQuality>(0);
constexpr TestETestQuality TestETestQuality_MAX = static_cast<TestETestQuality>(4);
constexpr int TestETestQuality_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
TestETestQuality_descriptor();
template <typename T>
const std::string& TestETestQuality_Name(T value) {
  static_assert(std::is_same<T, TestETestQuality>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestETestQuality_Name().");
  return TestETestQuality_Name(static_cast<TestETestQuality>(value));
}
template <>
inline const std::string& TestETestQuality_Name(TestETestQuality value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestETestQuality_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool TestETestQuality_Parse(absl::string_view name, TestETestQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestETestQuality>(
      TestETestQuality_descriptor(), name, value);
}
enum TestAccessFlag : int {
  TestAccessFlag_None = 0,
  TestAccessFlag_WRITE = 1,
  TestAccessFlag_READ = 2,
  TestAccessFlag_TRUNCATE = 4,
  TestAccessFlag_NEW = 8,
  TestAccessFlag_READ_WRITE = 3,
  TestAccessFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestAccessFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestAccessFlag_IsValid(int value);
extern const uint32_t TestAccessFlag_internal_data_[];
constexpr TestAccessFlag TestAccessFlag_MIN = static_cast<TestAccessFlag>(0);
constexpr TestAccessFlag TestAccessFlag_MAX = static_cast<TestAccessFlag>(8);
constexpr int TestAccessFlag_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
TestAccessFlag_descriptor();
template <typename T>
const std::string& TestAccessFlag_Name(T value) {
  static_assert(std::is_same<T, TestAccessFlag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestAccessFlag_Name().");
  return TestAccessFlag_Name(static_cast<TestAccessFlag>(value));
}
template <>
inline const std::string& TestAccessFlag_Name(TestAccessFlag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestAccessFlag_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool TestAccessFlag_Parse(absl::string_view name, TestAccessFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestAccessFlag>(
      TestAccessFlag_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class vec4 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.vec4) */ {
 public:
  inline vec4() : vec4(nullptr) {}
  ~vec4() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR vec4(::google::protobuf::internal::ConstantInitialized);

  vec4(const vec4& from);
  vec4(vec4&& from) noexcept
    : vec4() {
    *this = ::std::move(from);
  }

  inline vec4(::google::protobuf::Arena* arena, const vec4& from)
    : vec4(arena) {
    MergeFrom(from);
  }
  inline vec4& operator=(const vec4& from) {
    CopyFrom(from);
    return *this;
  }
  inline vec4& operator=(vec4&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const vec4& default_instance() {
    return *internal_default_instance();
  }
  static inline const vec4* internal_default_instance() {
    return reinterpret_cast<const vec4*>(
               &_vec4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(vec4& a, vec4& b) {
    a.Swap(&b);
  }
  inline void Swap(vec4* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vec4* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vec4* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vec4>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const vec4& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const vec4& from) {
    vec4::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vec4* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.vec4";
  }
  protected:
  explicit vec4(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // float w = 4;
  void clear_w() ;
  float w() const;
  void set_w(float value);

  private:
  float _internal_w() const;
  void _internal_set_w(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.vec4)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    float w_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class vec3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.vec3) */ {
 public:
  inline vec3() : vec3(nullptr) {}
  ~vec3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR vec3(::google::protobuf::internal::ConstantInitialized);

  vec3(const vec3& from);
  vec3(vec3&& from) noexcept
    : vec3() {
    *this = ::std::move(from);
  }

  inline vec3(::google::protobuf::Arena* arena, const vec3& from)
    : vec3(arena) {
    MergeFrom(from);
  }
  inline vec3& operator=(const vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline vec3& operator=(vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const vec3* internal_default_instance() {
    return reinterpret_cast<const vec3*>(
               &_vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(vec3& a, vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vec3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vec3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const vec3& from) {
    vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vec3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.vec3";
  }
  protected:
  explicit vec3(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.vec3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class vec2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.vec2) */ {
 public:
  inline vec2() : vec2(nullptr) {}
  ~vec2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR vec2(::google::protobuf::internal::ConstantInitialized);

  vec2(const vec2& from);
  vec2(vec2&& from) noexcept
    : vec2() {
    *this = ::std::move(from);
  }

  inline vec2(::google::protobuf::Arena* arena, const vec2& from)
    : vec2(arena) {
    MergeFrom(from);
  }
  inline vec2& operator=(const vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline vec2& operator=(vec2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const vec2& default_instance() {
    return *internal_default_instance();
  }
  static inline const vec2* internal_default_instance() {
    return reinterpret_cast<const vec2*>(
               &_vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(vec2& a, vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(vec2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vec2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vec2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vec2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const vec2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const vec2& from) {
    vec2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vec2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.vec2";
  }
  protected:
  explicit vec2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.vec2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestSize_X4Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestTestSize_X4Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestTestSize_X4Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestTestSize_X4Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestSize_X4Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestTestSize_X4Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestTestSize_X4Entry_DoNotUse& other);
  static const TestTestSize_X4Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestTestSize_X4Entry_DoNotUse*>(&_TestTestSize_X4Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestTestSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestSet) */ {
 public:
  inline TestTestSet() : TestTestSet(nullptr) {}
  ~TestTestSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestSet(::google::protobuf::internal::ConstantInitialized);

  TestTestSet(const TestTestSet& from);
  TestTestSet(TestTestSet&& from) noexcept
    : TestTestSet() {
    *this = ::std::move(from);
  }

  inline TestTestSet(::google::protobuf::Arena* arena, const TestTestSet& from)
    : TestTestSet(arena) {
    MergeFrom(from);
  }
  inline TestTestSet& operator=(const TestTestSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestSet& operator=(TestTestSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestSet* internal_default_instance() {
    return reinterpret_cast<const TestTestSet*>(
               &_TestTestSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(TestTestSet& a, TestTestSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestSet& from) {
    TestTestSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestSet* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestSet";
  }
  protected:
  explicit TestTestSet(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 3,
    kX2FieldNumber = 4,
    kX3FieldNumber = 5,
    kX4FieldNumber = 6,
    kX0FieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated int32 x1 = 3 [packed = true];
  int x1_size() const;
  private:
  int _internal_x1_size() const;

  public:
  void clear_x1() ;
  ::int32_t x1(int index) const;
  void set_x1(int index, ::int32_t value);
  void add_x1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& x1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_x1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_x1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_x1();

  public:
  // repeated int64 x2 = 4 [packed = true];
  int x2_size() const;
  private:
  int _internal_x2_size() const;

  public:
  void clear_x2() ;
  ::int64_t x2(int index) const;
  void set_x2(int index, ::int64_t value);
  void add_x2(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& x2() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_x2();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_x2() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_x2();

  public:
  // repeated string x3 = 5 [packed = false];
  int x3_size() const;
  private:
  int _internal_x3_size() const;

  public:
  void clear_x3() ;
  const std::string& x3(int index) const;
  std::string* mutable_x3(int index);
  void set_x3(int index, const std::string& value);
  void set_x3(int index, std::string&& value);
  void set_x3(int index, const char* value);
  void set_x3(int index, const char* value, std::size_t size);
  void set_x3(int index, absl::string_view value);
  std::string* add_x3();
  void add_x3(const std::string& value);
  void add_x3(std::string&& value);
  void add_x3(const char* value);
  void add_x3(const char* value, std::size_t size);
  void add_x3(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& x3() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_x3();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_x3() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_x3();

  public:
  // repeated .cfg.TestDemoEnum x4 = 6 [packed = false];
  int x4_size() const;
  private:
  int _internal_x4_size() const;

  public:
  void clear_x4() ;
  public:
  ::cfg::TestDemoEnum x4(int index) const;
  void set_x4(int index, ::cfg::TestDemoEnum value);
  void add_x4(::cfg::TestDemoEnum value);
  const ::google::protobuf::RepeatedField<int>& x4() const;
  ::google::protobuf::RepeatedField<int>* mutable_x4();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_x4() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_x4();

  public:
  // string x0 = 2;
  void clear_x0() ;
  const std::string& x0() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_x0(Arg_&& arg, Args_... args);
  std::string* mutable_x0();
  PROTOBUF_NODISCARD std::string* release_x0();
  void set_allocated_x0(std::string* ptr);

  private:
  const std::string& _internal_x0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x0(
      const std::string& value);
  std::string* _internal_mutable_x0();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestSet)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      28, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> x1_;
    mutable ::google::protobuf::internal::CachedSize _x1_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> x2_;
    mutable ::google::protobuf::internal::CachedSize _x2_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> x3_;
    ::google::protobuf::RepeatedField<int> x4_;
    ::google::protobuf::internal::ArenaStringPtr x0_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestRef_D2Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestTestRef_D2Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestTestRef_D2Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestTestRef_D2Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestRef_D2Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestTestRef_D2Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestTestRef_D2Entry_DoNotUse& other);
  static const TestTestRef_D2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestTestRef_D2Entry_DoNotUse*>(&_TestTestRef_D2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestTestRef_D1Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestTestRef_D1Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestTestRef_D1Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestTestRef_D1Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestRef_D1Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestTestRef_D1Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestTestRef_D1Entry_DoNotUse& other);
  static const TestTestRef_D1Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestTestRef_D1Entry_DoNotUse*>(&_TestTestRef_D1Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestTestMap_X4Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestTestMap_X4Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestTestMap_X4Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestTestMap_X4Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestMap_X4Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestTestMap_X4Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestTestMap_X4Entry_DoNotUse& other);
  static const TestTestMap_X4Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestTestMap_X4Entry_DoNotUse*>(&_TestTestMap_X4Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestTestMap_X3Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestTestMap_X3Entry_DoNotUse, 
    std::string, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestTestMap_X3Entry_DoNotUse, 
    std::string, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestTestMap_X3Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestMap_X3Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestTestMap_X3Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestTestMap_X3Entry_DoNotUse& other);
  static const TestTestMap_X3Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestTestMap_X3Entry_DoNotUse*>(&_TestTestMap_X3Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "cfg.TestTestMap.X3Entry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestTestMap_X2Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestTestMap_X2Entry_DoNotUse, 
    ::int64_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestTestMap_X2Entry_DoNotUse, 
    ::int64_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestTestMap_X2Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestMap_X2Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestTestMap_X2Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestTestMap_X2Entry_DoNotUse& other);
  static const TestTestMap_X2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestTestMap_X2Entry_DoNotUse*>(&_TestTestMap_X2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestTestMap_X1Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestTestMap_X1Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestTestMap_X1Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestTestMap_X1Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestMap_X1Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestTestMap_X1Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestTestMap_X1Entry_DoNotUse& other);
  static const TestTestMap_X1Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestTestMap_X1Entry_DoNotUse*>(&_TestTestMap_X1Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestTestGlobal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestGlobal) */ {
 public:
  inline TestTestGlobal() : TestTestGlobal(nullptr) {}
  ~TestTestGlobal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestGlobal(::google::protobuf::internal::ConstantInitialized);

  TestTestGlobal(const TestTestGlobal& from);
  TestTestGlobal(TestTestGlobal&& from) noexcept
    : TestTestGlobal() {
    *this = ::std::move(from);
  }

  inline TestTestGlobal(::google::protobuf::Arena* arena, const TestTestGlobal& from)
    : TestTestGlobal(arena) {
    MergeFrom(from);
  }
  inline TestTestGlobal& operator=(const TestTestGlobal& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestGlobal& operator=(TestTestGlobal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestGlobal& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestGlobal* internal_default_instance() {
    return reinterpret_cast<const TestTestGlobal*>(
               &_TestTestGlobal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(TestTestGlobal& a, TestTestGlobal& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestGlobal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestGlobal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestGlobal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestGlobal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestGlobal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestGlobal& from) {
    TestTestGlobal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestGlobal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestGlobal";
  }
  protected:
  explicit TestTestGlobal(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnlockEquipFieldNumber = 1,
    kUnlockHeroFieldNumber = 2,
  };
  // int32 unlock_equip = 1;
  void clear_unlock_equip() ;
  ::int32_t unlock_equip() const;
  void set_unlock_equip(::int32_t value);

  private:
  ::int32_t _internal_unlock_equip() const;
  void _internal_set_unlock_equip(::int32_t value);

  public:
  // int32 unlock_hero = 2;
  void clear_unlock_hero() ;
  ::int32_t unlock_hero() const;
  void set_unlock_hero(::int32_t value);

  private:
  ::int32_t _internal_unlock_hero() const;
  void _internal_set_unlock_hero(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestGlobal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t unlock_equip_;
    ::int32_t unlock_hero_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestBeRef final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestBeRef) */ {
 public:
  inline TestTestBeRef() : TestTestBeRef(nullptr) {}
  ~TestTestBeRef() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestBeRef(::google::protobuf::internal::ConstantInitialized);

  TestTestBeRef(const TestTestBeRef& from);
  TestTestBeRef(TestTestBeRef&& from) noexcept
    : TestTestBeRef() {
    *this = ::std::move(from);
  }

  inline TestTestBeRef(::google::protobuf::Arena* arena, const TestTestBeRef& from)
    : TestTestBeRef(arena) {
    MergeFrom(from);
  }
  inline TestTestBeRef& operator=(const TestTestBeRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestBeRef& operator=(TestTestBeRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestBeRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestBeRef* internal_default_instance() {
    return reinterpret_cast<const TestTestBeRef*>(
               &_TestTestBeRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(TestTestBeRef& a, TestTestBeRef& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestBeRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestBeRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestBeRef* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestBeRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestBeRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestBeRef& from) {
    TestTestBeRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestBeRef* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestBeRef";
  }
  protected:
  explicit TestTestBeRef(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 count = 2;
  void clear_count() ;
  ::int32_t count() const;
  void set_count(::int32_t value);

  private:
  ::int32_t _internal_count() const;
  void _internal_set_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestBeRef)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    ::int32_t count_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTest3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTest3) */ {
 public:
  inline TestTest3() : TestTest3(nullptr) {}
  ~TestTest3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTest3(::google::protobuf::internal::ConstantInitialized);

  TestTest3(const TestTest3& from);
  TestTest3(TestTest3&& from) noexcept
    : TestTest3() {
    *this = ::std::move(from);
  }

  inline TestTest3(::google::protobuf::Arena* arena, const TestTest3& from)
    : TestTest3(arena) {
    MergeFrom(from);
  }
  inline TestTest3& operator=(const TestTest3& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTest3& operator=(TestTest3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTest3& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTest3* internal_default_instance() {
    return reinterpret_cast<const TestTest3*>(
               &_TestTest3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(TestTest3& a, TestTest3& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTest3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTest3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTest3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTest3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTest3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTest3& from) {
    TestTest3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTest3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTest3";
  }
  protected:
  explicit TestTest3(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTest3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x_;
    ::int32_t y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestRefBean final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestRefBean) */ {
 public:
  inline TestRefBean() : TestRefBean(nullptr) {}
  ~TestRefBean() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestRefBean(::google::protobuf::internal::ConstantInitialized);

  TestRefBean(const TestRefBean& from);
  TestRefBean(TestRefBean&& from) noexcept
    : TestRefBean() {
    *this = ::std::move(from);
  }

  inline TestRefBean(::google::protobuf::Arena* arena, const TestRefBean& from)
    : TestRefBean(arena) {
    MergeFrom(from);
  }
  inline TestRefBean& operator=(const TestRefBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRefBean& operator=(TestRefBean&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRefBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRefBean* internal_default_instance() {
    return reinterpret_cast<const TestRefBean*>(
               &_TestRefBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(TestRefBean& a, TestRefBean& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRefBean* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRefBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRefBean* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRefBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestRefBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestRefBean& from) {
    TestRefBean::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRefBean* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestRefBean";
  }
  protected:
  explicit TestRefBean(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrFieldNumber = 2,
    kXFieldNumber = 1,
  };
  // repeated int32 arr = 2 [packed = true];
  int arr_size() const;
  private:
  int _internal_arr_size() const;

  public:
  void clear_arr() ;
  ::int32_t arr(int index) const;
  void set_arr(int index, ::int32_t value);
  void add_arr(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& arr() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_arr();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_arr() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_arr();

  public:
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestRefBean)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> arr_;
    mutable ::google::protobuf::internal::CachedSize _arr_cached_byte_size_;
    ::int32_t x_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestNotIndexList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestNotIndexList) */ {
 public:
  inline TestNotIndexList() : TestNotIndexList(nullptr) {}
  ~TestNotIndexList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestNotIndexList(::google::protobuf::internal::ConstantInitialized);

  TestNotIndexList(const TestNotIndexList& from);
  TestNotIndexList(TestNotIndexList&& from) noexcept
    : TestNotIndexList() {
    *this = ::std::move(from);
  }

  inline TestNotIndexList(::google::protobuf::Arena* arena, const TestNotIndexList& from)
    : TestNotIndexList(arena) {
    MergeFrom(from);
  }
  inline TestNotIndexList& operator=(const TestNotIndexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestNotIndexList& operator=(TestNotIndexList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestNotIndexList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestNotIndexList* internal_default_instance() {
    return reinterpret_cast<const TestNotIndexList*>(
               &_TestNotIndexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(TestNotIndexList& a, TestNotIndexList& b) {
    a.Swap(&b);
  }
  inline void Swap(TestNotIndexList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestNotIndexList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestNotIndexList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestNotIndexList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestNotIndexList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestNotIndexList& from) {
    TestNotIndexList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestNotIndexList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestNotIndexList";
  }
  protected:
  explicit TestNotIndexList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestNotIndexList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x_;
    ::int32_t y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiUnionIndexList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestMultiUnionIndexList) */ {
 public:
  inline TestMultiUnionIndexList() : TestMultiUnionIndexList(nullptr) {}
  ~TestMultiUnionIndexList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiUnionIndexList(::google::protobuf::internal::ConstantInitialized);

  TestMultiUnionIndexList(const TestMultiUnionIndexList& from);
  TestMultiUnionIndexList(TestMultiUnionIndexList&& from) noexcept
    : TestMultiUnionIndexList() {
    *this = ::std::move(from);
  }

  inline TestMultiUnionIndexList(::google::protobuf::Arena* arena, const TestMultiUnionIndexList& from)
    : TestMultiUnionIndexList(arena) {
    MergeFrom(from);
  }
  inline TestMultiUnionIndexList& operator=(const TestMultiUnionIndexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMultiUnionIndexList& operator=(TestMultiUnionIndexList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMultiUnionIndexList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMultiUnionIndexList* internal_default_instance() {
    return reinterpret_cast<const TestMultiUnionIndexList*>(
               &_TestMultiUnionIndexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(TestMultiUnionIndexList& a, TestMultiUnionIndexList& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMultiUnionIndexList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMultiUnionIndexList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMultiUnionIndexList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMultiUnionIndexList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMultiUnionIndexList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestMultiUnionIndexList& from) {
    TestMultiUnionIndexList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiUnionIndexList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestMultiUnionIndexList";
  }
  protected:
  explicit TestMultiUnionIndexList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kId3FieldNumber = 3,
    kDescFieldNumber = 5,
    kId2FieldNumber = 2,
    kId1FieldNumber = 1,
    kNumFieldNumber = 4,
  };
  // string id3 = 3;
  void clear_id3() ;
  const std::string& id3() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id3(Arg_&& arg, Args_... args);
  std::string* mutable_id3();
  PROTOBUF_NODISCARD std::string* release_id3();
  void set_allocated_id3(std::string* ptr);

  private:
  const std::string& _internal_id3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id3(
      const std::string& value);
  std::string* _internal_mutable_id3();

  public:
  // string desc = 5;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // int64 id2 = 2;
  void clear_id2() ;
  ::int64_t id2() const;
  void set_id2(::int64_t value);

  private:
  ::int64_t _internal_id2() const;
  void _internal_set_id2(::int64_t value);

  public:
  // int32 id1 = 1;
  void clear_id1() ;
  ::int32_t id1() const;
  void set_id1(::int32_t value);

  private:
  ::int32_t _internal_id1() const;
  void _internal_set_id1(::int32_t value);

  public:
  // int32 num = 4;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestMultiUnionIndexList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      43, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id3_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::int64_t id2_;
    ::int32_t id1_;
    ::int32_t num_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiRowType2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestMultiRowType2) */ {
 public:
  inline TestMultiRowType2() : TestMultiRowType2(nullptr) {}
  ~TestMultiRowType2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowType2(::google::protobuf::internal::ConstantInitialized);

  TestMultiRowType2(const TestMultiRowType2& from);
  TestMultiRowType2(TestMultiRowType2&& from) noexcept
    : TestMultiRowType2() {
    *this = ::std::move(from);
  }

  inline TestMultiRowType2(::google::protobuf::Arena* arena, const TestMultiRowType2& from)
    : TestMultiRowType2(arena) {
    MergeFrom(from);
  }
  inline TestMultiRowType2& operator=(const TestMultiRowType2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMultiRowType2& operator=(TestMultiRowType2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMultiRowType2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMultiRowType2* internal_default_instance() {
    return reinterpret_cast<const TestMultiRowType2*>(
               &_TestMultiRowType2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(TestMultiRowType2& a, TestMultiRowType2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMultiRowType2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMultiRowType2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMultiRowType2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMultiRowType2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMultiRowType2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestMultiRowType2& from) {
    TestMultiRowType2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiRowType2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestMultiRowType2";
  }
  protected:
  explicit TestMultiRowType2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 x = 2;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // float y = 3;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestMultiRowType2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    ::int32_t x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiRowType1 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestMultiRowType1) */ {
 public:
  inline TestMultiRowType1() : TestMultiRowType1(nullptr) {}
  ~TestMultiRowType1() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowType1(::google::protobuf::internal::ConstantInitialized);

  TestMultiRowType1(const TestMultiRowType1& from);
  TestMultiRowType1(TestMultiRowType1&& from) noexcept
    : TestMultiRowType1() {
    *this = ::std::move(from);
  }

  inline TestMultiRowType1(::google::protobuf::Arena* arena, const TestMultiRowType1& from)
    : TestMultiRowType1(arena) {
    MergeFrom(from);
  }
  inline TestMultiRowType1& operator=(const TestMultiRowType1& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMultiRowType1& operator=(TestMultiRowType1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMultiRowType1& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMultiRowType1* internal_default_instance() {
    return reinterpret_cast<const TestMultiRowType1*>(
               &_TestMultiRowType1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(TestMultiRowType1& a, TestMultiRowType1& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMultiRowType1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMultiRowType1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMultiRowType1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMultiRowType1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMultiRowType1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestMultiRowType1& from) {
    TestMultiRowType1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiRowType1* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestMultiRowType1";
  }
  protected:
  explicit TestMultiRowType1(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 x = 2;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestMultiRowType1)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    ::int32_t x_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiRowRecord_MultiRows7Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestMultiRowRecord_MultiRows7Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestMultiRowRecord_MultiRows7Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestMultiRowRecord_MultiRows7Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowRecord_MultiRows7Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestMultiRowRecord_MultiRows7Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestMultiRowRecord_MultiRows7Entry_DoNotUse& other);
  static const TestMultiRowRecord_MultiRows7Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestMultiRowRecord_MultiRows7Entry_DoNotUse*>(&_TestMultiRowRecord_MultiRows7Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestMultiIndexList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestMultiIndexList) */ {
 public:
  inline TestMultiIndexList() : TestMultiIndexList(nullptr) {}
  ~TestMultiIndexList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiIndexList(::google::protobuf::internal::ConstantInitialized);

  TestMultiIndexList(const TestMultiIndexList& from);
  TestMultiIndexList(TestMultiIndexList&& from) noexcept
    : TestMultiIndexList() {
    *this = ::std::move(from);
  }

  inline TestMultiIndexList(::google::protobuf::Arena* arena, const TestMultiIndexList& from)
    : TestMultiIndexList(arena) {
    MergeFrom(from);
  }
  inline TestMultiIndexList& operator=(const TestMultiIndexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMultiIndexList& operator=(TestMultiIndexList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMultiIndexList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMultiIndexList* internal_default_instance() {
    return reinterpret_cast<const TestMultiIndexList*>(
               &_TestMultiIndexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(TestMultiIndexList& a, TestMultiIndexList& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMultiIndexList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMultiIndexList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMultiIndexList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMultiIndexList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMultiIndexList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestMultiIndexList& from) {
    TestMultiIndexList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiIndexList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestMultiIndexList";
  }
  protected:
  explicit TestMultiIndexList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kId3FieldNumber = 3,
    kDescFieldNumber = 5,
    kId2FieldNumber = 2,
    kId1FieldNumber = 1,
    kNumFieldNumber = 4,
  };
  // string id3 = 3;
  void clear_id3() ;
  const std::string& id3() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id3(Arg_&& arg, Args_... args);
  std::string* mutable_id3();
  PROTOBUF_NODISCARD std::string* release_id3();
  void set_allocated_id3(std::string* ptr);

  private:
  const std::string& _internal_id3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id3(
      const std::string& value);
  std::string* _internal_mutable_id3();

  public:
  // string desc = 5;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // int64 id2 = 2;
  void clear_id2() ;
  ::int64_t id2() const;
  void set_id2(::int64_t value);

  private:
  ::int64_t _internal_id2() const;
  void _internal_set_id2(::int64_t value);

  public:
  // int32 id1 = 1;
  void clear_id1() ;
  ::int32_t id1() const;
  void set_id1(::int32_t value);

  private:
  ::int32_t _internal_id1() const;
  void _internal_set_id1(::int32_t value);

  public:
  // int32 num = 4;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestMultiIndexList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      38, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id3_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::int64_t id2_;
    ::int32_t id1_;
    ::int32_t num_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestLoginRoleInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestLoginRoleInfo) */ {
 public:
  inline TestLoginRoleInfo() : TestLoginRoleInfo(nullptr) {}
  ~TestLoginRoleInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestLoginRoleInfo(::google::protobuf::internal::ConstantInitialized);

  TestLoginRoleInfo(const TestLoginRoleInfo& from);
  TestLoginRoleInfo(TestLoginRoleInfo&& from) noexcept
    : TestLoginRoleInfo() {
    *this = ::std::move(from);
  }

  inline TestLoginRoleInfo(::google::protobuf::Arena* arena, const TestLoginRoleInfo& from)
    : TestLoginRoleInfo(arena) {
    MergeFrom(from);
  }
  inline TestLoginRoleInfo& operator=(const TestLoginRoleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestLoginRoleInfo& operator=(TestLoginRoleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestLoginRoleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestLoginRoleInfo* internal_default_instance() {
    return reinterpret_cast<const TestLoginRoleInfo*>(
               &_TestLoginRoleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(TestLoginRoleInfo& a, TestLoginRoleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TestLoginRoleInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestLoginRoleInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestLoginRoleInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestLoginRoleInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestLoginRoleInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestLoginRoleInfo& from) {
    TestLoginRoleInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestLoginRoleInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestLoginRoleInfo";
  }
  protected:
  explicit TestLoginRoleInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 1,
    kX3FieldNumber = 2,
    kRoleIdFieldNumber = 3,
  };
  // int32 x1 = 1;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // int32 x3 = 2;
  void clear_x3() ;
  ::int32_t x3() const;
  void set_x3(::int32_t value);

  private:
  ::int32_t _internal_x3() const;
  void _internal_set_x3(::int32_t value);

  public:
  // int64 role_id = 3;
  void clear_role_id() ;
  ::int64_t role_id() const;
  void set_role_id(::int64_t value);

  private:
  ::int64_t _internal_role_id() const;
  void _internal_set_role_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestLoginRoleInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x1_;
    ::int32_t x3_;
    ::int64_t role_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestItem) */ {
 public:
  inline TestItem() : TestItem(nullptr) {}
  ~TestItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestItem(::google::protobuf::internal::ConstantInitialized);

  TestItem(const TestItem& from);
  TestItem(TestItem&& from) noexcept
    : TestItem() {
    *this = ::std::move(from);
  }

  inline TestItem(::google::protobuf::Arena* arena, const TestItem& from)
    : TestItem(arena) {
    MergeFrom(from);
  }
  inline TestItem& operator=(const TestItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestItem& operator=(TestItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestItem* internal_default_instance() {
    return reinterpret_cast<const TestItem*>(
               &_TestItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(TestItem& a, TestItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TestItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestItem& from) {
    TestItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestItem";
  }
  protected:
  explicit TestItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDescFieldNumber = 3,
    kIdFieldNumber = 1,
    kNumFieldNumber = 4,
    kPriceFieldNumber = 5,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string desc = 3;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 num = 4;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // int32 price = 5;
  void clear_price() ;
  ::int32_t price() const;
  void set_price(::int32_t value);

  private:
  ::int32_t _internal_price() const;
  void _internal_set_price(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      29, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::int32_t id_;
    ::int32_t num_;
    ::int32_t price_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestInnerGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestInnerGroup) */ {
 public:
  inline TestInnerGroup() : TestInnerGroup(nullptr) {}
  ~TestInnerGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestInnerGroup(::google::protobuf::internal::ConstantInitialized);

  TestInnerGroup(const TestInnerGroup& from);
  TestInnerGroup(TestInnerGroup&& from) noexcept
    : TestInnerGroup() {
    *this = ::std::move(from);
  }

  inline TestInnerGroup(::google::protobuf::Arena* arena, const TestInnerGroup& from)
    : TestInnerGroup(arena) {
    MergeFrom(from);
  }
  inline TestInnerGroup& operator=(const TestInnerGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestInnerGroup& operator=(TestInnerGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestInnerGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestInnerGroup* internal_default_instance() {
    return reinterpret_cast<const TestInnerGroup*>(
               &_TestInnerGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(TestInnerGroup& a, TestInnerGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(TestInnerGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestInnerGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestInnerGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestInnerGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestInnerGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestInnerGroup& from) {
    TestInnerGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestInnerGroup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestInnerGroup";
  }
  protected:
  explicit TestInnerGroup(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kY1FieldNumber = 1,
  };
  // int32 y1 = 1;
  void clear_y1() ;
  ::int32_t y1() const;
  void set_y1(::int32_t value);

  private:
  ::int32_t _internal_y1() const;
  void _internal_set_y1(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestInnerGroup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t y1_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestH2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestH2) */ {
 public:
  inline TestH2() : TestH2(nullptr) {}
  ~TestH2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestH2(::google::protobuf::internal::ConstantInitialized);

  TestH2(const TestH2& from);
  TestH2(TestH2&& from) noexcept
    : TestH2() {
    *this = ::std::move(from);
  }

  inline TestH2(::google::protobuf::Arena* arena, const TestH2& from)
    : TestH2(arena) {
    MergeFrom(from);
  }
  inline TestH2& operator=(const TestH2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestH2& operator=(TestH2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestH2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestH2* internal_default_instance() {
    return reinterpret_cast<const TestH2*>(
               &_TestH2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(TestH2& a, TestH2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestH2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestH2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestH2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestH2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestH2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestH2& from) {
    TestH2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestH2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestH2";
  }
  protected:
  explicit TestH2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZ2FieldNumber = 1,
    kZ3FieldNumber = 2,
  };
  // int32 z2 = 1;
  void clear_z2() ;
  ::int32_t z2() const;
  void set_z2(::int32_t value);

  private:
  ::int32_t _internal_z2() const;
  void _internal_set_z2(::int32_t value);

  public:
  // int32 z3 = 2;
  void clear_z3() ;
  ::int32_t z3() const;
  void set_z3(::int32_t value);

  private:
  ::int32_t _internal_z3() const;
  void _internal_set_z3(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestH2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t z2_;
    ::int32_t z3_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestFoo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestFoo) */ {
 public:
  inline TestFoo() : TestFoo(nullptr) {}
  ~TestFoo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestFoo(::google::protobuf::internal::ConstantInitialized);

  TestFoo(const TestFoo& from);
  TestFoo(TestFoo&& from) noexcept
    : TestFoo() {
    *this = ::std::move(from);
  }

  inline TestFoo(::google::protobuf::Arena* arena, const TestFoo& from)
    : TestFoo(arena) {
    MergeFrom(from);
  }
  inline TestFoo& operator=(const TestFoo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFoo& operator=(TestFoo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFoo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFoo* internal_default_instance() {
    return reinterpret_cast<const TestFoo*>(
               &_TestFoo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(TestFoo& a, TestFoo& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFoo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFoo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFoo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFoo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestFoo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestFoo& from) {
    TestFoo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFoo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestFoo";
  }
  protected:
  explicit TestFoo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kY1FieldNumber = 1,
    kY2FieldNumber = 2,
    kY3FieldNumber = 3,
  };
  // int32 y1 = 1;
  void clear_y1() ;
  ::int32_t y1() const;
  void set_y1(::int32_t value);

  private:
  ::int32_t _internal_y1() const;
  void _internal_set_y1(::int32_t value);

  public:
  // int32 y2 = 2;
  void clear_y2() ;
  ::int32_t y2() const;
  void set_y2(::int32_t value);

  private:
  ::int32_t _internal_y2() const;
  void _internal_set_y2(::int32_t value);

  public:
  // int32 y3 = 3;
  void clear_y3() ;
  ::int32_t y3() const;
  void set_y3(::int32_t value);

  private:
  ::int32_t _internal_y3() const;
  void _internal_set_y3(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestFoo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t y1_;
    ::int32_t y2_;
    ::int32_t y3_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestExcelFromJson_K8Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestExcelFromJson_K8Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestExcelFromJson_K8Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestExcelFromJson_K8Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestExcelFromJson_K8Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestExcelFromJson_K8Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestExcelFromJson_K8Entry_DoNotUse& other);
  static const TestExcelFromJson_K8Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestExcelFromJson_K8Entry_DoNotUse*>(&_TestExcelFromJson_K8Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestEquipment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestEquipment) */ {
 public:
  inline TestEquipment() : TestEquipment(nullptr) {}
  ~TestEquipment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestEquipment(::google::protobuf::internal::ConstantInitialized);

  TestEquipment(const TestEquipment& from);
  TestEquipment(TestEquipment&& from) noexcept
    : TestEquipment() {
    *this = ::std::move(from);
  }

  inline TestEquipment(::google::protobuf::Arena* arena, const TestEquipment& from)
    : TestEquipment(arena) {
    MergeFrom(from);
  }
  inline TestEquipment& operator=(const TestEquipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestEquipment& operator=(TestEquipment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestEquipment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestEquipment* internal_default_instance() {
    return reinterpret_cast<const TestEquipment*>(
               &_TestEquipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(TestEquipment& a, TestEquipment& b) {
    a.Swap(&b);
  }
  inline void Swap(TestEquipment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestEquipment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestEquipment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestEquipment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestEquipment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestEquipment& from) {
    TestEquipment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestEquipment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestEquipment";
  }
  protected:
  explicit TestEquipment(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDescFieldNumber = 3,
    kIdFieldNumber = 1,
    kAttrFieldNumber = 4,
    kValueFieldNumber = 5,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string desc = 3;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.TestDemoEnum attr = 4;
  void clear_attr() ;
  ::cfg::TestDemoEnum attr() const;
  void set_attr(::cfg::TestDemoEnum value);

  private:
  ::cfg::TestDemoEnum _internal_attr() const;
  void _internal_set_attr(::cfg::TestDemoEnum value);

  public:
  // int32 value = 5;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestEquipment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      34, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::int32_t id_;
    int attr_;
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDetectEncoding final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDetectEncoding) */ {
 public:
  inline TestDetectEncoding() : TestDetectEncoding(nullptr) {}
  ~TestDetectEncoding() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDetectEncoding(::google::protobuf::internal::ConstantInitialized);

  TestDetectEncoding(const TestDetectEncoding& from);
  TestDetectEncoding(TestDetectEncoding&& from) noexcept
    : TestDetectEncoding() {
    *this = ::std::move(from);
  }

  inline TestDetectEncoding(::google::protobuf::Arena* arena, const TestDetectEncoding& from)
    : TestDetectEncoding(arena) {
    MergeFrom(from);
  }
  inline TestDetectEncoding& operator=(const TestDetectEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDetectEncoding& operator=(TestDetectEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDetectEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDetectEncoding* internal_default_instance() {
    return reinterpret_cast<const TestDetectEncoding*>(
               &_TestDetectEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(TestDetectEncoding& a, TestDetectEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDetectEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDetectEncoding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDetectEncoding* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDetectEncoding>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDetectEncoding& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDetectEncoding& from) {
    TestDetectEncoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDetectEncoding* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDetectEncoding";
  }
  protected:
  explicit TestDetectEncoding(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDetectEncoding)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      35, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoType2_K8Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestDemoType2_K8Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestDemoType2_K8Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestDemoType2_K8Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoType2_K8Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestDemoType2_K8Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestDemoType2_K8Entry_DoNotUse& other);
  static const TestDemoType2_K8Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestDemoType2_K8Entry_DoNotUse*>(&_TestDemoType2_K8Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestDemoType1 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoType1) */ {
 public:
  inline TestDemoType1() : TestDemoType1(nullptr) {}
  ~TestDemoType1() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoType1(::google::protobuf::internal::ConstantInitialized);

  TestDemoType1(const TestDemoType1& from);
  TestDemoType1(TestDemoType1&& from) noexcept
    : TestDemoType1() {
    *this = ::std::move(from);
  }

  inline TestDemoType1(::google::protobuf::Arena* arena, const TestDemoType1& from)
    : TestDemoType1(arena) {
    MergeFrom(from);
  }
  inline TestDemoType1& operator=(const TestDemoType1& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoType1& operator=(TestDemoType1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoType1& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoType1* internal_default_instance() {
    return reinterpret_cast<const TestDemoType1*>(
               &_TestDemoType1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(TestDemoType1& a, TestDemoType1& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoType1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoType1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoType1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoType1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoType1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoType1& from) {
    TestDemoType1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoType1* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoType1";
  }
  protected:
  explicit TestDemoType1(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 1,
  };
  // int32 x1 = 1;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoType1)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x1_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoE2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoE2) */ {
 public:
  inline TestDemoE2() : TestDemoE2(nullptr) {}
  ~TestDemoE2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoE2(::google::protobuf::internal::ConstantInitialized);

  TestDemoE2(const TestDemoE2& from);
  TestDemoE2(TestDemoE2&& from) noexcept
    : TestDemoE2() {
    *this = ::std::move(from);
  }

  inline TestDemoE2(::google::protobuf::Arena* arena, const TestDemoE2& from)
    : TestDemoE2(arena) {
    MergeFrom(from);
  }
  inline TestDemoE2& operator=(const TestDemoE2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoE2& operator=(TestDemoE2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoE2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoE2* internal_default_instance() {
    return reinterpret_cast<const TestDemoE2*>(
               &_TestDemoE2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(TestDemoE2& a, TestDemoE2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoE2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoE2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoE2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoE2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoE2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoE2& from) {
    TestDemoE2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoE2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoE2";
  }
  protected:
  explicit TestDemoE2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kY1FieldNumber = 1,
    kY2FieldNumber = 2,
  };
  // optional int32 y1 = 1;
  bool has_y1() const;
  void clear_y1() ;
  ::int32_t y1() const;
  void set_y1(::int32_t value);

  private:
  ::int32_t _internal_y1() const;
  void _internal_set_y1(::int32_t value);

  public:
  // bool y2 = 2;
  void clear_y2() ;
  bool y2() const;
  void set_y2(bool value);

  private:
  bool _internal_y2() const;
  void _internal_set_y2(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoE2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t y1_;
    bool y2_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoE1 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoE1) */ {
 public:
  inline TestDemoE1() : TestDemoE1(nullptr) {}
  ~TestDemoE1() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoE1(::google::protobuf::internal::ConstantInitialized);

  TestDemoE1(const TestDemoE1& from);
  TestDemoE1(TestDemoE1&& from) noexcept
    : TestDemoE1() {
    *this = ::std::move(from);
  }

  inline TestDemoE1(::google::protobuf::Arena* arena, const TestDemoE1& from)
    : TestDemoE1(arena) {
    MergeFrom(from);
  }
  inline TestDemoE1& operator=(const TestDemoE1& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoE1& operator=(TestDemoE1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoE1& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoE1* internal_default_instance() {
    return reinterpret_cast<const TestDemoE1*>(
               &_TestDemoE1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(TestDemoE1& a, TestDemoE1& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoE1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoE1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoE1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoE1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoE1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoE1& from) {
    TestDemoE1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoE1* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoE1";
  }
  protected:
  explicit TestDemoE1(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 1,
    kX3FieldNumber = 2,
    kX4FieldNumber = 3,
  };
  // int32 x1 = 1;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // int32 x3 = 2;
  void clear_x3() ;
  ::int32_t x3() const;
  void set_x3(::int32_t value);

  private:
  ::int32_t _internal_x3() const;
  void _internal_set_x3(::int32_t value);

  public:
  // int32 x4 = 3;
  void clear_x4() ;
  ::int32_t x4() const;
  void set_x4(::int32_t value);

  private:
  ::int32_t _internal_x4() const;
  void _internal_set_x4(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoE1)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x1_;
    ::int32_t x3_;
    ::int32_t x4_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoD2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoD2) */ {
 public:
  inline TestDemoD2() : TestDemoD2(nullptr) {}
  ~TestDemoD2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoD2(::google::protobuf::internal::ConstantInitialized);

  TestDemoD2(const TestDemoD2& from);
  TestDemoD2(TestDemoD2&& from) noexcept
    : TestDemoD2() {
    *this = ::std::move(from);
  }

  inline TestDemoD2(::google::protobuf::Arena* arena, const TestDemoD2& from)
    : TestDemoD2(arena) {
    MergeFrom(from);
  }
  inline TestDemoD2& operator=(const TestDemoD2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoD2& operator=(TestDemoD2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoD2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoD2* internal_default_instance() {
    return reinterpret_cast<const TestDemoD2*>(
               &_TestDemoD2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(TestDemoD2& a, TestDemoD2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoD2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoD2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoD2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoD2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoD2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoD2& from) {
    TestDemoD2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoD2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoD2";
  }
  protected:
  explicit TestDemoD2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 1,
    kX2FieldNumber = 2,
  };
  // int32 x1 = 1;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // int32 x2 = 2;
  void clear_x2() ;
  ::int32_t x2() const;
  void set_x2(::int32_t value);

  private:
  ::int32_t _internal_x2() const;
  void _internal_set_x2(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoD2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x1_;
    ::int32_t x2_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDecorator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDecorator) */ {
 public:
  inline TestDecorator() : TestDecorator(nullptr) {}
  ~TestDecorator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDecorator(::google::protobuf::internal::ConstantInitialized);

  TestDecorator(const TestDecorator& from);
  TestDecorator(TestDecorator&& from) noexcept
    : TestDecorator() {
    *this = ::std::move(from);
  }

  inline TestDecorator(::google::protobuf::Arena* arena, const TestDecorator& from)
    : TestDecorator(arena) {
    MergeFrom(from);
  }
  inline TestDecorator& operator=(const TestDecorator& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDecorator& operator=(TestDecorator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDecorator& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDecorator* internal_default_instance() {
    return reinterpret_cast<const TestDecorator*>(
               &_TestDecorator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(TestDecorator& a, TestDecorator& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDecorator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDecorator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDecorator* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDecorator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDecorator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDecorator& from) {
    TestDecorator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDecorator* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDecorator";
  }
  protected:
  explicit TestDecorator(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDescFieldNumber = 3,
    kIdFieldNumber = 1,
    kDurationFieldNumber = 4,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string desc = 3;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 duration = 4;
  void clear_duration() ;
  ::int32_t duration() const;
  void set_duration(::int32_t value);

  private:
  ::int32_t _internal_duration() const;
  void _internal_set_duration(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDecorator)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      34, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::int32_t id_;
    ::int32_t duration_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDateTimeRange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDateTimeRange) */ {
 public:
  inline TestDateTimeRange() : TestDateTimeRange(nullptr) {}
  ~TestDateTimeRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDateTimeRange(::google::protobuf::internal::ConstantInitialized);

  TestDateTimeRange(const TestDateTimeRange& from);
  TestDateTimeRange(TestDateTimeRange&& from) noexcept
    : TestDateTimeRange() {
    *this = ::std::move(from);
  }

  inline TestDateTimeRange(::google::protobuf::Arena* arena, const TestDateTimeRange& from)
    : TestDateTimeRange(arena) {
    MergeFrom(from);
  }
  inline TestDateTimeRange& operator=(const TestDateTimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDateTimeRange& operator=(TestDateTimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDateTimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDateTimeRange* internal_default_instance() {
    return reinterpret_cast<const TestDateTimeRange*>(
               &_TestDateTimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(TestDateTimeRange& a, TestDateTimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDateTimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDateTimeRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDateTimeRange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDateTimeRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDateTimeRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDateTimeRange& from) {
    TestDateTimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDateTimeRange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDateTimeRange";
  }
  protected:
  explicit TestDateTimeRange(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // int64 start_time = 1;
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // int64 end_time = 2;
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDateTimeRange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t start_time_;
    ::int64_t end_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestCompositeJsonTable3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestCompositeJsonTable3) */ {
 public:
  inline TestCompositeJsonTable3() : TestCompositeJsonTable3(nullptr) {}
  ~TestCompositeJsonTable3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestCompositeJsonTable3(::google::protobuf::internal::ConstantInitialized);

  TestCompositeJsonTable3(const TestCompositeJsonTable3& from);
  TestCompositeJsonTable3(TestCompositeJsonTable3&& from) noexcept
    : TestCompositeJsonTable3() {
    *this = ::std::move(from);
  }

  inline TestCompositeJsonTable3(::google::protobuf::Arena* arena, const TestCompositeJsonTable3& from)
    : TestCompositeJsonTable3(arena) {
    MergeFrom(from);
  }
  inline TestCompositeJsonTable3& operator=(const TestCompositeJsonTable3& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestCompositeJsonTable3& operator=(TestCompositeJsonTable3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestCompositeJsonTable3& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestCompositeJsonTable3* internal_default_instance() {
    return reinterpret_cast<const TestCompositeJsonTable3*>(
               &_TestCompositeJsonTable3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(TestCompositeJsonTable3& a, TestCompositeJsonTable3& b) {
    a.Swap(&b);
  }
  inline void Swap(TestCompositeJsonTable3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestCompositeJsonTable3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestCompositeJsonTable3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestCompositeJsonTable3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestCompositeJsonTable3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestCompositeJsonTable3& from) {
    TestCompositeJsonTable3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestCompositeJsonTable3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestCompositeJsonTable3";
  }
  protected:
  explicit TestCompositeJsonTable3(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFieldNumber = 1,
    kBFieldNumber = 2,
  };
  // int32 a = 1;
  void clear_a() ;
  ::int32_t a() const;
  void set_a(::int32_t value);

  private:
  ::int32_t _internal_a() const;
  void _internal_set_a(::int32_t value);

  public:
  // int32 b = 2;
  void clear_b() ;
  ::int32_t b() const;
  void set_b(::int32_t value);

  private:
  ::int32_t _internal_b() const;
  void _internal_set_b(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestCompositeJsonTable3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t a_;
    ::int32_t b_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestCompositeJsonTable2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestCompositeJsonTable2) */ {
 public:
  inline TestCompositeJsonTable2() : TestCompositeJsonTable2(nullptr) {}
  ~TestCompositeJsonTable2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestCompositeJsonTable2(::google::protobuf::internal::ConstantInitialized);

  TestCompositeJsonTable2(const TestCompositeJsonTable2& from);
  TestCompositeJsonTable2(TestCompositeJsonTable2&& from) noexcept
    : TestCompositeJsonTable2() {
    *this = ::std::move(from);
  }

  inline TestCompositeJsonTable2(::google::protobuf::Arena* arena, const TestCompositeJsonTable2& from)
    : TestCompositeJsonTable2(arena) {
    MergeFrom(from);
  }
  inline TestCompositeJsonTable2& operator=(const TestCompositeJsonTable2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestCompositeJsonTable2& operator=(TestCompositeJsonTable2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestCompositeJsonTable2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestCompositeJsonTable2* internal_default_instance() {
    return reinterpret_cast<const TestCompositeJsonTable2*>(
               &_TestCompositeJsonTable2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(TestCompositeJsonTable2& a, TestCompositeJsonTable2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestCompositeJsonTable2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestCompositeJsonTable2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestCompositeJsonTable2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestCompositeJsonTable2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestCompositeJsonTable2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestCompositeJsonTable2& from) {
    TestCompositeJsonTable2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestCompositeJsonTable2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestCompositeJsonTable2";
  }
  protected:
  explicit TestCompositeJsonTable2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestCompositeJsonTable2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    ::int32_t y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestCompositeJsonTable1 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestCompositeJsonTable1) */ {
 public:
  inline TestCompositeJsonTable1() : TestCompositeJsonTable1(nullptr) {}
  ~TestCompositeJsonTable1() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestCompositeJsonTable1(::google::protobuf::internal::ConstantInitialized);

  TestCompositeJsonTable1(const TestCompositeJsonTable1& from);
  TestCompositeJsonTable1(TestCompositeJsonTable1&& from) noexcept
    : TestCompositeJsonTable1() {
    *this = ::std::move(from);
  }

  inline TestCompositeJsonTable1(::google::protobuf::Arena* arena, const TestCompositeJsonTable1& from)
    : TestCompositeJsonTable1(arena) {
    MergeFrom(from);
  }
  inline TestCompositeJsonTable1& operator=(const TestCompositeJsonTable1& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestCompositeJsonTable1& operator=(TestCompositeJsonTable1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestCompositeJsonTable1& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestCompositeJsonTable1* internal_default_instance() {
    return reinterpret_cast<const TestCompositeJsonTable1*>(
               &_TestCompositeJsonTable1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(TestCompositeJsonTable1& a, TestCompositeJsonTable1& b) {
    a.Swap(&b);
  }
  inline void Swap(TestCompositeJsonTable1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestCompositeJsonTable1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestCompositeJsonTable1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestCompositeJsonTable1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestCompositeJsonTable1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestCompositeJsonTable1& from) {
    TestCompositeJsonTable1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestCompositeJsonTable1* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestCompositeJsonTable1";
  }
  protected:
  explicit TestCompositeJsonTable1(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string x = 2;
  void clear_x() ;
  const std::string& x() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_x(Arg_&& arg, Args_... args);
  std::string* mutable_x();
  PROTOBUF_NODISCARD std::string* release_x();
  void set_allocated_x(std::string* ptr);

  private:
  const std::string& _internal_x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x(
      const std::string& value);
  std::string* _internal_mutable_x();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestCompositeJsonTable1)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr x_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestCompactString final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestCompactString) */ {
 public:
  inline TestCompactString() : TestCompactString(nullptr) {}
  ~TestCompactString() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestCompactString(::google::protobuf::internal::ConstantInitialized);

  TestCompactString(const TestCompactString& from);
  TestCompactString(TestCompactString&& from) noexcept
    : TestCompactString() {
    *this = ::std::move(from);
  }

  inline TestCompactString(::google::protobuf::Arena* arena, const TestCompactString& from)
    : TestCompactString(arena) {
    MergeFrom(from);
  }
  inline TestCompactString& operator=(const TestCompactString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestCompactString& operator=(TestCompactString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestCompactString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestCompactString* internal_default_instance() {
    return reinterpret_cast<const TestCompactString*>(
               &_TestCompactString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(TestCompactString& a, TestCompactString& b) {
    a.Swap(&b);
  }
  inline void Swap(TestCompactString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestCompactString* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestCompactString* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestCompactString>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestCompactString& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestCompactString& from) {
    TestCompactString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestCompactString* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestCompactString";
  }
  protected:
  explicit TestCompactString(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS2FieldNumber = 2,
    kS3FieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string s2 = 2;
  void clear_s2() ;
  const std::string& s2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s2(Arg_&& arg, Args_... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* ptr);

  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(
      const std::string& value);
  std::string* _internal_mutable_s2();

  public:
  // string s3 = 3;
  void clear_s3() ;
  const std::string& s3() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s3(Arg_&& arg, Args_... args);
  std::string* mutable_s3();
  PROTOBUF_NODISCARD std::string* release_s3();
  void set_allocated_s3(std::string* ptr);

  private:
  const std::string& _internal_s3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s3(
      const std::string& value);
  std::string* _internal_mutable_s3();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestCompactString)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      34, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr s2_;
    ::google::protobuf::internal::ArenaStringPtr s3_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestCircle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestCircle) */ {
 public:
  inline TestCircle() : TestCircle(nullptr) {}
  ~TestCircle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestCircle(::google::protobuf::internal::ConstantInitialized);

  TestCircle(const TestCircle& from);
  TestCircle(TestCircle&& from) noexcept
    : TestCircle() {
    *this = ::std::move(from);
  }

  inline TestCircle(::google::protobuf::Arena* arena, const TestCircle& from)
    : TestCircle(arena) {
    MergeFrom(from);
  }
  inline TestCircle& operator=(const TestCircle& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestCircle& operator=(TestCircle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestCircle& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestCircle* internal_default_instance() {
    return reinterpret_cast<const TestCircle*>(
               &_TestCircle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(TestCircle& a, TestCircle& b) {
    a.Swap(&b);
  }
  inline void Swap(TestCircle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestCircle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestCircle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestCircle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestCircle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestCircle& from) {
    TestCircle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestCircle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestCircle";
  }
  protected:
  explicit TestCircle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
  };
  // float radius = 1;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestCircle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float radius_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class Test2Rectangle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.Test2Rectangle) */ {
 public:
  inline Test2Rectangle() : Test2Rectangle(nullptr) {}
  ~Test2Rectangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Test2Rectangle(::google::protobuf::internal::ConstantInitialized);

  Test2Rectangle(const Test2Rectangle& from);
  Test2Rectangle(Test2Rectangle&& from) noexcept
    : Test2Rectangle() {
    *this = ::std::move(from);
  }

  inline Test2Rectangle(::google::protobuf::Arena* arena, const Test2Rectangle& from)
    : Test2Rectangle(arena) {
    MergeFrom(from);
  }
  inline Test2Rectangle& operator=(const Test2Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Test2Rectangle& operator=(Test2Rectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Test2Rectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Test2Rectangle* internal_default_instance() {
    return reinterpret_cast<const Test2Rectangle*>(
               &_Test2Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(Test2Rectangle& a, Test2Rectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(Test2Rectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Test2Rectangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Test2Rectangle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Test2Rectangle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Test2Rectangle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Test2Rectangle& from) {
    Test2Rectangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Test2Rectangle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.Test2Rectangle";
  }
  protected:
  explicit Test2Rectangle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // float width = 1;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  // float height = 2;
  void clear_height() ;
  float height() const;
  void set_height(float value);

  private:
  float _internal_height() const;
  void _internal_set_height(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.Test2Rectangle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float width_;
    float height_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TagTestTag final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TagTestTag) */ {
 public:
  inline TagTestTag() : TagTestTag(nullptr) {}
  ~TagTestTag() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TagTestTag(::google::protobuf::internal::ConstantInitialized);

  TagTestTag(const TagTestTag& from);
  TagTestTag(TagTestTag&& from) noexcept
    : TagTestTag() {
    *this = ::std::move(from);
  }

  inline TagTestTag(::google::protobuf::Arena* arena, const TagTestTag& from)
    : TagTestTag(arena) {
    MergeFrom(from);
  }
  inline TagTestTag& operator=(const TagTestTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTestTag& operator=(TagTestTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTestTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTestTag* internal_default_instance() {
    return reinterpret_cast<const TagTestTag*>(
               &_TagTestTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(TagTestTag& a, TagTestTag& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTestTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTestTag* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagTestTag* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagTestTag>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TagTestTag& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TagTestTag& from) {
    TagTestTag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTestTag* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TagTestTag";
  }
  protected:
  explicit TagTestTag(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TagTestTag)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      28, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class L10nPatchDemo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.L10nPatchDemo) */ {
 public:
  inline L10nPatchDemo() : L10nPatchDemo(nullptr) {}
  ~L10nPatchDemo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR L10nPatchDemo(::google::protobuf::internal::ConstantInitialized);

  L10nPatchDemo(const L10nPatchDemo& from);
  L10nPatchDemo(L10nPatchDemo&& from) noexcept
    : L10nPatchDemo() {
    *this = ::std::move(from);
  }

  inline L10nPatchDemo(::google::protobuf::Arena* arena, const L10nPatchDemo& from)
    : L10nPatchDemo(arena) {
    MergeFrom(from);
  }
  inline L10nPatchDemo& operator=(const L10nPatchDemo& from) {
    CopyFrom(from);
    return *this;
  }
  inline L10nPatchDemo& operator=(L10nPatchDemo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L10nPatchDemo& default_instance() {
    return *internal_default_instance();
  }
  static inline const L10nPatchDemo* internal_default_instance() {
    return reinterpret_cast<const L10nPatchDemo*>(
               &_L10nPatchDemo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(L10nPatchDemo& a, L10nPatchDemo& b) {
    a.Swap(&b);
  }
  inline void Swap(L10nPatchDemo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L10nPatchDemo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L10nPatchDemo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L10nPatchDemo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const L10nPatchDemo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const L10nPatchDemo& from) {
    L10nPatchDemo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L10nPatchDemo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.L10nPatchDemo";
  }
  protected:
  explicit L10nPatchDemo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 value = 2;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.L10nPatchDemo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class L10nL10NDemo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.L10nL10NDemo) */ {
 public:
  inline L10nL10NDemo() : L10nL10NDemo(nullptr) {}
  ~L10nL10NDemo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR L10nL10NDemo(::google::protobuf::internal::ConstantInitialized);

  L10nL10NDemo(const L10nL10NDemo& from);
  L10nL10NDemo(L10nL10NDemo&& from) noexcept
    : L10nL10NDemo() {
    *this = ::std::move(from);
  }

  inline L10nL10NDemo(::google::protobuf::Arena* arena, const L10nL10NDemo& from)
    : L10nL10NDemo(arena) {
    MergeFrom(from);
  }
  inline L10nL10NDemo& operator=(const L10nL10NDemo& from) {
    CopyFrom(from);
    return *this;
  }
  inline L10nL10NDemo& operator=(L10nL10NDemo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L10nL10NDemo& default_instance() {
    return *internal_default_instance();
  }
  static inline const L10nL10NDemo* internal_default_instance() {
    return reinterpret_cast<const L10nL10NDemo*>(
               &_L10nL10NDemo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(L10nL10NDemo& a, L10nL10NDemo& b) {
    a.Swap(&b);
  }
  inline void Swap(L10nL10NDemo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L10nL10NDemo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L10nL10NDemo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L10nL10NDemo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const L10nL10NDemo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const L10nL10NDemo& from) {
    L10nL10NDemo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L10nL10NDemo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.L10nL10NDemo";
  }
  protected:
  explicit L10nL10NDemo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string text = 2;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.L10nL10NDemo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      29, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class ItemItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.ItemItem) */ {
 public:
  inline ItemItem() : ItemItem(nullptr) {}
  ~ItemItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ItemItem(::google::protobuf::internal::ConstantInitialized);

  ItemItem(const ItemItem& from);
  ItemItem(ItemItem&& from) noexcept
    : ItemItem() {
    *this = ::std::move(from);
  }

  inline ItemItem(::google::protobuf::Arena* arena, const ItemItem& from)
    : ItemItem(arena) {
    MergeFrom(from);
  }
  inline ItemItem& operator=(const ItemItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemItem& operator=(ItemItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemItem* internal_default_instance() {
    return reinterpret_cast<const ItemItem*>(
               &_ItemItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ItemItem& a, ItemItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ItemItem& from) {
    ItemItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.ItemItem";
  }
  protected:
  explicit ItemItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIconBackgroudFieldNumber = 8,
    kIconMaskFieldNumber = 9,
    kDescFieldNumber = 10,
    kIdFieldNumber = 1,
    kMinorTypeFieldNumber = 4,
    kQualityFieldNumber = 6,
    kShowOrderFieldNumber = 11,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string icon_backgroud = 8;
  void clear_icon_backgroud() ;
  const std::string& icon_backgroud() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_icon_backgroud(Arg_&& arg, Args_... args);
  std::string* mutable_icon_backgroud();
  PROTOBUF_NODISCARD std::string* release_icon_backgroud();
  void set_allocated_icon_backgroud(std::string* ptr);

  private:
  const std::string& _internal_icon_backgroud() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_backgroud(
      const std::string& value);
  std::string* _internal_mutable_icon_backgroud();

  public:
  // string icon_mask = 9;
  void clear_icon_mask() ;
  const std::string& icon_mask() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_icon_mask(Arg_&& arg, Args_... args);
  std::string* mutable_icon_mask();
  PROTOBUF_NODISCARD std::string* release_icon_mask();
  void set_allocated_icon_mask(std::string* ptr);

  private:
  const std::string& _internal_icon_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_mask(
      const std::string& value);
  std::string* _internal_mutable_icon_mask();

  public:
  // string desc = 10;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.ItemEMinorType minor_type = 4;
  void clear_minor_type() ;
  ::cfg::ItemEMinorType minor_type() const;
  void set_minor_type(::cfg::ItemEMinorType value);

  private:
  ::cfg::ItemEMinorType _internal_minor_type() const;
  void _internal_set_minor_type(::cfg::ItemEMinorType value);

  public:
  // .cfg.ItemEItemQuality quality = 6;
  void clear_quality() ;
  ::cfg::ItemEItemQuality quality() const;
  void set_quality(::cfg::ItemEItemQuality value);

  private:
  ::cfg::ItemEItemQuality _internal_quality() const;
  void _internal_set_quality(::cfg::ItemEItemQuality value);

  public:
  // int32 show_order = 11;
  void clear_show_order() ;
  ::int32_t show_order() const;
  void set_show_order(::int32_t value);

  private:
  ::int32_t _internal_show_order() const;
  void _internal_set_show_order(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.ItemItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 0,
      60, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr icon_backgroud_;
    ::google::protobuf::internal::ArenaStringPtr icon_mask_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::int32_t id_;
    int minor_type_;
    int quality_;
    ::int32_t show_order_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class DefineFromExcel2_K8Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<DefineFromExcel2_K8Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::google::protobuf::internal::MapEntry<DefineFromExcel2_K8Entry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32> SuperType;
  DefineFromExcel2_K8Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DefineFromExcel2_K8Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit DefineFromExcel2_K8Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const DefineFromExcel2_K8Entry_DoNotUse& other);
  static const DefineFromExcel2_K8Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DefineFromExcel2_K8Entry_DoNotUse*>(&_DefineFromExcel2_K8Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class CommonGlobalConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.CommonGlobalConfig) */ {
 public:
  inline CommonGlobalConfig() : CommonGlobalConfig(nullptr) {}
  ~CommonGlobalConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonGlobalConfig(::google::protobuf::internal::ConstantInitialized);

  CommonGlobalConfig(const CommonGlobalConfig& from);
  CommonGlobalConfig(CommonGlobalConfig&& from) noexcept
    : CommonGlobalConfig() {
    *this = ::std::move(from);
  }

  inline CommonGlobalConfig(::google::protobuf::Arena* arena, const CommonGlobalConfig& from)
    : CommonGlobalConfig(arena) {
    MergeFrom(from);
  }
  inline CommonGlobalConfig& operator=(const CommonGlobalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonGlobalConfig& operator=(CommonGlobalConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonGlobalConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonGlobalConfig* internal_default_instance() {
    return reinterpret_cast<const CommonGlobalConfig*>(
               &_CommonGlobalConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CommonGlobalConfig& a, CommonGlobalConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonGlobalConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonGlobalConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonGlobalConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonGlobalConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonGlobalConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonGlobalConfig& from) {
    CommonGlobalConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonGlobalConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.CommonGlobalConfig";
  }
  protected:
  explicit CommonGlobalConfig(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX7FieldNumber = 7,
    kX1FieldNumber = 1,
    kX2FieldNumber = 2,
    kX3FieldNumber = 3,
    kX4FieldNumber = 4,
    kX5FieldNumber = 5,
    kX6FieldNumber = 6,
  };
  // repeated int32 x7 = 7 [packed = true];
  int x7_size() const;
  private:
  int _internal_x7_size() const;

  public:
  void clear_x7() ;
  ::int32_t x7(int index) const;
  void set_x7(int index, ::int32_t value);
  void add_x7(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& x7() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_x7();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_x7() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_x7();

  public:
  // int32 x1 = 1;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // int32 x2 = 2;
  void clear_x2() ;
  ::int32_t x2() const;
  void set_x2(::int32_t value);

  private:
  ::int32_t _internal_x2() const;
  void _internal_set_x2(::int32_t value);

  public:
  // int32 x3 = 3;
  void clear_x3() ;
  ::int32_t x3() const;
  void set_x3(::int32_t value);

  private:
  ::int32_t _internal_x3() const;
  void _internal_set_x3(::int32_t value);

  public:
  // int32 x4 = 4;
  void clear_x4() ;
  ::int32_t x4() const;
  void set_x4(::int32_t value);

  private:
  ::int32_t _internal_x4() const;
  void _internal_set_x4(::int32_t value);

  public:
  // int32 x5 = 5;
  void clear_x5() ;
  ::int32_t x5() const;
  void set_x5(::int32_t value);

  private:
  ::int32_t _internal_x5() const;
  void _internal_set_x5(::int32_t value);

  public:
  // int32 x6 = 6;
  void clear_x6() ;
  ::int32_t x6() const;
  void set_x6(::int32_t value);

  private:
  ::int32_t _internal_x6() const;
  void _internal_set_x6(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.CommonGlobalConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> x7_;
    mutable ::google::protobuf::internal::CachedSize _x7_cached_byte_size_;
    ::int32_t x1_;
    ::int32_t x2_;
    ::int32_t x3_;
    ::int32_t x4_;
    ::int32_t x5_;
    ::int32_t x6_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUpdateDailyBehaviorProps final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUpdateDailyBehaviorProps) */ {
 public:
  inline AiUpdateDailyBehaviorProps() : AiUpdateDailyBehaviorProps(nullptr) {}
  ~AiUpdateDailyBehaviorProps() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUpdateDailyBehaviorProps(::google::protobuf::internal::ConstantInitialized);

  AiUpdateDailyBehaviorProps(const AiUpdateDailyBehaviorProps& from);
  AiUpdateDailyBehaviorProps(AiUpdateDailyBehaviorProps&& from) noexcept
    : AiUpdateDailyBehaviorProps() {
    *this = ::std::move(from);
  }

  inline AiUpdateDailyBehaviorProps(::google::protobuf::Arena* arena, const AiUpdateDailyBehaviorProps& from)
    : AiUpdateDailyBehaviorProps(arena) {
    MergeFrom(from);
  }
  inline AiUpdateDailyBehaviorProps& operator=(const AiUpdateDailyBehaviorProps& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUpdateDailyBehaviorProps& operator=(AiUpdateDailyBehaviorProps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUpdateDailyBehaviorProps& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUpdateDailyBehaviorProps* internal_default_instance() {
    return reinterpret_cast<const AiUpdateDailyBehaviorProps*>(
               &_AiUpdateDailyBehaviorProps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AiUpdateDailyBehaviorProps& a, AiUpdateDailyBehaviorProps& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUpdateDailyBehaviorProps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUpdateDailyBehaviorProps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUpdateDailyBehaviorProps* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUpdateDailyBehaviorProps>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUpdateDailyBehaviorProps& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUpdateDailyBehaviorProps& from) {
    AiUpdateDailyBehaviorProps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUpdateDailyBehaviorProps* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUpdateDailyBehaviorProps";
  }
  protected:
  explicit AiUpdateDailyBehaviorProps(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kSatietyKeyFieldNumber = 3,
    kEnergyKeyFieldNumber = 4,
    kMoodKeyFieldNumber = 5,
    kSatietyLowerThresholdKeyFieldNumber = 6,
    kSatietyUpperThresholdKeyFieldNumber = 7,
    kEnergyLowerThresholdKeyFieldNumber = 8,
    kEnergyUpperThresholdKeyFieldNumber = 9,
    kMoodLowerThresholdKeyFieldNumber = 10,
    kMoodUpperThresholdKeyFieldNumber = 11,
    kIdFieldNumber = 1,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string satiety_key = 3;
  void clear_satiety_key() ;
  const std::string& satiety_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_satiety_key(Arg_&& arg, Args_... args);
  std::string* mutable_satiety_key();
  PROTOBUF_NODISCARD std::string* release_satiety_key();
  void set_allocated_satiety_key(std::string* ptr);

  private:
  const std::string& _internal_satiety_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_satiety_key(
      const std::string& value);
  std::string* _internal_mutable_satiety_key();

  public:
  // string energy_key = 4;
  void clear_energy_key() ;
  const std::string& energy_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_energy_key(Arg_&& arg, Args_... args);
  std::string* mutable_energy_key();
  PROTOBUF_NODISCARD std::string* release_energy_key();
  void set_allocated_energy_key(std::string* ptr);

  private:
  const std::string& _internal_energy_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_energy_key(
      const std::string& value);
  std::string* _internal_mutable_energy_key();

  public:
  // string mood_key = 5;
  void clear_mood_key() ;
  const std::string& mood_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mood_key(Arg_&& arg, Args_... args);
  std::string* mutable_mood_key();
  PROTOBUF_NODISCARD std::string* release_mood_key();
  void set_allocated_mood_key(std::string* ptr);

  private:
  const std::string& _internal_mood_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mood_key(
      const std::string& value);
  std::string* _internal_mutable_mood_key();

  public:
  // string satiety_lower_threshold_key = 6;
  void clear_satiety_lower_threshold_key() ;
  const std::string& satiety_lower_threshold_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_satiety_lower_threshold_key(Arg_&& arg, Args_... args);
  std::string* mutable_satiety_lower_threshold_key();
  PROTOBUF_NODISCARD std::string* release_satiety_lower_threshold_key();
  void set_allocated_satiety_lower_threshold_key(std::string* ptr);

  private:
  const std::string& _internal_satiety_lower_threshold_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_satiety_lower_threshold_key(
      const std::string& value);
  std::string* _internal_mutable_satiety_lower_threshold_key();

  public:
  // string satiety_upper_threshold_key = 7;
  void clear_satiety_upper_threshold_key() ;
  const std::string& satiety_upper_threshold_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_satiety_upper_threshold_key(Arg_&& arg, Args_... args);
  std::string* mutable_satiety_upper_threshold_key();
  PROTOBUF_NODISCARD std::string* release_satiety_upper_threshold_key();
  void set_allocated_satiety_upper_threshold_key(std::string* ptr);

  private:
  const std::string& _internal_satiety_upper_threshold_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_satiety_upper_threshold_key(
      const std::string& value);
  std::string* _internal_mutable_satiety_upper_threshold_key();

  public:
  // string energy_lower_threshold_key = 8;
  void clear_energy_lower_threshold_key() ;
  const std::string& energy_lower_threshold_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_energy_lower_threshold_key(Arg_&& arg, Args_... args);
  std::string* mutable_energy_lower_threshold_key();
  PROTOBUF_NODISCARD std::string* release_energy_lower_threshold_key();
  void set_allocated_energy_lower_threshold_key(std::string* ptr);

  private:
  const std::string& _internal_energy_lower_threshold_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_energy_lower_threshold_key(
      const std::string& value);
  std::string* _internal_mutable_energy_lower_threshold_key();

  public:
  // string energy_upper_threshold_key = 9;
  void clear_energy_upper_threshold_key() ;
  const std::string& energy_upper_threshold_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_energy_upper_threshold_key(Arg_&& arg, Args_... args);
  std::string* mutable_energy_upper_threshold_key();
  PROTOBUF_NODISCARD std::string* release_energy_upper_threshold_key();
  void set_allocated_energy_upper_threshold_key(std::string* ptr);

  private:
  const std::string& _internal_energy_upper_threshold_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_energy_upper_threshold_key(
      const std::string& value);
  std::string* _internal_mutable_energy_upper_threshold_key();

  public:
  // string mood_lower_threshold_key = 10;
  void clear_mood_lower_threshold_key() ;
  const std::string& mood_lower_threshold_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mood_lower_threshold_key(Arg_&& arg, Args_... args);
  std::string* mutable_mood_lower_threshold_key();
  PROTOBUF_NODISCARD std::string* release_mood_lower_threshold_key();
  void set_allocated_mood_lower_threshold_key(std::string* ptr);

  private:
  const std::string& _internal_mood_lower_threshold_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mood_lower_threshold_key(
      const std::string& value);
  std::string* _internal_mutable_mood_lower_threshold_key();

  public:
  // string mood_upper_threshold_key = 11;
  void clear_mood_upper_threshold_key() ;
  const std::string& mood_upper_threshold_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mood_upper_threshold_key(Arg_&& arg, Args_... args);
  std::string* mutable_mood_upper_threshold_key();
  PROTOBUF_NODISCARD std::string* release_mood_upper_threshold_key();
  void set_allocated_mood_upper_threshold_key(std::string* ptr);

  private:
  const std::string& _internal_mood_upper_threshold_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mood_upper_threshold_key(
      const std::string& value);
  std::string* _internal_mutable_mood_upper_threshold_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUpdateDailyBehaviorProps)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      239, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr satiety_key_;
    ::google::protobuf::internal::ArenaStringPtr energy_key_;
    ::google::protobuf::internal::ArenaStringPtr mood_key_;
    ::google::protobuf::internal::ArenaStringPtr satiety_lower_threshold_key_;
    ::google::protobuf::internal::ArenaStringPtr satiety_upper_threshold_key_;
    ::google::protobuf::internal::ArenaStringPtr energy_lower_threshold_key_;
    ::google::protobuf::internal::ArenaStringPtr energy_upper_threshold_key_;
    ::google::protobuf::internal::ArenaStringPtr mood_lower_threshold_key_;
    ::google::protobuf::internal::ArenaStringPtr mood_upper_threshold_key_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeTimeLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeTimeLimit) */ {
 public:
  inline AiUeTimeLimit() : AiUeTimeLimit(nullptr) {}
  ~AiUeTimeLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeTimeLimit(::google::protobuf::internal::ConstantInitialized);

  AiUeTimeLimit(const AiUeTimeLimit& from);
  AiUeTimeLimit(AiUeTimeLimit&& from) noexcept
    : AiUeTimeLimit() {
    *this = ::std::move(from);
  }

  inline AiUeTimeLimit(::google::protobuf::Arena* arena, const AiUeTimeLimit& from)
    : AiUeTimeLimit(arena) {
    MergeFrom(from);
  }
  inline AiUeTimeLimit& operator=(const AiUeTimeLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeTimeLimit& operator=(AiUeTimeLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeTimeLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeTimeLimit* internal_default_instance() {
    return reinterpret_cast<const AiUeTimeLimit*>(
               &_AiUeTimeLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AiUeTimeLimit& a, AiUeTimeLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeTimeLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeTimeLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeTimeLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeTimeLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeTimeLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeTimeLimit& from) {
    AiUeTimeLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeTimeLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeTimeLimit";
  }
  protected:
  explicit AiUeTimeLimit(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kFlowAbortModeFieldNumber = 3,
    kLimitTimeFieldNumber = 4,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFlowAbortMode flow_abort_mode = 3;
  void clear_flow_abort_mode() ;
  ::cfg::AiEFlowAbortMode flow_abort_mode() const;
  void set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  private:
  ::cfg::AiEFlowAbortMode _internal_flow_abort_mode() const;
  void _internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  public:
  // float limit_time = 4;
  void clear_limit_time() ;
  float limit_time() const;
  void set_limit_time(float value);

  private:
  float _internal_limit_time() const;
  void _internal_set_limit_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeTimeLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      35, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    int flow_abort_mode_;
    float limit_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeSetDefaultFocus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeSetDefaultFocus) */ {
 public:
  inline AiUeSetDefaultFocus() : AiUeSetDefaultFocus(nullptr) {}
  ~AiUeSetDefaultFocus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeSetDefaultFocus(::google::protobuf::internal::ConstantInitialized);

  AiUeSetDefaultFocus(const AiUeSetDefaultFocus& from);
  AiUeSetDefaultFocus(AiUeSetDefaultFocus&& from) noexcept
    : AiUeSetDefaultFocus() {
    *this = ::std::move(from);
  }

  inline AiUeSetDefaultFocus(::google::protobuf::Arena* arena, const AiUeSetDefaultFocus& from)
    : AiUeSetDefaultFocus(arena) {
    MergeFrom(from);
  }
  inline AiUeSetDefaultFocus& operator=(const AiUeSetDefaultFocus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeSetDefaultFocus& operator=(AiUeSetDefaultFocus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeSetDefaultFocus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeSetDefaultFocus* internal_default_instance() {
    return reinterpret_cast<const AiUeSetDefaultFocus*>(
               &_AiUeSetDefaultFocus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AiUeSetDefaultFocus& a, AiUeSetDefaultFocus& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeSetDefaultFocus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeSetDefaultFocus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeSetDefaultFocus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeSetDefaultFocus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeSetDefaultFocus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeSetDefaultFocus& from) {
    AiUeSetDefaultFocus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeSetDefaultFocus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeSetDefaultFocus";
  }
  protected:
  explicit AiUeSetDefaultFocus(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kKeyboardKeyFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string keyboard_key = 3;
  void clear_keyboard_key() ;
  const std::string& keyboard_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_keyboard_key(Arg_&& arg, Args_... args);
  std::string* mutable_keyboard_key();
  PROTOBUF_NODISCARD std::string* release_keyboard_key();
  void set_allocated_keyboard_key(std::string* ptr);

  private:
  const std::string& _internal_keyboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyboard_key(
      const std::string& value);
  std::string* _internal_mutable_keyboard_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeSetDefaultFocus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr keyboard_key_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeLoop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeLoop) */ {
 public:
  inline AiUeLoop() : AiUeLoop(nullptr) {}
  ~AiUeLoop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeLoop(::google::protobuf::internal::ConstantInitialized);

  AiUeLoop(const AiUeLoop& from);
  AiUeLoop(AiUeLoop&& from) noexcept
    : AiUeLoop() {
    *this = ::std::move(from);
  }

  inline AiUeLoop(::google::protobuf::Arena* arena, const AiUeLoop& from)
    : AiUeLoop(arena) {
    MergeFrom(from);
  }
  inline AiUeLoop& operator=(const AiUeLoop& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeLoop& operator=(AiUeLoop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeLoop& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeLoop* internal_default_instance() {
    return reinterpret_cast<const AiUeLoop*>(
               &_AiUeLoop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AiUeLoop& a, AiUeLoop& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeLoop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeLoop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeLoop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeLoop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeLoop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeLoop& from) {
    AiUeLoop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeLoop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeLoop";
  }
  protected:
  explicit AiUeLoop(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kFlowAbortModeFieldNumber = 3,
    kNumLoopsFieldNumber = 4,
    kInfiniteLoopFieldNumber = 5,
    kInfiniteLoopTimeoutTimeFieldNumber = 6,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFlowAbortMode flow_abort_mode = 3;
  void clear_flow_abort_mode() ;
  ::cfg::AiEFlowAbortMode flow_abort_mode() const;
  void set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  private:
  ::cfg::AiEFlowAbortMode _internal_flow_abort_mode() const;
  void _internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  public:
  // int32 num_loops = 4;
  void clear_num_loops() ;
  ::int32_t num_loops() const;
  void set_num_loops(::int32_t value);

  private:
  ::int32_t _internal_num_loops() const;
  void _internal_set_num_loops(::int32_t value);

  public:
  // bool infinite_loop = 5;
  void clear_infinite_loop() ;
  bool infinite_loop() const;
  void set_infinite_loop(bool value);

  private:
  bool _internal_infinite_loop() const;
  void _internal_set_infinite_loop(bool value);

  public:
  // float infinite_loop_timeout_time = 6;
  void clear_infinite_loop_timeout_time() ;
  float infinite_loop_timeout_time() const;
  void set_infinite_loop_timeout_time(float value);

  private:
  float _internal_infinite_loop_timeout_time() const;
  void _internal_set_infinite_loop_timeout_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeLoop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      30, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    int flow_abort_mode_;
    ::int32_t num_loops_;
    bool infinite_loop_;
    float infinite_loop_timeout_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeForceSuccess final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeForceSuccess) */ {
 public:
  inline AiUeForceSuccess() : AiUeForceSuccess(nullptr) {}
  ~AiUeForceSuccess() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeForceSuccess(::google::protobuf::internal::ConstantInitialized);

  AiUeForceSuccess(const AiUeForceSuccess& from);
  AiUeForceSuccess(AiUeForceSuccess&& from) noexcept
    : AiUeForceSuccess() {
    *this = ::std::move(from);
  }

  inline AiUeForceSuccess(::google::protobuf::Arena* arena, const AiUeForceSuccess& from)
    : AiUeForceSuccess(arena) {
    MergeFrom(from);
  }
  inline AiUeForceSuccess& operator=(const AiUeForceSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeForceSuccess& operator=(AiUeForceSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeForceSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeForceSuccess* internal_default_instance() {
    return reinterpret_cast<const AiUeForceSuccess*>(
               &_AiUeForceSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AiUeForceSuccess& a, AiUeForceSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeForceSuccess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeForceSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeForceSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeForceSuccess>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeForceSuccess& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeForceSuccess& from) {
    AiUeForceSuccess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeForceSuccess* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeForceSuccess";
  }
  protected:
  explicit AiUeForceSuccess(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kFlowAbortModeFieldNumber = 3,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFlowAbortMode flow_abort_mode = 3;
  void clear_flow_abort_mode() ;
  ::cfg::AiEFlowAbortMode flow_abort_mode() const;
  void set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  private:
  ::cfg::AiEFlowAbortMode _internal_flow_abort_mode() const;
  void _internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeForceSuccess)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      38, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    int flow_abort_mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeCooldown final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeCooldown) */ {
 public:
  inline AiUeCooldown() : AiUeCooldown(nullptr) {}
  ~AiUeCooldown() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeCooldown(::google::protobuf::internal::ConstantInitialized);

  AiUeCooldown(const AiUeCooldown& from);
  AiUeCooldown(AiUeCooldown&& from) noexcept
    : AiUeCooldown() {
    *this = ::std::move(from);
  }

  inline AiUeCooldown(::google::protobuf::Arena* arena, const AiUeCooldown& from)
    : AiUeCooldown(arena) {
    MergeFrom(from);
  }
  inline AiUeCooldown& operator=(const AiUeCooldown& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeCooldown& operator=(AiUeCooldown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeCooldown& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeCooldown* internal_default_instance() {
    return reinterpret_cast<const AiUeCooldown*>(
               &_AiUeCooldown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AiUeCooldown& a, AiUeCooldown& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeCooldown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeCooldown* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeCooldown* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeCooldown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeCooldown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeCooldown& from) {
    AiUeCooldown::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeCooldown* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeCooldown";
  }
  protected:
  explicit AiUeCooldown(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kFlowAbortModeFieldNumber = 3,
    kCooldownTimeFieldNumber = 4,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFlowAbortMode flow_abort_mode = 3;
  void clear_flow_abort_mode() ;
  ::cfg::AiEFlowAbortMode flow_abort_mode() const;
  void set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  private:
  ::cfg::AiEFlowAbortMode _internal_flow_abort_mode() const;
  void _internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  public:
  // float cooldown_time = 4;
  void clear_cooldown_time() ;
  float cooldown_time() const;
  void set_cooldown_time(float value);

  private:
  float _internal_cooldown_time() const;
  void _internal_set_cooldown_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeCooldown)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      34, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    int flow_abort_mode_;
    float cooldown_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiStringKeyData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiStringKeyData) */ {
 public:
  inline AiStringKeyData() : AiStringKeyData(nullptr) {}
  ~AiStringKeyData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiStringKeyData(::google::protobuf::internal::ConstantInitialized);

  AiStringKeyData(const AiStringKeyData& from);
  AiStringKeyData(AiStringKeyData&& from) noexcept
    : AiStringKeyData() {
    *this = ::std::move(from);
  }

  inline AiStringKeyData(::google::protobuf::Arena* arena, const AiStringKeyData& from)
    : AiStringKeyData(arena) {
    MergeFrom(from);
  }
  inline AiStringKeyData& operator=(const AiStringKeyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiStringKeyData& operator=(AiStringKeyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiStringKeyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiStringKeyData* internal_default_instance() {
    return reinterpret_cast<const AiStringKeyData*>(
               &_AiStringKeyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AiStringKeyData& a, AiStringKeyData& b) {
    a.Swap(&b);
  }
  inline void Swap(AiStringKeyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiStringKeyData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiStringKeyData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiStringKeyData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiStringKeyData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiStringKeyData& from) {
    AiStringKeyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiStringKeyData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiStringKeyData";
  }
  protected:
  explicit AiStringKeyData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiStringKeyData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      33, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiKeepFaceTarget final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiKeepFaceTarget) */ {
 public:
  inline AiKeepFaceTarget() : AiKeepFaceTarget(nullptr) {}
  ~AiKeepFaceTarget() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiKeepFaceTarget(::google::protobuf::internal::ConstantInitialized);

  AiKeepFaceTarget(const AiKeepFaceTarget& from);
  AiKeepFaceTarget(AiKeepFaceTarget&& from) noexcept
    : AiKeepFaceTarget() {
    *this = ::std::move(from);
  }

  inline AiKeepFaceTarget(::google::protobuf::Arena* arena, const AiKeepFaceTarget& from)
    : AiKeepFaceTarget(arena) {
    MergeFrom(from);
  }
  inline AiKeepFaceTarget& operator=(const AiKeepFaceTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiKeepFaceTarget& operator=(AiKeepFaceTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiKeepFaceTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiKeepFaceTarget* internal_default_instance() {
    return reinterpret_cast<const AiKeepFaceTarget*>(
               &_AiKeepFaceTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AiKeepFaceTarget& a, AiKeepFaceTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(AiKeepFaceTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiKeepFaceTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiKeepFaceTarget* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiKeepFaceTarget>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiKeepFaceTarget& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiKeepFaceTarget& from) {
    AiKeepFaceTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiKeepFaceTarget* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiKeepFaceTarget";
  }
  protected:
  explicit AiKeepFaceTarget(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kTargetActorKeyFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string target_actor_key = 3;
  void clear_target_actor_key() ;
  const std::string& target_actor_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_actor_key(Arg_&& arg, Args_... args);
  std::string* mutable_target_actor_key();
  PROTOBUF_NODISCARD std::string* release_target_actor_key();
  void set_allocated_target_actor_key(std::string* ptr);

  private:
  const std::string& _internal_target_actor_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_actor_key(
      const std::string& value);
  std::string* _internal_mutable_target_actor_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiKeepFaceTarget)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr target_actor_key_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiIsSet final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cfg.AiIsSet) */ {
 public:
  inline AiIsSet() : AiIsSet(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiIsSet(::google::protobuf::internal::ConstantInitialized);

  AiIsSet(const AiIsSet& from);
  AiIsSet(AiIsSet&& from) noexcept
    : AiIsSet() {
    *this = ::std::move(from);
  }

  inline AiIsSet(::google::protobuf::Arena* arena, const AiIsSet& from)
    : AiIsSet(arena) {
    MergeFrom(from);
  }
  inline AiIsSet& operator=(const AiIsSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiIsSet& operator=(AiIsSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiIsSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiIsSet* internal_default_instance() {
    return reinterpret_cast<const AiIsSet*>(
               &_AiIsSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AiIsSet& a, AiIsSet& b) {
    a.Swap(&b);
  }
  inline void Swap(AiIsSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiIsSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiIsSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiIsSet>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AiIsSet& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AiIsSet& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiIsSet";
  }
  protected:
  explicit AiIsSet(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cfg.AiIsSet)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiIsNotSet final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cfg.AiIsNotSet) */ {
 public:
  inline AiIsNotSet() : AiIsNotSet(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiIsNotSet(::google::protobuf::internal::ConstantInitialized);

  AiIsNotSet(const AiIsNotSet& from);
  AiIsNotSet(AiIsNotSet&& from) noexcept
    : AiIsNotSet() {
    *this = ::std::move(from);
  }

  inline AiIsNotSet(::google::protobuf::Arena* arena, const AiIsNotSet& from)
    : AiIsNotSet(arena) {
    MergeFrom(from);
  }
  inline AiIsNotSet& operator=(const AiIsNotSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiIsNotSet& operator=(AiIsNotSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiIsNotSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiIsNotSet* internal_default_instance() {
    return reinterpret_cast<const AiIsNotSet*>(
               &_AiIsNotSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AiIsNotSet& a, AiIsNotSet& b) {
    a.Swap(&b);
  }
  inline void Swap(AiIsNotSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiIsNotSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiIsNotSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiIsNotSet>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AiIsNotSet& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AiIsNotSet& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiIsNotSet";
  }
  protected:
  explicit AiIsNotSet(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cfg.AiIsNotSet)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiIsAtLocation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiIsAtLocation) */ {
 public:
  inline AiIsAtLocation() : AiIsAtLocation(nullptr) {}
  ~AiIsAtLocation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiIsAtLocation(::google::protobuf::internal::ConstantInitialized);

  AiIsAtLocation(const AiIsAtLocation& from);
  AiIsAtLocation(AiIsAtLocation&& from) noexcept
    : AiIsAtLocation() {
    *this = ::std::move(from);
  }

  inline AiIsAtLocation(::google::protobuf::Arena* arena, const AiIsAtLocation& from)
    : AiIsAtLocation(arena) {
    MergeFrom(from);
  }
  inline AiIsAtLocation& operator=(const AiIsAtLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiIsAtLocation& operator=(AiIsAtLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiIsAtLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiIsAtLocation* internal_default_instance() {
    return reinterpret_cast<const AiIsAtLocation*>(
               &_AiIsAtLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AiIsAtLocation& a, AiIsAtLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(AiIsAtLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiIsAtLocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiIsAtLocation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiIsAtLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiIsAtLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiIsAtLocation& from) {
    AiIsAtLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiIsAtLocation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiIsAtLocation";
  }
  protected:
  explicit AiIsAtLocation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kKeyboardKeyFieldNumber = 5,
    kIdFieldNumber = 1,
    kFlowAbortModeFieldNumber = 3,
    kAcceptableRadiusFieldNumber = 4,
    kInverseConditionFieldNumber = 6,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string keyboard_key = 5;
  void clear_keyboard_key() ;
  const std::string& keyboard_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_keyboard_key(Arg_&& arg, Args_... args);
  std::string* mutable_keyboard_key();
  PROTOBUF_NODISCARD std::string* release_keyboard_key();
  void set_allocated_keyboard_key(std::string* ptr);

  private:
  const std::string& _internal_keyboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyboard_key(
      const std::string& value);
  std::string* _internal_mutable_keyboard_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFlowAbortMode flow_abort_mode = 3;
  void clear_flow_abort_mode() ;
  ::cfg::AiEFlowAbortMode flow_abort_mode() const;
  void set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  private:
  ::cfg::AiEFlowAbortMode _internal_flow_abort_mode() const;
  void _internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  public:
  // float acceptable_radius = 4;
  void clear_acceptable_radius() ;
  float acceptable_radius() const;
  void set_acceptable_radius(float value);

  private:
  float _internal_acceptable_radius() const;
  void _internal_set_acceptable_radius(float value);

  public:
  // bool inverse_condition = 6;
  void clear_inverse_condition() ;
  bool inverse_condition() const;
  void set_inverse_condition(bool value);

  private:
  bool _internal_inverse_condition() const;
  void _internal_set_inverse_condition(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiIsAtLocation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      48, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr keyboard_key_;
    ::int32_t id_;
    int flow_abort_mode_;
    float acceptable_radius_;
    bool inverse_condition_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiIntKeyData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiIntKeyData) */ {
 public:
  inline AiIntKeyData() : AiIntKeyData(nullptr) {}
  ~AiIntKeyData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiIntKeyData(::google::protobuf::internal::ConstantInitialized);

  AiIntKeyData(const AiIntKeyData& from);
  AiIntKeyData(AiIntKeyData&& from) noexcept
    : AiIntKeyData() {
    *this = ::std::move(from);
  }

  inline AiIntKeyData(::google::protobuf::Arena* arena, const AiIntKeyData& from)
    : AiIntKeyData(arena) {
    MergeFrom(from);
  }
  inline AiIntKeyData& operator=(const AiIntKeyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiIntKeyData& operator=(AiIntKeyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiIntKeyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiIntKeyData* internal_default_instance() {
    return reinterpret_cast<const AiIntKeyData*>(
               &_AiIntKeyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AiIntKeyData& a, AiIntKeyData& b) {
    a.Swap(&b);
  }
  inline void Swap(AiIntKeyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiIntKeyData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiIntKeyData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiIntKeyData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiIntKeyData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiIntKeyData& from) {
    AiIntKeyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiIntKeyData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiIntKeyData";
  }
  protected:
  explicit AiIntKeyData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiIntKeyData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiGetOwnerPlayer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiGetOwnerPlayer) */ {
 public:
  inline AiGetOwnerPlayer() : AiGetOwnerPlayer(nullptr) {}
  ~AiGetOwnerPlayer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiGetOwnerPlayer(::google::protobuf::internal::ConstantInitialized);

  AiGetOwnerPlayer(const AiGetOwnerPlayer& from);
  AiGetOwnerPlayer(AiGetOwnerPlayer&& from) noexcept
    : AiGetOwnerPlayer() {
    *this = ::std::move(from);
  }

  inline AiGetOwnerPlayer(::google::protobuf::Arena* arena, const AiGetOwnerPlayer& from)
    : AiGetOwnerPlayer(arena) {
    MergeFrom(from);
  }
  inline AiGetOwnerPlayer& operator=(const AiGetOwnerPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiGetOwnerPlayer& operator=(AiGetOwnerPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiGetOwnerPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiGetOwnerPlayer* internal_default_instance() {
    return reinterpret_cast<const AiGetOwnerPlayer*>(
               &_AiGetOwnerPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AiGetOwnerPlayer& a, AiGetOwnerPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(AiGetOwnerPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiGetOwnerPlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiGetOwnerPlayer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiGetOwnerPlayer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiGetOwnerPlayer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiGetOwnerPlayer& from) {
    AiGetOwnerPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiGetOwnerPlayer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiGetOwnerPlayer";
  }
  protected:
  explicit AiGetOwnerPlayer(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kPlayerActorKeyFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string player_actor_key = 3;
  void clear_player_actor_key() ;
  const std::string& player_actor_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_actor_key(Arg_&& arg, Args_... args);
  std::string* mutable_player_actor_key();
  PROTOBUF_NODISCARD std::string* release_player_actor_key();
  void set_allocated_player_actor_key(std::string* ptr);

  private:
  const std::string& _internal_player_actor_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_actor_key(
      const std::string& value);
  std::string* _internal_mutable_player_actor_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiGetOwnerPlayer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr player_actor_key_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiFloatKeyData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiFloatKeyData) */ {
 public:
  inline AiFloatKeyData() : AiFloatKeyData(nullptr) {}
  ~AiFloatKeyData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiFloatKeyData(::google::protobuf::internal::ConstantInitialized);

  AiFloatKeyData(const AiFloatKeyData& from);
  AiFloatKeyData(AiFloatKeyData&& from) noexcept
    : AiFloatKeyData() {
    *this = ::std::move(from);
  }

  inline AiFloatKeyData(::google::protobuf::Arena* arena, const AiFloatKeyData& from)
    : AiFloatKeyData(arena) {
    MergeFrom(from);
  }
  inline AiFloatKeyData& operator=(const AiFloatKeyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiFloatKeyData& operator=(AiFloatKeyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiFloatKeyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiFloatKeyData* internal_default_instance() {
    return reinterpret_cast<const AiFloatKeyData*>(
               &_AiFloatKeyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AiFloatKeyData& a, AiFloatKeyData& b) {
    a.Swap(&b);
  }
  inline void Swap(AiFloatKeyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiFloatKeyData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiFloatKeyData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiFloatKeyData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiFloatKeyData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiFloatKeyData& from) {
    AiFloatKeyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiFloatKeyData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiFloatKeyData";
  }
  protected:
  explicit AiFloatKeyData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // float value = 1;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiFloatKeyData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiExecuteTimeStatistic final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiExecuteTimeStatistic) */ {
 public:
  inline AiExecuteTimeStatistic() : AiExecuteTimeStatistic(nullptr) {}
  ~AiExecuteTimeStatistic() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiExecuteTimeStatistic(::google::protobuf::internal::ConstantInitialized);

  AiExecuteTimeStatistic(const AiExecuteTimeStatistic& from);
  AiExecuteTimeStatistic(AiExecuteTimeStatistic&& from) noexcept
    : AiExecuteTimeStatistic() {
    *this = ::std::move(from);
  }

  inline AiExecuteTimeStatistic(::google::protobuf::Arena* arena, const AiExecuteTimeStatistic& from)
    : AiExecuteTimeStatistic(arena) {
    MergeFrom(from);
  }
  inline AiExecuteTimeStatistic& operator=(const AiExecuteTimeStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiExecuteTimeStatistic& operator=(AiExecuteTimeStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiExecuteTimeStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiExecuteTimeStatistic* internal_default_instance() {
    return reinterpret_cast<const AiExecuteTimeStatistic*>(
               &_AiExecuteTimeStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AiExecuteTimeStatistic& a, AiExecuteTimeStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(AiExecuteTimeStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiExecuteTimeStatistic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiExecuteTimeStatistic* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiExecuteTimeStatistic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiExecuteTimeStatistic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiExecuteTimeStatistic& from) {
    AiExecuteTimeStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiExecuteTimeStatistic* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiExecuteTimeStatistic";
  }
  protected:
  explicit AiExecuteTimeStatistic(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiExecuteTimeStatistic)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiDistanceLessThan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiDistanceLessThan) */ {
 public:
  inline AiDistanceLessThan() : AiDistanceLessThan(nullptr) {}
  ~AiDistanceLessThan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiDistanceLessThan(::google::protobuf::internal::ConstantInitialized);

  AiDistanceLessThan(const AiDistanceLessThan& from);
  AiDistanceLessThan(AiDistanceLessThan&& from) noexcept
    : AiDistanceLessThan() {
    *this = ::std::move(from);
  }

  inline AiDistanceLessThan(::google::protobuf::Arena* arena, const AiDistanceLessThan& from)
    : AiDistanceLessThan(arena) {
    MergeFrom(from);
  }
  inline AiDistanceLessThan& operator=(const AiDistanceLessThan& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiDistanceLessThan& operator=(AiDistanceLessThan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiDistanceLessThan& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiDistanceLessThan* internal_default_instance() {
    return reinterpret_cast<const AiDistanceLessThan*>(
               &_AiDistanceLessThan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(AiDistanceLessThan& a, AiDistanceLessThan& b) {
    a.Swap(&b);
  }
  inline void Swap(AiDistanceLessThan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiDistanceLessThan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiDistanceLessThan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiDistanceLessThan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiDistanceLessThan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiDistanceLessThan& from) {
    AiDistanceLessThan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiDistanceLessThan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiDistanceLessThan";
  }
  protected:
  explicit AiDistanceLessThan(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kActor1KeyFieldNumber = 4,
    kActor2KeyFieldNumber = 5,
    kIdFieldNumber = 1,
    kFlowAbortModeFieldNumber = 3,
    kDistanceFieldNumber = 6,
    kReverseResultFieldNumber = 7,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string actor1_key = 4;
  void clear_actor1_key() ;
  const std::string& actor1_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_actor1_key(Arg_&& arg, Args_... args);
  std::string* mutable_actor1_key();
  PROTOBUF_NODISCARD std::string* release_actor1_key();
  void set_allocated_actor1_key(std::string* ptr);

  private:
  const std::string& _internal_actor1_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor1_key(
      const std::string& value);
  std::string* _internal_mutable_actor1_key();

  public:
  // string actor2_key = 5;
  void clear_actor2_key() ;
  const std::string& actor2_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_actor2_key(Arg_&& arg, Args_... args);
  std::string* mutable_actor2_key();
  PROTOBUF_NODISCARD std::string* release_actor2_key();
  void set_allocated_actor2_key(std::string* ptr);

  private:
  const std::string& _internal_actor2_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor2_key(
      const std::string& value);
  std::string* _internal_mutable_actor2_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFlowAbortMode flow_abort_mode = 3;
  void clear_flow_abort_mode() ;
  ::cfg::AiEFlowAbortMode flow_abort_mode() const;
  void set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  private:
  ::cfg::AiEFlowAbortMode _internal_flow_abort_mode() const;
  void _internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  public:
  // float distance = 6;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  // bool reverse_result = 7;
  void clear_reverse_result() ;
  bool reverse_result() const;
  void set_reverse_result(bool value);

  private:
  bool _internal_reverse_result() const;
  void _internal_set_reverse_result(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiDistanceLessThan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      60, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr actor1_key_;
    ::google::protobuf::internal::ArenaStringPtr actor2_key_;
    ::int32_t id_;
    int flow_abort_mode_;
    float distance_;
    bool reverse_result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiChooseTarget final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiChooseTarget) */ {
 public:
  inline AiChooseTarget() : AiChooseTarget(nullptr) {}
  ~AiChooseTarget() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiChooseTarget(::google::protobuf::internal::ConstantInitialized);

  AiChooseTarget(const AiChooseTarget& from);
  AiChooseTarget(AiChooseTarget&& from) noexcept
    : AiChooseTarget() {
    *this = ::std::move(from);
  }

  inline AiChooseTarget(::google::protobuf::Arena* arena, const AiChooseTarget& from)
    : AiChooseTarget(arena) {
    MergeFrom(from);
  }
  inline AiChooseTarget& operator=(const AiChooseTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiChooseTarget& operator=(AiChooseTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiChooseTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiChooseTarget* internal_default_instance() {
    return reinterpret_cast<const AiChooseTarget*>(
               &_AiChooseTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AiChooseTarget& a, AiChooseTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(AiChooseTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiChooseTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiChooseTarget* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiChooseTarget>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiChooseTarget& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiChooseTarget& from) {
    AiChooseTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiChooseTarget* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiChooseTarget";
  }
  protected:
  explicit AiChooseTarget(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kResultTargetKeyFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string result_target_key = 3;
  void clear_result_target_key() ;
  const std::string& result_target_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_target_key(Arg_&& arg, Args_... args);
  std::string* mutable_result_target_key();
  PROTOBUF_NODISCARD std::string* release_result_target_key();
  void set_allocated_result_target_key(std::string* ptr);

  private:
  const std::string& _internal_result_target_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_target_key(
      const std::string& value);
  std::string* _internal_mutable_result_target_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiChooseTarget)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr result_target_key_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiBlackboardKeyData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiBlackboardKeyData) */ {
 public:
  inline AiBlackboardKeyData() : AiBlackboardKeyData(nullptr) {}
  ~AiBlackboardKeyData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiBlackboardKeyData(::google::protobuf::internal::ConstantInitialized);

  AiBlackboardKeyData(const AiBlackboardKeyData& from);
  AiBlackboardKeyData(AiBlackboardKeyData&& from) noexcept
    : AiBlackboardKeyData() {
    *this = ::std::move(from);
  }

  inline AiBlackboardKeyData(::google::protobuf::Arena* arena, const AiBlackboardKeyData& from)
    : AiBlackboardKeyData(arena) {
    MergeFrom(from);
  }
  inline AiBlackboardKeyData& operator=(const AiBlackboardKeyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiBlackboardKeyData& operator=(AiBlackboardKeyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiBlackboardKeyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiBlackboardKeyData* internal_default_instance() {
    return reinterpret_cast<const AiBlackboardKeyData*>(
               &_AiBlackboardKeyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AiBlackboardKeyData& a, AiBlackboardKeyData& b) {
    a.Swap(&b);
  }
  inline void Swap(AiBlackboardKeyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiBlackboardKeyData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiBlackboardKeyData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiBlackboardKeyData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiBlackboardKeyData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiBlackboardKeyData& from) {
    AiBlackboardKeyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiBlackboardKeyData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiBlackboardKeyData";
  }
  protected:
  explicit AiBlackboardKeyData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiBlackboardKeyData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiBlackboardKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiBlackboardKey) */ {
 public:
  inline AiBlackboardKey() : AiBlackboardKey(nullptr) {}
  ~AiBlackboardKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiBlackboardKey(::google::protobuf::internal::ConstantInitialized);

  AiBlackboardKey(const AiBlackboardKey& from);
  AiBlackboardKey(AiBlackboardKey&& from) noexcept
    : AiBlackboardKey() {
    *this = ::std::move(from);
  }

  inline AiBlackboardKey(::google::protobuf::Arena* arena, const AiBlackboardKey& from)
    : AiBlackboardKey(arena) {
    MergeFrom(from);
  }
  inline AiBlackboardKey& operator=(const AiBlackboardKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiBlackboardKey& operator=(AiBlackboardKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiBlackboardKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiBlackboardKey* internal_default_instance() {
    return reinterpret_cast<const AiBlackboardKey*>(
               &_AiBlackboardKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AiBlackboardKey& a, AiBlackboardKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AiBlackboardKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiBlackboardKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiBlackboardKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiBlackboardKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiBlackboardKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiBlackboardKey& from) {
    AiBlackboardKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiBlackboardKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiBlackboardKey";
  }
  protected:
  explicit AiBlackboardKey(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescFieldNumber = 2,
    kTypeClassNameFieldNumber = 5,
    kIsStaticFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string desc = 2;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // string type_class_name = 5;
  void clear_type_class_name() ;
  const std::string& type_class_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type_class_name(Arg_&& arg, Args_... args);
  std::string* mutable_type_class_name();
  PROTOBUF_NODISCARD std::string* release_type_class_name();
  void set_allocated_type_class_name(std::string* ptr);

  private:
  const std::string& _internal_type_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_class_name(
      const std::string& value);
  std::string* _internal_mutable_type_class_name();

  public:
  // bool is_static = 3;
  void clear_is_static() ;
  bool is_static() const;
  void set_is_static(bool value);

  private:
  bool _internal_is_static() const;
  void _internal_set_is_static(bool value);

  public:
  // .cfg.AiEKeyType type = 4;
  void clear_type() ;
  ::cfg::AiEKeyType type() const;
  void set_type(::cfg::AiEKeyType value);

  private:
  ::cfg::AiEKeyType _internal_type() const;
  void _internal_set_type(::cfg::AiEKeyType value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiBlackboardKey)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      51, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr type_class_name_;
    bool is_static_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestString final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestString) */ {
 public:
  inline TestTestString() : TestTestString(nullptr) {}
  ~TestTestString() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestString(::google::protobuf::internal::ConstantInitialized);

  TestTestString(const TestTestString& from);
  TestTestString(TestTestString&& from) noexcept
    : TestTestString() {
    *this = ::std::move(from);
  }

  inline TestTestString(::google::protobuf::Arena* arena, const TestTestString& from)
    : TestTestString(arena) {
    MergeFrom(from);
  }
  inline TestTestString& operator=(const TestTestString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestString& operator=(TestTestString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestString* internal_default_instance() {
    return reinterpret_cast<const TestTestString*>(
               &_TestTestString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(TestTestString& a, TestTestString& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestString* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestString* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestString>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestString& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestString& from) {
    TestTestString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestString* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestString";
  }
  protected:
  explicit TestTestString(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kS1FieldNumber = 2,
    kS2FieldNumber = 3,
    kCs1FieldNumber = 4,
    kCs2FieldNumber = 5,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string s1 = 2;
  void clear_s1() ;
  const std::string& s1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s1(Arg_&& arg, Args_... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* ptr);

  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(
      const std::string& value);
  std::string* _internal_mutable_s1();

  public:
  // string s2 = 3;
  void clear_s2() ;
  const std::string& s2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s2(Arg_&& arg, Args_... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* ptr);

  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(
      const std::string& value);
  std::string* _internal_mutable_s2();

  public:
  // .cfg.TestCompactString cs1 = 4;
  bool has_cs1() const;
  void clear_cs1() ;
  const ::cfg::TestCompactString& cs1() const;
  PROTOBUF_NODISCARD ::cfg::TestCompactString* release_cs1();
  ::cfg::TestCompactString* mutable_cs1();
  void set_allocated_cs1(::cfg::TestCompactString* value);
  void unsafe_arena_set_allocated_cs1(::cfg::TestCompactString* value);
  ::cfg::TestCompactString* unsafe_arena_release_cs1();

  private:
  const ::cfg::TestCompactString& _internal_cs1() const;
  ::cfg::TestCompactString* _internal_mutable_cs1();

  public:
  // .cfg.TestCompactString cs2 = 5;
  bool has_cs2() const;
  void clear_cs2() ;
  const ::cfg::TestCompactString& cs2() const;
  PROTOBUF_NODISCARD ::cfg::TestCompactString* release_cs2();
  ::cfg::TestCompactString* mutable_cs2();
  void set_allocated_cs2(::cfg::TestCompactString* value);
  void unsafe_arena_set_allocated_cs2(::cfg::TestCompactString* value);
  ::cfg::TestCompactString* unsafe_arena_release_cs2();

  private:
  const ::cfg::TestCompactString& _internal_cs2() const;
  ::cfg::TestCompactString* _internal_mutable_cs2();

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestString)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      33, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr s1_;
    ::google::protobuf::internal::ArenaStringPtr s2_;
    ::cfg::TestCompactString* cs1_;
    ::cfg::TestCompactString* cs2_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestSize final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestSize) */ {
 public:
  inline TestTestSize() : TestTestSize(nullptr) {}
  ~TestTestSize() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestSize(::google::protobuf::internal::ConstantInitialized);

  TestTestSize(const TestTestSize& from);
  TestTestSize(TestTestSize&& from) noexcept
    : TestTestSize() {
    *this = ::std::move(from);
  }

  inline TestTestSize(::google::protobuf::Arena* arena, const TestTestSize& from)
    : TestTestSize(arena) {
    MergeFrom(from);
  }
  inline TestTestSize& operator=(const TestTestSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestSize& operator=(TestTestSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestSize* internal_default_instance() {
    return reinterpret_cast<const TestTestSize*>(
               &_TestTestSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(TestTestSize& a, TestTestSize& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestSize* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestSize* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestSize>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestSize& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestSize& from) {
    TestTestSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestSize* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestSize";
  }
  protected:
  explicit TestTestSize(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 2,
    kX2FieldNumber = 3,
    kX3FieldNumber = 4,
    kX4FieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // repeated int32 x1 = 2 [packed = true];
  int x1_size() const;
  private:
  int _internal_x1_size() const;

  public:
  void clear_x1() ;
  ::int32_t x1(int index) const;
  void set_x1(int index, ::int32_t value);
  void add_x1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& x1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_x1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_x1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_x1();

  public:
  // repeated int32 x2 = 3 [packed = true];
  int x2_size() const;
  private:
  int _internal_x2_size() const;

  public:
  void clear_x2() ;
  ::int32_t x2(int index) const;
  void set_x2(int index, ::int32_t value);
  void add_x2(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& x2() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_x2();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_x2() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_x2();

  public:
  // repeated int32 x3 = 4 [packed = true];
  int x3_size() const;
  private:
  int _internal_x3_size() const;

  public:
  void clear_x3() ;
  ::int32_t x3(int index) const;
  void set_x3(int index, ::int32_t value);
  void add_x3(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& x3() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_x3();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_x3() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_x3();

  public:
  // map<int32, int32> x4 = 5;
  int x4_size() const;
  private:
  int _internal_x4_size() const;

  public:
  void clear_x4() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& x4() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_x4();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_x4() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_x4();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestSize)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> x1_;
    mutable ::google::protobuf::internal::CachedSize _x1_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> x2_;
    mutable ::google::protobuf::internal::CachedSize _x2_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> x3_;
    mutable ::google::protobuf::internal::CachedSize _x3_cached_byte_size_;
    ::google::protobuf::internal::MapField<TestTestSize_X4Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        x4_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestScriptableObject final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestScriptableObject) */ {
 public:
  inline TestTestScriptableObject() : TestTestScriptableObject(nullptr) {}
  ~TestTestScriptableObject() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestScriptableObject(::google::protobuf::internal::ConstantInitialized);

  TestTestScriptableObject(const TestTestScriptableObject& from);
  TestTestScriptableObject(TestTestScriptableObject&& from) noexcept
    : TestTestScriptableObject() {
    *this = ::std::move(from);
  }

  inline TestTestScriptableObject(::google::protobuf::Arena* arena, const TestTestScriptableObject& from)
    : TestTestScriptableObject(arena) {
    MergeFrom(from);
  }
  inline TestTestScriptableObject& operator=(const TestTestScriptableObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestScriptableObject& operator=(TestTestScriptableObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestScriptableObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestScriptableObject* internal_default_instance() {
    return reinterpret_cast<const TestTestScriptableObject*>(
               &_TestTestScriptableObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(TestTestScriptableObject& a, TestTestScriptableObject& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestScriptableObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestScriptableObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestScriptableObject* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestScriptableObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestScriptableObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestScriptableObject& from) {
    TestTestScriptableObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestScriptableObject* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestScriptableObject";
  }
  protected:
  explicit TestTestScriptableObject(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescFieldNumber = 2,
    kV2FieldNumber = 5,
    kV3FieldNumber = 6,
    kV4FieldNumber = 7,
    kIdFieldNumber = 1,
    kRateFieldNumber = 3,
    kNumFieldNumber = 4,
  };
  // string desc = 2;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // .cfg.vec2 v2 = 5;
  bool has_v2() const;
  void clear_v2() ;
  const ::cfg::vec2& v2() const;
  PROTOBUF_NODISCARD ::cfg::vec2* release_v2();
  ::cfg::vec2* mutable_v2();
  void set_allocated_v2(::cfg::vec2* value);
  void unsafe_arena_set_allocated_v2(::cfg::vec2* value);
  ::cfg::vec2* unsafe_arena_release_v2();

  private:
  const ::cfg::vec2& _internal_v2() const;
  ::cfg::vec2* _internal_mutable_v2();

  public:
  // .cfg.vec3 v3 = 6;
  bool has_v3() const;
  void clear_v3() ;
  const ::cfg::vec3& v3() const;
  PROTOBUF_NODISCARD ::cfg::vec3* release_v3();
  ::cfg::vec3* mutable_v3();
  void set_allocated_v3(::cfg::vec3* value);
  void unsafe_arena_set_allocated_v3(::cfg::vec3* value);
  ::cfg::vec3* unsafe_arena_release_v3();

  private:
  const ::cfg::vec3& _internal_v3() const;
  ::cfg::vec3* _internal_mutable_v3();

  public:
  // .cfg.vec4 v4 = 7;
  bool has_v4() const;
  void clear_v4() ;
  const ::cfg::vec4& v4() const;
  PROTOBUF_NODISCARD ::cfg::vec4* release_v4();
  ::cfg::vec4* mutable_v4();
  void set_allocated_v4(::cfg::vec4* value);
  void unsafe_arena_set_allocated_v4(::cfg::vec4* value);
  ::cfg::vec4* unsafe_arena_release_v4();

  private:
  const ::cfg::vec4& _internal_v4() const;
  ::cfg::vec4* _internal_mutable_v4();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // float rate = 3;
  void clear_rate() ;
  float rate() const;
  void set_rate(float value);

  private:
  float _internal_rate() const;
  void _internal_set_rate(float value);

  public:
  // int32 num = 4;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestScriptableObject)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      41, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::cfg::vec2* v2_;
    ::cfg::vec3* v3_;
    ::cfg::vec4* v4_;
    ::int32_t id_;
    float rate_;
    ::int32_t num_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestRow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestRow) */ {
 public:
  inline TestTestRow() : TestTestRow(nullptr) {}
  ~TestTestRow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestRow(::google::protobuf::internal::ConstantInitialized);

  TestTestRow(const TestTestRow& from);
  TestTestRow(TestTestRow&& from) noexcept
    : TestTestRow() {
    *this = ::std::move(from);
  }

  inline TestTestRow(::google::protobuf::Arena* arena, const TestTestRow& from)
    : TestTestRow(arena) {
    MergeFrom(from);
  }
  inline TestTestRow& operator=(const TestTestRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestRow& operator=(TestTestRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestRow* internal_default_instance() {
    return reinterpret_cast<const TestTestRow*>(
               &_TestTestRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(TestTestRow& a, TestTestRow& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestRow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestRow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestRow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestRow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestRow& from) {
    TestTestRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestRow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestRow";
  }
  protected:
  explicit TestTestRow(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBFieldNumber = 5,
    kZFieldNumber = 3,
    kAFieldNumber = 4,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // repeated int32 b = 5 [packed = true];
  int b_size() const;
  private:
  int _internal_b_size() const;

  public:
  void clear_b() ;
  ::int32_t b(int index) const;
  void set_b(int index, ::int32_t value);
  void add_b(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& b() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_b();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_b() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_b();

  public:
  // string z = 3;
  void clear_z() ;
  const std::string& z() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_z(Arg_&& arg, Args_... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* ptr);

  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(
      const std::string& value);
  std::string* _internal_mutable_z();

  public:
  // .cfg.TestTest3 a = 4;
  bool has_a() const;
  void clear_a() ;
  const ::cfg::TestTest3& a() const;
  PROTOBUF_NODISCARD ::cfg::TestTest3* release_a();
  ::cfg::TestTest3* mutable_a();
  void set_allocated_a(::cfg::TestTest3* value);
  void unsafe_arena_set_allocated_a(::cfg::TestTest3* value);
  ::cfg::TestTest3* unsafe_arena_release_a();

  private:
  const ::cfg::TestTest3& _internal_a() const;
  ::cfg::TestTest3* _internal_mutable_a();

  public:
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // bool y = 2;
  void clear_y() ;
  bool y() const;
  void set_y(bool value);

  private:
  bool _internal_y() const;
  void _internal_set_y(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestRow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      25, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> b_;
    mutable ::google::protobuf::internal::CachedSize _b_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr z_;
    ::cfg::TestTest3* a_;
    ::int32_t x_;
    bool y_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestMultiColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestMultiColumn) */ {
 public:
  inline TestTestMultiColumn() : TestTestMultiColumn(nullptr) {}
  ~TestTestMultiColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestMultiColumn(::google::protobuf::internal::ConstantInitialized);

  TestTestMultiColumn(const TestTestMultiColumn& from);
  TestTestMultiColumn(TestTestMultiColumn&& from) noexcept
    : TestTestMultiColumn() {
    *this = ::std::move(from);
  }

  inline TestTestMultiColumn(::google::protobuf::Arena* arena, const TestTestMultiColumn& from)
    : TestTestMultiColumn(arena) {
    MergeFrom(from);
  }
  inline TestTestMultiColumn& operator=(const TestTestMultiColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestMultiColumn& operator=(TestTestMultiColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestMultiColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestMultiColumn* internal_default_instance() {
    return reinterpret_cast<const TestTestMultiColumn*>(
               &_TestTestMultiColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(TestTestMultiColumn& a, TestTestMultiColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestMultiColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestMultiColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestMultiColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestMultiColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestMultiColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestMultiColumn& from) {
    TestTestMultiColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestMultiColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestMultiColumn";
  }
  protected:
  explicit TestTestMultiColumn(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFieldNumber = 2,
    kBFieldNumber = 3,
    kCFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // .cfg.TestFoo a = 2;
  bool has_a() const;
  void clear_a() ;
  const ::cfg::TestFoo& a() const;
  PROTOBUF_NODISCARD ::cfg::TestFoo* release_a();
  ::cfg::TestFoo* mutable_a();
  void set_allocated_a(::cfg::TestFoo* value);
  void unsafe_arena_set_allocated_a(::cfg::TestFoo* value);
  ::cfg::TestFoo* unsafe_arena_release_a();

  private:
  const ::cfg::TestFoo& _internal_a() const;
  ::cfg::TestFoo* _internal_mutable_a();

  public:
  // .cfg.TestFoo b = 3;
  bool has_b() const;
  void clear_b() ;
  const ::cfg::TestFoo& b() const;
  PROTOBUF_NODISCARD ::cfg::TestFoo* release_b();
  ::cfg::TestFoo* mutable_b();
  void set_allocated_b(::cfg::TestFoo* value);
  void unsafe_arena_set_allocated_b(::cfg::TestFoo* value);
  ::cfg::TestFoo* unsafe_arena_release_b();

  private:
  const ::cfg::TestFoo& _internal_b() const;
  ::cfg::TestFoo* _internal_mutable_b();

  public:
  // .cfg.TestFoo c = 4;
  bool has_c() const;
  void clear_c() ;
  const ::cfg::TestFoo& c() const;
  PROTOBUF_NODISCARD ::cfg::TestFoo* release_c();
  ::cfg::TestFoo* mutable_c();
  void set_allocated_c(::cfg::TestFoo* value);
  void unsafe_arena_set_allocated_c(::cfg::TestFoo* value);
  ::cfg::TestFoo* unsafe_arena_release_c();

  private:
  const ::cfg::TestFoo& _internal_c() const;
  ::cfg::TestFoo* _internal_mutable_c();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestMultiColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::cfg::TestFoo* a_;
    ::cfg::TestFoo* b_;
    ::cfg::TestFoo* c_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestMapper final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestMapper) */ {
 public:
  inline TestTestMapper() : TestTestMapper(nullptr) {}
  ~TestTestMapper() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestMapper(::google::protobuf::internal::ConstantInitialized);

  TestTestMapper(const TestTestMapper& from);
  TestTestMapper(TestTestMapper&& from) noexcept
    : TestTestMapper() {
    *this = ::std::move(from);
  }

  inline TestTestMapper(::google::protobuf::Arena* arena, const TestTestMapper& from)
    : TestTestMapper(arena) {
    MergeFrom(from);
  }
  inline TestTestMapper& operator=(const TestTestMapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestMapper& operator=(TestTestMapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestMapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestMapper* internal_default_instance() {
    return reinterpret_cast<const TestTestMapper*>(
               &_TestTestMapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(TestTestMapper& a, TestTestMapper& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestMapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestMapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestMapper* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestMapper>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestMapper& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestMapper& from) {
    TestTestMapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestMapper* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestMapper";
  }
  protected:
  explicit TestTestMapper(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV2FieldNumber = 3,
    kIdFieldNumber = 1,
    kAudioTypeFieldNumber = 2,
  };
  // .cfg.vec2 v2 = 3;
  bool has_v2() const;
  void clear_v2() ;
  const ::cfg::vec2& v2() const;
  PROTOBUF_NODISCARD ::cfg::vec2* release_v2();
  ::cfg::vec2* mutable_v2();
  void set_allocated_v2(::cfg::vec2* value);
  void unsafe_arena_set_allocated_v2(::cfg::vec2* value);
  ::cfg::vec2* unsafe_arena_release_v2();

  private:
  const ::cfg::vec2& _internal_v2() const;
  ::cfg::vec2* _internal_mutable_v2();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AudioType audio_type = 2;
  void clear_audio_type() ;
  ::cfg::AudioType audio_type() const;
  void set_audio_type(::cfg::AudioType value);

  private:
  ::cfg::AudioType _internal_audio_type() const;
  void _internal_set_audio_type(::cfg::AudioType value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestMapper)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::cfg::vec2* v2_;
    ::int32_t id_;
    int audio_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestMap final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestMap) */ {
 public:
  inline TestTestMap() : TestTestMap(nullptr) {}
  ~TestTestMap() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestMap(::google::protobuf::internal::ConstantInitialized);

  TestTestMap(const TestTestMap& from);
  TestTestMap(TestTestMap&& from) noexcept
    : TestTestMap() {
    *this = ::std::move(from);
  }

  inline TestTestMap(::google::protobuf::Arena* arena, const TestTestMap& from)
    : TestTestMap(arena) {
    MergeFrom(from);
  }
  inline TestTestMap& operator=(const TestTestMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestMap& operator=(TestTestMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestMap* internal_default_instance() {
    return reinterpret_cast<const TestTestMap*>(
               &_TestTestMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(TestTestMap& a, TestTestMap& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestMap* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestMap* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestMap>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestMap& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestMap& from) {
    TestTestMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestMap* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestMap";
  }
  protected:
  explicit TestTestMap(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 2,
    kX2FieldNumber = 3,
    kX3FieldNumber = 4,
    kX4FieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // map<int32, int32> x1 = 2;
  int x1_size() const;
  private:
  int _internal_x1_size() const;

  public:
  void clear_x1() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& x1() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_x1();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_x1() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_x1();

  public:
  // map<int64, int32> x2 = 3;
  int x2_size() const;
  private:
  int _internal_x2_size() const;

  public:
  void clear_x2() ;
  const ::google::protobuf::Map<::int64_t, ::int32_t>& x2() const;
  ::google::protobuf::Map<::int64_t, ::int32_t>* mutable_x2();

  private:
  const ::google::protobuf::Map<::int64_t, ::int32_t>& _internal_x2() const;
  ::google::protobuf::Map<::int64_t, ::int32_t>* _internal_mutable_x2();

  public:
  // map<string, int32> x3 = 4;
  int x3_size() const;
  private:
  int _internal_x3_size() const;

  public:
  void clear_x3() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& x3() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_x3();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_x3() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_x3();

  public:
  // map<int32, int32> x4 = 5;
  int x4_size() const;
  private:
  int _internal_x4_size() const;

  public:
  void clear_x4() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& x4() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_x4();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_x4() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_x4();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestMap)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 4,
      26, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::MapField<TestTestMap_X1Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        x1_;
    ::google::protobuf::internal::MapField<TestTestMap_X2Entry_DoNotUse, ::int64_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        x2_;
    ::google::protobuf::internal::MapField<TestTestMap_X3Entry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        x3_;
    ::google::protobuf::internal::MapField<TestTestMap_X4Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        x4_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestIndex final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestIndex) */ {
 public:
  inline TestTestIndex() : TestTestIndex(nullptr) {}
  ~TestTestIndex() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestIndex(::google::protobuf::internal::ConstantInitialized);

  TestTestIndex(const TestTestIndex& from);
  TestTestIndex(TestTestIndex&& from) noexcept
    : TestTestIndex() {
    *this = ::std::move(from);
  }

  inline TestTestIndex(::google::protobuf::Arena* arena, const TestTestIndex& from)
    : TestTestIndex(arena) {
    MergeFrom(from);
  }
  inline TestTestIndex& operator=(const TestTestIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestIndex& operator=(TestTestIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestIndex* internal_default_instance() {
    return reinterpret_cast<const TestTestIndex*>(
               &_TestTestIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(TestTestIndex& a, TestTestIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestIndex* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestIndex* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestIndex>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestIndex& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestIndex& from) {
    TestTestIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestIndex* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestIndex";
  }
  protected:
  explicit TestTestIndex(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .cfg.TestDemoType1 eles = 2 [packed = false];
  int eles_size() const;
  private:
  int _internal_eles_size() const;

  public:
  void clear_eles() ;
  ::cfg::TestDemoType1* mutable_eles(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType1 >*
      mutable_eles();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType1>& _internal_eles() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType1>* _internal_mutable_eles();
  public:
  const ::cfg::TestDemoType1& eles(int index) const;
  ::cfg::TestDemoType1* add_eles();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType1 >&
      eles() const;
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestIndex)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType1 > eles_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestSet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestSet) */ {
 public:
  inline TestTbTestSet() : TestTbTestSet(nullptr) {}
  ~TestTbTestSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestSet(::google::protobuf::internal::ConstantInitialized);

  TestTbTestSet(const TestTbTestSet& from);
  TestTbTestSet(TestTbTestSet&& from) noexcept
    : TestTbTestSet() {
    *this = ::std::move(from);
  }

  inline TestTbTestSet(::google::protobuf::Arena* arena, const TestTbTestSet& from)
    : TestTbTestSet(arena) {
    MergeFrom(from);
  }
  inline TestTbTestSet& operator=(const TestTbTestSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestSet& operator=(TestTbTestSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestSet* internal_default_instance() {
    return reinterpret_cast<const TestTbTestSet*>(
               &_TestTbTestSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(TestTbTestSet& a, TestTbTestSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestSet& from) {
    TestTbTestSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestSet* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestSet";
  }
  protected:
  explicit TestTbTestSet(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestSet data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestSet* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestSet >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestSet>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestSet>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestSet& data_list(int index) const;
  ::cfg::TestTestSet* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestSet >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestSet)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestSet > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestGlobal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestGlobal) */ {
 public:
  inline TestTbTestGlobal() : TestTbTestGlobal(nullptr) {}
  ~TestTbTestGlobal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestGlobal(::google::protobuf::internal::ConstantInitialized);

  TestTbTestGlobal(const TestTbTestGlobal& from);
  TestTbTestGlobal(TestTbTestGlobal&& from) noexcept
    : TestTbTestGlobal() {
    *this = ::std::move(from);
  }

  inline TestTbTestGlobal(::google::protobuf::Arena* arena, const TestTbTestGlobal& from)
    : TestTbTestGlobal(arena) {
    MergeFrom(from);
  }
  inline TestTbTestGlobal& operator=(const TestTbTestGlobal& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestGlobal& operator=(TestTbTestGlobal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestGlobal& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestGlobal* internal_default_instance() {
    return reinterpret_cast<const TestTbTestGlobal*>(
               &_TestTbTestGlobal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(TestTbTestGlobal& a, TestTbTestGlobal& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestGlobal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestGlobal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestGlobal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestGlobal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestGlobal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestGlobal& from) {
    TestTbTestGlobal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestGlobal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestGlobal";
  }
  protected:
  explicit TestTbTestGlobal(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestGlobal data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestGlobal* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestGlobal >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestGlobal>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestGlobal>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestGlobal& data_list(int index) const;
  ::cfg::TestTestGlobal* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestGlobal >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestGlobal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestGlobal > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestBeRef2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestBeRef2) */ {
 public:
  inline TestTbTestBeRef2() : TestTbTestBeRef2(nullptr) {}
  ~TestTbTestBeRef2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestBeRef2(::google::protobuf::internal::ConstantInitialized);

  TestTbTestBeRef2(const TestTbTestBeRef2& from);
  TestTbTestBeRef2(TestTbTestBeRef2&& from) noexcept
    : TestTbTestBeRef2() {
    *this = ::std::move(from);
  }

  inline TestTbTestBeRef2(::google::protobuf::Arena* arena, const TestTbTestBeRef2& from)
    : TestTbTestBeRef2(arena) {
    MergeFrom(from);
  }
  inline TestTbTestBeRef2& operator=(const TestTbTestBeRef2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestBeRef2& operator=(TestTbTestBeRef2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestBeRef2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestBeRef2* internal_default_instance() {
    return reinterpret_cast<const TestTbTestBeRef2*>(
               &_TestTbTestBeRef2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(TestTbTestBeRef2& a, TestTbTestBeRef2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestBeRef2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestBeRef2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestBeRef2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestBeRef2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestBeRef2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestBeRef2& from) {
    TestTbTestBeRef2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestBeRef2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestBeRef2";
  }
  protected:
  explicit TestTbTestBeRef2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestBeRef data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestBeRef* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestBeRef >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestBeRef& data_list(int index) const;
  ::cfg::TestTestBeRef* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestBeRef >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestBeRef2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestBeRef > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestBeRef final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestBeRef) */ {
 public:
  inline TestTbTestBeRef() : TestTbTestBeRef(nullptr) {}
  ~TestTbTestBeRef() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestBeRef(::google::protobuf::internal::ConstantInitialized);

  TestTbTestBeRef(const TestTbTestBeRef& from);
  TestTbTestBeRef(TestTbTestBeRef&& from) noexcept
    : TestTbTestBeRef() {
    *this = ::std::move(from);
  }

  inline TestTbTestBeRef(::google::protobuf::Arena* arena, const TestTbTestBeRef& from)
    : TestTbTestBeRef(arena) {
    MergeFrom(from);
  }
  inline TestTbTestBeRef& operator=(const TestTbTestBeRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestBeRef& operator=(TestTbTestBeRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestBeRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestBeRef* internal_default_instance() {
    return reinterpret_cast<const TestTbTestBeRef*>(
               &_TestTbTestBeRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(TestTbTestBeRef& a, TestTbTestBeRef& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestBeRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestBeRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestBeRef* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestBeRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestBeRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestBeRef& from) {
    TestTbTestBeRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestBeRef* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestBeRef";
  }
  protected:
  explicit TestTbTestBeRef(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestBeRef data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestBeRef* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestBeRef >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestBeRef& data_list(int index) const;
  ::cfg::TestTestBeRef* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestBeRef >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestBeRef)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestBeRef > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbNotIndexList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbNotIndexList) */ {
 public:
  inline TestTbNotIndexList() : TestTbNotIndexList(nullptr) {}
  ~TestTbNotIndexList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbNotIndexList(::google::protobuf::internal::ConstantInitialized);

  TestTbNotIndexList(const TestTbNotIndexList& from);
  TestTbNotIndexList(TestTbNotIndexList&& from) noexcept
    : TestTbNotIndexList() {
    *this = ::std::move(from);
  }

  inline TestTbNotIndexList(::google::protobuf::Arena* arena, const TestTbNotIndexList& from)
    : TestTbNotIndexList(arena) {
    MergeFrom(from);
  }
  inline TestTbNotIndexList& operator=(const TestTbNotIndexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbNotIndexList& operator=(TestTbNotIndexList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbNotIndexList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbNotIndexList* internal_default_instance() {
    return reinterpret_cast<const TestTbNotIndexList*>(
               &_TestTbNotIndexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(TestTbNotIndexList& a, TestTbNotIndexList& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbNotIndexList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbNotIndexList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbNotIndexList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbNotIndexList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbNotIndexList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbNotIndexList& from) {
    TestTbNotIndexList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbNotIndexList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbNotIndexList";
  }
  protected:
  explicit TestTbNotIndexList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestNotIndexList data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestNotIndexList* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestNotIndexList >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestNotIndexList>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestNotIndexList>* _internal_mutable_data_list();
  public:
  const ::cfg::TestNotIndexList& data_list(int index) const;
  ::cfg::TestNotIndexList* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestNotIndexList >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbNotIndexList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestNotIndexList > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbMultiUnionIndexList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbMultiUnionIndexList) */ {
 public:
  inline TestTbMultiUnionIndexList() : TestTbMultiUnionIndexList(nullptr) {}
  ~TestTbMultiUnionIndexList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbMultiUnionIndexList(::google::protobuf::internal::ConstantInitialized);

  TestTbMultiUnionIndexList(const TestTbMultiUnionIndexList& from);
  TestTbMultiUnionIndexList(TestTbMultiUnionIndexList&& from) noexcept
    : TestTbMultiUnionIndexList() {
    *this = ::std::move(from);
  }

  inline TestTbMultiUnionIndexList(::google::protobuf::Arena* arena, const TestTbMultiUnionIndexList& from)
    : TestTbMultiUnionIndexList(arena) {
    MergeFrom(from);
  }
  inline TestTbMultiUnionIndexList& operator=(const TestTbMultiUnionIndexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbMultiUnionIndexList& operator=(TestTbMultiUnionIndexList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbMultiUnionIndexList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbMultiUnionIndexList* internal_default_instance() {
    return reinterpret_cast<const TestTbMultiUnionIndexList*>(
               &_TestTbMultiUnionIndexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(TestTbMultiUnionIndexList& a, TestTbMultiUnionIndexList& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbMultiUnionIndexList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbMultiUnionIndexList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbMultiUnionIndexList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbMultiUnionIndexList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbMultiUnionIndexList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbMultiUnionIndexList& from) {
    TestTbMultiUnionIndexList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbMultiUnionIndexList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbMultiUnionIndexList";
  }
  protected:
  explicit TestTbMultiUnionIndexList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestMultiUnionIndexList data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestMultiUnionIndexList* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiUnionIndexList >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiUnionIndexList>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiUnionIndexList>* _internal_mutable_data_list();
  public:
  const ::cfg::TestMultiUnionIndexList& data_list(int index) const;
  ::cfg::TestMultiUnionIndexList* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiUnionIndexList >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbMultiUnionIndexList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiUnionIndexList > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbMultiIndexList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbMultiIndexList) */ {
 public:
  inline TestTbMultiIndexList() : TestTbMultiIndexList(nullptr) {}
  ~TestTbMultiIndexList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbMultiIndexList(::google::protobuf::internal::ConstantInitialized);

  TestTbMultiIndexList(const TestTbMultiIndexList& from);
  TestTbMultiIndexList(TestTbMultiIndexList&& from) noexcept
    : TestTbMultiIndexList() {
    *this = ::std::move(from);
  }

  inline TestTbMultiIndexList(::google::protobuf::Arena* arena, const TestTbMultiIndexList& from)
    : TestTbMultiIndexList(arena) {
    MergeFrom(from);
  }
  inline TestTbMultiIndexList& operator=(const TestTbMultiIndexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbMultiIndexList& operator=(TestTbMultiIndexList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbMultiIndexList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbMultiIndexList* internal_default_instance() {
    return reinterpret_cast<const TestTbMultiIndexList*>(
               &_TestTbMultiIndexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(TestTbMultiIndexList& a, TestTbMultiIndexList& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbMultiIndexList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbMultiIndexList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbMultiIndexList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbMultiIndexList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbMultiIndexList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbMultiIndexList& from) {
    TestTbMultiIndexList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbMultiIndexList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbMultiIndexList";
  }
  protected:
  explicit TestTbMultiIndexList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestMultiIndexList data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestMultiIndexList* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiIndexList >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiIndexList>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiIndexList>* _internal_mutable_data_list();
  public:
  const ::cfg::TestMultiIndexList& data_list(int index) const;
  ::cfg::TestMultiIndexList* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiIndexList >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbMultiIndexList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiIndexList > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbDetectCsvEncoding final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbDetectCsvEncoding) */ {
 public:
  inline TestTbDetectCsvEncoding() : TestTbDetectCsvEncoding(nullptr) {}
  ~TestTbDetectCsvEncoding() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbDetectCsvEncoding(::google::protobuf::internal::ConstantInitialized);

  TestTbDetectCsvEncoding(const TestTbDetectCsvEncoding& from);
  TestTbDetectCsvEncoding(TestTbDetectCsvEncoding&& from) noexcept
    : TestTbDetectCsvEncoding() {
    *this = ::std::move(from);
  }

  inline TestTbDetectCsvEncoding(::google::protobuf::Arena* arena, const TestTbDetectCsvEncoding& from)
    : TestTbDetectCsvEncoding(arena) {
    MergeFrom(from);
  }
  inline TestTbDetectCsvEncoding& operator=(const TestTbDetectCsvEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbDetectCsvEncoding& operator=(TestTbDetectCsvEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbDetectCsvEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbDetectCsvEncoding* internal_default_instance() {
    return reinterpret_cast<const TestTbDetectCsvEncoding*>(
               &_TestTbDetectCsvEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(TestTbDetectCsvEncoding& a, TestTbDetectCsvEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbDetectCsvEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbDetectCsvEncoding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbDetectCsvEncoding* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbDetectCsvEncoding>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbDetectCsvEncoding& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbDetectCsvEncoding& from) {
    TestTbDetectCsvEncoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbDetectCsvEncoding* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbDetectCsvEncoding";
  }
  protected:
  explicit TestTbDetectCsvEncoding(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestDetectEncoding data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestDetectEncoding* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDetectEncoding >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDetectEncoding>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDetectEncoding>* _internal_mutable_data_list();
  public:
  const ::cfg::TestDetectEncoding& data_list(int index) const;
  ::cfg::TestDetectEncoding* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDetectEncoding >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbDetectCsvEncoding)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDetectEncoding > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbCompositeJsonTable3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbCompositeJsonTable3) */ {
 public:
  inline TestTbCompositeJsonTable3() : TestTbCompositeJsonTable3(nullptr) {}
  ~TestTbCompositeJsonTable3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbCompositeJsonTable3(::google::protobuf::internal::ConstantInitialized);

  TestTbCompositeJsonTable3(const TestTbCompositeJsonTable3& from);
  TestTbCompositeJsonTable3(TestTbCompositeJsonTable3&& from) noexcept
    : TestTbCompositeJsonTable3() {
    *this = ::std::move(from);
  }

  inline TestTbCompositeJsonTable3(::google::protobuf::Arena* arena, const TestTbCompositeJsonTable3& from)
    : TestTbCompositeJsonTable3(arena) {
    MergeFrom(from);
  }
  inline TestTbCompositeJsonTable3& operator=(const TestTbCompositeJsonTable3& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbCompositeJsonTable3& operator=(TestTbCompositeJsonTable3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbCompositeJsonTable3& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbCompositeJsonTable3* internal_default_instance() {
    return reinterpret_cast<const TestTbCompositeJsonTable3*>(
               &_TestTbCompositeJsonTable3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(TestTbCompositeJsonTable3& a, TestTbCompositeJsonTable3& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbCompositeJsonTable3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbCompositeJsonTable3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbCompositeJsonTable3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbCompositeJsonTable3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbCompositeJsonTable3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbCompositeJsonTable3& from) {
    TestTbCompositeJsonTable3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbCompositeJsonTable3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbCompositeJsonTable3";
  }
  protected:
  explicit TestTbCompositeJsonTable3(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestCompositeJsonTable3 data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestCompositeJsonTable3* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable3 >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable3>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable3>* _internal_mutable_data_list();
  public:
  const ::cfg::TestCompositeJsonTable3& data_list(int index) const;
  ::cfg::TestCompositeJsonTable3* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable3 >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbCompositeJsonTable3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable3 > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbCompositeJsonTable2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbCompositeJsonTable2) */ {
 public:
  inline TestTbCompositeJsonTable2() : TestTbCompositeJsonTable2(nullptr) {}
  ~TestTbCompositeJsonTable2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbCompositeJsonTable2(::google::protobuf::internal::ConstantInitialized);

  TestTbCompositeJsonTable2(const TestTbCompositeJsonTable2& from);
  TestTbCompositeJsonTable2(TestTbCompositeJsonTable2&& from) noexcept
    : TestTbCompositeJsonTable2() {
    *this = ::std::move(from);
  }

  inline TestTbCompositeJsonTable2(::google::protobuf::Arena* arena, const TestTbCompositeJsonTable2& from)
    : TestTbCompositeJsonTable2(arena) {
    MergeFrom(from);
  }
  inline TestTbCompositeJsonTable2& operator=(const TestTbCompositeJsonTable2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbCompositeJsonTable2& operator=(TestTbCompositeJsonTable2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbCompositeJsonTable2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbCompositeJsonTable2* internal_default_instance() {
    return reinterpret_cast<const TestTbCompositeJsonTable2*>(
               &_TestTbCompositeJsonTable2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(TestTbCompositeJsonTable2& a, TestTbCompositeJsonTable2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbCompositeJsonTable2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbCompositeJsonTable2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbCompositeJsonTable2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbCompositeJsonTable2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbCompositeJsonTable2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbCompositeJsonTable2& from) {
    TestTbCompositeJsonTable2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbCompositeJsonTable2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbCompositeJsonTable2";
  }
  protected:
  explicit TestTbCompositeJsonTable2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestCompositeJsonTable2 data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestCompositeJsonTable2* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable2 >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable2>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable2>* _internal_mutable_data_list();
  public:
  const ::cfg::TestCompositeJsonTable2& data_list(int index) const;
  ::cfg::TestCompositeJsonTable2* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable2 >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbCompositeJsonTable2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable2 > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbCompositeJsonTable1 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbCompositeJsonTable1) */ {
 public:
  inline TestTbCompositeJsonTable1() : TestTbCompositeJsonTable1(nullptr) {}
  ~TestTbCompositeJsonTable1() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbCompositeJsonTable1(::google::protobuf::internal::ConstantInitialized);

  TestTbCompositeJsonTable1(const TestTbCompositeJsonTable1& from);
  TestTbCompositeJsonTable1(TestTbCompositeJsonTable1&& from) noexcept
    : TestTbCompositeJsonTable1() {
    *this = ::std::move(from);
  }

  inline TestTbCompositeJsonTable1(::google::protobuf::Arena* arena, const TestTbCompositeJsonTable1& from)
    : TestTbCompositeJsonTable1(arena) {
    MergeFrom(from);
  }
  inline TestTbCompositeJsonTable1& operator=(const TestTbCompositeJsonTable1& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbCompositeJsonTable1& operator=(TestTbCompositeJsonTable1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbCompositeJsonTable1& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbCompositeJsonTable1* internal_default_instance() {
    return reinterpret_cast<const TestTbCompositeJsonTable1*>(
               &_TestTbCompositeJsonTable1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(TestTbCompositeJsonTable1& a, TestTbCompositeJsonTable1& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbCompositeJsonTable1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbCompositeJsonTable1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbCompositeJsonTable1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbCompositeJsonTable1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbCompositeJsonTable1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbCompositeJsonTable1& from) {
    TestTbCompositeJsonTable1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbCompositeJsonTable1* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbCompositeJsonTable1";
  }
  protected:
  explicit TestTbCompositeJsonTable1(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestCompositeJsonTable1 data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestCompositeJsonTable1* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable1 >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable1>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable1>* _internal_mutable_data_list();
  public:
  const ::cfg::TestCompositeJsonTable1& data_list(int index) const;
  ::cfg::TestCompositeJsonTable1* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable1 >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbCompositeJsonTable1)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestCompositeJsonTable1 > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestShape final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestShape) */ {
 public:
  inline TestShape() : TestShape(nullptr) {}
  ~TestShape() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestShape(::google::protobuf::internal::ConstantInitialized);

  TestShape(const TestShape& from);
  TestShape(TestShape&& from) noexcept
    : TestShape() {
    *this = ::std::move(from);
  }

  inline TestShape(::google::protobuf::Arena* arena, const TestShape& from)
    : TestShape(arena) {
    MergeFrom(from);
  }
  inline TestShape& operator=(const TestShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestShape& operator=(TestShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestShape& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kCircle = 1,
    kRectangle = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const TestShape* internal_default_instance() {
    return reinterpret_cast<const TestShape*>(
               &_TestShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(TestShape& a, TestShape& b) {
    a.Swap(&b);
  }
  inline void Swap(TestShape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestShape* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestShape* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestShape>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestShape& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestShape& from) {
    TestShape::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestShape* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestShape";
  }
  protected:
  explicit TestShape(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircleFieldNumber = 1,
    kRectangleFieldNumber = 2,
  };
  // .cfg.TestCircle Circle = 1;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;

  public:
  void clear_circle() ;
  const ::cfg::TestCircle& circle() const;
  PROTOBUF_NODISCARD ::cfg::TestCircle* release_circle();
  ::cfg::TestCircle* mutable_circle();
  void set_allocated_circle(::cfg::TestCircle* value);
  void unsafe_arena_set_allocated_circle(::cfg::TestCircle* value);
  ::cfg::TestCircle* unsafe_arena_release_circle();

  private:
  const ::cfg::TestCircle& _internal_circle() const;
  ::cfg::TestCircle* _internal_mutable_circle();

  public:
  // .cfg.Test2Rectangle Rectangle = 2;
  bool has_rectangle() const;
  private:
  bool _internal_has_rectangle() const;

  public:
  void clear_rectangle() ;
  const ::cfg::Test2Rectangle& rectangle() const;
  PROTOBUF_NODISCARD ::cfg::Test2Rectangle* release_rectangle();
  ::cfg::Test2Rectangle* mutable_rectangle();
  void set_allocated_rectangle(::cfg::Test2Rectangle* value);
  void unsafe_arena_set_allocated_rectangle(::cfg::Test2Rectangle* value);
  ::cfg::Test2Rectangle* unsafe_arena_release_rectangle();

  private:
  const ::cfg::Test2Rectangle& _internal_rectangle() const;
  ::cfg::Test2Rectangle* _internal_mutable_rectangle();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.TestShape)
 private:
  class _Internal;
  void set_has_circle();
  void set_has_rectangle();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::TestCircle* circle_;
      ::cfg::Test2Rectangle* rectangle_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestRefDynamicBase final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestRefDynamicBase) */ {
 public:
  inline TestRefDynamicBase() : TestRefDynamicBase(nullptr) {}
  ~TestRefDynamicBase() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestRefDynamicBase(::google::protobuf::internal::ConstantInitialized);

  TestRefDynamicBase(const TestRefDynamicBase& from);
  TestRefDynamicBase(TestRefDynamicBase&& from) noexcept
    : TestRefDynamicBase() {
    *this = ::std::move(from);
  }

  inline TestRefDynamicBase(::google::protobuf::Arena* arena, const TestRefDynamicBase& from)
    : TestRefDynamicBase(arena) {
    MergeFrom(from);
  }
  inline TestRefDynamicBase& operator=(const TestRefDynamicBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRefDynamicBase& operator=(TestRefDynamicBase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRefDynamicBase& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kRefBean = 1,
    VALUE_NOT_SET = 0,
  };

  static inline const TestRefDynamicBase* internal_default_instance() {
    return reinterpret_cast<const TestRefDynamicBase*>(
               &_TestRefDynamicBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(TestRefDynamicBase& a, TestRefDynamicBase& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRefDynamicBase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRefDynamicBase* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRefDynamicBase* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRefDynamicBase>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestRefDynamicBase& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestRefDynamicBase& from) {
    TestRefDynamicBase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRefDynamicBase* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestRefDynamicBase";
  }
  protected:
  explicit TestRefDynamicBase(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefBeanFieldNumber = 1,
  };
  // .cfg.TestRefBean RefBean = 1;
  bool has_refbean() const;
  private:
  bool _internal_has_refbean() const;

  public:
  void clear_refbean() ;
  const ::cfg::TestRefBean& refbean() const;
  PROTOBUF_NODISCARD ::cfg::TestRefBean* release_refbean();
  ::cfg::TestRefBean* mutable_refbean();
  void set_allocated_refbean(::cfg::TestRefBean* value);
  void unsafe_arena_set_allocated_refbean(::cfg::TestRefBean* value);
  ::cfg::TestRefBean* unsafe_arena_release_refbean();

  private:
  const ::cfg::TestRefBean& _internal_refbean() const;
  ::cfg::TestRefBean* _internal_mutable_refbean();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.TestRefDynamicBase)
 private:
  class _Internal;
  void set_has_refbean();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::TestRefBean* refbean_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiRowType3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestMultiRowType3) */ {
 public:
  inline TestMultiRowType3() : TestMultiRowType3(nullptr) {}
  ~TestMultiRowType3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowType3(::google::protobuf::internal::ConstantInitialized);

  TestMultiRowType3(const TestMultiRowType3& from);
  TestMultiRowType3(TestMultiRowType3&& from) noexcept
    : TestMultiRowType3() {
    *this = ::std::move(from);
  }

  inline TestMultiRowType3(::google::protobuf::Arena* arena, const TestMultiRowType3& from)
    : TestMultiRowType3(arena) {
    MergeFrom(from);
  }
  inline TestMultiRowType3& operator=(const TestMultiRowType3& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMultiRowType3& operator=(TestMultiRowType3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMultiRowType3& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMultiRowType3* internal_default_instance() {
    return reinterpret_cast<const TestMultiRowType3*>(
               &_TestMultiRowType3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(TestMultiRowType3& a, TestMultiRowType3& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMultiRowType3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMultiRowType3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMultiRowType3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMultiRowType3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMultiRowType3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestMultiRowType3& from) {
    TestMultiRowType3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiRowType3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestMultiRowType3";
  }
  protected:
  explicit TestMultiRowType3(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .cfg.TestMultiRowType1 items = 2 [packed = false];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::cfg::TestMultiRowType1* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* _internal_mutable_items();
  public:
  const ::cfg::TestMultiRowType1& items(int index) const;
  ::cfg::TestMultiRowType1* add_items();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >&
      items() const;
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestMultiRowType3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 > items_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiRowRecord_MultiRows6Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestMultiRowRecord_MultiRows6Entry_DoNotUse, 
    ::int32_t, ::cfg::TestMultiRowType2,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestMultiRowRecord_MultiRows6Entry_DoNotUse, 
    ::int32_t, ::cfg::TestMultiRowType2,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestMultiRowRecord_MultiRows6Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowRecord_MultiRows6Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestMultiRowRecord_MultiRows6Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestMultiRowRecord_MultiRows6Entry_DoNotUse& other);
  static const TestMultiRowRecord_MultiRows6Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestMultiRowRecord_MultiRows6Entry_DoNotUse*>(&_TestMultiRowRecord_MultiRows6Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestMultiRowRecord_MultiRows4Entry_DoNotUse final : public ::google::protobuf::internal::MapEntry<TestMultiRowRecord_MultiRows4Entry_DoNotUse, 
    ::int32_t, ::cfg::TestMultiRowType2,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::google::protobuf::internal::MapEntry<TestMultiRowRecord_MultiRows4Entry_DoNotUse, 
    ::int32_t, ::cfg::TestMultiRowType2,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TestMultiRowRecord_MultiRows4Entry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowRecord_MultiRows4Entry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TestMultiRowRecord_MultiRows4Entry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TestMultiRowRecord_MultiRows4Entry_DoNotUse& other);
  static const TestMultiRowRecord_MultiRows4Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestMultiRowRecord_MultiRows4Entry_DoNotUse*>(&_TestMultiRowRecord_MultiRows4Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class TestItemBase final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestItemBase) */ {
 public:
  inline TestItemBase() : TestItemBase(nullptr) {}
  ~TestItemBase() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestItemBase(::google::protobuf::internal::ConstantInitialized);

  TestItemBase(const TestItemBase& from);
  TestItemBase(TestItemBase&& from) noexcept
    : TestItemBase() {
    *this = ::std::move(from);
  }

  inline TestItemBase(::google::protobuf::Arena* arena, const TestItemBase& from)
    : TestItemBase(arena) {
    MergeFrom(from);
  }
  inline TestItemBase& operator=(const TestItemBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestItemBase& operator=(TestItemBase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestItemBase& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kItem = 1,
    kEquipment = 2,
    kDecorator = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const TestItemBase* internal_default_instance() {
    return reinterpret_cast<const TestItemBase*>(
               &_TestItemBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(TestItemBase& a, TestItemBase& b) {
    a.Swap(&b);
  }
  inline void Swap(TestItemBase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestItemBase* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestItemBase* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestItemBase>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestItemBase& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestItemBase& from) {
    TestItemBase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestItemBase* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestItemBase";
  }
  protected:
  explicit TestItemBase(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kEquipmentFieldNumber = 2,
    kDecoratorFieldNumber = 3,
  };
  // .cfg.TestItem Item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;

  public:
  void clear_item() ;
  const ::cfg::TestItem& item() const;
  PROTOBUF_NODISCARD ::cfg::TestItem* release_item();
  ::cfg::TestItem* mutable_item();
  void set_allocated_item(::cfg::TestItem* value);
  void unsafe_arena_set_allocated_item(::cfg::TestItem* value);
  ::cfg::TestItem* unsafe_arena_release_item();

  private:
  const ::cfg::TestItem& _internal_item() const;
  ::cfg::TestItem* _internal_mutable_item();

  public:
  // .cfg.TestEquipment Equipment = 2;
  bool has_equipment() const;
  private:
  bool _internal_has_equipment() const;

  public:
  void clear_equipment() ;
  const ::cfg::TestEquipment& equipment() const;
  PROTOBUF_NODISCARD ::cfg::TestEquipment* release_equipment();
  ::cfg::TestEquipment* mutable_equipment();
  void set_allocated_equipment(::cfg::TestEquipment* value);
  void unsafe_arena_set_allocated_equipment(::cfg::TestEquipment* value);
  ::cfg::TestEquipment* unsafe_arena_release_equipment();

  private:
  const ::cfg::TestEquipment& _internal_equipment() const;
  ::cfg::TestEquipment* _internal_mutable_equipment();

  public:
  // .cfg.TestDecorator Decorator = 3;
  bool has_decorator() const;
  private:
  bool _internal_has_decorator() const;

  public:
  void clear_decorator() ;
  const ::cfg::TestDecorator& decorator() const;
  PROTOBUF_NODISCARD ::cfg::TestDecorator* release_decorator();
  ::cfg::TestDecorator* mutable_decorator();
  void set_allocated_decorator(::cfg::TestDecorator* value);
  void unsafe_arena_set_allocated_decorator(::cfg::TestDecorator* value);
  ::cfg::TestDecorator* unsafe_arena_release_decorator();

  private:
  const ::cfg::TestDecorator& _internal_decorator() const;
  ::cfg::TestDecorator* _internal_mutable_decorator();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.TestItemBase)
 private:
  class _Internal;
  void set_has_item();
  void set_has_equipment();
  void set_has_decorator();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::TestItem* item_;
      ::cfg::TestEquipment* equipment_;
      ::cfg::TestDecorator* decorator_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestH1 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestH1) */ {
 public:
  inline TestH1() : TestH1(nullptr) {}
  ~TestH1() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestH1(::google::protobuf::internal::ConstantInitialized);

  TestH1(const TestH1& from);
  TestH1(TestH1&& from) noexcept
    : TestH1() {
    *this = ::std::move(from);
  }

  inline TestH1(::google::protobuf::Arena* arena, const TestH1& from)
    : TestH1(arena) {
    MergeFrom(from);
  }
  inline TestH1& operator=(const TestH1& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestH1& operator=(TestH1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestH1& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestH1* internal_default_instance() {
    return reinterpret_cast<const TestH1*>(
               &_TestH1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(TestH1& a, TestH1& b) {
    a.Swap(&b);
  }
  inline void Swap(TestH1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestH1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestH1* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestH1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestH1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestH1& from) {
    TestH1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestH1* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestH1";
  }
  protected:
  explicit TestH1(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kY2FieldNumber = 1,
    kY3FieldNumber = 2,
  };
  // .cfg.TestH2 y2 = 1;
  bool has_y2() const;
  void clear_y2() ;
  const ::cfg::TestH2& y2() const;
  PROTOBUF_NODISCARD ::cfg::TestH2* release_y2();
  ::cfg::TestH2* mutable_y2();
  void set_allocated_y2(::cfg::TestH2* value);
  void unsafe_arena_set_allocated_y2(::cfg::TestH2* value);
  ::cfg::TestH2* unsafe_arena_release_y2();

  private:
  const ::cfg::TestH2& _internal_y2() const;
  ::cfg::TestH2* _internal_mutable_y2();

  public:
  // int32 y3 = 2;
  void clear_y3() ;
  ::int32_t y3() const;
  void set_y3(::int32_t value);

  private:
  ::int32_t _internal_y3() const;
  void _internal_set_y3(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestH1)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::cfg::TestH2* y2_;
    ::int32_t y3_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoPrimitiveTypesTable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoPrimitiveTypesTable) */ {
 public:
  inline TestDemoPrimitiveTypesTable() : TestDemoPrimitiveTypesTable(nullptr) {}
  ~TestDemoPrimitiveTypesTable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoPrimitiveTypesTable(::google::protobuf::internal::ConstantInitialized);

  TestDemoPrimitiveTypesTable(const TestDemoPrimitiveTypesTable& from);
  TestDemoPrimitiveTypesTable(TestDemoPrimitiveTypesTable&& from) noexcept
    : TestDemoPrimitiveTypesTable() {
    *this = ::std::move(from);
  }

  inline TestDemoPrimitiveTypesTable(::google::protobuf::Arena* arena, const TestDemoPrimitiveTypesTable& from)
    : TestDemoPrimitiveTypesTable(arena) {
    MergeFrom(from);
  }
  inline TestDemoPrimitiveTypesTable& operator=(const TestDemoPrimitiveTypesTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoPrimitiveTypesTable& operator=(TestDemoPrimitiveTypesTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoPrimitiveTypesTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoPrimitiveTypesTable* internal_default_instance() {
    return reinterpret_cast<const TestDemoPrimitiveTypesTable*>(
               &_TestDemoPrimitiveTypesTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(TestDemoPrimitiveTypesTable& a, TestDemoPrimitiveTypesTable& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoPrimitiveTypesTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoPrimitiveTypesTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoPrimitiveTypesTable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoPrimitiveTypesTable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoPrimitiveTypesTable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoPrimitiveTypesTable& from) {
    TestDemoPrimitiveTypesTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoPrimitiveTypesTable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoPrimitiveTypesTable";
  }
  protected:
  explicit TestDemoPrimitiveTypesTable(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 8,
    kS2FieldNumber = 9,
    kV2FieldNumber = 10,
    kV3FieldNumber = 11,
    kV4FieldNumber = 12,
    kX1FieldNumber = 1,
    kX2FieldNumber = 2,
    kX3FieldNumber = 3,
    kX4FieldNumber = 4,
    kX5FieldNumber = 5,
    kX7FieldNumber = 7,
    kT1FieldNumber = 13,
    kX6FieldNumber = 6,
  };
  // string s1 = 8;
  void clear_s1() ;
  const std::string& s1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s1(Arg_&& arg, Args_... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* ptr);

  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(
      const std::string& value);
  std::string* _internal_mutable_s1();

  public:
  // string s2 = 9;
  void clear_s2() ;
  const std::string& s2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s2(Arg_&& arg, Args_... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* ptr);

  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(
      const std::string& value);
  std::string* _internal_mutable_s2();

  public:
  // .cfg.vec2 v2 = 10;
  bool has_v2() const;
  void clear_v2() ;
  const ::cfg::vec2& v2() const;
  PROTOBUF_NODISCARD ::cfg::vec2* release_v2();
  ::cfg::vec2* mutable_v2();
  void set_allocated_v2(::cfg::vec2* value);
  void unsafe_arena_set_allocated_v2(::cfg::vec2* value);
  ::cfg::vec2* unsafe_arena_release_v2();

  private:
  const ::cfg::vec2& _internal_v2() const;
  ::cfg::vec2* _internal_mutable_v2();

  public:
  // .cfg.vec3 v3 = 11;
  bool has_v3() const;
  void clear_v3() ;
  const ::cfg::vec3& v3() const;
  PROTOBUF_NODISCARD ::cfg::vec3* release_v3();
  ::cfg::vec3* mutable_v3();
  void set_allocated_v3(::cfg::vec3* value);
  void unsafe_arena_set_allocated_v3(::cfg::vec3* value);
  ::cfg::vec3* unsafe_arena_release_v3();

  private:
  const ::cfg::vec3& _internal_v3() const;
  ::cfg::vec3* _internal_mutable_v3();

  public:
  // .cfg.vec4 v4 = 12;
  bool has_v4() const;
  void clear_v4() ;
  const ::cfg::vec4& v4() const;
  PROTOBUF_NODISCARD ::cfg::vec4* release_v4();
  ::cfg::vec4* mutable_v4();
  void set_allocated_v4(::cfg::vec4* value);
  void unsafe_arena_set_allocated_v4(::cfg::vec4* value);
  ::cfg::vec4* unsafe_arena_release_v4();

  private:
  const ::cfg::vec4& _internal_v4() const;
  ::cfg::vec4* _internal_mutable_v4();

  public:
  // bool x1 = 1;
  void clear_x1() ;
  bool x1() const;
  void set_x1(bool value);

  private:
  bool _internal_x1() const;
  void _internal_set_x1(bool value);

  public:
  // int32 x2 = 2;
  void clear_x2() ;
  ::int32_t x2() const;
  void set_x2(::int32_t value);

  private:
  ::int32_t _internal_x2() const;
  void _internal_set_x2(::int32_t value);

  public:
  // int32 x3 = 3;
  void clear_x3() ;
  ::int32_t x3() const;
  void set_x3(::int32_t value);

  private:
  ::int32_t _internal_x3() const;
  void _internal_set_x3(::int32_t value);

  public:
  // int32 x4 = 4;
  void clear_x4() ;
  ::int32_t x4() const;
  void set_x4(::int32_t value);

  private:
  ::int32_t _internal_x4() const;
  void _internal_set_x4(::int32_t value);

  public:
  // int64 x5 = 5;
  void clear_x5() ;
  ::int64_t x5() const;
  void set_x5(::int64_t value);

  private:
  ::int64_t _internal_x5() const;
  void _internal_set_x5(::int64_t value);

  public:
  // double x7 = 7;
  void clear_x7() ;
  double x7() const;
  void set_x7(double value);

  private:
  double _internal_x7() const;
  void _internal_set_x7(double value);

  public:
  // int64 t1 = 13;
  void clear_t1() ;
  ::int64_t t1() const;
  void set_t1(::int64_t value);

  private:
  ::int64_t _internal_t1() const;
  void _internal_set_t1(::int64_t value);

  public:
  // float x6 = 6;
  void clear_x6() ;
  float x6() const;
  void set_x6(float value);

  private:
  float _internal_x6() const;
  void _internal_set_x6(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoPrimitiveTypesTable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 3,
      52, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr s1_;
    ::google::protobuf::internal::ArenaStringPtr s2_;
    ::cfg::vec2* v2_;
    ::cfg::vec3* v3_;
    ::cfg::vec4* v4_;
    bool x1_;
    ::int32_t x2_;
    ::int32_t x3_;
    ::int32_t x4_;
    ::int64_t x5_;
    double x7_;
    ::int64_t t1_;
    float x6_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoGroup) */ {
 public:
  inline TestDemoGroup() : TestDemoGroup(nullptr) {}
  ~TestDemoGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoGroup(::google::protobuf::internal::ConstantInitialized);

  TestDemoGroup(const TestDemoGroup& from);
  TestDemoGroup(TestDemoGroup&& from) noexcept
    : TestDemoGroup() {
    *this = ::std::move(from);
  }

  inline TestDemoGroup(::google::protobuf::Arena* arena, const TestDemoGroup& from)
    : TestDemoGroup(arena) {
    MergeFrom(from);
  }
  inline TestDemoGroup& operator=(const TestDemoGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoGroup& operator=(TestDemoGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoGroup* internal_default_instance() {
    return reinterpret_cast<const TestDemoGroup*>(
               &_TestDemoGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(TestDemoGroup& a, TestDemoGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoGroup& from) {
    TestDemoGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoGroup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoGroup";
  }
  protected:
  explicit TestDemoGroup(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX5FieldNumber = 6,
    kIdFieldNumber = 1,
  };
  // .cfg.TestInnerGroup x5 = 6;
  bool has_x5() const;
  void clear_x5() ;
  const ::cfg::TestInnerGroup& x5() const;
  PROTOBUF_NODISCARD ::cfg::TestInnerGroup* release_x5();
  ::cfg::TestInnerGroup* mutable_x5();
  void set_allocated_x5(::cfg::TestInnerGroup* value);
  void unsafe_arena_set_allocated_x5(::cfg::TestInnerGroup* value);
  ::cfg::TestInnerGroup* unsafe_arena_release_x5();

  private:
  const ::cfg::TestInnerGroup& _internal_x5() const;
  ::cfg::TestInnerGroup* _internal_mutable_x5();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoGroup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::cfg::TestInnerGroup* x5_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoD5 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoD5) */ {
 public:
  inline TestDemoD5() : TestDemoD5(nullptr) {}
  ~TestDemoD5() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoD5(::google::protobuf::internal::ConstantInitialized);

  TestDemoD5(const TestDemoD5& from);
  TestDemoD5(TestDemoD5&& from) noexcept
    : TestDemoD5() {
    *this = ::std::move(from);
  }

  inline TestDemoD5(::google::protobuf::Arena* arena, const TestDemoD5& from)
    : TestDemoD5(arena) {
    MergeFrom(from);
  }
  inline TestDemoD5& operator=(const TestDemoD5& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoD5& operator=(TestDemoD5&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoD5& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoD5* internal_default_instance() {
    return reinterpret_cast<const TestDemoD5*>(
               &_TestDemoD5_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(TestDemoD5& a, TestDemoD5& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoD5* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoD5* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoD5* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoD5>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoD5& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoD5& from) {
    TestDemoD5::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoD5* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoD5";
  }
  protected:
  explicit TestDemoD5(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 2,
    kX1FieldNumber = 1,
  };
  // .cfg.TestDateTimeRange time = 2;
  bool has_time() const;
  void clear_time() ;
  const ::cfg::TestDateTimeRange& time() const;
  PROTOBUF_NODISCARD ::cfg::TestDateTimeRange* release_time();
  ::cfg::TestDateTimeRange* mutable_time();
  void set_allocated_time(::cfg::TestDateTimeRange* value);
  void unsafe_arena_set_allocated_time(::cfg::TestDateTimeRange* value);
  ::cfg::TestDateTimeRange* unsafe_arena_release_time();

  private:
  const ::cfg::TestDateTimeRange& _internal_time() const;
  ::cfg::TestDateTimeRange* _internal_mutable_time();

  public:
  // int32 x1 = 1;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoD5)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::cfg::TestDateTimeRange* time_;
    ::int32_t x1_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoD3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoD3) */ {
 public:
  inline TestDemoD3() : TestDemoD3(nullptr) {}
  ~TestDemoD3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoD3(::google::protobuf::internal::ConstantInitialized);

  TestDemoD3(const TestDemoD3& from);
  TestDemoD3(TestDemoD3&& from) noexcept
    : TestDemoD3() {
    *this = ::std::move(from);
  }

  inline TestDemoD3(::google::protobuf::Arena* arena, const TestDemoD3& from)
    : TestDemoD3(arena) {
    MergeFrom(from);
  }
  inline TestDemoD3& operator=(const TestDemoD3& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoD3& operator=(TestDemoD3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoD3& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kDemoE1 = 2,
    kRoleInfo = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const TestDemoD3* internal_default_instance() {
    return reinterpret_cast<const TestDemoD3*>(
               &_TestDemoD3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(TestDemoD3& a, TestDemoD3& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoD3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoD3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoD3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoD3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoD3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoD3& from) {
    TestDemoD3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoD3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoD3";
  }
  protected:
  explicit TestDemoD3(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDemoE1FieldNumber = 2,
    kRoleInfoFieldNumber = 3,
  };
  // .cfg.TestDemoE1 DemoE1 = 2;
  bool has_demoe1() const;
  private:
  bool _internal_has_demoe1() const;

  public:
  void clear_demoe1() ;
  const ::cfg::TestDemoE1& demoe1() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoE1* release_demoe1();
  ::cfg::TestDemoE1* mutable_demoe1();
  void set_allocated_demoe1(::cfg::TestDemoE1* value);
  void unsafe_arena_set_allocated_demoe1(::cfg::TestDemoE1* value);
  ::cfg::TestDemoE1* unsafe_arena_release_demoe1();

  private:
  const ::cfg::TestDemoE1& _internal_demoe1() const;
  ::cfg::TestDemoE1* _internal_mutable_demoe1();

  public:
  // .cfg.TestLoginRoleInfo RoleInfo = 3;
  bool has_roleinfo() const;
  private:
  bool _internal_has_roleinfo() const;

  public:
  void clear_roleinfo() ;
  const ::cfg::TestLoginRoleInfo& roleinfo() const;
  PROTOBUF_NODISCARD ::cfg::TestLoginRoleInfo* release_roleinfo();
  ::cfg::TestLoginRoleInfo* mutable_roleinfo();
  void set_allocated_roleinfo(::cfg::TestLoginRoleInfo* value);
  void unsafe_arena_set_allocated_roleinfo(::cfg::TestLoginRoleInfo* value);
  ::cfg::TestLoginRoleInfo* unsafe_arena_release_roleinfo();

  private:
  const ::cfg::TestLoginRoleInfo& _internal_roleinfo() const;
  ::cfg::TestLoginRoleInfo* _internal_mutable_roleinfo();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.TestDemoD3)
 private:
  class _Internal;
  void set_has_demoe1();
  void set_has_roleinfo();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::TestDemoE1* demoe1_;
      ::cfg::TestLoginRoleInfo* roleinfo_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TagTbTestTag final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TagTbTestTag) */ {
 public:
  inline TagTbTestTag() : TagTbTestTag(nullptr) {}
  ~TagTbTestTag() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TagTbTestTag(::google::protobuf::internal::ConstantInitialized);

  TagTbTestTag(const TagTbTestTag& from);
  TagTbTestTag(TagTbTestTag&& from) noexcept
    : TagTbTestTag() {
    *this = ::std::move(from);
  }

  inline TagTbTestTag(::google::protobuf::Arena* arena, const TagTbTestTag& from)
    : TagTbTestTag(arena) {
    MergeFrom(from);
  }
  inline TagTbTestTag& operator=(const TagTbTestTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTbTestTag& operator=(TagTbTestTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTbTestTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTbTestTag* internal_default_instance() {
    return reinterpret_cast<const TagTbTestTag*>(
               &_TagTbTestTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(TagTbTestTag& a, TagTbTestTag& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTbTestTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTbTestTag* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagTbTestTag* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagTbTestTag>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TagTbTestTag& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TagTbTestTag& from) {
    TagTbTestTag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTbTestTag* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TagTbTestTag";
  }
  protected:
  explicit TagTbTestTag(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TagTestTag data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TagTestTag* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TagTestTag >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TagTestTag>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TagTestTag>* _internal_mutable_data_list();
  public:
  const ::cfg::TagTestTag& data_list(int index) const;
  ::cfg::TagTestTag* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TagTestTag >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TagTbTestTag)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TagTestTag > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class L10nTbPatchDemo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.L10nTbPatchDemo) */ {
 public:
  inline L10nTbPatchDemo() : L10nTbPatchDemo(nullptr) {}
  ~L10nTbPatchDemo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR L10nTbPatchDemo(::google::protobuf::internal::ConstantInitialized);

  L10nTbPatchDemo(const L10nTbPatchDemo& from);
  L10nTbPatchDemo(L10nTbPatchDemo&& from) noexcept
    : L10nTbPatchDemo() {
    *this = ::std::move(from);
  }

  inline L10nTbPatchDemo(::google::protobuf::Arena* arena, const L10nTbPatchDemo& from)
    : L10nTbPatchDemo(arena) {
    MergeFrom(from);
  }
  inline L10nTbPatchDemo& operator=(const L10nTbPatchDemo& from) {
    CopyFrom(from);
    return *this;
  }
  inline L10nTbPatchDemo& operator=(L10nTbPatchDemo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L10nTbPatchDemo& default_instance() {
    return *internal_default_instance();
  }
  static inline const L10nTbPatchDemo* internal_default_instance() {
    return reinterpret_cast<const L10nTbPatchDemo*>(
               &_L10nTbPatchDemo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(L10nTbPatchDemo& a, L10nTbPatchDemo& b) {
    a.Swap(&b);
  }
  inline void Swap(L10nTbPatchDemo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L10nTbPatchDemo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L10nTbPatchDemo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L10nTbPatchDemo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const L10nTbPatchDemo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const L10nTbPatchDemo& from) {
    L10nTbPatchDemo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L10nTbPatchDemo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.L10nTbPatchDemo";
  }
  protected:
  explicit L10nTbPatchDemo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.L10nPatchDemo data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::L10nPatchDemo* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::L10nPatchDemo >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::L10nPatchDemo>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::L10nPatchDemo>* _internal_mutable_data_list();
  public:
  const ::cfg::L10nPatchDemo& data_list(int index) const;
  ::cfg::L10nPatchDemo* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::L10nPatchDemo >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.L10nTbPatchDemo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::L10nPatchDemo > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class L10nTbL10NDemo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.L10nTbL10NDemo) */ {
 public:
  inline L10nTbL10NDemo() : L10nTbL10NDemo(nullptr) {}
  ~L10nTbL10NDemo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR L10nTbL10NDemo(::google::protobuf::internal::ConstantInitialized);

  L10nTbL10NDemo(const L10nTbL10NDemo& from);
  L10nTbL10NDemo(L10nTbL10NDemo&& from) noexcept
    : L10nTbL10NDemo() {
    *this = ::std::move(from);
  }

  inline L10nTbL10NDemo(::google::protobuf::Arena* arena, const L10nTbL10NDemo& from)
    : L10nTbL10NDemo(arena) {
    MergeFrom(from);
  }
  inline L10nTbL10NDemo& operator=(const L10nTbL10NDemo& from) {
    CopyFrom(from);
    return *this;
  }
  inline L10nTbL10NDemo& operator=(L10nTbL10NDemo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L10nTbL10NDemo& default_instance() {
    return *internal_default_instance();
  }
  static inline const L10nTbL10NDemo* internal_default_instance() {
    return reinterpret_cast<const L10nTbL10NDemo*>(
               &_L10nTbL10NDemo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(L10nTbL10NDemo& a, L10nTbL10NDemo& b) {
    a.Swap(&b);
  }
  inline void Swap(L10nTbL10NDemo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L10nTbL10NDemo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L10nTbL10NDemo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L10nTbL10NDemo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const L10nTbL10NDemo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const L10nTbL10NDemo& from) {
    L10nTbL10NDemo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L10nTbL10NDemo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.L10nTbL10NDemo";
  }
  protected:
  explicit L10nTbL10NDemo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.L10nL10NDemo data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::L10nL10NDemo* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::L10nL10NDemo >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::L10nL10NDemo>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::L10nL10NDemo>* _internal_mutable_data_list();
  public:
  const ::cfg::L10nL10NDemo& data_list(int index) const;
  ::cfg::L10nL10NDemo* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::L10nL10NDemo >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.L10nTbL10NDemo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::L10nL10NDemo > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class ItemTbItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.ItemTbItem) */ {
 public:
  inline ItemTbItem() : ItemTbItem(nullptr) {}
  ~ItemTbItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ItemTbItem(::google::protobuf::internal::ConstantInitialized);

  ItemTbItem(const ItemTbItem& from);
  ItemTbItem(ItemTbItem&& from) noexcept
    : ItemTbItem() {
    *this = ::std::move(from);
  }

  inline ItemTbItem(::google::protobuf::Arena* arena, const ItemTbItem& from)
    : ItemTbItem(arena) {
    MergeFrom(from);
  }
  inline ItemTbItem& operator=(const ItemTbItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemTbItem& operator=(ItemTbItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemTbItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemTbItem* internal_default_instance() {
    return reinterpret_cast<const ItemTbItem*>(
               &_ItemTbItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(ItemTbItem& a, ItemTbItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemTbItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemTbItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemTbItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemTbItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemTbItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ItemTbItem& from) {
    ItemTbItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemTbItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.ItemTbItem";
  }
  protected:
  explicit ItemTbItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.ItemItem data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::ItemItem* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::ItemItem >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::ItemItem>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::ItemItem>* _internal_mutable_data_list();
  public:
  const ::cfg::ItemItem& data_list(int index) const;
  ::cfg::ItemItem* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::ItemItem >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.ItemTbItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::ItemItem > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class CommonTbGlobalConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.CommonTbGlobalConfig) */ {
 public:
  inline CommonTbGlobalConfig() : CommonTbGlobalConfig(nullptr) {}
  ~CommonTbGlobalConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonTbGlobalConfig(::google::protobuf::internal::ConstantInitialized);

  CommonTbGlobalConfig(const CommonTbGlobalConfig& from);
  CommonTbGlobalConfig(CommonTbGlobalConfig&& from) noexcept
    : CommonTbGlobalConfig() {
    *this = ::std::move(from);
  }

  inline CommonTbGlobalConfig(::google::protobuf::Arena* arena, const CommonTbGlobalConfig& from)
    : CommonTbGlobalConfig(arena) {
    MergeFrom(from);
  }
  inline CommonTbGlobalConfig& operator=(const CommonTbGlobalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonTbGlobalConfig& operator=(CommonTbGlobalConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonTbGlobalConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonTbGlobalConfig* internal_default_instance() {
    return reinterpret_cast<const CommonTbGlobalConfig*>(
               &_CommonTbGlobalConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(CommonTbGlobalConfig& a, CommonTbGlobalConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonTbGlobalConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonTbGlobalConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonTbGlobalConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonTbGlobalConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonTbGlobalConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonTbGlobalConfig& from) {
    CommonTbGlobalConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonTbGlobalConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.CommonTbGlobalConfig";
  }
  protected:
  explicit CommonTbGlobalConfig(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.CommonGlobalConfig data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::CommonGlobalConfig* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::CommonGlobalConfig >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::CommonGlobalConfig>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::CommonGlobalConfig>* _internal_mutable_data_list();
  public:
  const ::cfg::CommonGlobalConfig& data_list(int index) const;
  ::cfg::CommonGlobalConfig* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::CommonGlobalConfig >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.CommonTbGlobalConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::CommonGlobalConfig > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiService final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiService) */ {
 public:
  inline AiService() : AiService(nullptr) {}
  ~AiService() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiService(::google::protobuf::internal::ConstantInitialized);

  AiService(const AiService& from);
  AiService(AiService&& from) noexcept
    : AiService() {
    *this = ::std::move(from);
  }

  inline AiService(::google::protobuf::Arena* arena, const AiService& from)
    : AiService(arena) {
    MergeFrom(from);
  }
  inline AiService& operator=(const AiService& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiService& operator=(AiService&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiService& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUeSetDefaultFocus = 1,
    kExecuteTimeStatistic = 2,
    kChooseTarget = 3,
    kKeepFaceTarget = 4,
    kGetOwnerPlayer = 5,
    kUpdateDailyBehaviorProps = 6,
    VALUE_NOT_SET = 0,
  };

  static inline const AiService* internal_default_instance() {
    return reinterpret_cast<const AiService*>(
               &_AiService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AiService& a, AiService& b) {
    a.Swap(&b);
  }
  inline void Swap(AiService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiService* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiService* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiService>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiService& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiService& from) {
    AiService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiService* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiService";
  }
  protected:
  explicit AiService(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeSetDefaultFocusFieldNumber = 1,
    kExecuteTimeStatisticFieldNumber = 2,
    kChooseTargetFieldNumber = 3,
    kKeepFaceTargetFieldNumber = 4,
    kGetOwnerPlayerFieldNumber = 5,
    kUpdateDailyBehaviorPropsFieldNumber = 6,
  };
  // .cfg.AiUeSetDefaultFocus UeSetDefaultFocus = 1;
  bool has_uesetdefaultfocus() const;
  private:
  bool _internal_has_uesetdefaultfocus() const;

  public:
  void clear_uesetdefaultfocus() ;
  const ::cfg::AiUeSetDefaultFocus& uesetdefaultfocus() const;
  PROTOBUF_NODISCARD ::cfg::AiUeSetDefaultFocus* release_uesetdefaultfocus();
  ::cfg::AiUeSetDefaultFocus* mutable_uesetdefaultfocus();
  void set_allocated_uesetdefaultfocus(::cfg::AiUeSetDefaultFocus* value);
  void unsafe_arena_set_allocated_uesetdefaultfocus(::cfg::AiUeSetDefaultFocus* value);
  ::cfg::AiUeSetDefaultFocus* unsafe_arena_release_uesetdefaultfocus();

  private:
  const ::cfg::AiUeSetDefaultFocus& _internal_uesetdefaultfocus() const;
  ::cfg::AiUeSetDefaultFocus* _internal_mutable_uesetdefaultfocus();

  public:
  // .cfg.AiExecuteTimeStatistic ExecuteTimeStatistic = 2;
  bool has_executetimestatistic() const;
  private:
  bool _internal_has_executetimestatistic() const;

  public:
  void clear_executetimestatistic() ;
  const ::cfg::AiExecuteTimeStatistic& executetimestatistic() const;
  PROTOBUF_NODISCARD ::cfg::AiExecuteTimeStatistic* release_executetimestatistic();
  ::cfg::AiExecuteTimeStatistic* mutable_executetimestatistic();
  void set_allocated_executetimestatistic(::cfg::AiExecuteTimeStatistic* value);
  void unsafe_arena_set_allocated_executetimestatistic(::cfg::AiExecuteTimeStatistic* value);
  ::cfg::AiExecuteTimeStatistic* unsafe_arena_release_executetimestatistic();

  private:
  const ::cfg::AiExecuteTimeStatistic& _internal_executetimestatistic() const;
  ::cfg::AiExecuteTimeStatistic* _internal_mutable_executetimestatistic();

  public:
  // .cfg.AiChooseTarget ChooseTarget = 3;
  bool has_choosetarget() const;
  private:
  bool _internal_has_choosetarget() const;

  public:
  void clear_choosetarget() ;
  const ::cfg::AiChooseTarget& choosetarget() const;
  PROTOBUF_NODISCARD ::cfg::AiChooseTarget* release_choosetarget();
  ::cfg::AiChooseTarget* mutable_choosetarget();
  void set_allocated_choosetarget(::cfg::AiChooseTarget* value);
  void unsafe_arena_set_allocated_choosetarget(::cfg::AiChooseTarget* value);
  ::cfg::AiChooseTarget* unsafe_arena_release_choosetarget();

  private:
  const ::cfg::AiChooseTarget& _internal_choosetarget() const;
  ::cfg::AiChooseTarget* _internal_mutable_choosetarget();

  public:
  // .cfg.AiKeepFaceTarget KeepFaceTarget = 4;
  bool has_keepfacetarget() const;
  private:
  bool _internal_has_keepfacetarget() const;

  public:
  void clear_keepfacetarget() ;
  const ::cfg::AiKeepFaceTarget& keepfacetarget() const;
  PROTOBUF_NODISCARD ::cfg::AiKeepFaceTarget* release_keepfacetarget();
  ::cfg::AiKeepFaceTarget* mutable_keepfacetarget();
  void set_allocated_keepfacetarget(::cfg::AiKeepFaceTarget* value);
  void unsafe_arena_set_allocated_keepfacetarget(::cfg::AiKeepFaceTarget* value);
  ::cfg::AiKeepFaceTarget* unsafe_arena_release_keepfacetarget();

  private:
  const ::cfg::AiKeepFaceTarget& _internal_keepfacetarget() const;
  ::cfg::AiKeepFaceTarget* _internal_mutable_keepfacetarget();

  public:
  // .cfg.AiGetOwnerPlayer GetOwnerPlayer = 5;
  bool has_getownerplayer() const;
  private:
  bool _internal_has_getownerplayer() const;

  public:
  void clear_getownerplayer() ;
  const ::cfg::AiGetOwnerPlayer& getownerplayer() const;
  PROTOBUF_NODISCARD ::cfg::AiGetOwnerPlayer* release_getownerplayer();
  ::cfg::AiGetOwnerPlayer* mutable_getownerplayer();
  void set_allocated_getownerplayer(::cfg::AiGetOwnerPlayer* value);
  void unsafe_arena_set_allocated_getownerplayer(::cfg::AiGetOwnerPlayer* value);
  ::cfg::AiGetOwnerPlayer* unsafe_arena_release_getownerplayer();

  private:
  const ::cfg::AiGetOwnerPlayer& _internal_getownerplayer() const;
  ::cfg::AiGetOwnerPlayer* _internal_mutable_getownerplayer();

  public:
  // .cfg.AiUpdateDailyBehaviorProps UpdateDailyBehaviorProps = 6;
  bool has_updatedailybehaviorprops() const;
  private:
  bool _internal_has_updatedailybehaviorprops() const;

  public:
  void clear_updatedailybehaviorprops() ;
  const ::cfg::AiUpdateDailyBehaviorProps& updatedailybehaviorprops() const;
  PROTOBUF_NODISCARD ::cfg::AiUpdateDailyBehaviorProps* release_updatedailybehaviorprops();
  ::cfg::AiUpdateDailyBehaviorProps* mutable_updatedailybehaviorprops();
  void set_allocated_updatedailybehaviorprops(::cfg::AiUpdateDailyBehaviorProps* value);
  void unsafe_arena_set_allocated_updatedailybehaviorprops(::cfg::AiUpdateDailyBehaviorProps* value);
  ::cfg::AiUpdateDailyBehaviorProps* unsafe_arena_release_updatedailybehaviorprops();

  private:
  const ::cfg::AiUpdateDailyBehaviorProps& _internal_updatedailybehaviorprops() const;
  ::cfg::AiUpdateDailyBehaviorProps* _internal_mutable_updatedailybehaviorprops();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiService)
 private:
  class _Internal;
  void set_has_uesetdefaultfocus();
  void set_has_executetimestatistic();
  void set_has_choosetarget();
  void set_has_keepfacetarget();
  void set_has_getownerplayer();
  void set_has_updatedailybehaviorprops();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 6,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiUeSetDefaultFocus* uesetdefaultfocus_;
      ::cfg::AiExecuteTimeStatistic* executetimestatistic_;
      ::cfg::AiChooseTarget* choosetarget_;
      ::cfg::AiKeepFaceTarget* keepfacetarget_;
      ::cfg::AiGetOwnerPlayer* getownerplayer_;
      ::cfg::AiUpdateDailyBehaviorProps* updatedailybehaviorprops_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiKeyData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiKeyData) */ {
 public:
  inline AiKeyData() : AiKeyData(nullptr) {}
  ~AiKeyData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiKeyData(::google::protobuf::internal::ConstantInitialized);

  AiKeyData(const AiKeyData& from);
  AiKeyData(AiKeyData&& from) noexcept
    : AiKeyData() {
    *this = ::std::move(from);
  }

  inline AiKeyData(::google::protobuf::Arena* arena, const AiKeyData& from)
    : AiKeyData(arena) {
    MergeFrom(from);
  }
  inline AiKeyData& operator=(const AiKeyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiKeyData& operator=(AiKeyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiKeyData& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kFloatKeyData = 1,
    kIntKeyData = 2,
    kStringKeyData = 3,
    kBlackboardKeyData = 4,
    VALUE_NOT_SET = 0,
  };

  static inline const AiKeyData* internal_default_instance() {
    return reinterpret_cast<const AiKeyData*>(
               &_AiKeyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AiKeyData& a, AiKeyData& b) {
    a.Swap(&b);
  }
  inline void Swap(AiKeyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiKeyData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiKeyData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiKeyData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiKeyData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiKeyData& from) {
    AiKeyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiKeyData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiKeyData";
  }
  protected:
  explicit AiKeyData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatKeyDataFieldNumber = 1,
    kIntKeyDataFieldNumber = 2,
    kStringKeyDataFieldNumber = 3,
    kBlackboardKeyDataFieldNumber = 4,
  };
  // .cfg.AiFloatKeyData FloatKeyData = 1;
  bool has_floatkeydata() const;
  private:
  bool _internal_has_floatkeydata() const;

  public:
  void clear_floatkeydata() ;
  const ::cfg::AiFloatKeyData& floatkeydata() const;
  PROTOBUF_NODISCARD ::cfg::AiFloatKeyData* release_floatkeydata();
  ::cfg::AiFloatKeyData* mutable_floatkeydata();
  void set_allocated_floatkeydata(::cfg::AiFloatKeyData* value);
  void unsafe_arena_set_allocated_floatkeydata(::cfg::AiFloatKeyData* value);
  ::cfg::AiFloatKeyData* unsafe_arena_release_floatkeydata();

  private:
  const ::cfg::AiFloatKeyData& _internal_floatkeydata() const;
  ::cfg::AiFloatKeyData* _internal_mutable_floatkeydata();

  public:
  // .cfg.AiIntKeyData IntKeyData = 2;
  bool has_intkeydata() const;
  private:
  bool _internal_has_intkeydata() const;

  public:
  void clear_intkeydata() ;
  const ::cfg::AiIntKeyData& intkeydata() const;
  PROTOBUF_NODISCARD ::cfg::AiIntKeyData* release_intkeydata();
  ::cfg::AiIntKeyData* mutable_intkeydata();
  void set_allocated_intkeydata(::cfg::AiIntKeyData* value);
  void unsafe_arena_set_allocated_intkeydata(::cfg::AiIntKeyData* value);
  ::cfg::AiIntKeyData* unsafe_arena_release_intkeydata();

  private:
  const ::cfg::AiIntKeyData& _internal_intkeydata() const;
  ::cfg::AiIntKeyData* _internal_mutable_intkeydata();

  public:
  // .cfg.AiStringKeyData StringKeyData = 3;
  bool has_stringkeydata() const;
  private:
  bool _internal_has_stringkeydata() const;

  public:
  void clear_stringkeydata() ;
  const ::cfg::AiStringKeyData& stringkeydata() const;
  PROTOBUF_NODISCARD ::cfg::AiStringKeyData* release_stringkeydata();
  ::cfg::AiStringKeyData* mutable_stringkeydata();
  void set_allocated_stringkeydata(::cfg::AiStringKeyData* value);
  void unsafe_arena_set_allocated_stringkeydata(::cfg::AiStringKeyData* value);
  ::cfg::AiStringKeyData* unsafe_arena_release_stringkeydata();

  private:
  const ::cfg::AiStringKeyData& _internal_stringkeydata() const;
  ::cfg::AiStringKeyData* _internal_mutable_stringkeydata();

  public:
  // .cfg.AiBlackboardKeyData BlackboardKeyData = 4;
  bool has_blackboardkeydata() const;
  private:
  bool _internal_has_blackboardkeydata() const;

  public:
  void clear_blackboardkeydata() ;
  const ::cfg::AiBlackboardKeyData& blackboardkeydata() const;
  PROTOBUF_NODISCARD ::cfg::AiBlackboardKeyData* release_blackboardkeydata();
  ::cfg::AiBlackboardKeyData* mutable_blackboardkeydata();
  void set_allocated_blackboardkeydata(::cfg::AiBlackboardKeyData* value);
  void unsafe_arena_set_allocated_blackboardkeydata(::cfg::AiBlackboardKeyData* value);
  ::cfg::AiBlackboardKeyData* unsafe_arena_release_blackboardkeydata();

  private:
  const ::cfg::AiBlackboardKeyData& _internal_blackboardkeydata() const;
  ::cfg::AiBlackboardKeyData* _internal_mutable_blackboardkeydata();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiKeyData)
 private:
  class _Internal;
  void set_has_floatkeydata();
  void set_has_intkeydata();
  void set_has_stringkeydata();
  void set_has_blackboardkeydata();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiFloatKeyData* floatkeydata_;
      ::cfg::AiIntKeyData* intkeydata_;
      ::cfg::AiStringKeyData* stringkeydata_;
      ::cfg::AiBlackboardKeyData* blackboardkeydata_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiBlackboard final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiBlackboard) */ {
 public:
  inline AiBlackboard() : AiBlackboard(nullptr) {}
  ~AiBlackboard() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiBlackboard(::google::protobuf::internal::ConstantInitialized);

  AiBlackboard(const AiBlackboard& from);
  AiBlackboard(AiBlackboard&& from) noexcept
    : AiBlackboard() {
    *this = ::std::move(from);
  }

  inline AiBlackboard(::google::protobuf::Arena* arena, const AiBlackboard& from)
    : AiBlackboard(arena) {
    MergeFrom(from);
  }
  inline AiBlackboard& operator=(const AiBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiBlackboard& operator=(AiBlackboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiBlackboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiBlackboard* internal_default_instance() {
    return reinterpret_cast<const AiBlackboard*>(
               &_AiBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AiBlackboard& a, AiBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(AiBlackboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiBlackboard* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiBlackboard* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiBlackboard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiBlackboard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiBlackboard& from) {
    AiBlackboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiBlackboard* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiBlackboard";
  }
  protected:
  explicit AiBlackboard(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 4,
    kNameFieldNumber = 1,
    kDescFieldNumber = 2,
    kParentNameFieldNumber = 3,
  };
  // repeated .cfg.AiBlackboardKey keys = 4 [packed = false];
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  ::cfg::AiBlackboardKey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiBlackboardKey >*
      mutable_keys();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboardKey>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboardKey>* _internal_mutable_keys();
  public:
  const ::cfg::AiBlackboardKey& keys(int index) const;
  ::cfg::AiBlackboardKey* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiBlackboardKey >&
      keys() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string desc = 2;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // string parent_name = 3;
  void clear_parent_name() ;
  const std::string& parent_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_name(Arg_&& arg, Args_... args);
  std::string* mutable_parent_name();
  PROTOBUF_NODISCARD std::string* release_parent_name();
  void set_allocated_parent_name(std::string* ptr);

  private:
  const std::string& _internal_parent_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_name(
      const std::string& value);
  std::string* _internal_mutable_parent_name();

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiBlackboard)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      44, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiBlackboardKey > keys_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr parent_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestRef final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestRef) */ {
 public:
  inline TestTestRef() : TestTestRef(nullptr) {}
  ~TestTestRef() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestRef(::google::protobuf::internal::ConstantInitialized);

  TestTestRef(const TestTestRef& from);
  TestTestRef(TestTestRef&& from) noexcept
    : TestTestRef() {
    *this = ::std::move(from);
  }

  inline TestTestRef(::google::protobuf::Arena* arena, const TestTestRef& from)
    : TestTestRef(arena) {
    MergeFrom(from);
  }
  inline TestTestRef& operator=(const TestTestRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestRef& operator=(TestTestRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestRef* internal_default_instance() {
    return reinterpret_cast<const TestTestRef*>(
               &_TestTestRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(TestTestRef& a, TestTestRef& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestRef* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestRef& from) {
    TestTestRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestRef* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestRef";
  }
  protected:
  explicit TestTestRef(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kA1FieldNumber = 7,
    kA2FieldNumber = 8,
    kB1FieldNumber = 9,
    kB2FieldNumber = 10,
    kC1FieldNumber = 11,
    kC2FieldNumber = 12,
    kD1FieldNumber = 13,
    kD2FieldNumber = 14,
    kE3FieldNumber = 17,
    kF3FieldNumber = 20,
    kS1FieldNumber = 21,
    kIdFieldNumber = 1,
    kX1FieldNumber = 2,
    kX12FieldNumber = 3,
    kX2FieldNumber = 4,
    kX3FieldNumber = 5,
    kX4FieldNumber = 6,
    kE2FieldNumber = 16,
    kE1FieldNumber = 15,
    kF1FieldNumber = 18,
    kF2FieldNumber = 19,
  };
  // repeated int32 a1 = 7 [packed = true];
  int a1_size() const;
  private:
  int _internal_a1_size() const;

  public:
  void clear_a1() ;
  ::int32_t a1(int index) const;
  void set_a1(int index, ::int32_t value);
  void add_a1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& a1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_a1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_a1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_a1();

  public:
  // repeated int32 a2 = 8 [packed = true];
  int a2_size() const;
  private:
  int _internal_a2_size() const;

  public:
  void clear_a2() ;
  ::int32_t a2(int index) const;
  void set_a2(int index, ::int32_t value);
  void add_a2(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& a2() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_a2();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_a2() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_a2();

  public:
  // repeated int32 b1 = 9 [packed = true];
  int b1_size() const;
  private:
  int _internal_b1_size() const;

  public:
  void clear_b1() ;
  ::int32_t b1(int index) const;
  void set_b1(int index, ::int32_t value);
  void add_b1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& b1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_b1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_b1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_b1();

  public:
  // repeated int32 b2 = 10 [packed = true];
  int b2_size() const;
  private:
  int _internal_b2_size() const;

  public:
  void clear_b2() ;
  ::int32_t b2(int index) const;
  void set_b2(int index, ::int32_t value);
  void add_b2(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& b2() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_b2();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_b2() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_b2();

  public:
  // repeated int32 c1 = 11 [packed = true];
  int c1_size() const;
  private:
  int _internal_c1_size() const;

  public:
  void clear_c1() ;
  ::int32_t c1(int index) const;
  void set_c1(int index, ::int32_t value);
  void add_c1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& c1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_c1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_c1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_c1();

  public:
  // repeated int32 c2 = 12 [packed = true];
  int c2_size() const;
  private:
  int _internal_c2_size() const;

  public:
  void clear_c2() ;
  ::int32_t c2(int index) const;
  void set_c2(int index, ::int32_t value);
  void add_c2(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& c2() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_c2();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_c2() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_c2();

  public:
  // map<int32, int32> d1 = 13;
  int d1_size() const;
  private:
  int _internal_d1_size() const;

  public:
  void clear_d1() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& d1() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_d1();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_d1() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_d1();

  public:
  // map<int32, int32> d2 = 14;
  int d2_size() const;
  private:
  int _internal_d2_size() const;

  public:
  void clear_d2() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& d2() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_d2();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_d2() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_d2();

  public:
  // string e3 = 17;
  void clear_e3() ;
  const std::string& e3() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_e3(Arg_&& arg, Args_... args);
  std::string* mutable_e3();
  PROTOBUF_NODISCARD std::string* release_e3();
  void set_allocated_e3(std::string* ptr);

  private:
  const std::string& _internal_e3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e3(
      const std::string& value);
  std::string* _internal_mutable_e3();

  public:
  // string f3 = 20;
  void clear_f3() ;
  const std::string& f3() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_f3(Arg_&& arg, Args_... args);
  std::string* mutable_f3();
  PROTOBUF_NODISCARD std::string* release_f3();
  void set_allocated_f3(std::string* ptr);

  private:
  const std::string& _internal_f3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f3(
      const std::string& value);
  std::string* _internal_mutable_f3();

  public:
  // .cfg.TestRefDynamicBase s1 = 21;
  bool has_s1() const;
  void clear_s1() ;
  const ::cfg::TestRefDynamicBase& s1() const;
  PROTOBUF_NODISCARD ::cfg::TestRefDynamicBase* release_s1();
  ::cfg::TestRefDynamicBase* mutable_s1();
  void set_allocated_s1(::cfg::TestRefDynamicBase* value);
  void unsafe_arena_set_allocated_s1(::cfg::TestRefDynamicBase* value);
  ::cfg::TestRefDynamicBase* unsafe_arena_release_s1();

  private:
  const ::cfg::TestRefDynamicBase& _internal_s1() const;
  ::cfg::TestRefDynamicBase* _internal_mutable_s1();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 x1 = 2;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // int32 x1_2 = 3;
  void clear_x1_2() ;
  ::int32_t x1_2() const;
  void set_x1_2(::int32_t value);

  private:
  ::int32_t _internal_x1_2() const;
  void _internal_set_x1_2(::int32_t value);

  public:
  // int32 x2 = 4;
  void clear_x2() ;
  ::int32_t x2() const;
  void set_x2(::int32_t value);

  private:
  ::int32_t _internal_x2() const;
  void _internal_set_x2(::int32_t value);

  public:
  // int32 x3 = 5;
  void clear_x3() ;
  ::int32_t x3() const;
  void set_x3(::int32_t value);

  private:
  ::int32_t _internal_x3() const;
  void _internal_set_x3(::int32_t value);

  public:
  // int32 x4 = 6;
  void clear_x4() ;
  ::int32_t x4() const;
  void set_x4(::int32_t value);

  private:
  ::int32_t _internal_x4() const;
  void _internal_set_x4(::int32_t value);

  public:
  // int64 e2 = 16;
  void clear_e2() ;
  ::int64_t e2() const;
  void set_e2(::int64_t value);

  private:
  ::int64_t _internal_e2() const;
  void _internal_set_e2(::int64_t value);

  public:
  // int32 e1 = 15;
  void clear_e1() ;
  ::int32_t e1() const;
  void set_e1(::int32_t value);

  private:
  ::int32_t _internal_e1() const;
  void _internal_set_e1(::int32_t value);

  public:
  // int32 f1 = 18;
  void clear_f1() ;
  ::int32_t f1() const;
  void set_f1(::int32_t value);

  private:
  ::int32_t _internal_f1() const;
  void _internal_set_f1(::int32_t value);

  public:
  // int64 f2 = 19;
  void clear_f2() ;
  ::int64_t f2() const;
  void set_f2(::int64_t value);

  private:
  ::int64_t _internal_f2() const;
  void _internal_set_f2(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestRef)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 21, 3,
      44, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> a1_;
    mutable ::google::protobuf::internal::CachedSize _a1_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> a2_;
    mutable ::google::protobuf::internal::CachedSize _a2_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> b1_;
    mutable ::google::protobuf::internal::CachedSize _b1_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> b2_;
    mutable ::google::protobuf::internal::CachedSize _b2_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> c1_;
    mutable ::google::protobuf::internal::CachedSize _c1_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> c2_;
    mutable ::google::protobuf::internal::CachedSize _c2_cached_byte_size_;
    ::google::protobuf::internal::MapField<TestTestRef_D1Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        d1_;
    ::google::protobuf::internal::MapField<TestTestRef_D2Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        d2_;
    ::google::protobuf::internal::ArenaStringPtr e3_;
    ::google::protobuf::internal::ArenaStringPtr f3_;
    ::cfg::TestRefDynamicBase* s1_;
    ::int32_t id_;
    ::int32_t x1_;
    ::int32_t x1_2_;
    ::int32_t x2_;
    ::int32_t x3_;
    ::int32_t x4_;
    ::int64_t e2_;
    ::int32_t e1_;
    ::int32_t f1_;
    ::int64_t f2_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestString final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestString) */ {
 public:
  inline TestTbTestString() : TestTbTestString(nullptr) {}
  ~TestTbTestString() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestString(::google::protobuf::internal::ConstantInitialized);

  TestTbTestString(const TestTbTestString& from);
  TestTbTestString(TestTbTestString&& from) noexcept
    : TestTbTestString() {
    *this = ::std::move(from);
  }

  inline TestTbTestString(::google::protobuf::Arena* arena, const TestTbTestString& from)
    : TestTbTestString(arena) {
    MergeFrom(from);
  }
  inline TestTbTestString& operator=(const TestTbTestString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestString& operator=(TestTbTestString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestString* internal_default_instance() {
    return reinterpret_cast<const TestTbTestString*>(
               &_TestTbTestString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(TestTbTestString& a, TestTbTestString& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestString* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestString* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestString>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestString& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestString& from) {
    TestTbTestString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestString* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestString";
  }
  protected:
  explicit TestTbTestString(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestString data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestString* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestString >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestString>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestString>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestString& data_list(int index) const;
  ::cfg::TestTestString* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestString >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestString)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestString > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestSize final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestSize) */ {
 public:
  inline TestTbTestSize() : TestTbTestSize(nullptr) {}
  ~TestTbTestSize() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestSize(::google::protobuf::internal::ConstantInitialized);

  TestTbTestSize(const TestTbTestSize& from);
  TestTbTestSize(TestTbTestSize&& from) noexcept
    : TestTbTestSize() {
    *this = ::std::move(from);
  }

  inline TestTbTestSize(::google::protobuf::Arena* arena, const TestTbTestSize& from)
    : TestTbTestSize(arena) {
    MergeFrom(from);
  }
  inline TestTbTestSize& operator=(const TestTbTestSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestSize& operator=(TestTbTestSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestSize* internal_default_instance() {
    return reinterpret_cast<const TestTbTestSize*>(
               &_TestTbTestSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(TestTbTestSize& a, TestTbTestSize& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestSize* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestSize* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestSize>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestSize& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestSize& from) {
    TestTbTestSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestSize* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestSize";
  }
  protected:
  explicit TestTbTestSize(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestSize data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestSize* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestSize >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestSize>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestSize>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestSize& data_list(int index) const;
  ::cfg::TestTestSize* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestSize >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestSize)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestSize > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestScriptableObject final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestScriptableObject) */ {
 public:
  inline TestTbTestScriptableObject() : TestTbTestScriptableObject(nullptr) {}
  ~TestTbTestScriptableObject() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestScriptableObject(::google::protobuf::internal::ConstantInitialized);

  TestTbTestScriptableObject(const TestTbTestScriptableObject& from);
  TestTbTestScriptableObject(TestTbTestScriptableObject&& from) noexcept
    : TestTbTestScriptableObject() {
    *this = ::std::move(from);
  }

  inline TestTbTestScriptableObject(::google::protobuf::Arena* arena, const TestTbTestScriptableObject& from)
    : TestTbTestScriptableObject(arena) {
    MergeFrom(from);
  }
  inline TestTbTestScriptableObject& operator=(const TestTbTestScriptableObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestScriptableObject& operator=(TestTbTestScriptableObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestScriptableObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestScriptableObject* internal_default_instance() {
    return reinterpret_cast<const TestTbTestScriptableObject*>(
               &_TestTbTestScriptableObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(TestTbTestScriptableObject& a, TestTbTestScriptableObject& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestScriptableObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestScriptableObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestScriptableObject* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestScriptableObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestScriptableObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestScriptableObject& from) {
    TestTbTestScriptableObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestScriptableObject* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestScriptableObject";
  }
  protected:
  explicit TestTbTestScriptableObject(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestScriptableObject data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestScriptableObject* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestScriptableObject >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestScriptableObject>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestScriptableObject>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestScriptableObject& data_list(int index) const;
  ::cfg::TestTestScriptableObject* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestScriptableObject >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestScriptableObject)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestScriptableObject > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestMultiColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestMultiColumn) */ {
 public:
  inline TestTbTestMultiColumn() : TestTbTestMultiColumn(nullptr) {}
  ~TestTbTestMultiColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestMultiColumn(::google::protobuf::internal::ConstantInitialized);

  TestTbTestMultiColumn(const TestTbTestMultiColumn& from);
  TestTbTestMultiColumn(TestTbTestMultiColumn&& from) noexcept
    : TestTbTestMultiColumn() {
    *this = ::std::move(from);
  }

  inline TestTbTestMultiColumn(::google::protobuf::Arena* arena, const TestTbTestMultiColumn& from)
    : TestTbTestMultiColumn(arena) {
    MergeFrom(from);
  }
  inline TestTbTestMultiColumn& operator=(const TestTbTestMultiColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestMultiColumn& operator=(TestTbTestMultiColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestMultiColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestMultiColumn* internal_default_instance() {
    return reinterpret_cast<const TestTbTestMultiColumn*>(
               &_TestTbTestMultiColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(TestTbTestMultiColumn& a, TestTbTestMultiColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestMultiColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestMultiColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestMultiColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestMultiColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestMultiColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestMultiColumn& from) {
    TestTbTestMultiColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestMultiColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestMultiColumn";
  }
  protected:
  explicit TestTbTestMultiColumn(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestMultiColumn data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestMultiColumn* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMultiColumn >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMultiColumn>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestMultiColumn>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestMultiColumn& data_list(int index) const;
  ::cfg::TestTestMultiColumn* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMultiColumn >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestMultiColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMultiColumn > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestMapper final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestMapper) */ {
 public:
  inline TestTbTestMapper() : TestTbTestMapper(nullptr) {}
  ~TestTbTestMapper() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestMapper(::google::protobuf::internal::ConstantInitialized);

  TestTbTestMapper(const TestTbTestMapper& from);
  TestTbTestMapper(TestTbTestMapper&& from) noexcept
    : TestTbTestMapper() {
    *this = ::std::move(from);
  }

  inline TestTbTestMapper(::google::protobuf::Arena* arena, const TestTbTestMapper& from)
    : TestTbTestMapper(arena) {
    MergeFrom(from);
  }
  inline TestTbTestMapper& operator=(const TestTbTestMapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestMapper& operator=(TestTbTestMapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestMapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestMapper* internal_default_instance() {
    return reinterpret_cast<const TestTbTestMapper*>(
               &_TestTbTestMapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(TestTbTestMapper& a, TestTbTestMapper& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestMapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestMapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestMapper* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestMapper>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestMapper& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestMapper& from) {
    TestTbTestMapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestMapper* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestMapper";
  }
  protected:
  explicit TestTbTestMapper(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestMapper data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestMapper* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMapper >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMapper>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestMapper>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestMapper& data_list(int index) const;
  ::cfg::TestTestMapper* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMapper >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestMapper)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMapper > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestMap final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestMap) */ {
 public:
  inline TestTbTestMap() : TestTbTestMap(nullptr) {}
  ~TestTbTestMap() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestMap(::google::protobuf::internal::ConstantInitialized);

  TestTbTestMap(const TestTbTestMap& from);
  TestTbTestMap(TestTbTestMap&& from) noexcept
    : TestTbTestMap() {
    *this = ::std::move(from);
  }

  inline TestTbTestMap(::google::protobuf::Arena* arena, const TestTbTestMap& from)
    : TestTbTestMap(arena) {
    MergeFrom(from);
  }
  inline TestTbTestMap& operator=(const TestTbTestMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestMap& operator=(TestTbTestMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestMap* internal_default_instance() {
    return reinterpret_cast<const TestTbTestMap*>(
               &_TestTbTestMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(TestTbTestMap& a, TestTbTestMap& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestMap* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestMap* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestMap>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestMap& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestMap& from) {
    TestTbTestMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestMap* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestMap";
  }
  protected:
  explicit TestTbTestMap(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestMap data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestMap* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMap >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMap>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestMap>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestMap& data_list(int index) const;
  ::cfg::TestTestMap* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMap >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestMap)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestMap > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestIndex final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestIndex) */ {
 public:
  inline TestTbTestIndex() : TestTbTestIndex(nullptr) {}
  ~TestTbTestIndex() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestIndex(::google::protobuf::internal::ConstantInitialized);

  TestTbTestIndex(const TestTbTestIndex& from);
  TestTbTestIndex(TestTbTestIndex&& from) noexcept
    : TestTbTestIndex() {
    *this = ::std::move(from);
  }

  inline TestTbTestIndex(::google::protobuf::Arena* arena, const TestTbTestIndex& from)
    : TestTbTestIndex(arena) {
    MergeFrom(from);
  }
  inline TestTbTestIndex& operator=(const TestTbTestIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestIndex& operator=(TestTbTestIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestIndex* internal_default_instance() {
    return reinterpret_cast<const TestTbTestIndex*>(
               &_TestTbTestIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(TestTbTestIndex& a, TestTbTestIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestIndex* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestIndex* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestIndex>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestIndex& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestIndex& from) {
    TestTbTestIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestIndex* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestIndex";
  }
  protected:
  explicit TestTbTestIndex(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestIndex data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestIndex* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestIndex >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestIndex>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestIndex>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestIndex& data_list(int index) const;
  ::cfg::TestTestIndex* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestIndex >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestIndex)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestIndex > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbItem2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbItem2) */ {
 public:
  inline TestTbItem2() : TestTbItem2(nullptr) {}
  ~TestTbItem2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbItem2(::google::protobuf::internal::ConstantInitialized);

  TestTbItem2(const TestTbItem2& from);
  TestTbItem2(TestTbItem2&& from) noexcept
    : TestTbItem2() {
    *this = ::std::move(from);
  }

  inline TestTbItem2(::google::protobuf::Arena* arena, const TestTbItem2& from)
    : TestTbItem2(arena) {
    MergeFrom(from);
  }
  inline TestTbItem2& operator=(const TestTbItem2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbItem2& operator=(TestTbItem2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbItem2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbItem2* internal_default_instance() {
    return reinterpret_cast<const TestTbItem2*>(
               &_TestTbItem2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(TestTbItem2& a, TestTbItem2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbItem2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbItem2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbItem2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbItem2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbItem2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbItem2& from) {
    TestTbItem2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbItem2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbItem2";
  }
  protected:
  explicit TestTbItem2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestItemBase data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestItemBase* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestItemBase >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestItemBase>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestItemBase>* _internal_mutable_data_list();
  public:
  const ::cfg::TestItemBase& data_list(int index) const;
  ::cfg::TestItemBase* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestItemBase >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbItem2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestItemBase > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbDemoPrimitive final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbDemoPrimitive) */ {
 public:
  inline TestTbDemoPrimitive() : TestTbDemoPrimitive(nullptr) {}
  ~TestTbDemoPrimitive() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbDemoPrimitive(::google::protobuf::internal::ConstantInitialized);

  TestTbDemoPrimitive(const TestTbDemoPrimitive& from);
  TestTbDemoPrimitive(TestTbDemoPrimitive&& from) noexcept
    : TestTbDemoPrimitive() {
    *this = ::std::move(from);
  }

  inline TestTbDemoPrimitive(::google::protobuf::Arena* arena, const TestTbDemoPrimitive& from)
    : TestTbDemoPrimitive(arena) {
    MergeFrom(from);
  }
  inline TestTbDemoPrimitive& operator=(const TestTbDemoPrimitive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbDemoPrimitive& operator=(TestTbDemoPrimitive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbDemoPrimitive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbDemoPrimitive* internal_default_instance() {
    return reinterpret_cast<const TestTbDemoPrimitive*>(
               &_TestTbDemoPrimitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(TestTbDemoPrimitive& a, TestTbDemoPrimitive& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbDemoPrimitive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbDemoPrimitive* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbDemoPrimitive* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbDemoPrimitive>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbDemoPrimitive& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbDemoPrimitive& from) {
    TestTbDemoPrimitive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbDemoPrimitive* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbDemoPrimitive";
  }
  protected:
  explicit TestTbDemoPrimitive(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestDemoPrimitiveTypesTable data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestDemoPrimitiveTypesTable* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoPrimitiveTypesTable >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoPrimitiveTypesTable>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoPrimitiveTypesTable>* _internal_mutable_data_list();
  public:
  const ::cfg::TestDemoPrimitiveTypesTable& data_list(int index) const;
  ::cfg::TestDemoPrimitiveTypesTable* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoPrimitiveTypesTable >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbDemoPrimitive)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoPrimitiveTypesTable > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbDemoGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbDemoGroup) */ {
 public:
  inline TestTbDemoGroup() : TestTbDemoGroup(nullptr) {}
  ~TestTbDemoGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbDemoGroup(::google::protobuf::internal::ConstantInitialized);

  TestTbDemoGroup(const TestTbDemoGroup& from);
  TestTbDemoGroup(TestTbDemoGroup&& from) noexcept
    : TestTbDemoGroup() {
    *this = ::std::move(from);
  }

  inline TestTbDemoGroup(::google::protobuf::Arena* arena, const TestTbDemoGroup& from)
    : TestTbDemoGroup(arena) {
    MergeFrom(from);
  }
  inline TestTbDemoGroup& operator=(const TestTbDemoGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbDemoGroup& operator=(TestTbDemoGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbDemoGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbDemoGroup* internal_default_instance() {
    return reinterpret_cast<const TestTbDemoGroup*>(
               &_TestTbDemoGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(TestTbDemoGroup& a, TestTbDemoGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbDemoGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbDemoGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbDemoGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbDemoGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbDemoGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbDemoGroup& from) {
    TestTbDemoGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbDemoGroup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbDemoGroup";
  }
  protected:
  explicit TestTbDemoGroup(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestDemoGroup data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestDemoGroup* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoGroup >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoGroup>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoGroup>* _internal_mutable_data_list();
  public:
  const ::cfg::TestDemoGroup& data_list(int index) const;
  ::cfg::TestDemoGroup* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoGroup >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbDemoGroup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoGroup > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiRowTitle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestMultiRowTitle) */ {
 public:
  inline TestMultiRowTitle() : TestMultiRowTitle(nullptr) {}
  ~TestMultiRowTitle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowTitle(::google::protobuf::internal::ConstantInitialized);

  TestMultiRowTitle(const TestMultiRowTitle& from);
  TestMultiRowTitle(TestMultiRowTitle&& from) noexcept
    : TestMultiRowTitle() {
    *this = ::std::move(from);
  }

  inline TestMultiRowTitle(::google::protobuf::Arena* arena, const TestMultiRowTitle& from)
    : TestMultiRowTitle(arena) {
    MergeFrom(from);
  }
  inline TestMultiRowTitle& operator=(const TestMultiRowTitle& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMultiRowTitle& operator=(TestMultiRowTitle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMultiRowTitle& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMultiRowTitle* internal_default_instance() {
    return reinterpret_cast<const TestMultiRowTitle*>(
               &_TestMultiRowTitle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(TestMultiRowTitle& a, TestMultiRowTitle& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMultiRowTitle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMultiRowTitle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMultiRowTitle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMultiRowTitle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMultiRowTitle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestMultiRowTitle& from) {
    TestMultiRowTitle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiRowTitle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestMultiRowTitle";
  }
  protected:
  explicit TestMultiRowTitle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX2FieldNumber = 5,
    kX3FieldNumber = 6,
    kX4FieldNumber = 7,
    kNameFieldNumber = 2,
    kX1FieldNumber = 3,
    kX20FieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // repeated .cfg.TestH2 x2 = 5 [packed = false];
  int x2_size() const;
  private:
  int _internal_x2_size() const;

  public:
  void clear_x2() ;
  ::cfg::TestH2* mutable_x2(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 >*
      mutable_x2();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>& _internal_x2() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestH2>* _internal_mutable_x2();
  public:
  const ::cfg::TestH2& x2(int index) const;
  ::cfg::TestH2* add_x2();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 >&
      x2() const;
  // repeated .cfg.TestH2 x3 = 6 [packed = false];
  int x3_size() const;
  private:
  int _internal_x3_size() const;

  public:
  void clear_x3() ;
  ::cfg::TestH2* mutable_x3(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 >*
      mutable_x3();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>& _internal_x3() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestH2>* _internal_mutable_x3();
  public:
  const ::cfg::TestH2& x3(int index) const;
  ::cfg::TestH2* add_x3();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 >&
      x3() const;
  // repeated .cfg.TestH2 x4 = 7 [packed = false];
  int x4_size() const;
  private:
  int _internal_x4_size() const;

  public:
  void clear_x4() ;
  ::cfg::TestH2* mutable_x4(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 >*
      mutable_x4();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>& _internal_x4() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestH2>* _internal_mutable_x4();
  public:
  const ::cfg::TestH2& x4(int index) const;
  ::cfg::TestH2* add_x4();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 >&
      x4() const;
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .cfg.TestH1 x1 = 3;
  bool has_x1() const;
  void clear_x1() ;
  const ::cfg::TestH1& x1() const;
  PROTOBUF_NODISCARD ::cfg::TestH1* release_x1();
  ::cfg::TestH1* mutable_x1();
  void set_allocated_x1(::cfg::TestH1* value);
  void unsafe_arena_set_allocated_x1(::cfg::TestH1* value);
  ::cfg::TestH1* unsafe_arena_release_x1();

  private:
  const ::cfg::TestH1& _internal_x1() const;
  ::cfg::TestH1* _internal_mutable_x1();

  public:
  // optional .cfg.TestH2 x2_0 = 4;
  bool has_x2_0() const;
  void clear_x2_0() ;
  const ::cfg::TestH2& x2_0() const;
  PROTOBUF_NODISCARD ::cfg::TestH2* release_x2_0();
  ::cfg::TestH2* mutable_x2_0();
  void set_allocated_x2_0(::cfg::TestH2* value);
  void unsafe_arena_set_allocated_x2_0(::cfg::TestH2* value);
  ::cfg::TestH2* unsafe_arena_release_x2_0();

  private:
  const ::cfg::TestH2& _internal_x2_0() const;
  ::cfg::TestH2* _internal_mutable_x2_0();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestMultiRowTitle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      34, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 > x2_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 > x3_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestH2 > x4_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::cfg::TestH1* x1_;
    ::cfg::TestH2* x2_0_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestMultiRowRecord final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestMultiRowRecord) */ {
 public:
  inline TestMultiRowRecord() : TestMultiRowRecord(nullptr) {}
  ~TestMultiRowRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestMultiRowRecord(::google::protobuf::internal::ConstantInitialized);

  TestMultiRowRecord(const TestMultiRowRecord& from);
  TestMultiRowRecord(TestMultiRowRecord&& from) noexcept
    : TestMultiRowRecord() {
    *this = ::std::move(from);
  }

  inline TestMultiRowRecord(::google::protobuf::Arena* arena, const TestMultiRowRecord& from)
    : TestMultiRowRecord(arena) {
    MergeFrom(from);
  }
  inline TestMultiRowRecord& operator=(const TestMultiRowRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMultiRowRecord& operator=(TestMultiRowRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMultiRowRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMultiRowRecord* internal_default_instance() {
    return reinterpret_cast<const TestMultiRowRecord*>(
               &_TestMultiRowRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(TestMultiRowRecord& a, TestMultiRowRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMultiRowRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMultiRowRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMultiRowRecord* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMultiRowRecord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMultiRowRecord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestMultiRowRecord& from) {
    TestMultiRowRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiRowRecord* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestMultiRowRecord";
  }
  protected:
  explicit TestMultiRowRecord(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOneRowsFieldNumber = 3,
    kMultiRows1FieldNumber = 4,
    kMultiRows2FieldNumber = 5,
    kMultiRows4FieldNumber = 6,
    kMultiRows5FieldNumber = 7,
    kMultiRows6FieldNumber = 8,
    kMultiRows7FieldNumber = 9,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .cfg.TestMultiRowType1 one_rows = 3 [packed = false];
  int one_rows_size() const;
  private:
  int _internal_one_rows_size() const;

  public:
  void clear_one_rows() ;
  ::cfg::TestMultiRowType1* mutable_one_rows(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >*
      mutable_one_rows();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& _internal_one_rows() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* _internal_mutable_one_rows();
  public:
  const ::cfg::TestMultiRowType1& one_rows(int index) const;
  ::cfg::TestMultiRowType1* add_one_rows();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >&
      one_rows() const;
  // repeated .cfg.TestMultiRowType1 multi_rows1 = 4 [packed = false];
  int multi_rows1_size() const;
  private:
  int _internal_multi_rows1_size() const;

  public:
  void clear_multi_rows1() ;
  ::cfg::TestMultiRowType1* mutable_multi_rows1(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >*
      mutable_multi_rows1();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& _internal_multi_rows1() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* _internal_mutable_multi_rows1();
  public:
  const ::cfg::TestMultiRowType1& multi_rows1(int index) const;
  ::cfg::TestMultiRowType1* add_multi_rows1();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >&
      multi_rows1() const;
  // repeated .cfg.TestMultiRowType1 multi_rows2 = 5 [packed = false];
  int multi_rows2_size() const;
  private:
  int _internal_multi_rows2_size() const;

  public:
  void clear_multi_rows2() ;
  ::cfg::TestMultiRowType1* mutable_multi_rows2(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >*
      mutable_multi_rows2();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& _internal_multi_rows2() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* _internal_mutable_multi_rows2();
  public:
  const ::cfg::TestMultiRowType1& multi_rows2(int index) const;
  ::cfg::TestMultiRowType1* add_multi_rows2();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 >&
      multi_rows2() const;
  // map<int32, .cfg.TestMultiRowType2> multi_rows4 = 6;
  int multi_rows4_size() const;
  private:
  int _internal_multi_rows4_size() const;

  public:
  void clear_multi_rows4() ;
  const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& multi_rows4() const;
  ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* mutable_multi_rows4();

  private:
  const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& _internal_multi_rows4() const;
  ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* _internal_mutable_multi_rows4();

  public:
  // repeated .cfg.TestMultiRowType3 multi_rows5 = 7 [packed = false];
  int multi_rows5_size() const;
  private:
  int _internal_multi_rows5_size() const;

  public:
  void clear_multi_rows5() ;
  ::cfg::TestMultiRowType3* mutable_multi_rows5(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType3 >*
      mutable_multi_rows5();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType3>& _internal_multi_rows5() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType3>* _internal_mutable_multi_rows5();
  public:
  const ::cfg::TestMultiRowType3& multi_rows5(int index) const;
  ::cfg::TestMultiRowType3* add_multi_rows5();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType3 >&
      multi_rows5() const;
  // map<int32, .cfg.TestMultiRowType2> multi_rows6 = 8;
  int multi_rows6_size() const;
  private:
  int _internal_multi_rows6_size() const;

  public:
  void clear_multi_rows6() ;
  const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& multi_rows6() const;
  ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* mutable_multi_rows6();

  private:
  const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& _internal_multi_rows6() const;
  ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* _internal_mutable_multi_rows6();

  public:
  // map<int32, int32> multi_rows7 = 9;
  int multi_rows7_size() const;
  private:
  int _internal_multi_rows7_size() const;

  public:
  void clear_multi_rows7() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& multi_rows7() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_multi_rows7();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_multi_rows7() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_multi_rows7();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestMultiRowRecord)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 9,
      43, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 > one_rows_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 > multi_rows1_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType1 > multi_rows2_;
    ::google::protobuf::internal::MapField<TestMultiRowRecord_MultiRows4Entry_DoNotUse, ::int32_t, ::cfg::TestMultiRowType2,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        multi_rows4_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowType3 > multi_rows5_;
    ::google::protobuf::internal::MapField<TestMultiRowRecord_MultiRows6Entry_DoNotUse, ::int32_t, ::cfg::TestMultiRowType2,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        multi_rows6_;
    ::google::protobuf::internal::MapField<TestMultiRowRecord_MultiRows7Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        multi_rows7_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestExcelFromJsonMultiRow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestExcelFromJsonMultiRow) */ {
 public:
  inline TestExcelFromJsonMultiRow() : TestExcelFromJsonMultiRow(nullptr) {}
  ~TestExcelFromJsonMultiRow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestExcelFromJsonMultiRow(::google::protobuf::internal::ConstantInitialized);

  TestExcelFromJsonMultiRow(const TestExcelFromJsonMultiRow& from);
  TestExcelFromJsonMultiRow(TestExcelFromJsonMultiRow&& from) noexcept
    : TestExcelFromJsonMultiRow() {
    *this = ::std::move(from);
  }

  inline TestExcelFromJsonMultiRow(::google::protobuf::Arena* arena, const TestExcelFromJsonMultiRow& from)
    : TestExcelFromJsonMultiRow(arena) {
    MergeFrom(from);
  }
  inline TestExcelFromJsonMultiRow& operator=(const TestExcelFromJsonMultiRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestExcelFromJsonMultiRow& operator=(TestExcelFromJsonMultiRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestExcelFromJsonMultiRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestExcelFromJsonMultiRow* internal_default_instance() {
    return reinterpret_cast<const TestExcelFromJsonMultiRow*>(
               &_TestExcelFromJsonMultiRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(TestExcelFromJsonMultiRow& a, TestExcelFromJsonMultiRow& b) {
    a.Swap(&b);
  }
  inline void Swap(TestExcelFromJsonMultiRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestExcelFromJsonMultiRow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestExcelFromJsonMultiRow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestExcelFromJsonMultiRow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestExcelFromJsonMultiRow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestExcelFromJsonMultiRow& from) {
    TestExcelFromJsonMultiRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestExcelFromJsonMultiRow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestExcelFromJsonMultiRow";
  }
  protected:
  explicit TestExcelFromJsonMultiRow(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
  };
  // repeated .cfg.TestTestRow items = 3 [packed = false];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::cfg::TestTestRow* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestRow >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestRow>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestRow>* _internal_mutable_items();
  public:
  const ::cfg::TestTestRow& items(int index) const;
  ::cfg::TestTestRow* add_items();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestRow >&
      items() const;
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 x = 2;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestExcelFromJsonMultiRow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestRow > items_;
    ::int32_t id_;
    ::int32_t x_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoDynamic final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoDynamic) */ {
 public:
  inline TestDemoDynamic() : TestDemoDynamic(nullptr) {}
  ~TestDemoDynamic() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoDynamic(::google::protobuf::internal::ConstantInitialized);

  TestDemoDynamic(const TestDemoDynamic& from);
  TestDemoDynamic(TestDemoDynamic&& from) noexcept
    : TestDemoDynamic() {
    *this = ::std::move(from);
  }

  inline TestDemoDynamic(::google::protobuf::Arena* arena, const TestDemoDynamic& from)
    : TestDemoDynamic(arena) {
    MergeFrom(from);
  }
  inline TestDemoDynamic& operator=(const TestDemoDynamic& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoDynamic& operator=(TestDemoDynamic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoDynamic& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kDemoD2 = 1,
    kDemoE1 = 2,
    kRoleInfo = 3,
    kDemoD5 = 4,
    VALUE_NOT_SET = 0,
  };

  static inline const TestDemoDynamic* internal_default_instance() {
    return reinterpret_cast<const TestDemoDynamic*>(
               &_TestDemoDynamic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(TestDemoDynamic& a, TestDemoDynamic& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoDynamic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoDynamic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoDynamic* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoDynamic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoDynamic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoDynamic& from) {
    TestDemoDynamic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoDynamic* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoDynamic";
  }
  protected:
  explicit TestDemoDynamic(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDemoD2FieldNumber = 1,
    kDemoE1FieldNumber = 2,
    kRoleInfoFieldNumber = 3,
    kDemoD5FieldNumber = 4,
  };
  // .cfg.TestDemoD2 DemoD2 = 1;
  bool has_demod2() const;
  private:
  bool _internal_has_demod2() const;

  public:
  void clear_demod2() ;
  const ::cfg::TestDemoD2& demod2() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoD2* release_demod2();
  ::cfg::TestDemoD2* mutable_demod2();
  void set_allocated_demod2(::cfg::TestDemoD2* value);
  void unsafe_arena_set_allocated_demod2(::cfg::TestDemoD2* value);
  ::cfg::TestDemoD2* unsafe_arena_release_demod2();

  private:
  const ::cfg::TestDemoD2& _internal_demod2() const;
  ::cfg::TestDemoD2* _internal_mutable_demod2();

  public:
  // .cfg.TestDemoE1 DemoE1 = 2;
  bool has_demoe1() const;
  private:
  bool _internal_has_demoe1() const;

  public:
  void clear_demoe1() ;
  const ::cfg::TestDemoE1& demoe1() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoE1* release_demoe1();
  ::cfg::TestDemoE1* mutable_demoe1();
  void set_allocated_demoe1(::cfg::TestDemoE1* value);
  void unsafe_arena_set_allocated_demoe1(::cfg::TestDemoE1* value);
  ::cfg::TestDemoE1* unsafe_arena_release_demoe1();

  private:
  const ::cfg::TestDemoE1& _internal_demoe1() const;
  ::cfg::TestDemoE1* _internal_mutable_demoe1();

  public:
  // .cfg.TestLoginRoleInfo RoleInfo = 3;
  bool has_roleinfo() const;
  private:
  bool _internal_has_roleinfo() const;

  public:
  void clear_roleinfo() ;
  const ::cfg::TestLoginRoleInfo& roleinfo() const;
  PROTOBUF_NODISCARD ::cfg::TestLoginRoleInfo* release_roleinfo();
  ::cfg::TestLoginRoleInfo* mutable_roleinfo();
  void set_allocated_roleinfo(::cfg::TestLoginRoleInfo* value);
  void unsafe_arena_set_allocated_roleinfo(::cfg::TestLoginRoleInfo* value);
  ::cfg::TestLoginRoleInfo* unsafe_arena_release_roleinfo();

  private:
  const ::cfg::TestLoginRoleInfo& _internal_roleinfo() const;
  ::cfg::TestLoginRoleInfo* _internal_mutable_roleinfo();

  public:
  // .cfg.TestDemoD5 DemoD5 = 4;
  bool has_demod5() const;
  private:
  bool _internal_has_demod5() const;

  public:
  void clear_demod5() ;
  const ::cfg::TestDemoD5& demod5() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoD5* release_demod5();
  ::cfg::TestDemoD5* mutable_demod5();
  void set_allocated_demod5(::cfg::TestDemoD5* value);
  void unsafe_arena_set_allocated_demod5(::cfg::TestDemoD5* value);
  ::cfg::TestDemoD5* unsafe_arena_release_demod5();

  private:
  const ::cfg::TestDemoD5& _internal_demod5() const;
  ::cfg::TestDemoD5* _internal_mutable_demod5();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.TestDemoDynamic)
 private:
  class _Internal;
  void set_has_demod2();
  void set_has_demoe1();
  void set_has_roleinfo();
  void set_has_demod5();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::TestDemoD2* demod2_;
      ::cfg::TestDemoE1* demoe1_;
      ::cfg::TestLoginRoleInfo* roleinfo_;
      ::cfg::TestDemoD5* demod5_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiTbBlackboard final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiTbBlackboard) */ {
 public:
  inline AiTbBlackboard() : AiTbBlackboard(nullptr) {}
  ~AiTbBlackboard() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiTbBlackboard(::google::protobuf::internal::ConstantInitialized);

  AiTbBlackboard(const AiTbBlackboard& from);
  AiTbBlackboard(AiTbBlackboard&& from) noexcept
    : AiTbBlackboard() {
    *this = ::std::move(from);
  }

  inline AiTbBlackboard(::google::protobuf::Arena* arena, const AiTbBlackboard& from)
    : AiTbBlackboard(arena) {
    MergeFrom(from);
  }
  inline AiTbBlackboard& operator=(const AiTbBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiTbBlackboard& operator=(AiTbBlackboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiTbBlackboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiTbBlackboard* internal_default_instance() {
    return reinterpret_cast<const AiTbBlackboard*>(
               &_AiTbBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(AiTbBlackboard& a, AiTbBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(AiTbBlackboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiTbBlackboard* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiTbBlackboard* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiTbBlackboard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiTbBlackboard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiTbBlackboard& from) {
    AiTbBlackboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiTbBlackboard* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiTbBlackboard";
  }
  protected:
  explicit AiTbBlackboard(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.AiBlackboard data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::AiBlackboard* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiBlackboard >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboard>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboard>* _internal_mutable_data_list();
  public:
  const ::cfg::AiBlackboard& data_list(int index) const;
  ::cfg::AiBlackboard* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiBlackboard >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.AiTbBlackboard)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiBlackboard > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiBinaryOperator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiBinaryOperator) */ {
 public:
  inline AiBinaryOperator() : AiBinaryOperator(nullptr) {}
  ~AiBinaryOperator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiBinaryOperator(::google::protobuf::internal::ConstantInitialized);

  AiBinaryOperator(const AiBinaryOperator& from);
  AiBinaryOperator(AiBinaryOperator&& from) noexcept
    : AiBinaryOperator() {
    *this = ::std::move(from);
  }

  inline AiBinaryOperator(::google::protobuf::Arena* arena, const AiBinaryOperator& from)
    : AiBinaryOperator(arena) {
    MergeFrom(from);
  }
  inline AiBinaryOperator& operator=(const AiBinaryOperator& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiBinaryOperator& operator=(AiBinaryOperator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiBinaryOperator& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiBinaryOperator* internal_default_instance() {
    return reinterpret_cast<const AiBinaryOperator*>(
               &_AiBinaryOperator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AiBinaryOperator& a, AiBinaryOperator& b) {
    a.Swap(&b);
  }
  inline void Swap(AiBinaryOperator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiBinaryOperator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiBinaryOperator* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiBinaryOperator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiBinaryOperator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiBinaryOperator& from) {
    AiBinaryOperator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiBinaryOperator* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiBinaryOperator";
  }
  protected:
  explicit AiBinaryOperator(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOperFieldNumber = 1,
  };
  // .cfg.AiKeyData data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::cfg::AiKeyData& data() const;
  PROTOBUF_NODISCARD ::cfg::AiKeyData* release_data();
  ::cfg::AiKeyData* mutable_data();
  void set_allocated_data(::cfg::AiKeyData* value);
  void unsafe_arena_set_allocated_data(::cfg::AiKeyData* value);
  ::cfg::AiKeyData* unsafe_arena_release_data();

  private:
  const ::cfg::AiKeyData& _internal_data() const;
  ::cfg::AiKeyData* _internal_mutable_data();

  public:
  // .cfg.AiEOperator oper = 1;
  void clear_oper() ;
  ::cfg::AiEOperator oper() const;
  void set_oper(::cfg::AiEOperator value);

  private:
  ::cfg::AiEOperator _internal_oper() const;
  void _internal_set_oper(::cfg::AiEOperator value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiBinaryOperator)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::cfg::AiKeyData* data_;
    int oper_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTestNull final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTestNull) */ {
 public:
  inline TestTestNull() : TestTestNull(nullptr) {}
  ~TestTestNull() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTestNull(::google::protobuf::internal::ConstantInitialized);

  TestTestNull(const TestTestNull& from);
  TestTestNull(TestTestNull&& from) noexcept
    : TestTestNull() {
    *this = ::std::move(from);
  }

  inline TestTestNull(::google::protobuf::Arena* arena, const TestTestNull& from)
    : TestTestNull(arena) {
    MergeFrom(from);
  }
  inline TestTestNull& operator=(const TestTestNull& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTestNull& operator=(TestTestNull&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTestNull& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTestNull* internal_default_instance() {
    return reinterpret_cast<const TestTestNull*>(
               &_TestTestNull_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(TestTestNull& a, TestTestNull& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTestNull* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTestNull* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTestNull* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTestNull>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTestNull& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTestNull& from) {
    TestTestNull::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTestNull* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTestNull";
  }
  protected:
  explicit TestTestNull(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 6,
    kS2FieldNumber = 7,
    kX3FieldNumber = 4,
    kX4FieldNumber = 5,
    kIdFieldNumber = 1,
    kX1FieldNumber = 2,
    kX2FieldNumber = 3,
  };
  // optional string s1 = 6;
  bool has_s1() const;
  void clear_s1() ;
  const std::string& s1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s1(Arg_&& arg, Args_... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* ptr);

  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(
      const std::string& value);
  std::string* _internal_mutable_s1();

  public:
  // optional string s2 = 7;
  bool has_s2() const;
  void clear_s2() ;
  const std::string& s2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s2(Arg_&& arg, Args_... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* ptr);

  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(
      const std::string& value);
  std::string* _internal_mutable_s2();

  public:
  // optional .cfg.TestDemoType1 x3 = 4;
  bool has_x3() const;
  void clear_x3() ;
  const ::cfg::TestDemoType1& x3() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoType1* release_x3();
  ::cfg::TestDemoType1* mutable_x3();
  void set_allocated_x3(::cfg::TestDemoType1* value);
  void unsafe_arena_set_allocated_x3(::cfg::TestDemoType1* value);
  ::cfg::TestDemoType1* unsafe_arena_release_x3();

  private:
  const ::cfg::TestDemoType1& _internal_x3() const;
  ::cfg::TestDemoType1* _internal_mutable_x3();

  public:
  // optional .cfg.TestDemoDynamic x4 = 5;
  bool has_x4() const;
  void clear_x4() ;
  const ::cfg::TestDemoDynamic& x4() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoDynamic* release_x4();
  ::cfg::TestDemoDynamic* mutable_x4();
  void set_allocated_x4(::cfg::TestDemoDynamic* value);
  void unsafe_arena_set_allocated_x4(::cfg::TestDemoDynamic* value);
  ::cfg::TestDemoDynamic* unsafe_arena_release_x4();

  private:
  const ::cfg::TestDemoDynamic& _internal_x4() const;
  ::cfg::TestDemoDynamic* _internal_mutable_x4();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // optional int32 x1 = 2;
  bool has_x1() const;
  void clear_x1() ;
  ::int32_t x1() const;
  void set_x1(::int32_t value);

  private:
  ::int32_t _internal_x1() const;
  void _internal_set_x1(::int32_t value);

  public:
  // optional .cfg.TestDemoEnum x2 = 3;
  bool has_x2() const;
  void clear_x2() ;
  ::cfg::TestDemoEnum x2() const;
  void set_x2(::cfg::TestDemoEnum value);

  private:
  ::cfg::TestDemoEnum _internal_x2() const;
  void _internal_set_x2(::cfg::TestDemoEnum value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestTestNull)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      29, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr s1_;
    ::google::protobuf::internal::ArenaStringPtr s2_;
    ::cfg::TestDemoType1* x3_;
    ::cfg::TestDemoDynamic* x4_;
    ::int32_t id_;
    ::int32_t x1_;
    int x2_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestRef final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestRef) */ {
 public:
  inline TestTbTestRef() : TestTbTestRef(nullptr) {}
  ~TestTbTestRef() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestRef(::google::protobuf::internal::ConstantInitialized);

  TestTbTestRef(const TestTbTestRef& from);
  TestTbTestRef(TestTbTestRef&& from) noexcept
    : TestTbTestRef() {
    *this = ::std::move(from);
  }

  inline TestTbTestRef(::google::protobuf::Arena* arena, const TestTbTestRef& from)
    : TestTbTestRef(arena) {
    MergeFrom(from);
  }
  inline TestTbTestRef& operator=(const TestTbTestRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestRef& operator=(TestTbTestRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestRef* internal_default_instance() {
    return reinterpret_cast<const TestTbTestRef*>(
               &_TestTbTestRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(TestTbTestRef& a, TestTbTestRef& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestRef* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestRef& from) {
    TestTbTestRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestRef* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestRef";
  }
  protected:
  explicit TestTbTestRef(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestRef data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestRef* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestRef >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestRef>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestRef>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestRef& data_list(int index) const;
  ::cfg::TestTestRef* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestRef >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestRef)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestRef > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbMultiRowTitle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbMultiRowTitle) */ {
 public:
  inline TestTbMultiRowTitle() : TestTbMultiRowTitle(nullptr) {}
  ~TestTbMultiRowTitle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbMultiRowTitle(::google::protobuf::internal::ConstantInitialized);

  TestTbMultiRowTitle(const TestTbMultiRowTitle& from);
  TestTbMultiRowTitle(TestTbMultiRowTitle&& from) noexcept
    : TestTbMultiRowTitle() {
    *this = ::std::move(from);
  }

  inline TestTbMultiRowTitle(::google::protobuf::Arena* arena, const TestTbMultiRowTitle& from)
    : TestTbMultiRowTitle(arena) {
    MergeFrom(from);
  }
  inline TestTbMultiRowTitle& operator=(const TestTbMultiRowTitle& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbMultiRowTitle& operator=(TestTbMultiRowTitle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbMultiRowTitle& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbMultiRowTitle* internal_default_instance() {
    return reinterpret_cast<const TestTbMultiRowTitle*>(
               &_TestTbMultiRowTitle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(TestTbMultiRowTitle& a, TestTbMultiRowTitle& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbMultiRowTitle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbMultiRowTitle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbMultiRowTitle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbMultiRowTitle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbMultiRowTitle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbMultiRowTitle& from) {
    TestTbMultiRowTitle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbMultiRowTitle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbMultiRowTitle";
  }
  protected:
  explicit TestTbMultiRowTitle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestMultiRowTitle data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestMultiRowTitle* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowTitle >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowTitle>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowTitle>* _internal_mutable_data_list();
  public:
  const ::cfg::TestMultiRowTitle& data_list(int index) const;
  ::cfg::TestMultiRowTitle* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowTitle >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbMultiRowTitle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowTitle > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbMultiRowRecord final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbMultiRowRecord) */ {
 public:
  inline TestTbMultiRowRecord() : TestTbMultiRowRecord(nullptr) {}
  ~TestTbMultiRowRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbMultiRowRecord(::google::protobuf::internal::ConstantInitialized);

  TestTbMultiRowRecord(const TestTbMultiRowRecord& from);
  TestTbMultiRowRecord(TestTbMultiRowRecord&& from) noexcept
    : TestTbMultiRowRecord() {
    *this = ::std::move(from);
  }

  inline TestTbMultiRowRecord(::google::protobuf::Arena* arena, const TestTbMultiRowRecord& from)
    : TestTbMultiRowRecord(arena) {
    MergeFrom(from);
  }
  inline TestTbMultiRowRecord& operator=(const TestTbMultiRowRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbMultiRowRecord& operator=(TestTbMultiRowRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbMultiRowRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbMultiRowRecord* internal_default_instance() {
    return reinterpret_cast<const TestTbMultiRowRecord*>(
               &_TestTbMultiRowRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(TestTbMultiRowRecord& a, TestTbMultiRowRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbMultiRowRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbMultiRowRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbMultiRowRecord* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbMultiRowRecord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbMultiRowRecord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbMultiRowRecord& from) {
    TestTbMultiRowRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbMultiRowRecord* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbMultiRowRecord";
  }
  protected:
  explicit TestTbMultiRowRecord(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestMultiRowRecord data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestMultiRowRecord* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowRecord >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowRecord>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowRecord>* _internal_mutable_data_list();
  public:
  const ::cfg::TestMultiRowRecord& data_list(int index) const;
  ::cfg::TestMultiRowRecord* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowRecord >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbMultiRowRecord)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestMultiRowRecord > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbExcelFromJsonMultiRow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbExcelFromJsonMultiRow) */ {
 public:
  inline TestTbExcelFromJsonMultiRow() : TestTbExcelFromJsonMultiRow(nullptr) {}
  ~TestTbExcelFromJsonMultiRow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbExcelFromJsonMultiRow(::google::protobuf::internal::ConstantInitialized);

  TestTbExcelFromJsonMultiRow(const TestTbExcelFromJsonMultiRow& from);
  TestTbExcelFromJsonMultiRow(TestTbExcelFromJsonMultiRow&& from) noexcept
    : TestTbExcelFromJsonMultiRow() {
    *this = ::std::move(from);
  }

  inline TestTbExcelFromJsonMultiRow(::google::protobuf::Arena* arena, const TestTbExcelFromJsonMultiRow& from)
    : TestTbExcelFromJsonMultiRow(arena) {
    MergeFrom(from);
  }
  inline TestTbExcelFromJsonMultiRow& operator=(const TestTbExcelFromJsonMultiRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbExcelFromJsonMultiRow& operator=(TestTbExcelFromJsonMultiRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbExcelFromJsonMultiRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbExcelFromJsonMultiRow* internal_default_instance() {
    return reinterpret_cast<const TestTbExcelFromJsonMultiRow*>(
               &_TestTbExcelFromJsonMultiRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(TestTbExcelFromJsonMultiRow& a, TestTbExcelFromJsonMultiRow& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbExcelFromJsonMultiRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbExcelFromJsonMultiRow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbExcelFromJsonMultiRow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbExcelFromJsonMultiRow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbExcelFromJsonMultiRow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbExcelFromJsonMultiRow& from) {
    TestTbExcelFromJsonMultiRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbExcelFromJsonMultiRow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbExcelFromJsonMultiRow";
  }
  protected:
  explicit TestTbExcelFromJsonMultiRow(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestExcelFromJsonMultiRow data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestExcelFromJsonMultiRow* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestExcelFromJsonMultiRow >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJsonMultiRow>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJsonMultiRow>* _internal_mutable_data_list();
  public:
  const ::cfg::TestExcelFromJsonMultiRow& data_list(int index) const;
  ::cfg::TestExcelFromJsonMultiRow* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestExcelFromJsonMultiRow >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbExcelFromJsonMultiRow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestExcelFromJsonMultiRow > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestExcelFromJson final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestExcelFromJson) */ {
 public:
  inline TestExcelFromJson() : TestExcelFromJson(nullptr) {}
  ~TestExcelFromJson() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestExcelFromJson(::google::protobuf::internal::ConstantInitialized);

  TestExcelFromJson(const TestExcelFromJson& from);
  TestExcelFromJson(TestExcelFromJson&& from) noexcept
    : TestExcelFromJson() {
    *this = ::std::move(from);
  }

  inline TestExcelFromJson(::google::protobuf::Arena* arena, const TestExcelFromJson& from)
    : TestExcelFromJson(arena) {
    MergeFrom(from);
  }
  inline TestExcelFromJson& operator=(const TestExcelFromJson& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestExcelFromJson& operator=(TestExcelFromJson&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestExcelFromJson& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestExcelFromJson* internal_default_instance() {
    return reinterpret_cast<const TestExcelFromJson*>(
               &_TestExcelFromJson_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(TestExcelFromJson& a, TestExcelFromJson& b) {
    a.Swap(&b);
  }
  inline void Swap(TestExcelFromJson* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestExcelFromJson* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestExcelFromJson* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestExcelFromJson>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestExcelFromJson& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestExcelFromJson& from) {
    TestExcelFromJson::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestExcelFromJson* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestExcelFromJson";
  }
  protected:
  explicit TestExcelFromJson(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kK1FieldNumber = 11,
    kK8FieldNumber = 12,
    kK9FieldNumber = 13,
    kK15FieldNumber = 14,
    kS1FieldNumber = 5,
    kS2FieldNumber = 6,
    kX12FieldNumber = 8,
    kX14FieldNumber = 10,
    kX4FieldNumber = 1,
    kX1FieldNumber = 2,
    kX5FieldNumber = 3,
    kX6FieldNumber = 4,
    kX13FieldNumber = 9,
    kT1FieldNumber = 7,
  };
  // repeated int32 k1 = 11 [packed = true];
  int k1_size() const;
  private:
  int _internal_k1_size() const;

  public:
  void clear_k1() ;
  ::int32_t k1(int index) const;
  void set_k1(int index, ::int32_t value);
  void add_k1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& k1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_k1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_k1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_k1();

  public:
  // map<int32, int32> k8 = 12;
  int k8_size() const;
  private:
  int _internal_k8_size() const;

  public:
  void clear_k8() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& k8() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_k8();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_k8() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_k8();

  public:
  // repeated .cfg.TestDemoE2 k9 = 13 [packed = false];
  int k9_size() const;
  private:
  int _internal_k9_size() const;

  public:
  void clear_k9() ;
  ::cfg::TestDemoE2* mutable_k9(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 >*
      mutable_k9();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>& _internal_k9() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>* _internal_mutable_k9();
  public:
  const ::cfg::TestDemoE2& k9(int index) const;
  ::cfg::TestDemoE2* add_k9();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 >&
      k9() const;
  // repeated .cfg.TestDemoDynamic k15 = 14 [packed = false];
  int k15_size() const;
  private:
  int _internal_k15_size() const;

  public:
  void clear_k15() ;
  ::cfg::TestDemoDynamic* mutable_k15(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoDynamic >*
      mutable_k15();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>& _internal_k15() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>* _internal_mutable_k15();
  public:
  const ::cfg::TestDemoDynamic& k15(int index) const;
  ::cfg::TestDemoDynamic* add_k15();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoDynamic >&
      k15() const;
  // string s1 = 5;
  void clear_s1() ;
  const std::string& s1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s1(Arg_&& arg, Args_... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* ptr);

  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(
      const std::string& value);
  std::string* _internal_mutable_s1();

  public:
  // string s2 = 6;
  void clear_s2() ;
  const std::string& s2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s2(Arg_&& arg, Args_... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* ptr);

  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(
      const std::string& value);
  std::string* _internal_mutable_s2();

  public:
  // .cfg.TestDemoType1 x12 = 8;
  bool has_x12() const;
  void clear_x12() ;
  const ::cfg::TestDemoType1& x12() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoType1* release_x12();
  ::cfg::TestDemoType1* mutable_x12();
  void set_allocated_x12(::cfg::TestDemoType1* value);
  void unsafe_arena_set_allocated_x12(::cfg::TestDemoType1* value);
  ::cfg::TestDemoType1* unsafe_arena_release_x12();

  private:
  const ::cfg::TestDemoType1& _internal_x12() const;
  ::cfg::TestDemoType1* _internal_mutable_x12();

  public:
  // .cfg.TestDemoDynamic x14 = 10;
  bool has_x14() const;
  void clear_x14() ;
  const ::cfg::TestDemoDynamic& x14() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoDynamic* release_x14();
  ::cfg::TestDemoDynamic* mutable_x14();
  void set_allocated_x14(::cfg::TestDemoDynamic* value);
  void unsafe_arena_set_allocated_x14(::cfg::TestDemoDynamic* value);
  ::cfg::TestDemoDynamic* unsafe_arena_release_x14();

  private:
  const ::cfg::TestDemoDynamic& _internal_x14() const;
  ::cfg::TestDemoDynamic* _internal_mutable_x14();

  public:
  // int32 x4 = 1;
  void clear_x4() ;
  ::int32_t x4() const;
  void set_x4(::int32_t value);

  private:
  ::int32_t _internal_x4() const;
  void _internal_set_x4(::int32_t value);

  public:
  // bool x1 = 2;
  void clear_x1() ;
  bool x1() const;
  void set_x1(bool value);

  private:
  bool _internal_x1() const;
  void _internal_set_x1(bool value);

  public:
  // int64 x5 = 3;
  void clear_x5() ;
  ::int64_t x5() const;
  void set_x5(::int64_t value);

  private:
  ::int64_t _internal_x5() const;
  void _internal_set_x5(::int64_t value);

  public:
  // float x6 = 4;
  void clear_x6() ;
  float x6() const;
  void set_x6(float value);

  private:
  float _internal_x6() const;
  void _internal_set_x6(float value);

  public:
  // .cfg.TestDemoEnum x13 = 9;
  void clear_x13() ;
  ::cfg::TestDemoEnum x13() const;
  void set_x13(::cfg::TestDemoEnum value);

  private:
  ::cfg::TestDemoEnum _internal_x13() const;
  void _internal_set_x13(::cfg::TestDemoEnum value);

  public:
  // int64 t1 = 7;
  void clear_t1() ;
  ::int64_t t1() const;
  void set_t1(::int64_t value);

  private:
  ::int64_t _internal_t1() const;
  void _internal_set_t1(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestExcelFromJson)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 5,
      42, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> k1_;
    mutable ::google::protobuf::internal::CachedSize _k1_cached_byte_size_;
    ::google::protobuf::internal::MapField<TestExcelFromJson_K8Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        k8_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 > k9_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoDynamic > k15_;
    ::google::protobuf::internal::ArenaStringPtr s1_;
    ::google::protobuf::internal::ArenaStringPtr s2_;
    ::cfg::TestDemoType1* x12_;
    ::cfg::TestDemoDynamic* x14_;
    ::int32_t x4_;
    bool x1_;
    ::int64_t x5_;
    float x6_;
    int x13_;
    ::int64_t t1_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoType2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoType2) */ {
 public:
  inline TestDemoType2() : TestDemoType2(nullptr) {}
  ~TestDemoType2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoType2(::google::protobuf::internal::ConstantInitialized);

  TestDemoType2(const TestDemoType2& from);
  TestDemoType2(TestDemoType2&& from) noexcept
    : TestDemoType2() {
    *this = ::std::move(from);
  }

  inline TestDemoType2(::google::protobuf::Arena* arena, const TestDemoType2& from)
    : TestDemoType2(arena) {
    MergeFrom(from);
  }
  inline TestDemoType2& operator=(const TestDemoType2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoType2& operator=(TestDemoType2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoType2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoType2* internal_default_instance() {
    return reinterpret_cast<const TestDemoType2*>(
               &_TestDemoType2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(TestDemoType2& a, TestDemoType2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoType2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoType2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoType2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoType2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoType2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoType2& from) {
    TestDemoType2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoType2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoType2";
  }
  protected:
  explicit TestDemoType2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kK1FieldNumber = 17,
    kK2FieldNumber = 18,
    kK5FieldNumber = 19,
    kK8FieldNumber = 20,
    kK9FieldNumber = 21,
    kK15FieldNumber = 22,
    kX10FieldNumber = 11,
    kS1FieldNumber = 15,
    kX12FieldNumber = 12,
    kX14FieldNumber = 14,
    kX4FieldNumber = 1,
    kX1FieldNumber = 2,
    kX2FieldNumber = 3,
    kX3FieldNumber = 4,
    kX5FieldNumber = 5,
    kX7FieldNumber = 7,
    kX6FieldNumber = 6,
    kX80FieldNumber = 8,
    kX9FieldNumber = 10,
    kX8FieldNumber = 9,
    kX13FieldNumber = 13,
    kT1FieldNumber = 16,
  };
  // repeated int32 k1 = 17 [packed = true];
  int k1_size() const;
  private:
  int _internal_k1_size() const;

  public:
  void clear_k1() ;
  ::int32_t k1(int index) const;
  void set_k1(int index, ::int32_t value);
  void add_k1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& k1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_k1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_k1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_k1();

  public:
  // repeated int32 k2 = 18 [packed = true];
  int k2_size() const;
  private:
  int _internal_k2_size() const;

  public:
  void clear_k2() ;
  ::int32_t k2(int index) const;
  void set_k2(int index, ::int32_t value);
  void add_k2(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& k2() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_k2();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_k2() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_k2();

  public:
  // repeated int32 k5 = 19 [packed = true];
  int k5_size() const;
  private:
  int _internal_k5_size() const;

  public:
  void clear_k5() ;
  ::int32_t k5(int index) const;
  void set_k5(int index, ::int32_t value);
  void add_k5(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& k5() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_k5();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_k5() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_k5();

  public:
  // map<int32, int32> k8 = 20;
  int k8_size() const;
  private:
  int _internal_k8_size() const;

  public:
  void clear_k8() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& k8() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_k8();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_k8() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_k8();

  public:
  // repeated .cfg.TestDemoE2 k9 = 21 [packed = false];
  int k9_size() const;
  private:
  int _internal_k9_size() const;

  public:
  void clear_k9() ;
  ::cfg::TestDemoE2* mutable_k9(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 >*
      mutable_k9();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>& _internal_k9() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>* _internal_mutable_k9();
  public:
  const ::cfg::TestDemoE2& k9(int index) const;
  ::cfg::TestDemoE2* add_k9();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 >&
      k9() const;
  // repeated .cfg.TestDemoDynamic k15 = 22 [packed = false];
  int k15_size() const;
  private:
  int _internal_k15_size() const;

  public:
  void clear_k15() ;
  ::cfg::TestDemoDynamic* mutable_k15(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoDynamic >*
      mutable_k15();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>& _internal_k15() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>* _internal_mutable_k15();
  public:
  const ::cfg::TestDemoDynamic& k15(int index) const;
  ::cfg::TestDemoDynamic* add_k15();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoDynamic >&
      k15() const;
  // string x10 = 11;
  void clear_x10() ;
  const std::string& x10() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_x10(Arg_&& arg, Args_... args);
  std::string* mutable_x10();
  PROTOBUF_NODISCARD std::string* release_x10();
  void set_allocated_x10(std::string* ptr);

  private:
  const std::string& _internal_x10() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x10(
      const std::string& value);
  std::string* _internal_mutable_x10();

  public:
  // string s1 = 15;
  void clear_s1() ;
  const std::string& s1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s1(Arg_&& arg, Args_... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* ptr);

  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(
      const std::string& value);
  std::string* _internal_mutable_s1();

  public:
  // .cfg.TestDemoType1 x12 = 12;
  bool has_x12() const;
  void clear_x12() ;
  const ::cfg::TestDemoType1& x12() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoType1* release_x12();
  ::cfg::TestDemoType1* mutable_x12();
  void set_allocated_x12(::cfg::TestDemoType1* value);
  void unsafe_arena_set_allocated_x12(::cfg::TestDemoType1* value);
  ::cfg::TestDemoType1* unsafe_arena_release_x12();

  private:
  const ::cfg::TestDemoType1& _internal_x12() const;
  ::cfg::TestDemoType1* _internal_mutable_x12();

  public:
  // .cfg.TestDemoDynamic x14 = 14;
  bool has_x14() const;
  void clear_x14() ;
  const ::cfg::TestDemoDynamic& x14() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoDynamic* release_x14();
  ::cfg::TestDemoDynamic* mutable_x14();
  void set_allocated_x14(::cfg::TestDemoDynamic* value);
  void unsafe_arena_set_allocated_x14(::cfg::TestDemoDynamic* value);
  ::cfg::TestDemoDynamic* unsafe_arena_release_x14();

  private:
  const ::cfg::TestDemoDynamic& _internal_x14() const;
  ::cfg::TestDemoDynamic* _internal_mutable_x14();

  public:
  // int32 x4 = 1;
  void clear_x4() ;
  ::int32_t x4() const;
  void set_x4(::int32_t value);

  private:
  ::int32_t _internal_x4() const;
  void _internal_set_x4(::int32_t value);

  public:
  // bool x1 = 2;
  void clear_x1() ;
  bool x1() const;
  void set_x1(bool value);

  private:
  bool _internal_x1() const;
  void _internal_set_x1(bool value);

  public:
  // int32 x2 = 3;
  void clear_x2() ;
  ::int32_t x2() const;
  void set_x2(::int32_t value);

  private:
  ::int32_t _internal_x2() const;
  void _internal_set_x2(::int32_t value);

  public:
  // int32 x3 = 4;
  void clear_x3() ;
  ::int32_t x3() const;
  void set_x3(::int32_t value);

  private:
  ::int32_t _internal_x3() const;
  void _internal_set_x3(::int32_t value);

  public:
  // int64 x5 = 5;
  void clear_x5() ;
  ::int64_t x5() const;
  void set_x5(::int64_t value);

  private:
  ::int64_t _internal_x5() const;
  void _internal_set_x5(::int64_t value);

  public:
  // double x7 = 7;
  void clear_x7() ;
  double x7() const;
  void set_x7(double value);

  private:
  double _internal_x7() const;
  void _internal_set_x7(double value);

  public:
  // float x6 = 6;
  void clear_x6() ;
  float x6() const;
  void set_x6(float value);

  private:
  float _internal_x6() const;
  void _internal_set_x6(float value);

  public:
  // int32 x8_0 = 8;
  void clear_x8_0() ;
  ::int32_t x8_0() const;
  void set_x8_0(::int32_t value);

  private:
  ::int32_t _internal_x8_0() const;
  void _internal_set_x8_0(::int32_t value);

  public:
  // int64 x9 = 10;
  void clear_x9() ;
  ::int64_t x9() const;
  void set_x9(::int64_t value);

  private:
  ::int64_t _internal_x9() const;
  void _internal_set_x9(::int64_t value);

  public:
  // int32 x8 = 9;
  void clear_x8() ;
  ::int32_t x8() const;
  void set_x8(::int32_t value);

  private:
  ::int32_t _internal_x8() const;
  void _internal_set_x8(::int32_t value);

  public:
  // .cfg.TestDemoEnum x13 = 13;
  void clear_x13() ;
  ::cfg::TestDemoEnum x13() const;
  void set_x13(::cfg::TestDemoEnum value);

  private:
  ::cfg::TestDemoEnum _internal_x13() const;
  void _internal_set_x13(::cfg::TestDemoEnum value);

  public:
  // int64 t1 = 16;
  void clear_t1() ;
  ::int64_t t1() const;
  void set_t1(::int64_t value);

  private:
  ::int64_t _internal_t1() const;
  void _internal_set_t1(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoType2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 22, 5,
      47, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> k1_;
    mutable ::google::protobuf::internal::CachedSize _k1_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> k2_;
    mutable ::google::protobuf::internal::CachedSize _k2_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> k5_;
    mutable ::google::protobuf::internal::CachedSize _k5_cached_byte_size_;
    ::google::protobuf::internal::MapField<TestDemoType2_K8Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        k8_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 > k9_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoDynamic > k15_;
    ::google::protobuf::internal::ArenaStringPtr x10_;
    ::google::protobuf::internal::ArenaStringPtr s1_;
    ::cfg::TestDemoType1* x12_;
    ::cfg::TestDemoDynamic* x14_;
    ::int32_t x4_;
    bool x1_;
    ::int32_t x2_;
    ::int32_t x3_;
    ::int64_t x5_;
    double x7_;
    float x6_;
    ::int32_t x8_0_;
    ::int64_t x9_;
    ::int32_t x8_;
    int x13_;
    ::int64_t t1_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestDemoSingletonType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestDemoSingletonType) */ {
 public:
  inline TestDemoSingletonType() : TestDemoSingletonType(nullptr) {}
  ~TestDemoSingletonType() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestDemoSingletonType(::google::protobuf::internal::ConstantInitialized);

  TestDemoSingletonType(const TestDemoSingletonType& from);
  TestDemoSingletonType(TestDemoSingletonType&& from) noexcept
    : TestDemoSingletonType() {
    *this = ::std::move(from);
  }

  inline TestDemoSingletonType(::google::protobuf::Arena* arena, const TestDemoSingletonType& from)
    : TestDemoSingletonType(arena) {
    MergeFrom(from);
  }
  inline TestDemoSingletonType& operator=(const TestDemoSingletonType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDemoSingletonType& operator=(TestDemoSingletonType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDemoSingletonType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDemoSingletonType* internal_default_instance() {
    return reinterpret_cast<const TestDemoSingletonType*>(
               &_TestDemoSingletonType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(TestDemoSingletonType& a, TestDemoSingletonType& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDemoSingletonType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDemoSingletonType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDemoSingletonType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDemoSingletonType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestDemoSingletonType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestDemoSingletonType& from) {
    TestDemoSingletonType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDemoSingletonType* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestDemoSingletonType";
  }
  protected:
  explicit TestDemoSingletonType(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDateFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .cfg.TestDemoDynamic date = 3;
  bool has_date() const;
  void clear_date() ;
  const ::cfg::TestDemoDynamic& date() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoDynamic* release_date();
  ::cfg::TestDemoDynamic* mutable_date();
  void set_allocated_date(::cfg::TestDemoDynamic* value);
  void unsafe_arena_set_allocated_date(::cfg::TestDemoDynamic* value);
  ::cfg::TestDemoDynamic* unsafe_arena_release_date();

  private:
  const ::cfg::TestDemoDynamic& _internal_date() const;
  ::cfg::TestDemoDynamic* _internal_mutable_date();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.TestDemoSingletonType)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      38, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::cfg::TestDemoDynamic* date_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class DefineFromExcel2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.DefineFromExcel2) */ {
 public:
  inline DefineFromExcel2() : DefineFromExcel2(nullptr) {}
  ~DefineFromExcel2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DefineFromExcel2(::google::protobuf::internal::ConstantInitialized);

  DefineFromExcel2(const DefineFromExcel2& from);
  DefineFromExcel2(DefineFromExcel2&& from) noexcept
    : DefineFromExcel2() {
    *this = ::std::move(from);
  }

  inline DefineFromExcel2(::google::protobuf::Arena* arena, const DefineFromExcel2& from)
    : DefineFromExcel2(arena) {
    MergeFrom(from);
  }
  inline DefineFromExcel2& operator=(const DefineFromExcel2& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefineFromExcel2& operator=(DefineFromExcel2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefineFromExcel2& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefineFromExcel2* internal_default_instance() {
    return reinterpret_cast<const DefineFromExcel2*>(
               &_DefineFromExcel2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(DefineFromExcel2& a, DefineFromExcel2& b) {
    a.Swap(&b);
  }
  inline void Swap(DefineFromExcel2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefineFromExcel2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefineFromExcel2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefineFromExcel2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DefineFromExcel2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DefineFromExcel2& from) {
    DefineFromExcel2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefineFromExcel2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.DefineFromExcel2";
  }
  protected:
  explicit DefineFromExcel2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kK1FieldNumber = 13,
    kK2FieldNumber = 14,
    kK8FieldNumber = 15,
    kK9FieldNumber = 16,
    kK10FieldNumber = 17,
    kK11FieldNumber = 18,
    kX10FieldNumber = 6,
    kX14FieldNumber = 9,
    kX15FieldNumber = 10,
    kV2FieldNumber = 11,
    kIdFieldNumber = 1,
    kX1FieldNumber = 2,
    kX5FieldNumber = 3,
    kX6FieldNumber = 4,
    kX8FieldNumber = 5,
    kX13FieldNumber = 7,
    kX132FieldNumber = 8,
    kT1FieldNumber = 12,
  };
  // repeated int32 k1 = 13 [packed = true];
  int k1_size() const;
  private:
  int _internal_k1_size() const;

  public:
  void clear_k1() ;
  ::int32_t k1(int index) const;
  void set_k1(int index, ::int32_t value);
  void add_k1(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& k1() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_k1();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_k1() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_k1();

  public:
  // repeated int32 k2 = 14 [packed = true];
  int k2_size() const;
  private:
  int _internal_k2_size() const;

  public:
  void clear_k2() ;
  ::int32_t k2(int index) const;
  void set_k2(int index, ::int32_t value);
  void add_k2(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& k2() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_k2();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_k2() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_k2();

  public:
  // map<int32, int32> k8 = 15;
  int k8_size() const;
  private:
  int _internal_k8_size() const;

  public:
  void clear_k8() ;
  const ::google::protobuf::Map<::int32_t, ::int32_t>& k8() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* mutable_k8();

  private:
  const ::google::protobuf::Map<::int32_t, ::int32_t>& _internal_k8() const;
  ::google::protobuf::Map<::int32_t, ::int32_t>* _internal_mutable_k8();

  public:
  // repeated .cfg.TestDemoE2 k9 = 16 [packed = false];
  int k9_size() const;
  private:
  int _internal_k9_size() const;

  public:
  void clear_k9() ;
  ::cfg::TestDemoE2* mutable_k9(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 >*
      mutable_k9();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>& _internal_k9() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>* _internal_mutable_k9();
  public:
  const ::cfg::TestDemoE2& k9(int index) const;
  ::cfg::TestDemoE2* add_k9();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 >&
      k9() const;
  // repeated .cfg.vec3 k10 = 17 [packed = false];
  int k10_size() const;
  private:
  int _internal_k10_size() const;

  public:
  void clear_k10() ;
  ::cfg::vec3* mutable_k10(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::vec3 >*
      mutable_k10();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::vec3>& _internal_k10() const;
  ::google::protobuf::RepeatedPtrField<::cfg::vec3>* _internal_mutable_k10();
  public:
  const ::cfg::vec3& k10(int index) const;
  ::cfg::vec3* add_k10();
  const ::google::protobuf::RepeatedPtrField< ::cfg::vec3 >&
      k10() const;
  // repeated .cfg.vec4 k11 = 18 [packed = false];
  int k11_size() const;
  private:
  int _internal_k11_size() const;

  public:
  void clear_k11() ;
  ::cfg::vec4* mutable_k11(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::vec4 >*
      mutable_k11();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::vec4>& _internal_k11() const;
  ::google::protobuf::RepeatedPtrField<::cfg::vec4>* _internal_mutable_k11();
  public:
  const ::cfg::vec4& k11(int index) const;
  ::cfg::vec4* add_k11();
  const ::google::protobuf::RepeatedPtrField< ::cfg::vec4 >&
      k11() const;
  // string x10 = 6;
  void clear_x10() ;
  const std::string& x10() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_x10(Arg_&& arg, Args_... args);
  std::string* mutable_x10();
  PROTOBUF_NODISCARD std::string* release_x10();
  void set_allocated_x10(std::string* ptr);

  private:
  const std::string& _internal_x10() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x10(
      const std::string& value);
  std::string* _internal_mutable_x10();

  public:
  // .cfg.TestDemoDynamic x14 = 9;
  bool has_x14() const;
  void clear_x14() ;
  const ::cfg::TestDemoDynamic& x14() const;
  PROTOBUF_NODISCARD ::cfg::TestDemoDynamic* release_x14();
  ::cfg::TestDemoDynamic* mutable_x14();
  void set_allocated_x14(::cfg::TestDemoDynamic* value);
  void unsafe_arena_set_allocated_x14(::cfg::TestDemoDynamic* value);
  ::cfg::TestDemoDynamic* unsafe_arena_release_x14();

  private:
  const ::cfg::TestDemoDynamic& _internal_x14() const;
  ::cfg::TestDemoDynamic* _internal_mutable_x14();

  public:
  // .cfg.TestShape x15 = 10;
  bool has_x15() const;
  void clear_x15() ;
  const ::cfg::TestShape& x15() const;
  PROTOBUF_NODISCARD ::cfg::TestShape* release_x15();
  ::cfg::TestShape* mutable_x15();
  void set_allocated_x15(::cfg::TestShape* value);
  void unsafe_arena_set_allocated_x15(::cfg::TestShape* value);
  ::cfg::TestShape* unsafe_arena_release_x15();

  private:
  const ::cfg::TestShape& _internal_x15() const;
  ::cfg::TestShape* _internal_mutable_x15();

  public:
  // .cfg.vec2 v2 = 11;
  bool has_v2() const;
  void clear_v2() ;
  const ::cfg::vec2& v2() const;
  PROTOBUF_NODISCARD ::cfg::vec2* release_v2();
  ::cfg::vec2* mutable_v2();
  void set_allocated_v2(::cfg::vec2* value);
  void unsafe_arena_set_allocated_v2(::cfg::vec2* value);
  ::cfg::vec2* unsafe_arena_release_v2();

  private:
  const ::cfg::vec2& _internal_v2() const;
  ::cfg::vec2* _internal_mutable_v2();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool x1 = 2;
  void clear_x1() ;
  bool x1() const;
  void set_x1(bool value);

  private:
  bool _internal_x1() const;
  void _internal_set_x1(bool value);

  public:
  // int64 x5 = 3;
  void clear_x5() ;
  ::int64_t x5() const;
  void set_x5(::int64_t value);

  private:
  ::int64_t _internal_x5() const;
  void _internal_set_x5(::int64_t value);

  public:
  // float x6 = 4;
  void clear_x6() ;
  float x6() const;
  void set_x6(float value);

  private:
  float _internal_x6() const;
  void _internal_set_x6(float value);

  public:
  // int32 x8 = 5;
  void clear_x8() ;
  ::int32_t x8() const;
  void set_x8(::int32_t value);

  private:
  ::int32_t _internal_x8() const;
  void _internal_set_x8(::int32_t value);

  public:
  // .cfg.TestDemoEnum x13 = 7;
  void clear_x13() ;
  ::cfg::TestDemoEnum x13() const;
  void set_x13(::cfg::TestDemoEnum value);

  private:
  ::cfg::TestDemoEnum _internal_x13() const;
  void _internal_set_x13(::cfg::TestDemoEnum value);

  public:
  // .cfg.TestDemoFlag x13_2 = 8;
  void clear_x13_2() ;
  ::cfg::TestDemoFlag x13_2() const;
  void set_x13_2(::cfg::TestDemoFlag value);

  private:
  ::cfg::TestDemoFlag _internal_x13_2() const;
  void _internal_set_x13_2(::cfg::TestDemoFlag value);

  public:
  // int64 t1 = 12;
  void clear_t1() ;
  ::int64_t t1() const;
  void set_t1(::int64_t value);

  private:
  ::int64_t _internal_t1() const;
  void _internal_set_t1(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.DefineFromExcel2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 18, 7,
      48, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> k1_;
    mutable ::google::protobuf::internal::CachedSize _k1_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> k2_;
    mutable ::google::protobuf::internal::CachedSize _k2_cached_byte_size_;
    ::google::protobuf::internal::MapField<DefineFromExcel2_K8Entry_DoNotUse, ::int32_t, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        k8_;
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoE2 > k9_;
    ::google::protobuf::RepeatedPtrField< ::cfg::vec3 > k10_;
    ::google::protobuf::RepeatedPtrField< ::cfg::vec4 > k11_;
    ::google::protobuf::internal::ArenaStringPtr x10_;
    ::cfg::TestDemoDynamic* x14_;
    ::cfg::TestShape* x15_;
    ::cfg::vec2* v2_;
    ::int32_t id_;
    bool x1_;
    ::int64_t x5_;
    float x6_;
    ::int32_t x8_;
    int x13_;
    int x13_2_;
    ::int64_t t1_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiKeyQueryOperator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiKeyQueryOperator) */ {
 public:
  inline AiKeyQueryOperator() : AiKeyQueryOperator(nullptr) {}
  ~AiKeyQueryOperator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiKeyQueryOperator(::google::protobuf::internal::ConstantInitialized);

  AiKeyQueryOperator(const AiKeyQueryOperator& from);
  AiKeyQueryOperator(AiKeyQueryOperator&& from) noexcept
    : AiKeyQueryOperator() {
    *this = ::std::move(from);
  }

  inline AiKeyQueryOperator(::google::protobuf::Arena* arena, const AiKeyQueryOperator& from)
    : AiKeyQueryOperator(arena) {
    MergeFrom(from);
  }
  inline AiKeyQueryOperator& operator=(const AiKeyQueryOperator& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiKeyQueryOperator& operator=(AiKeyQueryOperator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiKeyQueryOperator& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kIsSet = 1,
    kIsNotSet = 2,
    kBinaryOperator = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const AiKeyQueryOperator* internal_default_instance() {
    return reinterpret_cast<const AiKeyQueryOperator*>(
               &_AiKeyQueryOperator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AiKeyQueryOperator& a, AiKeyQueryOperator& b) {
    a.Swap(&b);
  }
  inline void Swap(AiKeyQueryOperator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiKeyQueryOperator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiKeyQueryOperator* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiKeyQueryOperator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiKeyQueryOperator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiKeyQueryOperator& from) {
    AiKeyQueryOperator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiKeyQueryOperator* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiKeyQueryOperator";
  }
  protected:
  explicit AiKeyQueryOperator(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSetFieldNumber = 1,
    kIsNotSetFieldNumber = 2,
    kBinaryOperatorFieldNumber = 3,
  };
  // .cfg.AiIsSet IsSet = 1;
  bool has_isset() const;
  private:
  bool _internal_has_isset() const;

  public:
  void clear_isset() ;
  const ::cfg::AiIsSet& isset() const;
  PROTOBUF_NODISCARD ::cfg::AiIsSet* release_isset();
  ::cfg::AiIsSet* mutable_isset();
  void set_allocated_isset(::cfg::AiIsSet* value);
  void unsafe_arena_set_allocated_isset(::cfg::AiIsSet* value);
  ::cfg::AiIsSet* unsafe_arena_release_isset();

  private:
  const ::cfg::AiIsSet& _internal_isset() const;
  ::cfg::AiIsSet* _internal_mutable_isset();

  public:
  // .cfg.AiIsNotSet IsNotSet = 2;
  bool has_isnotset() const;
  private:
  bool _internal_has_isnotset() const;

  public:
  void clear_isnotset() ;
  const ::cfg::AiIsNotSet& isnotset() const;
  PROTOBUF_NODISCARD ::cfg::AiIsNotSet* release_isnotset();
  ::cfg::AiIsNotSet* mutable_isnotset();
  void set_allocated_isnotset(::cfg::AiIsNotSet* value);
  void unsafe_arena_set_allocated_isnotset(::cfg::AiIsNotSet* value);
  ::cfg::AiIsNotSet* unsafe_arena_release_isnotset();

  private:
  const ::cfg::AiIsNotSet& _internal_isnotset() const;
  ::cfg::AiIsNotSet* _internal_mutable_isnotset();

  public:
  // .cfg.AiBinaryOperator BinaryOperator = 3;
  bool has_binaryoperator() const;
  private:
  bool _internal_has_binaryoperator() const;

  public:
  void clear_binaryoperator() ;
  const ::cfg::AiBinaryOperator& binaryoperator() const;
  PROTOBUF_NODISCARD ::cfg::AiBinaryOperator* release_binaryoperator();
  ::cfg::AiBinaryOperator* mutable_binaryoperator();
  void set_allocated_binaryoperator(::cfg::AiBinaryOperator* value);
  void unsafe_arena_set_allocated_binaryoperator(::cfg::AiBinaryOperator* value);
  ::cfg::AiBinaryOperator* unsafe_arena_release_binaryoperator();

  private:
  const ::cfg::AiBinaryOperator& _internal_binaryoperator() const;
  ::cfg::AiBinaryOperator* _internal_mutable_binaryoperator();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiKeyQueryOperator)
 private:
  class _Internal;
  void set_has_isset();
  void set_has_isnotset();
  void set_has_binaryoperator();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiIsSet* isset_;
      ::cfg::AiIsNotSet* isnotset_;
      ::cfg::AiBinaryOperator* binaryoperator_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbTestNull final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbTestNull) */ {
 public:
  inline TestTbTestNull() : TestTbTestNull(nullptr) {}
  ~TestTbTestNull() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbTestNull(::google::protobuf::internal::ConstantInitialized);

  TestTbTestNull(const TestTbTestNull& from);
  TestTbTestNull(TestTbTestNull&& from) noexcept
    : TestTbTestNull() {
    *this = ::std::move(from);
  }

  inline TestTbTestNull(::google::protobuf::Arena* arena, const TestTbTestNull& from)
    : TestTbTestNull(arena) {
    MergeFrom(from);
  }
  inline TestTbTestNull& operator=(const TestTbTestNull& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbTestNull& operator=(TestTbTestNull&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbTestNull& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbTestNull* internal_default_instance() {
    return reinterpret_cast<const TestTbTestNull*>(
               &_TestTbTestNull_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(TestTbTestNull& a, TestTbTestNull& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbTestNull* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbTestNull* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbTestNull* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbTestNull>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbTestNull& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbTestNull& from) {
    TestTbTestNull::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbTestNull* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbTestNull";
  }
  protected:
  explicit TestTbTestNull(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestTestNull data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestTestNull* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestTestNull >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestTestNull>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestTestNull>* _internal_mutable_data_list();
  public:
  const ::cfg::TestTestNull& data_list(int index) const;
  ::cfg::TestTestNull* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestTestNull >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbTestNull)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestTestNull > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbSingleton final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbSingleton) */ {
 public:
  inline TestTbSingleton() : TestTbSingleton(nullptr) {}
  ~TestTbSingleton() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbSingleton(::google::protobuf::internal::ConstantInitialized);

  TestTbSingleton(const TestTbSingleton& from);
  TestTbSingleton(TestTbSingleton&& from) noexcept
    : TestTbSingleton() {
    *this = ::std::move(from);
  }

  inline TestTbSingleton(::google::protobuf::Arena* arena, const TestTbSingleton& from)
    : TestTbSingleton(arena) {
    MergeFrom(from);
  }
  inline TestTbSingleton& operator=(const TestTbSingleton& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbSingleton& operator=(TestTbSingleton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbSingleton& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbSingleton* internal_default_instance() {
    return reinterpret_cast<const TestTbSingleton*>(
               &_TestTbSingleton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(TestTbSingleton& a, TestTbSingleton& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbSingleton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbSingleton* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbSingleton* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbSingleton>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbSingleton& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbSingleton& from) {
    TestTbSingleton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbSingleton* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbSingleton";
  }
  protected:
  explicit TestTbSingleton(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestDemoSingletonType data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestDemoSingletonType* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoSingletonType >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoSingletonType>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoSingletonType>* _internal_mutable_data_list();
  public:
  const ::cfg::TestDemoSingletonType& data_list(int index) const;
  ::cfg::TestDemoSingletonType* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoSingletonType >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbSingleton)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoSingletonType > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbFullTypes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbFullTypes) */ {
 public:
  inline TestTbFullTypes() : TestTbFullTypes(nullptr) {}
  ~TestTbFullTypes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbFullTypes(::google::protobuf::internal::ConstantInitialized);

  TestTbFullTypes(const TestTbFullTypes& from);
  TestTbFullTypes(TestTbFullTypes&& from) noexcept
    : TestTbFullTypes() {
    *this = ::std::move(from);
  }

  inline TestTbFullTypes(::google::protobuf::Arena* arena, const TestTbFullTypes& from)
    : TestTbFullTypes(arena) {
    MergeFrom(from);
  }
  inline TestTbFullTypes& operator=(const TestTbFullTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbFullTypes& operator=(TestTbFullTypes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbFullTypes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbFullTypes* internal_default_instance() {
    return reinterpret_cast<const TestTbFullTypes*>(
               &_TestTbFullTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(TestTbFullTypes& a, TestTbFullTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbFullTypes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbFullTypes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbFullTypes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbFullTypes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbFullTypes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbFullTypes& from) {
    TestTbFullTypes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbFullTypes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbFullTypes";
  }
  protected:
  explicit TestTbFullTypes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestDemoType2 data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestDemoType2* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType2 >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>* _internal_mutable_data_list();
  public:
  const ::cfg::TestDemoType2& data_list(int index) const;
  ::cfg::TestDemoType2* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType2 >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbFullTypes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType2 > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbExcelFromJson final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbExcelFromJson) */ {
 public:
  inline TestTbExcelFromJson() : TestTbExcelFromJson(nullptr) {}
  ~TestTbExcelFromJson() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbExcelFromJson(::google::protobuf::internal::ConstantInitialized);

  TestTbExcelFromJson(const TestTbExcelFromJson& from);
  TestTbExcelFromJson(TestTbExcelFromJson&& from) noexcept
    : TestTbExcelFromJson() {
    *this = ::std::move(from);
  }

  inline TestTbExcelFromJson(::google::protobuf::Arena* arena, const TestTbExcelFromJson& from)
    : TestTbExcelFromJson(arena) {
    MergeFrom(from);
  }
  inline TestTbExcelFromJson& operator=(const TestTbExcelFromJson& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbExcelFromJson& operator=(TestTbExcelFromJson&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbExcelFromJson& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbExcelFromJson* internal_default_instance() {
    return reinterpret_cast<const TestTbExcelFromJson*>(
               &_TestTbExcelFromJson_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(TestTbExcelFromJson& a, TestTbExcelFromJson& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbExcelFromJson* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbExcelFromJson* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbExcelFromJson* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbExcelFromJson>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbExcelFromJson& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbExcelFromJson& from) {
    TestTbExcelFromJson::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbExcelFromJson* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbExcelFromJson";
  }
  protected:
  explicit TestTbExcelFromJson(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestExcelFromJson data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestExcelFromJson* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestExcelFromJson >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJson>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJson>* _internal_mutable_data_list();
  public:
  const ::cfg::TestExcelFromJson& data_list(int index) const;
  ::cfg::TestExcelFromJson* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestExcelFromJson >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbExcelFromJson)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestExcelFromJson > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbDefineFromExcel2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbDefineFromExcel2) */ {
 public:
  inline TestTbDefineFromExcel2() : TestTbDefineFromExcel2(nullptr) {}
  ~TestTbDefineFromExcel2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbDefineFromExcel2(::google::protobuf::internal::ConstantInitialized);

  TestTbDefineFromExcel2(const TestTbDefineFromExcel2& from);
  TestTbDefineFromExcel2(TestTbDefineFromExcel2&& from) noexcept
    : TestTbDefineFromExcel2() {
    *this = ::std::move(from);
  }

  inline TestTbDefineFromExcel2(::google::protobuf::Arena* arena, const TestTbDefineFromExcel2& from)
    : TestTbDefineFromExcel2(arena) {
    MergeFrom(from);
  }
  inline TestTbDefineFromExcel2& operator=(const TestTbDefineFromExcel2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbDefineFromExcel2& operator=(TestTbDefineFromExcel2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbDefineFromExcel2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbDefineFromExcel2* internal_default_instance() {
    return reinterpret_cast<const TestTbDefineFromExcel2*>(
               &_TestTbDefineFromExcel2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(TestTbDefineFromExcel2& a, TestTbDefineFromExcel2& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbDefineFromExcel2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbDefineFromExcel2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbDefineFromExcel2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbDefineFromExcel2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbDefineFromExcel2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbDefineFromExcel2& from) {
    TestTbDefineFromExcel2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbDefineFromExcel2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbDefineFromExcel2";
  }
  protected:
  explicit TestTbDefineFromExcel2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.DefineFromExcel2 data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::DefineFromExcel2* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::DefineFromExcel2 >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::DefineFromExcel2>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::DefineFromExcel2>* _internal_mutable_data_list();
  public:
  const ::cfg::DefineFromExcel2& data_list(int index) const;
  ::cfg::DefineFromExcel2* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::DefineFromExcel2 >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbDefineFromExcel2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::DefineFromExcel2 > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class TestTbDataFromMisc final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.TestTbDataFromMisc) */ {
 public:
  inline TestTbDataFromMisc() : TestTbDataFromMisc(nullptr) {}
  ~TestTbDataFromMisc() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestTbDataFromMisc(::google::protobuf::internal::ConstantInitialized);

  TestTbDataFromMisc(const TestTbDataFromMisc& from);
  TestTbDataFromMisc(TestTbDataFromMisc&& from) noexcept
    : TestTbDataFromMisc() {
    *this = ::std::move(from);
  }

  inline TestTbDataFromMisc(::google::protobuf::Arena* arena, const TestTbDataFromMisc& from)
    : TestTbDataFromMisc(arena) {
    MergeFrom(from);
  }
  inline TestTbDataFromMisc& operator=(const TestTbDataFromMisc& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTbDataFromMisc& operator=(TestTbDataFromMisc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTbDataFromMisc& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTbDataFromMisc* internal_default_instance() {
    return reinterpret_cast<const TestTbDataFromMisc*>(
               &_TestTbDataFromMisc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(TestTbDataFromMisc& a, TestTbDataFromMisc& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTbDataFromMisc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTbDataFromMisc* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTbDataFromMisc* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTbDataFromMisc>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTbDataFromMisc& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestTbDataFromMisc& from) {
    TestTbDataFromMisc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTbDataFromMisc* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.TestTbDataFromMisc";
  }
  protected:
  explicit TestTbDataFromMisc(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.TestDemoType2 data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::TestDemoType2* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType2 >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>* _internal_mutable_data_list();
  public:
  const ::cfg::TestDemoType2& data_list(int index) const;
  ::cfg::TestDemoType2* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType2 >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.TestTbDataFromMisc)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::TestDemoType2 > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeBlackboard final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeBlackboard) */ {
 public:
  inline AiUeBlackboard() : AiUeBlackboard(nullptr) {}
  ~AiUeBlackboard() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeBlackboard(::google::protobuf::internal::ConstantInitialized);

  AiUeBlackboard(const AiUeBlackboard& from);
  AiUeBlackboard(AiUeBlackboard&& from) noexcept
    : AiUeBlackboard() {
    *this = ::std::move(from);
  }

  inline AiUeBlackboard(::google::protobuf::Arena* arena, const AiUeBlackboard& from)
    : AiUeBlackboard(arena) {
    MergeFrom(from);
  }
  inline AiUeBlackboard& operator=(const AiUeBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeBlackboard& operator=(AiUeBlackboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeBlackboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeBlackboard* internal_default_instance() {
    return reinterpret_cast<const AiUeBlackboard*>(
               &_AiUeBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AiUeBlackboard& a, AiUeBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeBlackboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeBlackboard* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeBlackboard* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeBlackboard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeBlackboard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeBlackboard& from) {
    AiUeBlackboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeBlackboard* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeBlackboard";
  }
  protected:
  explicit AiUeBlackboard(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kBlackboardKeyFieldNumber = 5,
    kKeyQueryFieldNumber = 6,
    kIdFieldNumber = 1,
    kFlowAbortModeFieldNumber = 3,
    kNotifyObserverFieldNumber = 4,
  };
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string blackboard_key = 5;
  void clear_blackboard_key() ;
  const std::string& blackboard_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_blackboard_key(Arg_&& arg, Args_... args);
  std::string* mutable_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_blackboard_key();
  void set_allocated_blackboard_key(std::string* ptr);

  private:
  const std::string& _internal_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blackboard_key(
      const std::string& value);
  std::string* _internal_mutable_blackboard_key();

  public:
  // .cfg.AiKeyQueryOperator key_query = 6;
  bool has_key_query() const;
  void clear_key_query() ;
  const ::cfg::AiKeyQueryOperator& key_query() const;
  PROTOBUF_NODISCARD ::cfg::AiKeyQueryOperator* release_key_query();
  ::cfg::AiKeyQueryOperator* mutable_key_query();
  void set_allocated_key_query(::cfg::AiKeyQueryOperator* value);
  void unsafe_arena_set_allocated_key_query(::cfg::AiKeyQueryOperator* value);
  ::cfg::AiKeyQueryOperator* unsafe_arena_release_key_query();

  private:
  const ::cfg::AiKeyQueryOperator& _internal_key_query() const;
  ::cfg::AiKeyQueryOperator* _internal_mutable_key_query();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFlowAbortMode flow_abort_mode = 3;
  void clear_flow_abort_mode() ;
  ::cfg::AiEFlowAbortMode flow_abort_mode() const;
  void set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  private:
  ::cfg::AiEFlowAbortMode _internal_flow_abort_mode() const;
  void _internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value);

  public:
  // .cfg.AiENotifyObserverMode notify_observer = 4;
  void clear_notify_observer() ;
  ::cfg::AiENotifyObserverMode notify_observer() const;
  void set_notify_observer(::cfg::AiENotifyObserverMode value);

  private:
  ::cfg::AiENotifyObserverMode _internal_notify_observer() const;
  void _internal_set_notify_observer(::cfg::AiENotifyObserverMode value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeBlackboard)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      50, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr blackboard_key_;
    ::cfg::AiKeyQueryOperator* key_query_;
    ::int32_t id_;
    int flow_abort_mode_;
    int notify_observer_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiDecorator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiDecorator) */ {
 public:
  inline AiDecorator() : AiDecorator(nullptr) {}
  ~AiDecorator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiDecorator(::google::protobuf::internal::ConstantInitialized);

  AiDecorator(const AiDecorator& from);
  AiDecorator(AiDecorator&& from) noexcept
    : AiDecorator() {
    *this = ::std::move(from);
  }

  inline AiDecorator(::google::protobuf::Arena* arena, const AiDecorator& from)
    : AiDecorator(arena) {
    MergeFrom(from);
  }
  inline AiDecorator& operator=(const AiDecorator& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiDecorator& operator=(AiDecorator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiDecorator& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUeLoop = 7,
    kUeCooldown = 8,
    kUeTimeLimit = 9,
    kUeBlackboard = 10,
    kUeForceSuccess = 11,
    kIsAtLocation = 12,
    kDistanceLessThan = 13,
    VALUE_NOT_SET = 0,
  };

  static inline const AiDecorator* internal_default_instance() {
    return reinterpret_cast<const AiDecorator*>(
               &_AiDecorator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AiDecorator& a, AiDecorator& b) {
    a.Swap(&b);
  }
  inline void Swap(AiDecorator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiDecorator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiDecorator* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiDecorator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiDecorator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiDecorator& from) {
    AiDecorator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiDecorator* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiDecorator";
  }
  protected:
  explicit AiDecorator(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeLoopFieldNumber = 7,
    kUeCooldownFieldNumber = 8,
    kUeTimeLimitFieldNumber = 9,
    kUeBlackboardFieldNumber = 10,
    kUeForceSuccessFieldNumber = 11,
    kIsAtLocationFieldNumber = 12,
    kDistanceLessThanFieldNumber = 13,
  };
  // .cfg.AiUeLoop UeLoop = 7;
  bool has_ueloop() const;
  private:
  bool _internal_has_ueloop() const;

  public:
  void clear_ueloop() ;
  const ::cfg::AiUeLoop& ueloop() const;
  PROTOBUF_NODISCARD ::cfg::AiUeLoop* release_ueloop();
  ::cfg::AiUeLoop* mutable_ueloop();
  void set_allocated_ueloop(::cfg::AiUeLoop* value);
  void unsafe_arena_set_allocated_ueloop(::cfg::AiUeLoop* value);
  ::cfg::AiUeLoop* unsafe_arena_release_ueloop();

  private:
  const ::cfg::AiUeLoop& _internal_ueloop() const;
  ::cfg::AiUeLoop* _internal_mutable_ueloop();

  public:
  // .cfg.AiUeCooldown UeCooldown = 8;
  bool has_uecooldown() const;
  private:
  bool _internal_has_uecooldown() const;

  public:
  void clear_uecooldown() ;
  const ::cfg::AiUeCooldown& uecooldown() const;
  PROTOBUF_NODISCARD ::cfg::AiUeCooldown* release_uecooldown();
  ::cfg::AiUeCooldown* mutable_uecooldown();
  void set_allocated_uecooldown(::cfg::AiUeCooldown* value);
  void unsafe_arena_set_allocated_uecooldown(::cfg::AiUeCooldown* value);
  ::cfg::AiUeCooldown* unsafe_arena_release_uecooldown();

  private:
  const ::cfg::AiUeCooldown& _internal_uecooldown() const;
  ::cfg::AiUeCooldown* _internal_mutable_uecooldown();

  public:
  // .cfg.AiUeTimeLimit UeTimeLimit = 9;
  bool has_uetimelimit() const;
  private:
  bool _internal_has_uetimelimit() const;

  public:
  void clear_uetimelimit() ;
  const ::cfg::AiUeTimeLimit& uetimelimit() const;
  PROTOBUF_NODISCARD ::cfg::AiUeTimeLimit* release_uetimelimit();
  ::cfg::AiUeTimeLimit* mutable_uetimelimit();
  void set_allocated_uetimelimit(::cfg::AiUeTimeLimit* value);
  void unsafe_arena_set_allocated_uetimelimit(::cfg::AiUeTimeLimit* value);
  ::cfg::AiUeTimeLimit* unsafe_arena_release_uetimelimit();

  private:
  const ::cfg::AiUeTimeLimit& _internal_uetimelimit() const;
  ::cfg::AiUeTimeLimit* _internal_mutable_uetimelimit();

  public:
  // .cfg.AiUeBlackboard UeBlackboard = 10;
  bool has_ueblackboard() const;
  private:
  bool _internal_has_ueblackboard() const;

  public:
  void clear_ueblackboard() ;
  const ::cfg::AiUeBlackboard& ueblackboard() const;
  PROTOBUF_NODISCARD ::cfg::AiUeBlackboard* release_ueblackboard();
  ::cfg::AiUeBlackboard* mutable_ueblackboard();
  void set_allocated_ueblackboard(::cfg::AiUeBlackboard* value);
  void unsafe_arena_set_allocated_ueblackboard(::cfg::AiUeBlackboard* value);
  ::cfg::AiUeBlackboard* unsafe_arena_release_ueblackboard();

  private:
  const ::cfg::AiUeBlackboard& _internal_ueblackboard() const;
  ::cfg::AiUeBlackboard* _internal_mutable_ueblackboard();

  public:
  // .cfg.AiUeForceSuccess UeForceSuccess = 11;
  bool has_ueforcesuccess() const;
  private:
  bool _internal_has_ueforcesuccess() const;

  public:
  void clear_ueforcesuccess() ;
  const ::cfg::AiUeForceSuccess& ueforcesuccess() const;
  PROTOBUF_NODISCARD ::cfg::AiUeForceSuccess* release_ueforcesuccess();
  ::cfg::AiUeForceSuccess* mutable_ueforcesuccess();
  void set_allocated_ueforcesuccess(::cfg::AiUeForceSuccess* value);
  void unsafe_arena_set_allocated_ueforcesuccess(::cfg::AiUeForceSuccess* value);
  ::cfg::AiUeForceSuccess* unsafe_arena_release_ueforcesuccess();

  private:
  const ::cfg::AiUeForceSuccess& _internal_ueforcesuccess() const;
  ::cfg::AiUeForceSuccess* _internal_mutable_ueforcesuccess();

  public:
  // .cfg.AiIsAtLocation IsAtLocation = 12;
  bool has_isatlocation() const;
  private:
  bool _internal_has_isatlocation() const;

  public:
  void clear_isatlocation() ;
  const ::cfg::AiIsAtLocation& isatlocation() const;
  PROTOBUF_NODISCARD ::cfg::AiIsAtLocation* release_isatlocation();
  ::cfg::AiIsAtLocation* mutable_isatlocation();
  void set_allocated_isatlocation(::cfg::AiIsAtLocation* value);
  void unsafe_arena_set_allocated_isatlocation(::cfg::AiIsAtLocation* value);
  ::cfg::AiIsAtLocation* unsafe_arena_release_isatlocation();

  private:
  const ::cfg::AiIsAtLocation& _internal_isatlocation() const;
  ::cfg::AiIsAtLocation* _internal_mutable_isatlocation();

  public:
  // .cfg.AiDistanceLessThan DistanceLessThan = 13;
  bool has_distancelessthan() const;
  private:
  bool _internal_has_distancelessthan() const;

  public:
  void clear_distancelessthan() ;
  const ::cfg::AiDistanceLessThan& distancelessthan() const;
  PROTOBUF_NODISCARD ::cfg::AiDistanceLessThan* release_distancelessthan();
  ::cfg::AiDistanceLessThan* mutable_distancelessthan();
  void set_allocated_distancelessthan(::cfg::AiDistanceLessThan* value);
  void unsafe_arena_set_allocated_distancelessthan(::cfg::AiDistanceLessThan* value);
  ::cfg::AiDistanceLessThan* unsafe_arena_release_distancelessthan();

  private:
  const ::cfg::AiDistanceLessThan& _internal_distancelessthan() const;
  ::cfg::AiDistanceLessThan* _internal_mutable_distancelessthan();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiDecorator)
 private:
  class _Internal;
  void set_has_ueloop();
  void set_has_uecooldown();
  void set_has_uetimelimit();
  void set_has_ueblackboard();
  void set_has_ueforcesuccess();
  void set_has_isatlocation();
  void set_has_distancelessthan();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 7,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiUeLoop* ueloop_;
      ::cfg::AiUeCooldown* uecooldown_;
      ::cfg::AiUeTimeLimit* uetimelimit_;
      ::cfg::AiUeBlackboard* ueblackboard_;
      ::cfg::AiUeForceSuccess* ueforcesuccess_;
      ::cfg::AiIsAtLocation* isatlocation_;
      ::cfg::AiDistanceLessThan* distancelessthan_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeWaitBlackboardTime final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeWaitBlackboardTime) */ {
 public:
  inline AiUeWaitBlackboardTime() : AiUeWaitBlackboardTime(nullptr) {}
  ~AiUeWaitBlackboardTime() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeWaitBlackboardTime(::google::protobuf::internal::ConstantInitialized);

  AiUeWaitBlackboardTime(const AiUeWaitBlackboardTime& from);
  AiUeWaitBlackboardTime(AiUeWaitBlackboardTime&& from) noexcept
    : AiUeWaitBlackboardTime() {
    *this = ::std::move(from);
  }

  inline AiUeWaitBlackboardTime(::google::protobuf::Arena* arena, const AiUeWaitBlackboardTime& from)
    : AiUeWaitBlackboardTime(arena) {
    MergeFrom(from);
  }
  inline AiUeWaitBlackboardTime& operator=(const AiUeWaitBlackboardTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeWaitBlackboardTime& operator=(AiUeWaitBlackboardTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeWaitBlackboardTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeWaitBlackboardTime* internal_default_instance() {
    return reinterpret_cast<const AiUeWaitBlackboardTime*>(
               &_AiUeWaitBlackboardTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(AiUeWaitBlackboardTime& a, AiUeWaitBlackboardTime& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeWaitBlackboardTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeWaitBlackboardTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeWaitBlackboardTime* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeWaitBlackboardTime>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeWaitBlackboardTime& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeWaitBlackboardTime& from) {
    AiUeWaitBlackboardTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeWaitBlackboardTime* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeWaitBlackboardTime";
  }
  protected:
  explicit AiUeWaitBlackboardTime(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kBlackboardKeyFieldNumber = 6,
    kIdFieldNumber = 1,
    kIgnoreRestartSelfFieldNumber = 5,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string blackboard_key = 6;
  void clear_blackboard_key() ;
  const std::string& blackboard_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_blackboard_key(Arg_&& arg, Args_... args);
  std::string* mutable_blackboard_key();
  PROTOBUF_NODISCARD std::string* release_blackboard_key();
  void set_allocated_blackboard_key(std::string* ptr);

  private:
  const std::string& _internal_blackboard_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blackboard_key(
      const std::string& value);
  std::string* _internal_mutable_blackboard_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool ignore_restart_self = 5;
  void clear_ignore_restart_self() ;
  bool ignore_restart_self() const;
  void set_ignore_restart_self(bool value);

  private:
  bool _internal_ignore_restart_self() const;
  void _internal_set_ignore_restart_self(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeWaitBlackboardTime)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      58, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr blackboard_key_;
    ::int32_t id_;
    bool ignore_restart_self_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiUeWait final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiUeWait) */ {
 public:
  inline AiUeWait() : AiUeWait(nullptr) {}
  ~AiUeWait() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiUeWait(::google::protobuf::internal::ConstantInitialized);

  AiUeWait(const AiUeWait& from);
  AiUeWait(AiUeWait&& from) noexcept
    : AiUeWait() {
    *this = ::std::move(from);
  }

  inline AiUeWait(::google::protobuf::Arena* arena, const AiUeWait& from)
    : AiUeWait(arena) {
    MergeFrom(from);
  }
  inline AiUeWait& operator=(const AiUeWait& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiUeWait& operator=(AiUeWait&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiUeWait& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiUeWait* internal_default_instance() {
    return reinterpret_cast<const AiUeWait*>(
               &_AiUeWait_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(AiUeWait& a, AiUeWait& b) {
    a.Swap(&b);
  }
  inline void Swap(AiUeWait* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiUeWait* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiUeWait* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiUeWait>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiUeWait& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiUeWait& from) {
    AiUeWait::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiUeWait* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiUeWait";
  }
  protected:
  explicit AiUeWait(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kIgnoreRestartSelfFieldNumber = 5,
    kWaitTimeFieldNumber = 6,
    kRandomDeviationFieldNumber = 7,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool ignore_restart_self = 5;
  void clear_ignore_restart_self() ;
  bool ignore_restart_self() const;
  void set_ignore_restart_self(bool value);

  private:
  bool _internal_ignore_restart_self() const;
  void _internal_set_ignore_restart_self(bool value);

  public:
  // float wait_time = 6;
  void clear_wait_time() ;
  float wait_time() const;
  void set_wait_time(float value);

  private:
  float _internal_wait_time() const;
  void _internal_set_wait_time(float value);

  public:
  // float random_deviation = 7;
  void clear_random_deviation() ;
  float random_deviation() const;
  void set_random_deviation(float value);

  private:
  float _internal_random_deviation() const;
  void _internal_set_random_deviation(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiUeWait)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      30, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    bool ignore_restart_self_;
    float wait_time_;
    float random_deviation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiMoveToTarget final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiMoveToTarget) */ {
 public:
  inline AiMoveToTarget() : AiMoveToTarget(nullptr) {}
  ~AiMoveToTarget() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiMoveToTarget(::google::protobuf::internal::ConstantInitialized);

  AiMoveToTarget(const AiMoveToTarget& from);
  AiMoveToTarget(AiMoveToTarget&& from) noexcept
    : AiMoveToTarget() {
    *this = ::std::move(from);
  }

  inline AiMoveToTarget(::google::protobuf::Arena* arena, const AiMoveToTarget& from)
    : AiMoveToTarget(arena) {
    MergeFrom(from);
  }
  inline AiMoveToTarget& operator=(const AiMoveToTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiMoveToTarget& operator=(AiMoveToTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiMoveToTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiMoveToTarget* internal_default_instance() {
    return reinterpret_cast<const AiMoveToTarget*>(
               &_AiMoveToTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(AiMoveToTarget& a, AiMoveToTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(AiMoveToTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiMoveToTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiMoveToTarget* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiMoveToTarget>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiMoveToTarget& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiMoveToTarget& from) {
    AiMoveToTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiMoveToTarget* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiMoveToTarget";
  }
  protected:
  explicit AiMoveToTarget(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kTargetActorKeyFieldNumber = 6,
    kIdFieldNumber = 1,
    kIgnoreRestartSelfFieldNumber = 5,
    kAcceptableRadiusFieldNumber = 7,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string target_actor_key = 6;
  void clear_target_actor_key() ;
  const std::string& target_actor_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_actor_key(Arg_&& arg, Args_... args);
  std::string* mutable_target_actor_key();
  PROTOBUF_NODISCARD std::string* release_target_actor_key();
  void set_allocated_target_actor_key(std::string* ptr);

  private:
  const std::string& _internal_target_actor_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_actor_key(
      const std::string& value);
  std::string* _internal_mutable_target_actor_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool ignore_restart_self = 5;
  void clear_ignore_restart_self() ;
  bool ignore_restart_self() const;
  void set_ignore_restart_self(bool value);

  private:
  bool _internal_ignore_restart_self() const;
  void _internal_set_ignore_restart_self(bool value);

  public:
  // float acceptable_radius = 7;
  void clear_acceptable_radius() ;
  float acceptable_radius() const;
  void set_acceptable_radius(float value);

  private:
  float _internal_acceptable_radius() const;
  void _internal_set_acceptable_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiMoveToTarget)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      52, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr target_actor_key_;
    ::int32_t id_;
    bool ignore_restart_self_;
    float acceptable_radius_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiMoveToRandomLocation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiMoveToRandomLocation) */ {
 public:
  inline AiMoveToRandomLocation() : AiMoveToRandomLocation(nullptr) {}
  ~AiMoveToRandomLocation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiMoveToRandomLocation(::google::protobuf::internal::ConstantInitialized);

  AiMoveToRandomLocation(const AiMoveToRandomLocation& from);
  AiMoveToRandomLocation(AiMoveToRandomLocation&& from) noexcept
    : AiMoveToRandomLocation() {
    *this = ::std::move(from);
  }

  inline AiMoveToRandomLocation(::google::protobuf::Arena* arena, const AiMoveToRandomLocation& from)
    : AiMoveToRandomLocation(arena) {
    MergeFrom(from);
  }
  inline AiMoveToRandomLocation& operator=(const AiMoveToRandomLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiMoveToRandomLocation& operator=(AiMoveToRandomLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiMoveToRandomLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiMoveToRandomLocation* internal_default_instance() {
    return reinterpret_cast<const AiMoveToRandomLocation*>(
               &_AiMoveToRandomLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(AiMoveToRandomLocation& a, AiMoveToRandomLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(AiMoveToRandomLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiMoveToRandomLocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiMoveToRandomLocation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiMoveToRandomLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiMoveToRandomLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiMoveToRandomLocation& from) {
    AiMoveToRandomLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiMoveToRandomLocation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiMoveToRandomLocation";
  }
  protected:
  explicit AiMoveToRandomLocation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kOriginPositionKeyFieldNumber = 6,
    kIdFieldNumber = 1,
    kIgnoreRestartSelfFieldNumber = 5,
    kRadiusFieldNumber = 7,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string origin_position_key = 6;
  void clear_origin_position_key() ;
  const std::string& origin_position_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_origin_position_key(Arg_&& arg, Args_... args);
  std::string* mutable_origin_position_key();
  PROTOBUF_NODISCARD std::string* release_origin_position_key();
  void set_allocated_origin_position_key(std::string* ptr);

  private:
  const std::string& _internal_origin_position_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin_position_key(
      const std::string& value);
  std::string* _internal_mutable_origin_position_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool ignore_restart_self = 5;
  void clear_ignore_restart_self() ;
  bool ignore_restart_self() const;
  void set_ignore_restart_self(bool value);

  private:
  bool _internal_ignore_restart_self() const;
  void _internal_set_ignore_restart_self(bool value);

  public:
  // float radius = 7;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiMoveToRandomLocation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      63, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr origin_position_key_;
    ::int32_t id_;
    bool ignore_restart_self_;
    float radius_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiMoveToLocation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiMoveToLocation) */ {
 public:
  inline AiMoveToLocation() : AiMoveToLocation(nullptr) {}
  ~AiMoveToLocation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiMoveToLocation(::google::protobuf::internal::ConstantInitialized);

  AiMoveToLocation(const AiMoveToLocation& from);
  AiMoveToLocation(AiMoveToLocation&& from) noexcept
    : AiMoveToLocation() {
    *this = ::std::move(from);
  }

  inline AiMoveToLocation(::google::protobuf::Arena* arena, const AiMoveToLocation& from)
    : AiMoveToLocation(arena) {
    MergeFrom(from);
  }
  inline AiMoveToLocation& operator=(const AiMoveToLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiMoveToLocation& operator=(AiMoveToLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiMoveToLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiMoveToLocation* internal_default_instance() {
    return reinterpret_cast<const AiMoveToLocation*>(
               &_AiMoveToLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(AiMoveToLocation& a, AiMoveToLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(AiMoveToLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiMoveToLocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiMoveToLocation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiMoveToLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiMoveToLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiMoveToLocation& from) {
    AiMoveToLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiMoveToLocation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiMoveToLocation";
  }
  protected:
  explicit AiMoveToLocation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kIgnoreRestartSelfFieldNumber = 5,
    kAcceptableRadiusFieldNumber = 6,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool ignore_restart_self = 5;
  void clear_ignore_restart_self() ;
  bool ignore_restart_self() const;
  void set_ignore_restart_self(bool value);

  private:
  bool _internal_ignore_restart_self() const;
  void _internal_set_ignore_restart_self(bool value);

  public:
  // float acceptable_radius = 6;
  void clear_acceptable_radius() ;
  float acceptable_radius() const;
  void set_acceptable_radius(float value);

  private:
  float _internal_acceptable_radius() const;
  void _internal_set_acceptable_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiMoveToLocation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      38, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    bool ignore_restart_self_;
    float acceptable_radius_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiDebugPrint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiDebugPrint) */ {
 public:
  inline AiDebugPrint() : AiDebugPrint(nullptr) {}
  ~AiDebugPrint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiDebugPrint(::google::protobuf::internal::ConstantInitialized);

  AiDebugPrint(const AiDebugPrint& from);
  AiDebugPrint(AiDebugPrint&& from) noexcept
    : AiDebugPrint() {
    *this = ::std::move(from);
  }

  inline AiDebugPrint(::google::protobuf::Arena* arena, const AiDebugPrint& from)
    : AiDebugPrint(arena) {
    MergeFrom(from);
  }
  inline AiDebugPrint& operator=(const AiDebugPrint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiDebugPrint& operator=(AiDebugPrint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiDebugPrint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiDebugPrint* internal_default_instance() {
    return reinterpret_cast<const AiDebugPrint*>(
               &_AiDebugPrint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(AiDebugPrint& a, AiDebugPrint& b) {
    a.Swap(&b);
  }
  inline void Swap(AiDebugPrint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiDebugPrint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiDebugPrint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiDebugPrint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiDebugPrint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiDebugPrint& from) {
    AiDebugPrint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiDebugPrint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiDebugPrint";
  }
  protected:
  explicit AiDebugPrint(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kTextFieldNumber = 6,
    kIdFieldNumber = 1,
    kIgnoreRestartSelfFieldNumber = 5,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string text = 6;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* ptr);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool ignore_restart_self = 5;
  void clear_ignore_restart_self() ;
  bool ignore_restart_self() const;
  void set_ignore_restart_self(bool value);

  private:
  bool _internal_ignore_restart_self() const;
  void _internal_set_ignore_restart_self(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiDebugPrint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      38, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::int32_t id_;
    bool ignore_restart_self_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiChooseSkill final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiChooseSkill) */ {
 public:
  inline AiChooseSkill() : AiChooseSkill(nullptr) {}
  ~AiChooseSkill() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiChooseSkill(::google::protobuf::internal::ConstantInitialized);

  AiChooseSkill(const AiChooseSkill& from);
  AiChooseSkill(AiChooseSkill&& from) noexcept
    : AiChooseSkill() {
    *this = ::std::move(from);
  }

  inline AiChooseSkill(::google::protobuf::Arena* arena, const AiChooseSkill& from)
    : AiChooseSkill(arena) {
    MergeFrom(from);
  }
  inline AiChooseSkill& operator=(const AiChooseSkill& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiChooseSkill& operator=(AiChooseSkill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiChooseSkill& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiChooseSkill* internal_default_instance() {
    return reinterpret_cast<const AiChooseSkill*>(
               &_AiChooseSkill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AiChooseSkill& a, AiChooseSkill& b) {
    a.Swap(&b);
  }
  inline void Swap(AiChooseSkill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiChooseSkill* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiChooseSkill* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiChooseSkill>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiChooseSkill& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiChooseSkill& from) {
    AiChooseSkill::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiChooseSkill* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiChooseSkill";
  }
  protected:
  explicit AiChooseSkill(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kTargetActorKeyFieldNumber = 6,
    kResultSkillIdKeyFieldNumber = 7,
    kIdFieldNumber = 1,
    kIgnoreRestartSelfFieldNumber = 5,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // string target_actor_key = 6;
  void clear_target_actor_key() ;
  const std::string& target_actor_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_actor_key(Arg_&& arg, Args_... args);
  std::string* mutable_target_actor_key();
  PROTOBUF_NODISCARD std::string* release_target_actor_key();
  void set_allocated_target_actor_key(std::string* ptr);

  private:
  const std::string& _internal_target_actor_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_actor_key(
      const std::string& value);
  std::string* _internal_mutable_target_actor_key();

  public:
  // string result_skill_id_key = 7;
  void clear_result_skill_id_key() ;
  const std::string& result_skill_id_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_skill_id_key(Arg_&& arg, Args_... args);
  std::string* mutable_result_skill_id_key();
  PROTOBUF_NODISCARD std::string* release_result_skill_id_key();
  void set_allocated_result_skill_id_key(std::string* ptr);

  private:
  const std::string& _internal_result_skill_id_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_skill_id_key(
      const std::string& value);
  std::string* _internal_mutable_result_skill_id_key();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool ignore_restart_self = 5;
  void clear_ignore_restart_self() ;
  bool ignore_restart_self() const;
  void set_ignore_restart_self(bool value);

  private:
  bool _internal_ignore_restart_self() const;
  void _internal_set_ignore_restart_self(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiChooseSkill)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      70, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::google::protobuf::internal::ArenaStringPtr target_actor_key_;
    ::google::protobuf::internal::ArenaStringPtr result_skill_id_key_;
    ::int32_t id_;
    bool ignore_restart_self_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiTask final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiTask) */ {
 public:
  inline AiTask() : AiTask(nullptr) {}
  ~AiTask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiTask(::google::protobuf::internal::ConstantInitialized);

  AiTask(const AiTask& from);
  AiTask(AiTask&& from) noexcept
    : AiTask() {
    *this = ::std::move(from);
  }

  inline AiTask(::google::protobuf::Arena* arena, const AiTask& from)
    : AiTask(arena) {
    MergeFrom(from);
  }
  inline AiTask& operator=(const AiTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiTask& operator=(AiTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiTask& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUeWait = 17,
    kUeWaitBlackboardTime = 18,
    kMoveToTarget = 19,
    kChooseSkill = 20,
    kMoveToRandomLocation = 21,
    kMoveToLocation = 22,
    kDebugPrint = 23,
    VALUE_NOT_SET = 0,
  };

  static inline const AiTask* internal_default_instance() {
    return reinterpret_cast<const AiTask*>(
               &_AiTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AiTask& a, AiTask& b) {
    a.Swap(&b);
  }
  inline void Swap(AiTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiTask& from) {
    AiTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiTask* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiTask";
  }
  protected:
  explicit AiTask(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeWaitFieldNumber = 17,
    kUeWaitBlackboardTimeFieldNumber = 18,
    kMoveToTargetFieldNumber = 19,
    kChooseSkillFieldNumber = 20,
    kMoveToRandomLocationFieldNumber = 21,
    kMoveToLocationFieldNumber = 22,
    kDebugPrintFieldNumber = 23,
  };
  // .cfg.AiUeWait UeWait = 17;
  bool has_uewait() const;
  private:
  bool _internal_has_uewait() const;

  public:
  void clear_uewait() ;
  const ::cfg::AiUeWait& uewait() const;
  PROTOBUF_NODISCARD ::cfg::AiUeWait* release_uewait();
  ::cfg::AiUeWait* mutable_uewait();
  void set_allocated_uewait(::cfg::AiUeWait* value);
  void unsafe_arena_set_allocated_uewait(::cfg::AiUeWait* value);
  ::cfg::AiUeWait* unsafe_arena_release_uewait();

  private:
  const ::cfg::AiUeWait& _internal_uewait() const;
  ::cfg::AiUeWait* _internal_mutable_uewait();

  public:
  // .cfg.AiUeWaitBlackboardTime UeWaitBlackboardTime = 18;
  bool has_uewaitblackboardtime() const;
  private:
  bool _internal_has_uewaitblackboardtime() const;

  public:
  void clear_uewaitblackboardtime() ;
  const ::cfg::AiUeWaitBlackboardTime& uewaitblackboardtime() const;
  PROTOBUF_NODISCARD ::cfg::AiUeWaitBlackboardTime* release_uewaitblackboardtime();
  ::cfg::AiUeWaitBlackboardTime* mutable_uewaitblackboardtime();
  void set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* value);
  void unsafe_arena_set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* value);
  ::cfg::AiUeWaitBlackboardTime* unsafe_arena_release_uewaitblackboardtime();

  private:
  const ::cfg::AiUeWaitBlackboardTime& _internal_uewaitblackboardtime() const;
  ::cfg::AiUeWaitBlackboardTime* _internal_mutable_uewaitblackboardtime();

  public:
  // .cfg.AiMoveToTarget MoveToTarget = 19;
  bool has_movetotarget() const;
  private:
  bool _internal_has_movetotarget() const;

  public:
  void clear_movetotarget() ;
  const ::cfg::AiMoveToTarget& movetotarget() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToTarget* release_movetotarget();
  ::cfg::AiMoveToTarget* mutable_movetotarget();
  void set_allocated_movetotarget(::cfg::AiMoveToTarget* value);
  void unsafe_arena_set_allocated_movetotarget(::cfg::AiMoveToTarget* value);
  ::cfg::AiMoveToTarget* unsafe_arena_release_movetotarget();

  private:
  const ::cfg::AiMoveToTarget& _internal_movetotarget() const;
  ::cfg::AiMoveToTarget* _internal_mutable_movetotarget();

  public:
  // .cfg.AiChooseSkill ChooseSkill = 20;
  bool has_chooseskill() const;
  private:
  bool _internal_has_chooseskill() const;

  public:
  void clear_chooseskill() ;
  const ::cfg::AiChooseSkill& chooseskill() const;
  PROTOBUF_NODISCARD ::cfg::AiChooseSkill* release_chooseskill();
  ::cfg::AiChooseSkill* mutable_chooseskill();
  void set_allocated_chooseskill(::cfg::AiChooseSkill* value);
  void unsafe_arena_set_allocated_chooseskill(::cfg::AiChooseSkill* value);
  ::cfg::AiChooseSkill* unsafe_arena_release_chooseskill();

  private:
  const ::cfg::AiChooseSkill& _internal_chooseskill() const;
  ::cfg::AiChooseSkill* _internal_mutable_chooseskill();

  public:
  // .cfg.AiMoveToRandomLocation MoveToRandomLocation = 21;
  bool has_movetorandomlocation() const;
  private:
  bool _internal_has_movetorandomlocation() const;

  public:
  void clear_movetorandomlocation() ;
  const ::cfg::AiMoveToRandomLocation& movetorandomlocation() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToRandomLocation* release_movetorandomlocation();
  ::cfg::AiMoveToRandomLocation* mutable_movetorandomlocation();
  void set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* value);
  void unsafe_arena_set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* value);
  ::cfg::AiMoveToRandomLocation* unsafe_arena_release_movetorandomlocation();

  private:
  const ::cfg::AiMoveToRandomLocation& _internal_movetorandomlocation() const;
  ::cfg::AiMoveToRandomLocation* _internal_mutable_movetorandomlocation();

  public:
  // .cfg.AiMoveToLocation MoveToLocation = 22;
  bool has_movetolocation() const;
  private:
  bool _internal_has_movetolocation() const;

  public:
  void clear_movetolocation() ;
  const ::cfg::AiMoveToLocation& movetolocation() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToLocation* release_movetolocation();
  ::cfg::AiMoveToLocation* mutable_movetolocation();
  void set_allocated_movetolocation(::cfg::AiMoveToLocation* value);
  void unsafe_arena_set_allocated_movetolocation(::cfg::AiMoveToLocation* value);
  ::cfg::AiMoveToLocation* unsafe_arena_release_movetolocation();

  private:
  const ::cfg::AiMoveToLocation& _internal_movetolocation() const;
  ::cfg::AiMoveToLocation* _internal_mutable_movetolocation();

  public:
  // .cfg.AiDebugPrint DebugPrint = 23;
  bool has_debugprint() const;
  private:
  bool _internal_has_debugprint() const;

  public:
  void clear_debugprint() ;
  const ::cfg::AiDebugPrint& debugprint() const;
  PROTOBUF_NODISCARD ::cfg::AiDebugPrint* release_debugprint();
  ::cfg::AiDebugPrint* mutable_debugprint();
  void set_allocated_debugprint(::cfg::AiDebugPrint* value);
  void unsafe_arena_set_allocated_debugprint(::cfg::AiDebugPrint* value);
  ::cfg::AiDebugPrint* unsafe_arena_release_debugprint();

  private:
  const ::cfg::AiDebugPrint& _internal_debugprint() const;
  ::cfg::AiDebugPrint* _internal_mutable_debugprint();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiTask)
 private:
  class _Internal;
  void set_has_uewait();
  void set_has_uewaitblackboardtime();
  void set_has_movetotarget();
  void set_has_chooseskill();
  void set_has_movetorandomlocation();
  void set_has_movetolocation();
  void set_has_debugprint();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 7,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiUeWait* uewait_;
      ::cfg::AiUeWaitBlackboardTime* uewaitblackboardtime_;
      ::cfg::AiMoveToTarget* movetotarget_;
      ::cfg::AiChooseSkill* chooseskill_;
      ::cfg::AiMoveToRandomLocation* movetorandomlocation_;
      ::cfg::AiMoveToLocation* movetolocation_;
      ::cfg::AiDebugPrint* debugprint_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiFlowNode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiFlowNode) */ {
 public:
  inline AiFlowNode() : AiFlowNode(nullptr) {}
  ~AiFlowNode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiFlowNode(::google::protobuf::internal::ConstantInitialized);

  AiFlowNode(const AiFlowNode& from);
  AiFlowNode(AiFlowNode&& from) noexcept
    : AiFlowNode() {
    *this = ::std::move(from);
  }

  inline AiFlowNode(::google::protobuf::Arena* arena, const AiFlowNode& from)
    : AiFlowNode(arena) {
    MergeFrom(from);
  }
  inline AiFlowNode& operator=(const AiFlowNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiFlowNode& operator=(AiFlowNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiFlowNode& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kSequence = 14,
    kSelector = 15,
    kSimpleParallel = 16,
    kUeWait = 17,
    kUeWaitBlackboardTime = 18,
    kMoveToTarget = 19,
    kChooseSkill = 20,
    kMoveToRandomLocation = 21,
    kMoveToLocation = 22,
    kDebugPrint = 23,
    VALUE_NOT_SET = 0,
  };

  static inline const AiFlowNode* internal_default_instance() {
    return reinterpret_cast<const AiFlowNode*>(
               &_AiFlowNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AiFlowNode& a, AiFlowNode& b) {
    a.Swap(&b);
  }
  inline void Swap(AiFlowNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiFlowNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiFlowNode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiFlowNode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiFlowNode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiFlowNode& from) {
    AiFlowNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiFlowNode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiFlowNode";
  }
  protected:
  explicit AiFlowNode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 14,
    kSelectorFieldNumber = 15,
    kSimpleParallelFieldNumber = 16,
    kUeWaitFieldNumber = 17,
    kUeWaitBlackboardTimeFieldNumber = 18,
    kMoveToTargetFieldNumber = 19,
    kChooseSkillFieldNumber = 20,
    kMoveToRandomLocationFieldNumber = 21,
    kMoveToLocationFieldNumber = 22,
    kDebugPrintFieldNumber = 23,
  };
  // .cfg.AiSequence Sequence = 14;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;

  public:
  void clear_sequence() ;
  const ::cfg::AiSequence& sequence() const;
  PROTOBUF_NODISCARD ::cfg::AiSequence* release_sequence();
  ::cfg::AiSequence* mutable_sequence();
  void set_allocated_sequence(::cfg::AiSequence* value);
  void unsafe_arena_set_allocated_sequence(::cfg::AiSequence* value);
  ::cfg::AiSequence* unsafe_arena_release_sequence();

  private:
  const ::cfg::AiSequence& _internal_sequence() const;
  ::cfg::AiSequence* _internal_mutable_sequence();

  public:
  // .cfg.AiSelector Selector = 15;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;

  public:
  void clear_selector() ;
  const ::cfg::AiSelector& selector() const;
  PROTOBUF_NODISCARD ::cfg::AiSelector* release_selector();
  ::cfg::AiSelector* mutable_selector();
  void set_allocated_selector(::cfg::AiSelector* value);
  void unsafe_arena_set_allocated_selector(::cfg::AiSelector* value);
  ::cfg::AiSelector* unsafe_arena_release_selector();

  private:
  const ::cfg::AiSelector& _internal_selector() const;
  ::cfg::AiSelector* _internal_mutable_selector();

  public:
  // .cfg.AiSimpleParallel SimpleParallel = 16;
  bool has_simpleparallel() const;
  private:
  bool _internal_has_simpleparallel() const;

  public:
  void clear_simpleparallel() ;
  const ::cfg::AiSimpleParallel& simpleparallel() const;
  PROTOBUF_NODISCARD ::cfg::AiSimpleParallel* release_simpleparallel();
  ::cfg::AiSimpleParallel* mutable_simpleparallel();
  void set_allocated_simpleparallel(::cfg::AiSimpleParallel* value);
  void unsafe_arena_set_allocated_simpleparallel(::cfg::AiSimpleParallel* value);
  ::cfg::AiSimpleParallel* unsafe_arena_release_simpleparallel();

  private:
  const ::cfg::AiSimpleParallel& _internal_simpleparallel() const;
  ::cfg::AiSimpleParallel* _internal_mutable_simpleparallel();

  public:
  // .cfg.AiUeWait UeWait = 17;
  bool has_uewait() const;
  private:
  bool _internal_has_uewait() const;

  public:
  void clear_uewait() ;
  const ::cfg::AiUeWait& uewait() const;
  PROTOBUF_NODISCARD ::cfg::AiUeWait* release_uewait();
  ::cfg::AiUeWait* mutable_uewait();
  void set_allocated_uewait(::cfg::AiUeWait* value);
  void unsafe_arena_set_allocated_uewait(::cfg::AiUeWait* value);
  ::cfg::AiUeWait* unsafe_arena_release_uewait();

  private:
  const ::cfg::AiUeWait& _internal_uewait() const;
  ::cfg::AiUeWait* _internal_mutable_uewait();

  public:
  // .cfg.AiUeWaitBlackboardTime UeWaitBlackboardTime = 18;
  bool has_uewaitblackboardtime() const;
  private:
  bool _internal_has_uewaitblackboardtime() const;

  public:
  void clear_uewaitblackboardtime() ;
  const ::cfg::AiUeWaitBlackboardTime& uewaitblackboardtime() const;
  PROTOBUF_NODISCARD ::cfg::AiUeWaitBlackboardTime* release_uewaitblackboardtime();
  ::cfg::AiUeWaitBlackboardTime* mutable_uewaitblackboardtime();
  void set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* value);
  void unsafe_arena_set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* value);
  ::cfg::AiUeWaitBlackboardTime* unsafe_arena_release_uewaitblackboardtime();

  private:
  const ::cfg::AiUeWaitBlackboardTime& _internal_uewaitblackboardtime() const;
  ::cfg::AiUeWaitBlackboardTime* _internal_mutable_uewaitblackboardtime();

  public:
  // .cfg.AiMoveToTarget MoveToTarget = 19;
  bool has_movetotarget() const;
  private:
  bool _internal_has_movetotarget() const;

  public:
  void clear_movetotarget() ;
  const ::cfg::AiMoveToTarget& movetotarget() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToTarget* release_movetotarget();
  ::cfg::AiMoveToTarget* mutable_movetotarget();
  void set_allocated_movetotarget(::cfg::AiMoveToTarget* value);
  void unsafe_arena_set_allocated_movetotarget(::cfg::AiMoveToTarget* value);
  ::cfg::AiMoveToTarget* unsafe_arena_release_movetotarget();

  private:
  const ::cfg::AiMoveToTarget& _internal_movetotarget() const;
  ::cfg::AiMoveToTarget* _internal_mutable_movetotarget();

  public:
  // .cfg.AiChooseSkill ChooseSkill = 20;
  bool has_chooseskill() const;
  private:
  bool _internal_has_chooseskill() const;

  public:
  void clear_chooseskill() ;
  const ::cfg::AiChooseSkill& chooseskill() const;
  PROTOBUF_NODISCARD ::cfg::AiChooseSkill* release_chooseskill();
  ::cfg::AiChooseSkill* mutable_chooseskill();
  void set_allocated_chooseskill(::cfg::AiChooseSkill* value);
  void unsafe_arena_set_allocated_chooseskill(::cfg::AiChooseSkill* value);
  ::cfg::AiChooseSkill* unsafe_arena_release_chooseskill();

  private:
  const ::cfg::AiChooseSkill& _internal_chooseskill() const;
  ::cfg::AiChooseSkill* _internal_mutable_chooseskill();

  public:
  // .cfg.AiMoveToRandomLocation MoveToRandomLocation = 21;
  bool has_movetorandomlocation() const;
  private:
  bool _internal_has_movetorandomlocation() const;

  public:
  void clear_movetorandomlocation() ;
  const ::cfg::AiMoveToRandomLocation& movetorandomlocation() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToRandomLocation* release_movetorandomlocation();
  ::cfg::AiMoveToRandomLocation* mutable_movetorandomlocation();
  void set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* value);
  void unsafe_arena_set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* value);
  ::cfg::AiMoveToRandomLocation* unsafe_arena_release_movetorandomlocation();

  private:
  const ::cfg::AiMoveToRandomLocation& _internal_movetorandomlocation() const;
  ::cfg::AiMoveToRandomLocation* _internal_mutable_movetorandomlocation();

  public:
  // .cfg.AiMoveToLocation MoveToLocation = 22;
  bool has_movetolocation() const;
  private:
  bool _internal_has_movetolocation() const;

  public:
  void clear_movetolocation() ;
  const ::cfg::AiMoveToLocation& movetolocation() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToLocation* release_movetolocation();
  ::cfg::AiMoveToLocation* mutable_movetolocation();
  void set_allocated_movetolocation(::cfg::AiMoveToLocation* value);
  void unsafe_arena_set_allocated_movetolocation(::cfg::AiMoveToLocation* value);
  ::cfg::AiMoveToLocation* unsafe_arena_release_movetolocation();

  private:
  const ::cfg::AiMoveToLocation& _internal_movetolocation() const;
  ::cfg::AiMoveToLocation* _internal_mutable_movetolocation();

  public:
  // .cfg.AiDebugPrint DebugPrint = 23;
  bool has_debugprint() const;
  private:
  bool _internal_has_debugprint() const;

  public:
  void clear_debugprint() ;
  const ::cfg::AiDebugPrint& debugprint() const;
  PROTOBUF_NODISCARD ::cfg::AiDebugPrint* release_debugprint();
  ::cfg::AiDebugPrint* mutable_debugprint();
  void set_allocated_debugprint(::cfg::AiDebugPrint* value);
  void unsafe_arena_set_allocated_debugprint(::cfg::AiDebugPrint* value);
  ::cfg::AiDebugPrint* unsafe_arena_release_debugprint();

  private:
  const ::cfg::AiDebugPrint& _internal_debugprint() const;
  ::cfg::AiDebugPrint* _internal_mutable_debugprint();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiFlowNode)
 private:
  class _Internal;
  void set_has_sequence();
  void set_has_selector();
  void set_has_simpleparallel();
  void set_has_uewait();
  void set_has_uewaitblackboardtime();
  void set_has_movetotarget();
  void set_has_chooseskill();
  void set_has_movetorandomlocation();
  void set_has_movetolocation();
  void set_has_debugprint();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 10, 10,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiSequence* sequence_;
      ::cfg::AiSelector* selector_;
      ::cfg::AiSimpleParallel* simpleparallel_;
      ::cfg::AiUeWait* uewait_;
      ::cfg::AiUeWaitBlackboardTime* uewaitblackboardtime_;
      ::cfg::AiMoveToTarget* movetotarget_;
      ::cfg::AiChooseSkill* chooseskill_;
      ::cfg::AiMoveToRandomLocation* movetorandomlocation_;
      ::cfg::AiMoveToLocation* movetolocation_;
      ::cfg::AiDebugPrint* debugprint_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiSelector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiSelector) */ {
 public:
  inline AiSelector() : AiSelector(nullptr) {}
  ~AiSelector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiSelector(::google::protobuf::internal::ConstantInitialized);

  AiSelector(const AiSelector& from);
  AiSelector(AiSelector&& from) noexcept
    : AiSelector() {
    *this = ::std::move(from);
  }

  inline AiSelector(::google::protobuf::Arena* arena, const AiSelector& from)
    : AiSelector(arena) {
    MergeFrom(from);
  }
  inline AiSelector& operator=(const AiSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiSelector& operator=(AiSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiSelector* internal_default_instance() {
    return reinterpret_cast<const AiSelector*>(
               &_AiSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AiSelector& a, AiSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(AiSelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiSelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiSelector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiSelector& from) {
    AiSelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiSelector* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiSelector";
  }
  protected:
  explicit AiSelector(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kChildrenFieldNumber = 5,
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // repeated .cfg.AiFlowNode children = 5 [packed = false];
  int children_size() const;
  private:
  int _internal_children_size() const;

  public:
  void clear_children() ;
  ::cfg::AiFlowNode* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiFlowNode >*
      mutable_children();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>& _internal_children() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>* _internal_mutable_children();
  public:
  const ::cfg::AiFlowNode& children(int index) const;
  ::cfg::AiFlowNode* add_children();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiFlowNode >&
      children() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiSelector)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      32, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiFlowNode > children_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiSequence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiSequence) */ {
 public:
  inline AiSequence() : AiSequence(nullptr) {}
  ~AiSequence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiSequence(::google::protobuf::internal::ConstantInitialized);

  AiSequence(const AiSequence& from);
  AiSequence(AiSequence&& from) noexcept
    : AiSequence() {
    *this = ::std::move(from);
  }

  inline AiSequence(::google::protobuf::Arena* arena, const AiSequence& from)
    : AiSequence(arena) {
    MergeFrom(from);
  }
  inline AiSequence& operator=(const AiSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiSequence& operator=(AiSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiSequence* internal_default_instance() {
    return reinterpret_cast<const AiSequence*>(
               &_AiSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AiSequence& a, AiSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(AiSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiSequence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiSequence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiSequence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiSequence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiSequence& from) {
    AiSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiSequence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiSequence";
  }
  protected:
  explicit AiSequence(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kChildrenFieldNumber = 5,
    kNodeNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // repeated .cfg.AiFlowNode children = 5 [packed = false];
  int children_size() const;
  private:
  int _internal_children_size() const;

  public:
  void clear_children() ;
  ::cfg::AiFlowNode* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiFlowNode >*
      mutable_children();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>& _internal_children() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>* _internal_mutable_children();
  public:
  const ::cfg::AiFlowNode& children(int index) const;
  ::cfg::AiFlowNode* add_children();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiFlowNode >&
      children() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiSequence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      32, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiFlowNode > children_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiSimpleParallel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiSimpleParallel) */ {
 public:
  inline AiSimpleParallel() : AiSimpleParallel(nullptr) {}
  ~AiSimpleParallel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiSimpleParallel(::google::protobuf::internal::ConstantInitialized);

  AiSimpleParallel(const AiSimpleParallel& from);
  AiSimpleParallel(AiSimpleParallel&& from) noexcept
    : AiSimpleParallel() {
    *this = ::std::move(from);
  }

  inline AiSimpleParallel(::google::protobuf::Arena* arena, const AiSimpleParallel& from)
    : AiSimpleParallel(arena) {
    MergeFrom(from);
  }
  inline AiSimpleParallel& operator=(const AiSimpleParallel& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiSimpleParallel& operator=(AiSimpleParallel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiSimpleParallel& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiSimpleParallel* internal_default_instance() {
    return reinterpret_cast<const AiSimpleParallel*>(
               &_AiSimpleParallel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AiSimpleParallel& a, AiSimpleParallel& b) {
    a.Swap(&b);
  }
  inline void Swap(AiSimpleParallel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiSimpleParallel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiSimpleParallel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiSimpleParallel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiSimpleParallel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiSimpleParallel& from) {
    AiSimpleParallel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiSimpleParallel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiSimpleParallel";
  }
  protected:
  explicit AiSimpleParallel(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoratorsFieldNumber = 3,
    kServicesFieldNumber = 4,
    kNodeNameFieldNumber = 2,
    kMainTaskFieldNumber = 6,
    kBackgroundNodeFieldNumber = 7,
    kIdFieldNumber = 1,
    kFinishModeFieldNumber = 5,
  };
  // repeated .cfg.AiDecorator decorators = 3 [packed = false];
  int decorators_size() const;
  private:
  int _internal_decorators_size() const;

  public:
  void clear_decorators() ;
  ::cfg::AiDecorator* mutable_decorators(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >*
      mutable_decorators();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& _internal_decorators() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* _internal_mutable_decorators();
  public:
  const ::cfg::AiDecorator& decorators(int index) const;
  ::cfg::AiDecorator* add_decorators();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator >&
      decorators() const;
  // repeated .cfg.AiService services = 4 [packed = false];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::cfg::AiService* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiService >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiService>* _internal_mutable_services();
  public:
  const ::cfg::AiService& services(int index) const;
  ::cfg::AiService* add_services();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiService >&
      services() const;
  // string node_name = 2;
  void clear_node_name() ;
  const std::string& node_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_name(Arg_&& arg, Args_... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* ptr);

  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(
      const std::string& value);
  std::string* _internal_mutable_node_name();

  public:
  // .cfg.AiTask main_task = 6;
  bool has_main_task() const;
  void clear_main_task() ;
  const ::cfg::AiTask& main_task() const;
  PROTOBUF_NODISCARD ::cfg::AiTask* release_main_task();
  ::cfg::AiTask* mutable_main_task();
  void set_allocated_main_task(::cfg::AiTask* value);
  void unsafe_arena_set_allocated_main_task(::cfg::AiTask* value);
  ::cfg::AiTask* unsafe_arena_release_main_task();

  private:
  const ::cfg::AiTask& _internal_main_task() const;
  ::cfg::AiTask* _internal_mutable_main_task();

  public:
  // .cfg.AiFlowNode background_node = 7;
  bool has_background_node() const;
  void clear_background_node() ;
  const ::cfg::AiFlowNode& background_node() const;
  PROTOBUF_NODISCARD ::cfg::AiFlowNode* release_background_node();
  ::cfg::AiFlowNode* mutable_background_node();
  void set_allocated_background_node(::cfg::AiFlowNode* value);
  void unsafe_arena_set_allocated_background_node(::cfg::AiFlowNode* value);
  ::cfg::AiFlowNode* unsafe_arena_release_background_node();

  private:
  const ::cfg::AiFlowNode& _internal_background_node() const;
  ::cfg::AiFlowNode* _internal_mutable_background_node();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .cfg.AiEFinishMode finish_mode = 5;
  void clear_finish_mode() ;
  ::cfg::AiEFinishMode finish_mode() const;
  void set_finish_mode(::cfg::AiEFinishMode value);

  private:
  ::cfg::AiEFinishMode _internal_finish_mode() const;
  void _internal_set_finish_mode(::cfg::AiEFinishMode value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiSimpleParallel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 4,
      38, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiDecorator > decorators_;
    ::google::protobuf::RepeatedPtrField< ::cfg::AiService > services_;
    ::google::protobuf::internal::ArenaStringPtr node_name_;
    ::cfg::AiTask* main_task_;
    ::cfg::AiFlowNode* background_node_;
    ::int32_t id_;
    int finish_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiNode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiNode) */ {
 public:
  inline AiNode() : AiNode(nullptr) {}
  ~AiNode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiNode(::google::protobuf::internal::ConstantInitialized);

  AiNode(const AiNode& from);
  AiNode(AiNode&& from) noexcept
    : AiNode() {
    *this = ::std::move(from);
  }

  inline AiNode(::google::protobuf::Arena* arena, const AiNode& from)
    : AiNode(arena) {
    MergeFrom(from);
  }
  inline AiNode& operator=(const AiNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiNode& operator=(AiNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiNode& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUeSetDefaultFocus = 1,
    kExecuteTimeStatistic = 2,
    kChooseTarget = 3,
    kKeepFaceTarget = 4,
    kGetOwnerPlayer = 5,
    kUpdateDailyBehaviorProps = 6,
    kUeLoop = 7,
    kUeCooldown = 8,
    kUeTimeLimit = 9,
    kUeBlackboard = 10,
    kUeForceSuccess = 11,
    kIsAtLocation = 12,
    kDistanceLessThan = 13,
    kSequence = 14,
    kSelector = 15,
    kSimpleParallel = 16,
    kUeWait = 17,
    kUeWaitBlackboardTime = 18,
    kMoveToTarget = 19,
    kChooseSkill = 20,
    kMoveToRandomLocation = 21,
    kMoveToLocation = 22,
    kDebugPrint = 23,
    VALUE_NOT_SET = 0,
  };

  static inline const AiNode* internal_default_instance() {
    return reinterpret_cast<const AiNode*>(
               &_AiNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AiNode& a, AiNode& b) {
    a.Swap(&b);
  }
  inline void Swap(AiNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiNode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiNode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiNode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiNode& from) {
    AiNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiNode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiNode";
  }
  protected:
  explicit AiNode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeSetDefaultFocusFieldNumber = 1,
    kExecuteTimeStatisticFieldNumber = 2,
    kChooseTargetFieldNumber = 3,
    kKeepFaceTargetFieldNumber = 4,
    kGetOwnerPlayerFieldNumber = 5,
    kUpdateDailyBehaviorPropsFieldNumber = 6,
    kUeLoopFieldNumber = 7,
    kUeCooldownFieldNumber = 8,
    kUeTimeLimitFieldNumber = 9,
    kUeBlackboardFieldNumber = 10,
    kUeForceSuccessFieldNumber = 11,
    kIsAtLocationFieldNumber = 12,
    kDistanceLessThanFieldNumber = 13,
    kSequenceFieldNumber = 14,
    kSelectorFieldNumber = 15,
    kSimpleParallelFieldNumber = 16,
    kUeWaitFieldNumber = 17,
    kUeWaitBlackboardTimeFieldNumber = 18,
    kMoveToTargetFieldNumber = 19,
    kChooseSkillFieldNumber = 20,
    kMoveToRandomLocationFieldNumber = 21,
    kMoveToLocationFieldNumber = 22,
    kDebugPrintFieldNumber = 23,
  };
  // .cfg.AiUeSetDefaultFocus UeSetDefaultFocus = 1;
  bool has_uesetdefaultfocus() const;
  private:
  bool _internal_has_uesetdefaultfocus() const;

  public:
  void clear_uesetdefaultfocus() ;
  const ::cfg::AiUeSetDefaultFocus& uesetdefaultfocus() const;
  PROTOBUF_NODISCARD ::cfg::AiUeSetDefaultFocus* release_uesetdefaultfocus();
  ::cfg::AiUeSetDefaultFocus* mutable_uesetdefaultfocus();
  void set_allocated_uesetdefaultfocus(::cfg::AiUeSetDefaultFocus* value);
  void unsafe_arena_set_allocated_uesetdefaultfocus(::cfg::AiUeSetDefaultFocus* value);
  ::cfg::AiUeSetDefaultFocus* unsafe_arena_release_uesetdefaultfocus();

  private:
  const ::cfg::AiUeSetDefaultFocus& _internal_uesetdefaultfocus() const;
  ::cfg::AiUeSetDefaultFocus* _internal_mutable_uesetdefaultfocus();

  public:
  // .cfg.AiExecuteTimeStatistic ExecuteTimeStatistic = 2;
  bool has_executetimestatistic() const;
  private:
  bool _internal_has_executetimestatistic() const;

  public:
  void clear_executetimestatistic() ;
  const ::cfg::AiExecuteTimeStatistic& executetimestatistic() const;
  PROTOBUF_NODISCARD ::cfg::AiExecuteTimeStatistic* release_executetimestatistic();
  ::cfg::AiExecuteTimeStatistic* mutable_executetimestatistic();
  void set_allocated_executetimestatistic(::cfg::AiExecuteTimeStatistic* value);
  void unsafe_arena_set_allocated_executetimestatistic(::cfg::AiExecuteTimeStatistic* value);
  ::cfg::AiExecuteTimeStatistic* unsafe_arena_release_executetimestatistic();

  private:
  const ::cfg::AiExecuteTimeStatistic& _internal_executetimestatistic() const;
  ::cfg::AiExecuteTimeStatistic* _internal_mutable_executetimestatistic();

  public:
  // .cfg.AiChooseTarget ChooseTarget = 3;
  bool has_choosetarget() const;
  private:
  bool _internal_has_choosetarget() const;

  public:
  void clear_choosetarget() ;
  const ::cfg::AiChooseTarget& choosetarget() const;
  PROTOBUF_NODISCARD ::cfg::AiChooseTarget* release_choosetarget();
  ::cfg::AiChooseTarget* mutable_choosetarget();
  void set_allocated_choosetarget(::cfg::AiChooseTarget* value);
  void unsafe_arena_set_allocated_choosetarget(::cfg::AiChooseTarget* value);
  ::cfg::AiChooseTarget* unsafe_arena_release_choosetarget();

  private:
  const ::cfg::AiChooseTarget& _internal_choosetarget() const;
  ::cfg::AiChooseTarget* _internal_mutable_choosetarget();

  public:
  // .cfg.AiKeepFaceTarget KeepFaceTarget = 4;
  bool has_keepfacetarget() const;
  private:
  bool _internal_has_keepfacetarget() const;

  public:
  void clear_keepfacetarget() ;
  const ::cfg::AiKeepFaceTarget& keepfacetarget() const;
  PROTOBUF_NODISCARD ::cfg::AiKeepFaceTarget* release_keepfacetarget();
  ::cfg::AiKeepFaceTarget* mutable_keepfacetarget();
  void set_allocated_keepfacetarget(::cfg::AiKeepFaceTarget* value);
  void unsafe_arena_set_allocated_keepfacetarget(::cfg::AiKeepFaceTarget* value);
  ::cfg::AiKeepFaceTarget* unsafe_arena_release_keepfacetarget();

  private:
  const ::cfg::AiKeepFaceTarget& _internal_keepfacetarget() const;
  ::cfg::AiKeepFaceTarget* _internal_mutable_keepfacetarget();

  public:
  // .cfg.AiGetOwnerPlayer GetOwnerPlayer = 5;
  bool has_getownerplayer() const;
  private:
  bool _internal_has_getownerplayer() const;

  public:
  void clear_getownerplayer() ;
  const ::cfg::AiGetOwnerPlayer& getownerplayer() const;
  PROTOBUF_NODISCARD ::cfg::AiGetOwnerPlayer* release_getownerplayer();
  ::cfg::AiGetOwnerPlayer* mutable_getownerplayer();
  void set_allocated_getownerplayer(::cfg::AiGetOwnerPlayer* value);
  void unsafe_arena_set_allocated_getownerplayer(::cfg::AiGetOwnerPlayer* value);
  ::cfg::AiGetOwnerPlayer* unsafe_arena_release_getownerplayer();

  private:
  const ::cfg::AiGetOwnerPlayer& _internal_getownerplayer() const;
  ::cfg::AiGetOwnerPlayer* _internal_mutable_getownerplayer();

  public:
  // .cfg.AiUpdateDailyBehaviorProps UpdateDailyBehaviorProps = 6;
  bool has_updatedailybehaviorprops() const;
  private:
  bool _internal_has_updatedailybehaviorprops() const;

  public:
  void clear_updatedailybehaviorprops() ;
  const ::cfg::AiUpdateDailyBehaviorProps& updatedailybehaviorprops() const;
  PROTOBUF_NODISCARD ::cfg::AiUpdateDailyBehaviorProps* release_updatedailybehaviorprops();
  ::cfg::AiUpdateDailyBehaviorProps* mutable_updatedailybehaviorprops();
  void set_allocated_updatedailybehaviorprops(::cfg::AiUpdateDailyBehaviorProps* value);
  void unsafe_arena_set_allocated_updatedailybehaviorprops(::cfg::AiUpdateDailyBehaviorProps* value);
  ::cfg::AiUpdateDailyBehaviorProps* unsafe_arena_release_updatedailybehaviorprops();

  private:
  const ::cfg::AiUpdateDailyBehaviorProps& _internal_updatedailybehaviorprops() const;
  ::cfg::AiUpdateDailyBehaviorProps* _internal_mutable_updatedailybehaviorprops();

  public:
  // .cfg.AiUeLoop UeLoop = 7;
  bool has_ueloop() const;
  private:
  bool _internal_has_ueloop() const;

  public:
  void clear_ueloop() ;
  const ::cfg::AiUeLoop& ueloop() const;
  PROTOBUF_NODISCARD ::cfg::AiUeLoop* release_ueloop();
  ::cfg::AiUeLoop* mutable_ueloop();
  void set_allocated_ueloop(::cfg::AiUeLoop* value);
  void unsafe_arena_set_allocated_ueloop(::cfg::AiUeLoop* value);
  ::cfg::AiUeLoop* unsafe_arena_release_ueloop();

  private:
  const ::cfg::AiUeLoop& _internal_ueloop() const;
  ::cfg::AiUeLoop* _internal_mutable_ueloop();

  public:
  // .cfg.AiUeCooldown UeCooldown = 8;
  bool has_uecooldown() const;
  private:
  bool _internal_has_uecooldown() const;

  public:
  void clear_uecooldown() ;
  const ::cfg::AiUeCooldown& uecooldown() const;
  PROTOBUF_NODISCARD ::cfg::AiUeCooldown* release_uecooldown();
  ::cfg::AiUeCooldown* mutable_uecooldown();
  void set_allocated_uecooldown(::cfg::AiUeCooldown* value);
  void unsafe_arena_set_allocated_uecooldown(::cfg::AiUeCooldown* value);
  ::cfg::AiUeCooldown* unsafe_arena_release_uecooldown();

  private:
  const ::cfg::AiUeCooldown& _internal_uecooldown() const;
  ::cfg::AiUeCooldown* _internal_mutable_uecooldown();

  public:
  // .cfg.AiUeTimeLimit UeTimeLimit = 9;
  bool has_uetimelimit() const;
  private:
  bool _internal_has_uetimelimit() const;

  public:
  void clear_uetimelimit() ;
  const ::cfg::AiUeTimeLimit& uetimelimit() const;
  PROTOBUF_NODISCARD ::cfg::AiUeTimeLimit* release_uetimelimit();
  ::cfg::AiUeTimeLimit* mutable_uetimelimit();
  void set_allocated_uetimelimit(::cfg::AiUeTimeLimit* value);
  void unsafe_arena_set_allocated_uetimelimit(::cfg::AiUeTimeLimit* value);
  ::cfg::AiUeTimeLimit* unsafe_arena_release_uetimelimit();

  private:
  const ::cfg::AiUeTimeLimit& _internal_uetimelimit() const;
  ::cfg::AiUeTimeLimit* _internal_mutable_uetimelimit();

  public:
  // .cfg.AiUeBlackboard UeBlackboard = 10;
  bool has_ueblackboard() const;
  private:
  bool _internal_has_ueblackboard() const;

  public:
  void clear_ueblackboard() ;
  const ::cfg::AiUeBlackboard& ueblackboard() const;
  PROTOBUF_NODISCARD ::cfg::AiUeBlackboard* release_ueblackboard();
  ::cfg::AiUeBlackboard* mutable_ueblackboard();
  void set_allocated_ueblackboard(::cfg::AiUeBlackboard* value);
  void unsafe_arena_set_allocated_ueblackboard(::cfg::AiUeBlackboard* value);
  ::cfg::AiUeBlackboard* unsafe_arena_release_ueblackboard();

  private:
  const ::cfg::AiUeBlackboard& _internal_ueblackboard() const;
  ::cfg::AiUeBlackboard* _internal_mutable_ueblackboard();

  public:
  // .cfg.AiUeForceSuccess UeForceSuccess = 11;
  bool has_ueforcesuccess() const;
  private:
  bool _internal_has_ueforcesuccess() const;

  public:
  void clear_ueforcesuccess() ;
  const ::cfg::AiUeForceSuccess& ueforcesuccess() const;
  PROTOBUF_NODISCARD ::cfg::AiUeForceSuccess* release_ueforcesuccess();
  ::cfg::AiUeForceSuccess* mutable_ueforcesuccess();
  void set_allocated_ueforcesuccess(::cfg::AiUeForceSuccess* value);
  void unsafe_arena_set_allocated_ueforcesuccess(::cfg::AiUeForceSuccess* value);
  ::cfg::AiUeForceSuccess* unsafe_arena_release_ueforcesuccess();

  private:
  const ::cfg::AiUeForceSuccess& _internal_ueforcesuccess() const;
  ::cfg::AiUeForceSuccess* _internal_mutable_ueforcesuccess();

  public:
  // .cfg.AiIsAtLocation IsAtLocation = 12;
  bool has_isatlocation() const;
  private:
  bool _internal_has_isatlocation() const;

  public:
  void clear_isatlocation() ;
  const ::cfg::AiIsAtLocation& isatlocation() const;
  PROTOBUF_NODISCARD ::cfg::AiIsAtLocation* release_isatlocation();
  ::cfg::AiIsAtLocation* mutable_isatlocation();
  void set_allocated_isatlocation(::cfg::AiIsAtLocation* value);
  void unsafe_arena_set_allocated_isatlocation(::cfg::AiIsAtLocation* value);
  ::cfg::AiIsAtLocation* unsafe_arena_release_isatlocation();

  private:
  const ::cfg::AiIsAtLocation& _internal_isatlocation() const;
  ::cfg::AiIsAtLocation* _internal_mutable_isatlocation();

  public:
  // .cfg.AiDistanceLessThan DistanceLessThan = 13;
  bool has_distancelessthan() const;
  private:
  bool _internal_has_distancelessthan() const;

  public:
  void clear_distancelessthan() ;
  const ::cfg::AiDistanceLessThan& distancelessthan() const;
  PROTOBUF_NODISCARD ::cfg::AiDistanceLessThan* release_distancelessthan();
  ::cfg::AiDistanceLessThan* mutable_distancelessthan();
  void set_allocated_distancelessthan(::cfg::AiDistanceLessThan* value);
  void unsafe_arena_set_allocated_distancelessthan(::cfg::AiDistanceLessThan* value);
  ::cfg::AiDistanceLessThan* unsafe_arena_release_distancelessthan();

  private:
  const ::cfg::AiDistanceLessThan& _internal_distancelessthan() const;
  ::cfg::AiDistanceLessThan* _internal_mutable_distancelessthan();

  public:
  // .cfg.AiSequence Sequence = 14;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;

  public:
  void clear_sequence() ;
  const ::cfg::AiSequence& sequence() const;
  PROTOBUF_NODISCARD ::cfg::AiSequence* release_sequence();
  ::cfg::AiSequence* mutable_sequence();
  void set_allocated_sequence(::cfg::AiSequence* value);
  void unsafe_arena_set_allocated_sequence(::cfg::AiSequence* value);
  ::cfg::AiSequence* unsafe_arena_release_sequence();

  private:
  const ::cfg::AiSequence& _internal_sequence() const;
  ::cfg::AiSequence* _internal_mutable_sequence();

  public:
  // .cfg.AiSelector Selector = 15;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;

  public:
  void clear_selector() ;
  const ::cfg::AiSelector& selector() const;
  PROTOBUF_NODISCARD ::cfg::AiSelector* release_selector();
  ::cfg::AiSelector* mutable_selector();
  void set_allocated_selector(::cfg::AiSelector* value);
  void unsafe_arena_set_allocated_selector(::cfg::AiSelector* value);
  ::cfg::AiSelector* unsafe_arena_release_selector();

  private:
  const ::cfg::AiSelector& _internal_selector() const;
  ::cfg::AiSelector* _internal_mutable_selector();

  public:
  // .cfg.AiSimpleParallel SimpleParallel = 16;
  bool has_simpleparallel() const;
  private:
  bool _internal_has_simpleparallel() const;

  public:
  void clear_simpleparallel() ;
  const ::cfg::AiSimpleParallel& simpleparallel() const;
  PROTOBUF_NODISCARD ::cfg::AiSimpleParallel* release_simpleparallel();
  ::cfg::AiSimpleParallel* mutable_simpleparallel();
  void set_allocated_simpleparallel(::cfg::AiSimpleParallel* value);
  void unsafe_arena_set_allocated_simpleparallel(::cfg::AiSimpleParallel* value);
  ::cfg::AiSimpleParallel* unsafe_arena_release_simpleparallel();

  private:
  const ::cfg::AiSimpleParallel& _internal_simpleparallel() const;
  ::cfg::AiSimpleParallel* _internal_mutable_simpleparallel();

  public:
  // .cfg.AiUeWait UeWait = 17;
  bool has_uewait() const;
  private:
  bool _internal_has_uewait() const;

  public:
  void clear_uewait() ;
  const ::cfg::AiUeWait& uewait() const;
  PROTOBUF_NODISCARD ::cfg::AiUeWait* release_uewait();
  ::cfg::AiUeWait* mutable_uewait();
  void set_allocated_uewait(::cfg::AiUeWait* value);
  void unsafe_arena_set_allocated_uewait(::cfg::AiUeWait* value);
  ::cfg::AiUeWait* unsafe_arena_release_uewait();

  private:
  const ::cfg::AiUeWait& _internal_uewait() const;
  ::cfg::AiUeWait* _internal_mutable_uewait();

  public:
  // .cfg.AiUeWaitBlackboardTime UeWaitBlackboardTime = 18;
  bool has_uewaitblackboardtime() const;
  private:
  bool _internal_has_uewaitblackboardtime() const;

  public:
  void clear_uewaitblackboardtime() ;
  const ::cfg::AiUeWaitBlackboardTime& uewaitblackboardtime() const;
  PROTOBUF_NODISCARD ::cfg::AiUeWaitBlackboardTime* release_uewaitblackboardtime();
  ::cfg::AiUeWaitBlackboardTime* mutable_uewaitblackboardtime();
  void set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* value);
  void unsafe_arena_set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* value);
  ::cfg::AiUeWaitBlackboardTime* unsafe_arena_release_uewaitblackboardtime();

  private:
  const ::cfg::AiUeWaitBlackboardTime& _internal_uewaitblackboardtime() const;
  ::cfg::AiUeWaitBlackboardTime* _internal_mutable_uewaitblackboardtime();

  public:
  // .cfg.AiMoveToTarget MoveToTarget = 19;
  bool has_movetotarget() const;
  private:
  bool _internal_has_movetotarget() const;

  public:
  void clear_movetotarget() ;
  const ::cfg::AiMoveToTarget& movetotarget() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToTarget* release_movetotarget();
  ::cfg::AiMoveToTarget* mutable_movetotarget();
  void set_allocated_movetotarget(::cfg::AiMoveToTarget* value);
  void unsafe_arena_set_allocated_movetotarget(::cfg::AiMoveToTarget* value);
  ::cfg::AiMoveToTarget* unsafe_arena_release_movetotarget();

  private:
  const ::cfg::AiMoveToTarget& _internal_movetotarget() const;
  ::cfg::AiMoveToTarget* _internal_mutable_movetotarget();

  public:
  // .cfg.AiChooseSkill ChooseSkill = 20;
  bool has_chooseskill() const;
  private:
  bool _internal_has_chooseskill() const;

  public:
  void clear_chooseskill() ;
  const ::cfg::AiChooseSkill& chooseskill() const;
  PROTOBUF_NODISCARD ::cfg::AiChooseSkill* release_chooseskill();
  ::cfg::AiChooseSkill* mutable_chooseskill();
  void set_allocated_chooseskill(::cfg::AiChooseSkill* value);
  void unsafe_arena_set_allocated_chooseskill(::cfg::AiChooseSkill* value);
  ::cfg::AiChooseSkill* unsafe_arena_release_chooseskill();

  private:
  const ::cfg::AiChooseSkill& _internal_chooseskill() const;
  ::cfg::AiChooseSkill* _internal_mutable_chooseskill();

  public:
  // .cfg.AiMoveToRandomLocation MoveToRandomLocation = 21;
  bool has_movetorandomlocation() const;
  private:
  bool _internal_has_movetorandomlocation() const;

  public:
  void clear_movetorandomlocation() ;
  const ::cfg::AiMoveToRandomLocation& movetorandomlocation() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToRandomLocation* release_movetorandomlocation();
  ::cfg::AiMoveToRandomLocation* mutable_movetorandomlocation();
  void set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* value);
  void unsafe_arena_set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* value);
  ::cfg::AiMoveToRandomLocation* unsafe_arena_release_movetorandomlocation();

  private:
  const ::cfg::AiMoveToRandomLocation& _internal_movetorandomlocation() const;
  ::cfg::AiMoveToRandomLocation* _internal_mutable_movetorandomlocation();

  public:
  // .cfg.AiMoveToLocation MoveToLocation = 22;
  bool has_movetolocation() const;
  private:
  bool _internal_has_movetolocation() const;

  public:
  void clear_movetolocation() ;
  const ::cfg::AiMoveToLocation& movetolocation() const;
  PROTOBUF_NODISCARD ::cfg::AiMoveToLocation* release_movetolocation();
  ::cfg::AiMoveToLocation* mutable_movetolocation();
  void set_allocated_movetolocation(::cfg::AiMoveToLocation* value);
  void unsafe_arena_set_allocated_movetolocation(::cfg::AiMoveToLocation* value);
  ::cfg::AiMoveToLocation* unsafe_arena_release_movetolocation();

  private:
  const ::cfg::AiMoveToLocation& _internal_movetolocation() const;
  ::cfg::AiMoveToLocation* _internal_mutable_movetolocation();

  public:
  // .cfg.AiDebugPrint DebugPrint = 23;
  bool has_debugprint() const;
  private:
  bool _internal_has_debugprint() const;

  public:
  void clear_debugprint() ;
  const ::cfg::AiDebugPrint& debugprint() const;
  PROTOBUF_NODISCARD ::cfg::AiDebugPrint* release_debugprint();
  ::cfg::AiDebugPrint* mutable_debugprint();
  void set_allocated_debugprint(::cfg::AiDebugPrint* value);
  void unsafe_arena_set_allocated_debugprint(::cfg::AiDebugPrint* value);
  ::cfg::AiDebugPrint* unsafe_arena_release_debugprint();

  private:
  const ::cfg::AiDebugPrint& _internal_debugprint() const;
  ::cfg::AiDebugPrint* _internal_mutable_debugprint();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiNode)
 private:
  class _Internal;
  void set_has_uesetdefaultfocus();
  void set_has_executetimestatistic();
  void set_has_choosetarget();
  void set_has_keepfacetarget();
  void set_has_getownerplayer();
  void set_has_updatedailybehaviorprops();
  void set_has_ueloop();
  void set_has_uecooldown();
  void set_has_uetimelimit();
  void set_has_ueblackboard();
  void set_has_ueforcesuccess();
  void set_has_isatlocation();
  void set_has_distancelessthan();
  void set_has_sequence();
  void set_has_selector();
  void set_has_simpleparallel();
  void set_has_uewait();
  void set_has_uewaitblackboardtime();
  void set_has_movetotarget();
  void set_has_chooseskill();
  void set_has_movetorandomlocation();
  void set_has_movetolocation();
  void set_has_debugprint();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 23, 23,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiUeSetDefaultFocus* uesetdefaultfocus_;
      ::cfg::AiExecuteTimeStatistic* executetimestatistic_;
      ::cfg::AiChooseTarget* choosetarget_;
      ::cfg::AiKeepFaceTarget* keepfacetarget_;
      ::cfg::AiGetOwnerPlayer* getownerplayer_;
      ::cfg::AiUpdateDailyBehaviorProps* updatedailybehaviorprops_;
      ::cfg::AiUeLoop* ueloop_;
      ::cfg::AiUeCooldown* uecooldown_;
      ::cfg::AiUeTimeLimit* uetimelimit_;
      ::cfg::AiUeBlackboard* ueblackboard_;
      ::cfg::AiUeForceSuccess* ueforcesuccess_;
      ::cfg::AiIsAtLocation* isatlocation_;
      ::cfg::AiDistanceLessThan* distancelessthan_;
      ::cfg::AiSequence* sequence_;
      ::cfg::AiSelector* selector_;
      ::cfg::AiSimpleParallel* simpleparallel_;
      ::cfg::AiUeWait* uewait_;
      ::cfg::AiUeWaitBlackboardTime* uewaitblackboardtime_;
      ::cfg::AiMoveToTarget* movetotarget_;
      ::cfg::AiChooseSkill* chooseskill_;
      ::cfg::AiMoveToRandomLocation* movetorandomlocation_;
      ::cfg::AiMoveToLocation* movetolocation_;
      ::cfg::AiDebugPrint* debugprint_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiComposeNode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiComposeNode) */ {
 public:
  inline AiComposeNode() : AiComposeNode(nullptr) {}
  ~AiComposeNode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiComposeNode(::google::protobuf::internal::ConstantInitialized);

  AiComposeNode(const AiComposeNode& from);
  AiComposeNode(AiComposeNode&& from) noexcept
    : AiComposeNode() {
    *this = ::std::move(from);
  }

  inline AiComposeNode(::google::protobuf::Arena* arena, const AiComposeNode& from)
    : AiComposeNode(arena) {
    MergeFrom(from);
  }
  inline AiComposeNode& operator=(const AiComposeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiComposeNode& operator=(AiComposeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiComposeNode& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kSequence = 14,
    kSelector = 15,
    kSimpleParallel = 16,
    VALUE_NOT_SET = 0,
  };

  static inline const AiComposeNode* internal_default_instance() {
    return reinterpret_cast<const AiComposeNode*>(
               &_AiComposeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AiComposeNode& a, AiComposeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(AiComposeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiComposeNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiComposeNode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiComposeNode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiComposeNode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiComposeNode& from) {
    AiComposeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiComposeNode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiComposeNode";
  }
  protected:
  explicit AiComposeNode(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 14,
    kSelectorFieldNumber = 15,
    kSimpleParallelFieldNumber = 16,
  };
  // .cfg.AiSequence Sequence = 14;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;

  public:
  void clear_sequence() ;
  const ::cfg::AiSequence& sequence() const;
  PROTOBUF_NODISCARD ::cfg::AiSequence* release_sequence();
  ::cfg::AiSequence* mutable_sequence();
  void set_allocated_sequence(::cfg::AiSequence* value);
  void unsafe_arena_set_allocated_sequence(::cfg::AiSequence* value);
  ::cfg::AiSequence* unsafe_arena_release_sequence();

  private:
  const ::cfg::AiSequence& _internal_sequence() const;
  ::cfg::AiSequence* _internal_mutable_sequence();

  public:
  // .cfg.AiSelector Selector = 15;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;

  public:
  void clear_selector() ;
  const ::cfg::AiSelector& selector() const;
  PROTOBUF_NODISCARD ::cfg::AiSelector* release_selector();
  ::cfg::AiSelector* mutable_selector();
  void set_allocated_selector(::cfg::AiSelector* value);
  void unsafe_arena_set_allocated_selector(::cfg::AiSelector* value);
  ::cfg::AiSelector* unsafe_arena_release_selector();

  private:
  const ::cfg::AiSelector& _internal_selector() const;
  ::cfg::AiSelector* _internal_mutable_selector();

  public:
  // .cfg.AiSimpleParallel SimpleParallel = 16;
  bool has_simpleparallel() const;
  private:
  bool _internal_has_simpleparallel() const;

  public:
  void clear_simpleparallel() ;
  const ::cfg::AiSimpleParallel& simpleparallel() const;
  PROTOBUF_NODISCARD ::cfg::AiSimpleParallel* release_simpleparallel();
  ::cfg::AiSimpleParallel* mutable_simpleparallel();
  void set_allocated_simpleparallel(::cfg::AiSimpleParallel* value);
  void unsafe_arena_set_allocated_simpleparallel(::cfg::AiSimpleParallel* value);
  ::cfg::AiSimpleParallel* unsafe_arena_release_simpleparallel();

  private:
  const ::cfg::AiSimpleParallel& _internal_simpleparallel() const;
  ::cfg::AiSimpleParallel* _internal_mutable_simpleparallel();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cfg.AiComposeNode)
 private:
  class _Internal;
  void set_has_sequence();
  void set_has_selector();
  void set_has_simpleparallel();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cfg::AiSequence* sequence_;
      ::cfg::AiSelector* selector_;
      ::cfg::AiSimpleParallel* simpleparallel_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiBehaviorTree final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiBehaviorTree) */ {
 public:
  inline AiBehaviorTree() : AiBehaviorTree(nullptr) {}
  ~AiBehaviorTree() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiBehaviorTree(::google::protobuf::internal::ConstantInitialized);

  AiBehaviorTree(const AiBehaviorTree& from);
  AiBehaviorTree(AiBehaviorTree&& from) noexcept
    : AiBehaviorTree() {
    *this = ::std::move(from);
  }

  inline AiBehaviorTree(::google::protobuf::Arena* arena, const AiBehaviorTree& from)
    : AiBehaviorTree(arena) {
    MergeFrom(from);
  }
  inline AiBehaviorTree& operator=(const AiBehaviorTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiBehaviorTree& operator=(AiBehaviorTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiBehaviorTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiBehaviorTree* internal_default_instance() {
    return reinterpret_cast<const AiBehaviorTree*>(
               &_AiBehaviorTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AiBehaviorTree& a, AiBehaviorTree& b) {
    a.Swap(&b);
  }
  inline void Swap(AiBehaviorTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiBehaviorTree* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiBehaviorTree* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiBehaviorTree>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiBehaviorTree& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiBehaviorTree& from) {
    AiBehaviorTree::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiBehaviorTree* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiBehaviorTree";
  }
  protected:
  explicit AiBehaviorTree(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDescFieldNumber = 3,
    kBlackboardIdFieldNumber = 4,
    kRootFieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string desc = 3;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* ptr);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // string blackboard_id = 4;
  void clear_blackboard_id() ;
  const std::string& blackboard_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_blackboard_id(Arg_&& arg, Args_... args);
  std::string* mutable_blackboard_id();
  PROTOBUF_NODISCARD std::string* release_blackboard_id();
  void set_allocated_blackboard_id(std::string* ptr);

  private:
  const std::string& _internal_blackboard_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blackboard_id(
      const std::string& value);
  std::string* _internal_mutable_blackboard_id();

  public:
  // .cfg.AiComposeNode root = 5;
  bool has_root() const;
  void clear_root() ;
  const ::cfg::AiComposeNode& root() const;
  PROTOBUF_NODISCARD ::cfg::AiComposeNode* release_root();
  ::cfg::AiComposeNode* mutable_root();
  void set_allocated_root(::cfg::AiComposeNode* value);
  void unsafe_arena_set_allocated_root(::cfg::AiComposeNode* value);
  ::cfg::AiComposeNode* unsafe_arena_release_root();

  private:
  const ::cfg::AiComposeNode& _internal_root() const;
  ::cfg::AiComposeNode* _internal_mutable_root();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cfg.AiBehaviorTree)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      48, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr blackboard_id_;
    ::cfg::AiComposeNode* root_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class AiTbBehaviorTree final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cfg.AiTbBehaviorTree) */ {
 public:
  inline AiTbBehaviorTree() : AiTbBehaviorTree(nullptr) {}
  ~AiTbBehaviorTree() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiTbBehaviorTree(::google::protobuf::internal::ConstantInitialized);

  AiTbBehaviorTree(const AiTbBehaviorTree& from);
  AiTbBehaviorTree(AiTbBehaviorTree&& from) noexcept
    : AiTbBehaviorTree() {
    *this = ::std::move(from);
  }

  inline AiTbBehaviorTree(::google::protobuf::Arena* arena, const AiTbBehaviorTree& from)
    : AiTbBehaviorTree(arena) {
    MergeFrom(from);
  }
  inline AiTbBehaviorTree& operator=(const AiTbBehaviorTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiTbBehaviorTree& operator=(AiTbBehaviorTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiTbBehaviorTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiTbBehaviorTree* internal_default_instance() {
    return reinterpret_cast<const AiTbBehaviorTree*>(
               &_AiTbBehaviorTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(AiTbBehaviorTree& a, AiTbBehaviorTree& b) {
    a.Swap(&b);
  }
  inline void Swap(AiTbBehaviorTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiTbBehaviorTree* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiTbBehaviorTree* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiTbBehaviorTree>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiTbBehaviorTree& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiTbBehaviorTree& from) {
    AiTbBehaviorTree::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiTbBehaviorTree* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cfg.AiTbBehaviorTree";
  }
  protected:
  explicit AiTbBehaviorTree(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated .cfg.AiBehaviorTree data_list = 1 [packed = false];
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;

  public:
  void clear_data_list() ;
  ::cfg::AiBehaviorTree* mutable_data_list(int index);
  ::google::protobuf::RepeatedPtrField< ::cfg::AiBehaviorTree >*
      mutable_data_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::cfg::AiBehaviorTree>& _internal_data_list() const;
  ::google::protobuf::RepeatedPtrField<::cfg::AiBehaviorTree>* _internal_mutable_data_list();
  public:
  const ::cfg::AiBehaviorTree& data_list(int index) const;
  ::cfg::AiBehaviorTree* add_data_list();
  const ::google::protobuf::RepeatedPtrField< ::cfg::AiBehaviorTree >&
      data_list() const;
  // @@protoc_insertion_point(class_scope:cfg.AiTbBehaviorTree)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::cfg::AiBehaviorTree > data_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AiBlackboard

// string name = 1;
inline void AiBlackboard::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AiBlackboard::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboard.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBlackboard::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBlackboard.name)
}
inline std::string* AiBlackboard::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboard.name)
  return _s;
}
inline const std::string& AiBlackboard::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AiBlackboard::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBlackboard::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBlackboard::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBlackboard.name)
  return _impl_.name_.Release();
}
inline void AiBlackboard::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBlackboard.name)
}

// string desc = 2;
inline void AiBlackboard::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& AiBlackboard::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboard.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBlackboard::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBlackboard.desc)
}
inline std::string* AiBlackboard::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboard.desc)
  return _s;
}
inline const std::string& AiBlackboard::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void AiBlackboard::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBlackboard::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBlackboard::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBlackboard.desc)
  return _impl_.desc_.Release();
}
inline void AiBlackboard::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBlackboard.desc)
}

// string parent_name = 3;
inline void AiBlackboard::clear_parent_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_name_.ClearToEmpty();
}
inline const std::string& AiBlackboard::parent_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboard.parent_name)
  return _internal_parent_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBlackboard::set_parent_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBlackboard.parent_name)
}
inline std::string* AiBlackboard::mutable_parent_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboard.parent_name)
  return _s;
}
inline const std::string& AiBlackboard::_internal_parent_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_name_.Get();
}
inline void AiBlackboard::_internal_set_parent_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBlackboard::_internal_mutable_parent_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBlackboard::release_parent_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBlackboard.parent_name)
  return _impl_.parent_name_.Release();
}
inline void AiBlackboard::set_allocated_parent_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_name_.IsDefault()) {
          _impl_.parent_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBlackboard.parent_name)
}

// repeated .cfg.AiBlackboardKey keys = 4 [packed = false];
inline int AiBlackboard::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int AiBlackboard::keys_size() const {
  return _internal_keys_size();
}
inline void AiBlackboard::clear_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keys_.Clear();
}
inline ::cfg::AiBlackboardKey* AiBlackboard::mutable_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboard.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboardKey>* AiBlackboard::mutable_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiBlackboard.keys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_keys();
}
inline const ::cfg::AiBlackboardKey& AiBlackboard::keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboard.keys)
  return _internal_keys().Get(index);
}
inline ::cfg::AiBlackboardKey* AiBlackboard::add_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiBlackboardKey* _add = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiBlackboard.keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboardKey>& AiBlackboard::keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiBlackboard.keys)
  return _internal_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboardKey>&
AiBlackboard::_internal_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboardKey>*
AiBlackboard::_internal_mutable_keys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// AiBlackboardKey

// string name = 1;
inline void AiBlackboardKey::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AiBlackboardKey::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboardKey.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBlackboardKey::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBlackboardKey.name)
}
inline std::string* AiBlackboardKey::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboardKey.name)
  return _s;
}
inline const std::string& AiBlackboardKey::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AiBlackboardKey::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBlackboardKey::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBlackboardKey::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBlackboardKey.name)
  return _impl_.name_.Release();
}
inline void AiBlackboardKey::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBlackboardKey.name)
}

// string desc = 2;
inline void AiBlackboardKey::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& AiBlackboardKey::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboardKey.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBlackboardKey::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBlackboardKey.desc)
}
inline std::string* AiBlackboardKey::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboardKey.desc)
  return _s;
}
inline const std::string& AiBlackboardKey::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void AiBlackboardKey::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBlackboardKey::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBlackboardKey::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBlackboardKey.desc)
  return _impl_.desc_.Release();
}
inline void AiBlackboardKey::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBlackboardKey.desc)
}

// bool is_static = 3;
inline void AiBlackboardKey::clear_is_static() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_static_ = false;
}
inline bool AiBlackboardKey::is_static() const {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboardKey.is_static)
  return _internal_is_static();
}
inline void AiBlackboardKey::set_is_static(bool value) {
  _internal_set_is_static(value);
  // @@protoc_insertion_point(field_set:cfg.AiBlackboardKey.is_static)
}
inline bool AiBlackboardKey::_internal_is_static() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_static_;
}
inline void AiBlackboardKey::_internal_set_is_static(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_static_ = value;
}

// .cfg.AiEKeyType type = 4;
inline void AiBlackboardKey::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::cfg::AiEKeyType AiBlackboardKey::type() const {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboardKey.type)
  return _internal_type();
}
inline void AiBlackboardKey::set_type(::cfg::AiEKeyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cfg.AiBlackboardKey.type)
}
inline ::cfg::AiEKeyType AiBlackboardKey::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEKeyType>(_impl_.type_);
}
inline void AiBlackboardKey::_internal_set_type(::cfg::AiEKeyType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string type_class_name = 5;
inline void AiBlackboardKey::clear_type_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_class_name_.ClearToEmpty();
}
inline const std::string& AiBlackboardKey::type_class_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboardKey.type_class_name)
  return _internal_type_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBlackboardKey::set_type_class_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBlackboardKey.type_class_name)
}
inline std::string* AiBlackboardKey::mutable_type_class_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type_class_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboardKey.type_class_name)
  return _s;
}
inline const std::string& AiBlackboardKey::_internal_type_class_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_class_name_.Get();
}
inline void AiBlackboardKey::_internal_set_type_class_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBlackboardKey::_internal_mutable_type_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_class_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBlackboardKey::release_type_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBlackboardKey.type_class_name)
  return _impl_.type_class_name_.Release();
}
inline void AiBlackboardKey::set_allocated_type_class_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_class_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_class_name_.IsDefault()) {
          _impl_.type_class_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBlackboardKey.type_class_name)
}

// -------------------------------------------------------------------

// AiBehaviorTree

// int32 id = 1;
inline void AiBehaviorTree::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiBehaviorTree::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiBehaviorTree.id)
  return _internal_id();
}
inline void AiBehaviorTree::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiBehaviorTree.id)
}
inline ::int32_t AiBehaviorTree::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiBehaviorTree::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void AiBehaviorTree::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AiBehaviorTree::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBehaviorTree.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBehaviorTree::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBehaviorTree.name)
}
inline std::string* AiBehaviorTree::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiBehaviorTree.name)
  return _s;
}
inline const std::string& AiBehaviorTree::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AiBehaviorTree::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBehaviorTree::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBehaviorTree::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBehaviorTree.name)
  return _impl_.name_.Release();
}
inline void AiBehaviorTree::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBehaviorTree.name)
}

// string desc = 3;
inline void AiBehaviorTree::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& AiBehaviorTree::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBehaviorTree.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBehaviorTree::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBehaviorTree.desc)
}
inline std::string* AiBehaviorTree::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.AiBehaviorTree.desc)
  return _s;
}
inline const std::string& AiBehaviorTree::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void AiBehaviorTree::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBehaviorTree::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBehaviorTree::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBehaviorTree.desc)
  return _impl_.desc_.Release();
}
inline void AiBehaviorTree::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBehaviorTree.desc)
}

// string blackboard_id = 4;
inline void AiBehaviorTree::clear_blackboard_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blackboard_id_.ClearToEmpty();
}
inline const std::string& AiBehaviorTree::blackboard_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBehaviorTree.blackboard_id)
  return _internal_blackboard_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBehaviorTree::set_blackboard_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blackboard_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBehaviorTree.blackboard_id)
}
inline std::string* AiBehaviorTree::mutable_blackboard_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_blackboard_id();
  // @@protoc_insertion_point(field_mutable:cfg.AiBehaviorTree.blackboard_id)
  return _s;
}
inline const std::string& AiBehaviorTree::_internal_blackboard_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blackboard_id_.Get();
}
inline void AiBehaviorTree::_internal_set_blackboard_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blackboard_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBehaviorTree::_internal_mutable_blackboard_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.blackboard_id_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBehaviorTree::release_blackboard_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBehaviorTree.blackboard_id)
  return _impl_.blackboard_id_.Release();
}
inline void AiBehaviorTree::set_allocated_blackboard_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blackboard_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.blackboard_id_.IsDefault()) {
          _impl_.blackboard_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBehaviorTree.blackboard_id)
}

// .cfg.AiComposeNode root = 5;
inline bool AiBehaviorTree::has_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.root_ != nullptr);
  return value;
}
inline void AiBehaviorTree::clear_root() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.root_ != nullptr) _impl_.root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::AiComposeNode& AiBehaviorTree::_internal_root() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::AiComposeNode* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::AiComposeNode&>(::cfg::_AiComposeNode_default_instance_);
}
inline const ::cfg::AiComposeNode& AiBehaviorTree::root() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBehaviorTree.root)
  return _internal_root();
}
inline void AiBehaviorTree::unsafe_arena_set_allocated_root(::cfg::AiComposeNode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = reinterpret_cast<::cfg::AiComposeNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiBehaviorTree.root)
}
inline ::cfg::AiComposeNode* AiBehaviorTree::release_root() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiComposeNode* released = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::AiComposeNode* AiBehaviorTree::unsafe_arena_release_root() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBehaviorTree.root)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiComposeNode* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::cfg::AiComposeNode* AiBehaviorTree::_internal_mutable_root() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::AiComposeNode>(GetArenaForAllocation());
    _impl_.root_ = reinterpret_cast<::cfg::AiComposeNode*>(p);
  }
  return _impl_.root_;
}
inline ::cfg::AiComposeNode* AiBehaviorTree::mutable_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiComposeNode* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:cfg.AiBehaviorTree.root)
  return _msg;
}
inline void AiBehaviorTree::set_allocated_root(::cfg::AiComposeNode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::AiComposeNode*>(_impl_.root_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::AiComposeNode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.root_ = reinterpret_cast<::cfg::AiComposeNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBehaviorTree.root)
}

// -------------------------------------------------------------------

// AiNode

// .cfg.AiUeSetDefaultFocus UeSetDefaultFocus = 1;
inline bool AiNode::has_uesetdefaultfocus() const {
  return value_case() == kUeSetDefaultFocus;
}
inline bool AiNode::_internal_has_uesetdefaultfocus() const {
  return value_case() == kUeSetDefaultFocus;
}
inline void AiNode::set_has_uesetdefaultfocus() {
  _impl_._oneof_case_[0] = kUeSetDefaultFocus;
}
inline void AiNode::clear_uesetdefaultfocus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeSetDefaultFocus) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uesetdefaultfocus_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeSetDefaultFocus* AiNode::release_uesetdefaultfocus() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeSetDefaultFocus)
  if (value_case() == kUeSetDefaultFocus) {
    clear_has_value();
    ::cfg::AiUeSetDefaultFocus* temp = _impl_.value_.uesetdefaultfocus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uesetdefaultfocus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeSetDefaultFocus& AiNode::_internal_uesetdefaultfocus() const {
  return value_case() == kUeSetDefaultFocus ? *_impl_.value_.uesetdefaultfocus_ : reinterpret_cast<::cfg::AiUeSetDefaultFocus&>(::cfg::_AiUeSetDefaultFocus_default_instance_);
}
inline const ::cfg::AiUeSetDefaultFocus& AiNode::uesetdefaultfocus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeSetDefaultFocus)
  return _internal_uesetdefaultfocus();
}
inline ::cfg::AiUeSetDefaultFocus* AiNode::unsafe_arena_release_uesetdefaultfocus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeSetDefaultFocus)
  if (value_case() == kUeSetDefaultFocus) {
    clear_has_value();
    ::cfg::AiUeSetDefaultFocus* temp = _impl_.value_.uesetdefaultfocus_;
    _impl_.value_.uesetdefaultfocus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_uesetdefaultfocus(::cfg::AiUeSetDefaultFocus* uesetdefaultfocus) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uesetdefaultfocus) {
    set_has_uesetdefaultfocus();
    _impl_.value_.uesetdefaultfocus_ = uesetdefaultfocus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeSetDefaultFocus)
}
inline ::cfg::AiUeSetDefaultFocus* AiNode::_internal_mutable_uesetdefaultfocus() {
  if (value_case() != kUeSetDefaultFocus) {
    clear_value();
    set_has_uesetdefaultfocus();
    _impl_.value_.uesetdefaultfocus_ =
        CreateMaybeMessage<::cfg::AiUeSetDefaultFocus>(GetArenaForAllocation());
  }
  return _impl_.value_.uesetdefaultfocus_;
}
inline ::cfg::AiUeSetDefaultFocus* AiNode::mutable_uesetdefaultfocus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeSetDefaultFocus* _msg = _internal_mutable_uesetdefaultfocus();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeSetDefaultFocus)
  return _msg;
}

// .cfg.AiExecuteTimeStatistic ExecuteTimeStatistic = 2;
inline bool AiNode::has_executetimestatistic() const {
  return value_case() == kExecuteTimeStatistic;
}
inline bool AiNode::_internal_has_executetimestatistic() const {
  return value_case() == kExecuteTimeStatistic;
}
inline void AiNode::set_has_executetimestatistic() {
  _impl_._oneof_case_[0] = kExecuteTimeStatistic;
}
inline void AiNode::clear_executetimestatistic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kExecuteTimeStatistic) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.executetimestatistic_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiExecuteTimeStatistic* AiNode::release_executetimestatistic() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.ExecuteTimeStatistic)
  if (value_case() == kExecuteTimeStatistic) {
    clear_has_value();
    ::cfg::AiExecuteTimeStatistic* temp = _impl_.value_.executetimestatistic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.executetimestatistic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiExecuteTimeStatistic& AiNode::_internal_executetimestatistic() const {
  return value_case() == kExecuteTimeStatistic ? *_impl_.value_.executetimestatistic_ : reinterpret_cast<::cfg::AiExecuteTimeStatistic&>(::cfg::_AiExecuteTimeStatistic_default_instance_);
}
inline const ::cfg::AiExecuteTimeStatistic& AiNode::executetimestatistic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.ExecuteTimeStatistic)
  return _internal_executetimestatistic();
}
inline ::cfg::AiExecuteTimeStatistic* AiNode::unsafe_arena_release_executetimestatistic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.ExecuteTimeStatistic)
  if (value_case() == kExecuteTimeStatistic) {
    clear_has_value();
    ::cfg::AiExecuteTimeStatistic* temp = _impl_.value_.executetimestatistic_;
    _impl_.value_.executetimestatistic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_executetimestatistic(::cfg::AiExecuteTimeStatistic* executetimestatistic) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (executetimestatistic) {
    set_has_executetimestatistic();
    _impl_.value_.executetimestatistic_ = executetimestatistic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.ExecuteTimeStatistic)
}
inline ::cfg::AiExecuteTimeStatistic* AiNode::_internal_mutable_executetimestatistic() {
  if (value_case() != kExecuteTimeStatistic) {
    clear_value();
    set_has_executetimestatistic();
    _impl_.value_.executetimestatistic_ =
        CreateMaybeMessage<::cfg::AiExecuteTimeStatistic>(GetArenaForAllocation());
  }
  return _impl_.value_.executetimestatistic_;
}
inline ::cfg::AiExecuteTimeStatistic* AiNode::mutable_executetimestatistic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiExecuteTimeStatistic* _msg = _internal_mutable_executetimestatistic();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.ExecuteTimeStatistic)
  return _msg;
}

// .cfg.AiChooseTarget ChooseTarget = 3;
inline bool AiNode::has_choosetarget() const {
  return value_case() == kChooseTarget;
}
inline bool AiNode::_internal_has_choosetarget() const {
  return value_case() == kChooseTarget;
}
inline void AiNode::set_has_choosetarget() {
  _impl_._oneof_case_[0] = kChooseTarget;
}
inline void AiNode::clear_choosetarget() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kChooseTarget) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.choosetarget_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiChooseTarget* AiNode::release_choosetarget() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.ChooseTarget)
  if (value_case() == kChooseTarget) {
    clear_has_value();
    ::cfg::AiChooseTarget* temp = _impl_.value_.choosetarget_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.choosetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiChooseTarget& AiNode::_internal_choosetarget() const {
  return value_case() == kChooseTarget ? *_impl_.value_.choosetarget_ : reinterpret_cast<::cfg::AiChooseTarget&>(::cfg::_AiChooseTarget_default_instance_);
}
inline const ::cfg::AiChooseTarget& AiNode::choosetarget() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.ChooseTarget)
  return _internal_choosetarget();
}
inline ::cfg::AiChooseTarget* AiNode::unsafe_arena_release_choosetarget() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.ChooseTarget)
  if (value_case() == kChooseTarget) {
    clear_has_value();
    ::cfg::AiChooseTarget* temp = _impl_.value_.choosetarget_;
    _impl_.value_.choosetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_choosetarget(::cfg::AiChooseTarget* choosetarget) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (choosetarget) {
    set_has_choosetarget();
    _impl_.value_.choosetarget_ = choosetarget;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.ChooseTarget)
}
inline ::cfg::AiChooseTarget* AiNode::_internal_mutable_choosetarget() {
  if (value_case() != kChooseTarget) {
    clear_value();
    set_has_choosetarget();
    _impl_.value_.choosetarget_ =
        CreateMaybeMessage<::cfg::AiChooseTarget>(GetArenaForAllocation());
  }
  return _impl_.value_.choosetarget_;
}
inline ::cfg::AiChooseTarget* AiNode::mutable_choosetarget() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiChooseTarget* _msg = _internal_mutable_choosetarget();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.ChooseTarget)
  return _msg;
}

// .cfg.AiKeepFaceTarget KeepFaceTarget = 4;
inline bool AiNode::has_keepfacetarget() const {
  return value_case() == kKeepFaceTarget;
}
inline bool AiNode::_internal_has_keepfacetarget() const {
  return value_case() == kKeepFaceTarget;
}
inline void AiNode::set_has_keepfacetarget() {
  _impl_._oneof_case_[0] = kKeepFaceTarget;
}
inline void AiNode::clear_keepfacetarget() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kKeepFaceTarget) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.keepfacetarget_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiKeepFaceTarget* AiNode::release_keepfacetarget() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.KeepFaceTarget)
  if (value_case() == kKeepFaceTarget) {
    clear_has_value();
    ::cfg::AiKeepFaceTarget* temp = _impl_.value_.keepfacetarget_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.keepfacetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiKeepFaceTarget& AiNode::_internal_keepfacetarget() const {
  return value_case() == kKeepFaceTarget ? *_impl_.value_.keepfacetarget_ : reinterpret_cast<::cfg::AiKeepFaceTarget&>(::cfg::_AiKeepFaceTarget_default_instance_);
}
inline const ::cfg::AiKeepFaceTarget& AiNode::keepfacetarget() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.KeepFaceTarget)
  return _internal_keepfacetarget();
}
inline ::cfg::AiKeepFaceTarget* AiNode::unsafe_arena_release_keepfacetarget() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.KeepFaceTarget)
  if (value_case() == kKeepFaceTarget) {
    clear_has_value();
    ::cfg::AiKeepFaceTarget* temp = _impl_.value_.keepfacetarget_;
    _impl_.value_.keepfacetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_keepfacetarget(::cfg::AiKeepFaceTarget* keepfacetarget) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (keepfacetarget) {
    set_has_keepfacetarget();
    _impl_.value_.keepfacetarget_ = keepfacetarget;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.KeepFaceTarget)
}
inline ::cfg::AiKeepFaceTarget* AiNode::_internal_mutable_keepfacetarget() {
  if (value_case() != kKeepFaceTarget) {
    clear_value();
    set_has_keepfacetarget();
    _impl_.value_.keepfacetarget_ =
        CreateMaybeMessage<::cfg::AiKeepFaceTarget>(GetArenaForAllocation());
  }
  return _impl_.value_.keepfacetarget_;
}
inline ::cfg::AiKeepFaceTarget* AiNode::mutable_keepfacetarget() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiKeepFaceTarget* _msg = _internal_mutable_keepfacetarget();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.KeepFaceTarget)
  return _msg;
}

// .cfg.AiGetOwnerPlayer GetOwnerPlayer = 5;
inline bool AiNode::has_getownerplayer() const {
  return value_case() == kGetOwnerPlayer;
}
inline bool AiNode::_internal_has_getownerplayer() const {
  return value_case() == kGetOwnerPlayer;
}
inline void AiNode::set_has_getownerplayer() {
  _impl_._oneof_case_[0] = kGetOwnerPlayer;
}
inline void AiNode::clear_getownerplayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kGetOwnerPlayer) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.getownerplayer_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiGetOwnerPlayer* AiNode::release_getownerplayer() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.GetOwnerPlayer)
  if (value_case() == kGetOwnerPlayer) {
    clear_has_value();
    ::cfg::AiGetOwnerPlayer* temp = _impl_.value_.getownerplayer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.getownerplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiGetOwnerPlayer& AiNode::_internal_getownerplayer() const {
  return value_case() == kGetOwnerPlayer ? *_impl_.value_.getownerplayer_ : reinterpret_cast<::cfg::AiGetOwnerPlayer&>(::cfg::_AiGetOwnerPlayer_default_instance_);
}
inline const ::cfg::AiGetOwnerPlayer& AiNode::getownerplayer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.GetOwnerPlayer)
  return _internal_getownerplayer();
}
inline ::cfg::AiGetOwnerPlayer* AiNode::unsafe_arena_release_getownerplayer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.GetOwnerPlayer)
  if (value_case() == kGetOwnerPlayer) {
    clear_has_value();
    ::cfg::AiGetOwnerPlayer* temp = _impl_.value_.getownerplayer_;
    _impl_.value_.getownerplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_getownerplayer(::cfg::AiGetOwnerPlayer* getownerplayer) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (getownerplayer) {
    set_has_getownerplayer();
    _impl_.value_.getownerplayer_ = getownerplayer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.GetOwnerPlayer)
}
inline ::cfg::AiGetOwnerPlayer* AiNode::_internal_mutable_getownerplayer() {
  if (value_case() != kGetOwnerPlayer) {
    clear_value();
    set_has_getownerplayer();
    _impl_.value_.getownerplayer_ =
        CreateMaybeMessage<::cfg::AiGetOwnerPlayer>(GetArenaForAllocation());
  }
  return _impl_.value_.getownerplayer_;
}
inline ::cfg::AiGetOwnerPlayer* AiNode::mutable_getownerplayer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiGetOwnerPlayer* _msg = _internal_mutable_getownerplayer();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.GetOwnerPlayer)
  return _msg;
}

// .cfg.AiUpdateDailyBehaviorProps UpdateDailyBehaviorProps = 6;
inline bool AiNode::has_updatedailybehaviorprops() const {
  return value_case() == kUpdateDailyBehaviorProps;
}
inline bool AiNode::_internal_has_updatedailybehaviorprops() const {
  return value_case() == kUpdateDailyBehaviorProps;
}
inline void AiNode::set_has_updatedailybehaviorprops() {
  _impl_._oneof_case_[0] = kUpdateDailyBehaviorProps;
}
inline void AiNode::clear_updatedailybehaviorprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUpdateDailyBehaviorProps) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.updatedailybehaviorprops_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiNode::release_updatedailybehaviorprops() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UpdateDailyBehaviorProps)
  if (value_case() == kUpdateDailyBehaviorProps) {
    clear_has_value();
    ::cfg::AiUpdateDailyBehaviorProps* temp = _impl_.value_.updatedailybehaviorprops_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.updatedailybehaviorprops_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUpdateDailyBehaviorProps& AiNode::_internal_updatedailybehaviorprops() const {
  return value_case() == kUpdateDailyBehaviorProps ? *_impl_.value_.updatedailybehaviorprops_ : reinterpret_cast<::cfg::AiUpdateDailyBehaviorProps&>(::cfg::_AiUpdateDailyBehaviorProps_default_instance_);
}
inline const ::cfg::AiUpdateDailyBehaviorProps& AiNode::updatedailybehaviorprops() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UpdateDailyBehaviorProps)
  return _internal_updatedailybehaviorprops();
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiNode::unsafe_arena_release_updatedailybehaviorprops() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UpdateDailyBehaviorProps)
  if (value_case() == kUpdateDailyBehaviorProps) {
    clear_has_value();
    ::cfg::AiUpdateDailyBehaviorProps* temp = _impl_.value_.updatedailybehaviorprops_;
    _impl_.value_.updatedailybehaviorprops_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_updatedailybehaviorprops(::cfg::AiUpdateDailyBehaviorProps* updatedailybehaviorprops) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (updatedailybehaviorprops) {
    set_has_updatedailybehaviorprops();
    _impl_.value_.updatedailybehaviorprops_ = updatedailybehaviorprops;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UpdateDailyBehaviorProps)
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiNode::_internal_mutable_updatedailybehaviorprops() {
  if (value_case() != kUpdateDailyBehaviorProps) {
    clear_value();
    set_has_updatedailybehaviorprops();
    _impl_.value_.updatedailybehaviorprops_ =
        CreateMaybeMessage<::cfg::AiUpdateDailyBehaviorProps>(GetArenaForAllocation());
  }
  return _impl_.value_.updatedailybehaviorprops_;
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiNode::mutable_updatedailybehaviorprops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUpdateDailyBehaviorProps* _msg = _internal_mutable_updatedailybehaviorprops();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UpdateDailyBehaviorProps)
  return _msg;
}

// .cfg.AiUeLoop UeLoop = 7;
inline bool AiNode::has_ueloop() const {
  return value_case() == kUeLoop;
}
inline bool AiNode::_internal_has_ueloop() const {
  return value_case() == kUeLoop;
}
inline void AiNode::set_has_ueloop() {
  _impl_._oneof_case_[0] = kUeLoop;
}
inline void AiNode::clear_ueloop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeLoop) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.ueloop_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeLoop* AiNode::release_ueloop() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeLoop)
  if (value_case() == kUeLoop) {
    clear_has_value();
    ::cfg::AiUeLoop* temp = _impl_.value_.ueloop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ueloop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeLoop& AiNode::_internal_ueloop() const {
  return value_case() == kUeLoop ? *_impl_.value_.ueloop_ : reinterpret_cast<::cfg::AiUeLoop&>(::cfg::_AiUeLoop_default_instance_);
}
inline const ::cfg::AiUeLoop& AiNode::ueloop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeLoop)
  return _internal_ueloop();
}
inline ::cfg::AiUeLoop* AiNode::unsafe_arena_release_ueloop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeLoop)
  if (value_case() == kUeLoop) {
    clear_has_value();
    ::cfg::AiUeLoop* temp = _impl_.value_.ueloop_;
    _impl_.value_.ueloop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_ueloop(::cfg::AiUeLoop* ueloop) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (ueloop) {
    set_has_ueloop();
    _impl_.value_.ueloop_ = ueloop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeLoop)
}
inline ::cfg::AiUeLoop* AiNode::_internal_mutable_ueloop() {
  if (value_case() != kUeLoop) {
    clear_value();
    set_has_ueloop();
    _impl_.value_.ueloop_ =
        CreateMaybeMessage<::cfg::AiUeLoop>(GetArenaForAllocation());
  }
  return _impl_.value_.ueloop_;
}
inline ::cfg::AiUeLoop* AiNode::mutable_ueloop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeLoop* _msg = _internal_mutable_ueloop();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeLoop)
  return _msg;
}

// .cfg.AiUeCooldown UeCooldown = 8;
inline bool AiNode::has_uecooldown() const {
  return value_case() == kUeCooldown;
}
inline bool AiNode::_internal_has_uecooldown() const {
  return value_case() == kUeCooldown;
}
inline void AiNode::set_has_uecooldown() {
  _impl_._oneof_case_[0] = kUeCooldown;
}
inline void AiNode::clear_uecooldown() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeCooldown) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uecooldown_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeCooldown* AiNode::release_uecooldown() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeCooldown)
  if (value_case() == kUeCooldown) {
    clear_has_value();
    ::cfg::AiUeCooldown* temp = _impl_.value_.uecooldown_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uecooldown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeCooldown& AiNode::_internal_uecooldown() const {
  return value_case() == kUeCooldown ? *_impl_.value_.uecooldown_ : reinterpret_cast<::cfg::AiUeCooldown&>(::cfg::_AiUeCooldown_default_instance_);
}
inline const ::cfg::AiUeCooldown& AiNode::uecooldown() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeCooldown)
  return _internal_uecooldown();
}
inline ::cfg::AiUeCooldown* AiNode::unsafe_arena_release_uecooldown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeCooldown)
  if (value_case() == kUeCooldown) {
    clear_has_value();
    ::cfg::AiUeCooldown* temp = _impl_.value_.uecooldown_;
    _impl_.value_.uecooldown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_uecooldown(::cfg::AiUeCooldown* uecooldown) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uecooldown) {
    set_has_uecooldown();
    _impl_.value_.uecooldown_ = uecooldown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeCooldown)
}
inline ::cfg::AiUeCooldown* AiNode::_internal_mutable_uecooldown() {
  if (value_case() != kUeCooldown) {
    clear_value();
    set_has_uecooldown();
    _impl_.value_.uecooldown_ =
        CreateMaybeMessage<::cfg::AiUeCooldown>(GetArenaForAllocation());
  }
  return _impl_.value_.uecooldown_;
}
inline ::cfg::AiUeCooldown* AiNode::mutable_uecooldown() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeCooldown* _msg = _internal_mutable_uecooldown();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeCooldown)
  return _msg;
}

// .cfg.AiUeTimeLimit UeTimeLimit = 9;
inline bool AiNode::has_uetimelimit() const {
  return value_case() == kUeTimeLimit;
}
inline bool AiNode::_internal_has_uetimelimit() const {
  return value_case() == kUeTimeLimit;
}
inline void AiNode::set_has_uetimelimit() {
  _impl_._oneof_case_[0] = kUeTimeLimit;
}
inline void AiNode::clear_uetimelimit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeTimeLimit) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uetimelimit_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeTimeLimit* AiNode::release_uetimelimit() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeTimeLimit)
  if (value_case() == kUeTimeLimit) {
    clear_has_value();
    ::cfg::AiUeTimeLimit* temp = _impl_.value_.uetimelimit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uetimelimit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeTimeLimit& AiNode::_internal_uetimelimit() const {
  return value_case() == kUeTimeLimit ? *_impl_.value_.uetimelimit_ : reinterpret_cast<::cfg::AiUeTimeLimit&>(::cfg::_AiUeTimeLimit_default_instance_);
}
inline const ::cfg::AiUeTimeLimit& AiNode::uetimelimit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeTimeLimit)
  return _internal_uetimelimit();
}
inline ::cfg::AiUeTimeLimit* AiNode::unsafe_arena_release_uetimelimit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeTimeLimit)
  if (value_case() == kUeTimeLimit) {
    clear_has_value();
    ::cfg::AiUeTimeLimit* temp = _impl_.value_.uetimelimit_;
    _impl_.value_.uetimelimit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_uetimelimit(::cfg::AiUeTimeLimit* uetimelimit) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uetimelimit) {
    set_has_uetimelimit();
    _impl_.value_.uetimelimit_ = uetimelimit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeTimeLimit)
}
inline ::cfg::AiUeTimeLimit* AiNode::_internal_mutable_uetimelimit() {
  if (value_case() != kUeTimeLimit) {
    clear_value();
    set_has_uetimelimit();
    _impl_.value_.uetimelimit_ =
        CreateMaybeMessage<::cfg::AiUeTimeLimit>(GetArenaForAllocation());
  }
  return _impl_.value_.uetimelimit_;
}
inline ::cfg::AiUeTimeLimit* AiNode::mutable_uetimelimit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeTimeLimit* _msg = _internal_mutable_uetimelimit();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeTimeLimit)
  return _msg;
}

// .cfg.AiUeBlackboard UeBlackboard = 10;
inline bool AiNode::has_ueblackboard() const {
  return value_case() == kUeBlackboard;
}
inline bool AiNode::_internal_has_ueblackboard() const {
  return value_case() == kUeBlackboard;
}
inline void AiNode::set_has_ueblackboard() {
  _impl_._oneof_case_[0] = kUeBlackboard;
}
inline void AiNode::clear_ueblackboard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeBlackboard) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.ueblackboard_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeBlackboard* AiNode::release_ueblackboard() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeBlackboard)
  if (value_case() == kUeBlackboard) {
    clear_has_value();
    ::cfg::AiUeBlackboard* temp = _impl_.value_.ueblackboard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ueblackboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeBlackboard& AiNode::_internal_ueblackboard() const {
  return value_case() == kUeBlackboard ? *_impl_.value_.ueblackboard_ : reinterpret_cast<::cfg::AiUeBlackboard&>(::cfg::_AiUeBlackboard_default_instance_);
}
inline const ::cfg::AiUeBlackboard& AiNode::ueblackboard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeBlackboard)
  return _internal_ueblackboard();
}
inline ::cfg::AiUeBlackboard* AiNode::unsafe_arena_release_ueblackboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeBlackboard)
  if (value_case() == kUeBlackboard) {
    clear_has_value();
    ::cfg::AiUeBlackboard* temp = _impl_.value_.ueblackboard_;
    _impl_.value_.ueblackboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_ueblackboard(::cfg::AiUeBlackboard* ueblackboard) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (ueblackboard) {
    set_has_ueblackboard();
    _impl_.value_.ueblackboard_ = ueblackboard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeBlackboard)
}
inline ::cfg::AiUeBlackboard* AiNode::_internal_mutable_ueblackboard() {
  if (value_case() != kUeBlackboard) {
    clear_value();
    set_has_ueblackboard();
    _impl_.value_.ueblackboard_ =
        CreateMaybeMessage<::cfg::AiUeBlackboard>(GetArenaForAllocation());
  }
  return _impl_.value_.ueblackboard_;
}
inline ::cfg::AiUeBlackboard* AiNode::mutable_ueblackboard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeBlackboard* _msg = _internal_mutable_ueblackboard();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeBlackboard)
  return _msg;
}

// .cfg.AiUeForceSuccess UeForceSuccess = 11;
inline bool AiNode::has_ueforcesuccess() const {
  return value_case() == kUeForceSuccess;
}
inline bool AiNode::_internal_has_ueforcesuccess() const {
  return value_case() == kUeForceSuccess;
}
inline void AiNode::set_has_ueforcesuccess() {
  _impl_._oneof_case_[0] = kUeForceSuccess;
}
inline void AiNode::clear_ueforcesuccess() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeForceSuccess) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.ueforcesuccess_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeForceSuccess* AiNode::release_ueforcesuccess() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeForceSuccess)
  if (value_case() == kUeForceSuccess) {
    clear_has_value();
    ::cfg::AiUeForceSuccess* temp = _impl_.value_.ueforcesuccess_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ueforcesuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeForceSuccess& AiNode::_internal_ueforcesuccess() const {
  return value_case() == kUeForceSuccess ? *_impl_.value_.ueforcesuccess_ : reinterpret_cast<::cfg::AiUeForceSuccess&>(::cfg::_AiUeForceSuccess_default_instance_);
}
inline const ::cfg::AiUeForceSuccess& AiNode::ueforcesuccess() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeForceSuccess)
  return _internal_ueforcesuccess();
}
inline ::cfg::AiUeForceSuccess* AiNode::unsafe_arena_release_ueforcesuccess() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeForceSuccess)
  if (value_case() == kUeForceSuccess) {
    clear_has_value();
    ::cfg::AiUeForceSuccess* temp = _impl_.value_.ueforcesuccess_;
    _impl_.value_.ueforcesuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_ueforcesuccess(::cfg::AiUeForceSuccess* ueforcesuccess) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (ueforcesuccess) {
    set_has_ueforcesuccess();
    _impl_.value_.ueforcesuccess_ = ueforcesuccess;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeForceSuccess)
}
inline ::cfg::AiUeForceSuccess* AiNode::_internal_mutable_ueforcesuccess() {
  if (value_case() != kUeForceSuccess) {
    clear_value();
    set_has_ueforcesuccess();
    _impl_.value_.ueforcesuccess_ =
        CreateMaybeMessage<::cfg::AiUeForceSuccess>(GetArenaForAllocation());
  }
  return _impl_.value_.ueforcesuccess_;
}
inline ::cfg::AiUeForceSuccess* AiNode::mutable_ueforcesuccess() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeForceSuccess* _msg = _internal_mutable_ueforcesuccess();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeForceSuccess)
  return _msg;
}

// .cfg.AiIsAtLocation IsAtLocation = 12;
inline bool AiNode::has_isatlocation() const {
  return value_case() == kIsAtLocation;
}
inline bool AiNode::_internal_has_isatlocation() const {
  return value_case() == kIsAtLocation;
}
inline void AiNode::set_has_isatlocation() {
  _impl_._oneof_case_[0] = kIsAtLocation;
}
inline void AiNode::clear_isatlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kIsAtLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.isatlocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiIsAtLocation* AiNode::release_isatlocation() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.IsAtLocation)
  if (value_case() == kIsAtLocation) {
    clear_has_value();
    ::cfg::AiIsAtLocation* temp = _impl_.value_.isatlocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.isatlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiIsAtLocation& AiNode::_internal_isatlocation() const {
  return value_case() == kIsAtLocation ? *_impl_.value_.isatlocation_ : reinterpret_cast<::cfg::AiIsAtLocation&>(::cfg::_AiIsAtLocation_default_instance_);
}
inline const ::cfg::AiIsAtLocation& AiNode::isatlocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.IsAtLocation)
  return _internal_isatlocation();
}
inline ::cfg::AiIsAtLocation* AiNode::unsafe_arena_release_isatlocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.IsAtLocation)
  if (value_case() == kIsAtLocation) {
    clear_has_value();
    ::cfg::AiIsAtLocation* temp = _impl_.value_.isatlocation_;
    _impl_.value_.isatlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_isatlocation(::cfg::AiIsAtLocation* isatlocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (isatlocation) {
    set_has_isatlocation();
    _impl_.value_.isatlocation_ = isatlocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.IsAtLocation)
}
inline ::cfg::AiIsAtLocation* AiNode::_internal_mutable_isatlocation() {
  if (value_case() != kIsAtLocation) {
    clear_value();
    set_has_isatlocation();
    _impl_.value_.isatlocation_ =
        CreateMaybeMessage<::cfg::AiIsAtLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.isatlocation_;
}
inline ::cfg::AiIsAtLocation* AiNode::mutable_isatlocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiIsAtLocation* _msg = _internal_mutable_isatlocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.IsAtLocation)
  return _msg;
}

// .cfg.AiDistanceLessThan DistanceLessThan = 13;
inline bool AiNode::has_distancelessthan() const {
  return value_case() == kDistanceLessThan;
}
inline bool AiNode::_internal_has_distancelessthan() const {
  return value_case() == kDistanceLessThan;
}
inline void AiNode::set_has_distancelessthan() {
  _impl_._oneof_case_[0] = kDistanceLessThan;
}
inline void AiNode::clear_distancelessthan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDistanceLessThan) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.distancelessthan_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiDistanceLessThan* AiNode::release_distancelessthan() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.DistanceLessThan)
  if (value_case() == kDistanceLessThan) {
    clear_has_value();
    ::cfg::AiDistanceLessThan* temp = _impl_.value_.distancelessthan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.distancelessthan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiDistanceLessThan& AiNode::_internal_distancelessthan() const {
  return value_case() == kDistanceLessThan ? *_impl_.value_.distancelessthan_ : reinterpret_cast<::cfg::AiDistanceLessThan&>(::cfg::_AiDistanceLessThan_default_instance_);
}
inline const ::cfg::AiDistanceLessThan& AiNode::distancelessthan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.DistanceLessThan)
  return _internal_distancelessthan();
}
inline ::cfg::AiDistanceLessThan* AiNode::unsafe_arena_release_distancelessthan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.DistanceLessThan)
  if (value_case() == kDistanceLessThan) {
    clear_has_value();
    ::cfg::AiDistanceLessThan* temp = _impl_.value_.distancelessthan_;
    _impl_.value_.distancelessthan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_distancelessthan(::cfg::AiDistanceLessThan* distancelessthan) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (distancelessthan) {
    set_has_distancelessthan();
    _impl_.value_.distancelessthan_ = distancelessthan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.DistanceLessThan)
}
inline ::cfg::AiDistanceLessThan* AiNode::_internal_mutable_distancelessthan() {
  if (value_case() != kDistanceLessThan) {
    clear_value();
    set_has_distancelessthan();
    _impl_.value_.distancelessthan_ =
        CreateMaybeMessage<::cfg::AiDistanceLessThan>(GetArenaForAllocation());
  }
  return _impl_.value_.distancelessthan_;
}
inline ::cfg::AiDistanceLessThan* AiNode::mutable_distancelessthan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiDistanceLessThan* _msg = _internal_mutable_distancelessthan();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.DistanceLessThan)
  return _msg;
}

// .cfg.AiSequence Sequence = 14;
inline bool AiNode::has_sequence() const {
  return value_case() == kSequence;
}
inline bool AiNode::_internal_has_sequence() const {
  return value_case() == kSequence;
}
inline void AiNode::set_has_sequence() {
  _impl_._oneof_case_[0] = kSequence;
}
inline void AiNode::clear_sequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSequence) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sequence_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSequence* AiNode::release_sequence() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.Sequence)
  if (value_case() == kSequence) {
    clear_has_value();
    ::cfg::AiSequence* temp = _impl_.value_.sequence_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSequence& AiNode::_internal_sequence() const {
  return value_case() == kSequence ? *_impl_.value_.sequence_ : reinterpret_cast<::cfg::AiSequence&>(::cfg::_AiSequence_default_instance_);
}
inline const ::cfg::AiSequence& AiNode::sequence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.Sequence)
  return _internal_sequence();
}
inline ::cfg::AiSequence* AiNode::unsafe_arena_release_sequence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.Sequence)
  if (value_case() == kSequence) {
    clear_has_value();
    ::cfg::AiSequence* temp = _impl_.value_.sequence_;
    _impl_.value_.sequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_sequence(::cfg::AiSequence* sequence) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (sequence) {
    set_has_sequence();
    _impl_.value_.sequence_ = sequence;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.Sequence)
}
inline ::cfg::AiSequence* AiNode::_internal_mutable_sequence() {
  if (value_case() != kSequence) {
    clear_value();
    set_has_sequence();
    _impl_.value_.sequence_ =
        CreateMaybeMessage<::cfg::AiSequence>(GetArenaForAllocation());
  }
  return _impl_.value_.sequence_;
}
inline ::cfg::AiSequence* AiNode::mutable_sequence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSequence* _msg = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.Sequence)
  return _msg;
}

// .cfg.AiSelector Selector = 15;
inline bool AiNode::has_selector() const {
  return value_case() == kSelector;
}
inline bool AiNode::_internal_has_selector() const {
  return value_case() == kSelector;
}
inline void AiNode::set_has_selector() {
  _impl_._oneof_case_[0] = kSelector;
}
inline void AiNode::clear_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSelector) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.selector_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSelector* AiNode::release_selector() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.Selector)
  if (value_case() == kSelector) {
    clear_has_value();
    ::cfg::AiSelector* temp = _impl_.value_.selector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSelector& AiNode::_internal_selector() const {
  return value_case() == kSelector ? *_impl_.value_.selector_ : reinterpret_cast<::cfg::AiSelector&>(::cfg::_AiSelector_default_instance_);
}
inline const ::cfg::AiSelector& AiNode::selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.Selector)
  return _internal_selector();
}
inline ::cfg::AiSelector* AiNode::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.Selector)
  if (value_case() == kSelector) {
    clear_has_value();
    ::cfg::AiSelector* temp = _impl_.value_.selector_;
    _impl_.value_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_selector(::cfg::AiSelector* selector) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (selector) {
    set_has_selector();
    _impl_.value_.selector_ = selector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.Selector)
}
inline ::cfg::AiSelector* AiNode::_internal_mutable_selector() {
  if (value_case() != kSelector) {
    clear_value();
    set_has_selector();
    _impl_.value_.selector_ =
        CreateMaybeMessage<::cfg::AiSelector>(GetArenaForAllocation());
  }
  return _impl_.value_.selector_;
}
inline ::cfg::AiSelector* AiNode::mutable_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSelector* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.Selector)
  return _msg;
}

// .cfg.AiSimpleParallel SimpleParallel = 16;
inline bool AiNode::has_simpleparallel() const {
  return value_case() == kSimpleParallel;
}
inline bool AiNode::_internal_has_simpleparallel() const {
  return value_case() == kSimpleParallel;
}
inline void AiNode::set_has_simpleparallel() {
  _impl_._oneof_case_[0] = kSimpleParallel;
}
inline void AiNode::clear_simpleparallel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSimpleParallel) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.simpleparallel_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSimpleParallel* AiNode::release_simpleparallel() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.SimpleParallel)
  if (value_case() == kSimpleParallel) {
    clear_has_value();
    ::cfg::AiSimpleParallel* temp = _impl_.value_.simpleparallel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.simpleparallel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSimpleParallel& AiNode::_internal_simpleparallel() const {
  return value_case() == kSimpleParallel ? *_impl_.value_.simpleparallel_ : reinterpret_cast<::cfg::AiSimpleParallel&>(::cfg::_AiSimpleParallel_default_instance_);
}
inline const ::cfg::AiSimpleParallel& AiNode::simpleparallel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.SimpleParallel)
  return _internal_simpleparallel();
}
inline ::cfg::AiSimpleParallel* AiNode::unsafe_arena_release_simpleparallel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.SimpleParallel)
  if (value_case() == kSimpleParallel) {
    clear_has_value();
    ::cfg::AiSimpleParallel* temp = _impl_.value_.simpleparallel_;
    _impl_.value_.simpleparallel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_simpleparallel(::cfg::AiSimpleParallel* simpleparallel) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (simpleparallel) {
    set_has_simpleparallel();
    _impl_.value_.simpleparallel_ = simpleparallel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.SimpleParallel)
}
inline ::cfg::AiSimpleParallel* AiNode::_internal_mutable_simpleparallel() {
  if (value_case() != kSimpleParallel) {
    clear_value();
    set_has_simpleparallel();
    _impl_.value_.simpleparallel_ =
        CreateMaybeMessage<::cfg::AiSimpleParallel>(GetArenaForAllocation());
  }
  return _impl_.value_.simpleparallel_;
}
inline ::cfg::AiSimpleParallel* AiNode::mutable_simpleparallel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSimpleParallel* _msg = _internal_mutable_simpleparallel();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.SimpleParallel)
  return _msg;
}

// .cfg.AiUeWait UeWait = 17;
inline bool AiNode::has_uewait() const {
  return value_case() == kUeWait;
}
inline bool AiNode::_internal_has_uewait() const {
  return value_case() == kUeWait;
}
inline void AiNode::set_has_uewait() {
  _impl_._oneof_case_[0] = kUeWait;
}
inline void AiNode::clear_uewait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeWait) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uewait_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeWait* AiNode::release_uewait() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeWait)
  if (value_case() == kUeWait) {
    clear_has_value();
    ::cfg::AiUeWait* temp = _impl_.value_.uewait_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uewait_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeWait& AiNode::_internal_uewait() const {
  return value_case() == kUeWait ? *_impl_.value_.uewait_ : reinterpret_cast<::cfg::AiUeWait&>(::cfg::_AiUeWait_default_instance_);
}
inline const ::cfg::AiUeWait& AiNode::uewait() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeWait)
  return _internal_uewait();
}
inline ::cfg::AiUeWait* AiNode::unsafe_arena_release_uewait() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeWait)
  if (value_case() == kUeWait) {
    clear_has_value();
    ::cfg::AiUeWait* temp = _impl_.value_.uewait_;
    _impl_.value_.uewait_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_uewait(::cfg::AiUeWait* uewait) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uewait) {
    set_has_uewait();
    _impl_.value_.uewait_ = uewait;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeWait)
}
inline ::cfg::AiUeWait* AiNode::_internal_mutable_uewait() {
  if (value_case() != kUeWait) {
    clear_value();
    set_has_uewait();
    _impl_.value_.uewait_ =
        CreateMaybeMessage<::cfg::AiUeWait>(GetArenaForAllocation());
  }
  return _impl_.value_.uewait_;
}
inline ::cfg::AiUeWait* AiNode::mutable_uewait() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeWait* _msg = _internal_mutable_uewait();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeWait)
  return _msg;
}

// .cfg.AiUeWaitBlackboardTime UeWaitBlackboardTime = 18;
inline bool AiNode::has_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime;
}
inline bool AiNode::_internal_has_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime;
}
inline void AiNode::set_has_uewaitblackboardtime() {
  _impl_._oneof_case_[0] = kUeWaitBlackboardTime;
}
inline void AiNode::clear_uewaitblackboardtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeWaitBlackboardTime) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uewaitblackboardtime_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeWaitBlackboardTime* AiNode::release_uewaitblackboardtime() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.UeWaitBlackboardTime)
  if (value_case() == kUeWaitBlackboardTime) {
    clear_has_value();
    ::cfg::AiUeWaitBlackboardTime* temp = _impl_.value_.uewaitblackboardtime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uewaitblackboardtime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeWaitBlackboardTime& AiNode::_internal_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime ? *_impl_.value_.uewaitblackboardtime_ : reinterpret_cast<::cfg::AiUeWaitBlackboardTime&>(::cfg::_AiUeWaitBlackboardTime_default_instance_);
}
inline const ::cfg::AiUeWaitBlackboardTime& AiNode::uewaitblackboardtime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.UeWaitBlackboardTime)
  return _internal_uewaitblackboardtime();
}
inline ::cfg::AiUeWaitBlackboardTime* AiNode::unsafe_arena_release_uewaitblackboardtime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.UeWaitBlackboardTime)
  if (value_case() == kUeWaitBlackboardTime) {
    clear_has_value();
    ::cfg::AiUeWaitBlackboardTime* temp = _impl_.value_.uewaitblackboardtime_;
    _impl_.value_.uewaitblackboardtime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* uewaitblackboardtime) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uewaitblackboardtime) {
    set_has_uewaitblackboardtime();
    _impl_.value_.uewaitblackboardtime_ = uewaitblackboardtime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.UeWaitBlackboardTime)
}
inline ::cfg::AiUeWaitBlackboardTime* AiNode::_internal_mutable_uewaitblackboardtime() {
  if (value_case() != kUeWaitBlackboardTime) {
    clear_value();
    set_has_uewaitblackboardtime();
    _impl_.value_.uewaitblackboardtime_ =
        CreateMaybeMessage<::cfg::AiUeWaitBlackboardTime>(GetArenaForAllocation());
  }
  return _impl_.value_.uewaitblackboardtime_;
}
inline ::cfg::AiUeWaitBlackboardTime* AiNode::mutable_uewaitblackboardtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeWaitBlackboardTime* _msg = _internal_mutable_uewaitblackboardtime();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.UeWaitBlackboardTime)
  return _msg;
}

// .cfg.AiMoveToTarget MoveToTarget = 19;
inline bool AiNode::has_movetotarget() const {
  return value_case() == kMoveToTarget;
}
inline bool AiNode::_internal_has_movetotarget() const {
  return value_case() == kMoveToTarget;
}
inline void AiNode::set_has_movetotarget() {
  _impl_._oneof_case_[0] = kMoveToTarget;
}
inline void AiNode::clear_movetotarget() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToTarget) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetotarget_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToTarget* AiNode::release_movetotarget() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.MoveToTarget)
  if (value_case() == kMoveToTarget) {
    clear_has_value();
    ::cfg::AiMoveToTarget* temp = _impl_.value_.movetotarget_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetotarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToTarget& AiNode::_internal_movetotarget() const {
  return value_case() == kMoveToTarget ? *_impl_.value_.movetotarget_ : reinterpret_cast<::cfg::AiMoveToTarget&>(::cfg::_AiMoveToTarget_default_instance_);
}
inline const ::cfg::AiMoveToTarget& AiNode::movetotarget() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.MoveToTarget)
  return _internal_movetotarget();
}
inline ::cfg::AiMoveToTarget* AiNode::unsafe_arena_release_movetotarget() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.MoveToTarget)
  if (value_case() == kMoveToTarget) {
    clear_has_value();
    ::cfg::AiMoveToTarget* temp = _impl_.value_.movetotarget_;
    _impl_.value_.movetotarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_movetotarget(::cfg::AiMoveToTarget* movetotarget) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetotarget) {
    set_has_movetotarget();
    _impl_.value_.movetotarget_ = movetotarget;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.MoveToTarget)
}
inline ::cfg::AiMoveToTarget* AiNode::_internal_mutable_movetotarget() {
  if (value_case() != kMoveToTarget) {
    clear_value();
    set_has_movetotarget();
    _impl_.value_.movetotarget_ =
        CreateMaybeMessage<::cfg::AiMoveToTarget>(GetArenaForAllocation());
  }
  return _impl_.value_.movetotarget_;
}
inline ::cfg::AiMoveToTarget* AiNode::mutable_movetotarget() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToTarget* _msg = _internal_mutable_movetotarget();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.MoveToTarget)
  return _msg;
}

// .cfg.AiChooseSkill ChooseSkill = 20;
inline bool AiNode::has_chooseskill() const {
  return value_case() == kChooseSkill;
}
inline bool AiNode::_internal_has_chooseskill() const {
  return value_case() == kChooseSkill;
}
inline void AiNode::set_has_chooseskill() {
  _impl_._oneof_case_[0] = kChooseSkill;
}
inline void AiNode::clear_chooseskill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kChooseSkill) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.chooseskill_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiChooseSkill* AiNode::release_chooseskill() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.ChooseSkill)
  if (value_case() == kChooseSkill) {
    clear_has_value();
    ::cfg::AiChooseSkill* temp = _impl_.value_.chooseskill_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.chooseskill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiChooseSkill& AiNode::_internal_chooseskill() const {
  return value_case() == kChooseSkill ? *_impl_.value_.chooseskill_ : reinterpret_cast<::cfg::AiChooseSkill&>(::cfg::_AiChooseSkill_default_instance_);
}
inline const ::cfg::AiChooseSkill& AiNode::chooseskill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.ChooseSkill)
  return _internal_chooseskill();
}
inline ::cfg::AiChooseSkill* AiNode::unsafe_arena_release_chooseskill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.ChooseSkill)
  if (value_case() == kChooseSkill) {
    clear_has_value();
    ::cfg::AiChooseSkill* temp = _impl_.value_.chooseskill_;
    _impl_.value_.chooseskill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_chooseskill(::cfg::AiChooseSkill* chooseskill) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (chooseskill) {
    set_has_chooseskill();
    _impl_.value_.chooseskill_ = chooseskill;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.ChooseSkill)
}
inline ::cfg::AiChooseSkill* AiNode::_internal_mutable_chooseskill() {
  if (value_case() != kChooseSkill) {
    clear_value();
    set_has_chooseskill();
    _impl_.value_.chooseskill_ =
        CreateMaybeMessage<::cfg::AiChooseSkill>(GetArenaForAllocation());
  }
  return _impl_.value_.chooseskill_;
}
inline ::cfg::AiChooseSkill* AiNode::mutable_chooseskill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiChooseSkill* _msg = _internal_mutable_chooseskill();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.ChooseSkill)
  return _msg;
}

// .cfg.AiMoveToRandomLocation MoveToRandomLocation = 21;
inline bool AiNode::has_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation;
}
inline bool AiNode::_internal_has_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation;
}
inline void AiNode::set_has_movetorandomlocation() {
  _impl_._oneof_case_[0] = kMoveToRandomLocation;
}
inline void AiNode::clear_movetorandomlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToRandomLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetorandomlocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToRandomLocation* AiNode::release_movetorandomlocation() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.MoveToRandomLocation)
  if (value_case() == kMoveToRandomLocation) {
    clear_has_value();
    ::cfg::AiMoveToRandomLocation* temp = _impl_.value_.movetorandomlocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetorandomlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToRandomLocation& AiNode::_internal_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation ? *_impl_.value_.movetorandomlocation_ : reinterpret_cast<::cfg::AiMoveToRandomLocation&>(::cfg::_AiMoveToRandomLocation_default_instance_);
}
inline const ::cfg::AiMoveToRandomLocation& AiNode::movetorandomlocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.MoveToRandomLocation)
  return _internal_movetorandomlocation();
}
inline ::cfg::AiMoveToRandomLocation* AiNode::unsafe_arena_release_movetorandomlocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.MoveToRandomLocation)
  if (value_case() == kMoveToRandomLocation) {
    clear_has_value();
    ::cfg::AiMoveToRandomLocation* temp = _impl_.value_.movetorandomlocation_;
    _impl_.value_.movetorandomlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* movetorandomlocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetorandomlocation) {
    set_has_movetorandomlocation();
    _impl_.value_.movetorandomlocation_ = movetorandomlocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.MoveToRandomLocation)
}
inline ::cfg::AiMoveToRandomLocation* AiNode::_internal_mutable_movetorandomlocation() {
  if (value_case() != kMoveToRandomLocation) {
    clear_value();
    set_has_movetorandomlocation();
    _impl_.value_.movetorandomlocation_ =
        CreateMaybeMessage<::cfg::AiMoveToRandomLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.movetorandomlocation_;
}
inline ::cfg::AiMoveToRandomLocation* AiNode::mutable_movetorandomlocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToRandomLocation* _msg = _internal_mutable_movetorandomlocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.MoveToRandomLocation)
  return _msg;
}

// .cfg.AiMoveToLocation MoveToLocation = 22;
inline bool AiNode::has_movetolocation() const {
  return value_case() == kMoveToLocation;
}
inline bool AiNode::_internal_has_movetolocation() const {
  return value_case() == kMoveToLocation;
}
inline void AiNode::set_has_movetolocation() {
  _impl_._oneof_case_[0] = kMoveToLocation;
}
inline void AiNode::clear_movetolocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetolocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToLocation* AiNode::release_movetolocation() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.MoveToLocation)
  if (value_case() == kMoveToLocation) {
    clear_has_value();
    ::cfg::AiMoveToLocation* temp = _impl_.value_.movetolocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetolocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToLocation& AiNode::_internal_movetolocation() const {
  return value_case() == kMoveToLocation ? *_impl_.value_.movetolocation_ : reinterpret_cast<::cfg::AiMoveToLocation&>(::cfg::_AiMoveToLocation_default_instance_);
}
inline const ::cfg::AiMoveToLocation& AiNode::movetolocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.MoveToLocation)
  return _internal_movetolocation();
}
inline ::cfg::AiMoveToLocation* AiNode::unsafe_arena_release_movetolocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.MoveToLocation)
  if (value_case() == kMoveToLocation) {
    clear_has_value();
    ::cfg::AiMoveToLocation* temp = _impl_.value_.movetolocation_;
    _impl_.value_.movetolocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_movetolocation(::cfg::AiMoveToLocation* movetolocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetolocation) {
    set_has_movetolocation();
    _impl_.value_.movetolocation_ = movetolocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.MoveToLocation)
}
inline ::cfg::AiMoveToLocation* AiNode::_internal_mutable_movetolocation() {
  if (value_case() != kMoveToLocation) {
    clear_value();
    set_has_movetolocation();
    _impl_.value_.movetolocation_ =
        CreateMaybeMessage<::cfg::AiMoveToLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.movetolocation_;
}
inline ::cfg::AiMoveToLocation* AiNode::mutable_movetolocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToLocation* _msg = _internal_mutable_movetolocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.MoveToLocation)
  return _msg;
}

// .cfg.AiDebugPrint DebugPrint = 23;
inline bool AiNode::has_debugprint() const {
  return value_case() == kDebugPrint;
}
inline bool AiNode::_internal_has_debugprint() const {
  return value_case() == kDebugPrint;
}
inline void AiNode::set_has_debugprint() {
  _impl_._oneof_case_[0] = kDebugPrint;
}
inline void AiNode::clear_debugprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDebugPrint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.debugprint_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiDebugPrint* AiNode::release_debugprint() {
  // @@protoc_insertion_point(field_release:cfg.AiNode.DebugPrint)
  if (value_case() == kDebugPrint) {
    clear_has_value();
    ::cfg::AiDebugPrint* temp = _impl_.value_.debugprint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.debugprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiDebugPrint& AiNode::_internal_debugprint() const {
  return value_case() == kDebugPrint ? *_impl_.value_.debugprint_ : reinterpret_cast<::cfg::AiDebugPrint&>(::cfg::_AiDebugPrint_default_instance_);
}
inline const ::cfg::AiDebugPrint& AiNode::debugprint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiNode.DebugPrint)
  return _internal_debugprint();
}
inline ::cfg::AiDebugPrint* AiNode::unsafe_arena_release_debugprint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiNode.DebugPrint)
  if (value_case() == kDebugPrint) {
    clear_has_value();
    ::cfg::AiDebugPrint* temp = _impl_.value_.debugprint_;
    _impl_.value_.debugprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiNode::unsafe_arena_set_allocated_debugprint(::cfg::AiDebugPrint* debugprint) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (debugprint) {
    set_has_debugprint();
    _impl_.value_.debugprint_ = debugprint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiNode.DebugPrint)
}
inline ::cfg::AiDebugPrint* AiNode::_internal_mutable_debugprint() {
  if (value_case() != kDebugPrint) {
    clear_value();
    set_has_debugprint();
    _impl_.value_.debugprint_ =
        CreateMaybeMessage<::cfg::AiDebugPrint>(GetArenaForAllocation());
  }
  return _impl_.value_.debugprint_;
}
inline ::cfg::AiDebugPrint* AiNode::mutable_debugprint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiDebugPrint* _msg = _internal_mutable_debugprint();
  // @@protoc_insertion_point(field_mutable:cfg.AiNode.DebugPrint)
  return _msg;
}

inline bool AiNode::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiNode::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiNode::ValueCase AiNode::value_case() const {
  return AiNode::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiService

// .cfg.AiUeSetDefaultFocus UeSetDefaultFocus = 1;
inline bool AiService::has_uesetdefaultfocus() const {
  return value_case() == kUeSetDefaultFocus;
}
inline bool AiService::_internal_has_uesetdefaultfocus() const {
  return value_case() == kUeSetDefaultFocus;
}
inline void AiService::set_has_uesetdefaultfocus() {
  _impl_._oneof_case_[0] = kUeSetDefaultFocus;
}
inline void AiService::clear_uesetdefaultfocus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeSetDefaultFocus) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uesetdefaultfocus_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeSetDefaultFocus* AiService::release_uesetdefaultfocus() {
  // @@protoc_insertion_point(field_release:cfg.AiService.UeSetDefaultFocus)
  if (value_case() == kUeSetDefaultFocus) {
    clear_has_value();
    ::cfg::AiUeSetDefaultFocus* temp = _impl_.value_.uesetdefaultfocus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uesetdefaultfocus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeSetDefaultFocus& AiService::_internal_uesetdefaultfocus() const {
  return value_case() == kUeSetDefaultFocus ? *_impl_.value_.uesetdefaultfocus_ : reinterpret_cast<::cfg::AiUeSetDefaultFocus&>(::cfg::_AiUeSetDefaultFocus_default_instance_);
}
inline const ::cfg::AiUeSetDefaultFocus& AiService::uesetdefaultfocus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiService.UeSetDefaultFocus)
  return _internal_uesetdefaultfocus();
}
inline ::cfg::AiUeSetDefaultFocus* AiService::unsafe_arena_release_uesetdefaultfocus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiService.UeSetDefaultFocus)
  if (value_case() == kUeSetDefaultFocus) {
    clear_has_value();
    ::cfg::AiUeSetDefaultFocus* temp = _impl_.value_.uesetdefaultfocus_;
    _impl_.value_.uesetdefaultfocus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiService::unsafe_arena_set_allocated_uesetdefaultfocus(::cfg::AiUeSetDefaultFocus* uesetdefaultfocus) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uesetdefaultfocus) {
    set_has_uesetdefaultfocus();
    _impl_.value_.uesetdefaultfocus_ = uesetdefaultfocus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiService.UeSetDefaultFocus)
}
inline ::cfg::AiUeSetDefaultFocus* AiService::_internal_mutable_uesetdefaultfocus() {
  if (value_case() != kUeSetDefaultFocus) {
    clear_value();
    set_has_uesetdefaultfocus();
    _impl_.value_.uesetdefaultfocus_ =
        CreateMaybeMessage<::cfg::AiUeSetDefaultFocus>(GetArenaForAllocation());
  }
  return _impl_.value_.uesetdefaultfocus_;
}
inline ::cfg::AiUeSetDefaultFocus* AiService::mutable_uesetdefaultfocus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeSetDefaultFocus* _msg = _internal_mutable_uesetdefaultfocus();
  // @@protoc_insertion_point(field_mutable:cfg.AiService.UeSetDefaultFocus)
  return _msg;
}

// .cfg.AiExecuteTimeStatistic ExecuteTimeStatistic = 2;
inline bool AiService::has_executetimestatistic() const {
  return value_case() == kExecuteTimeStatistic;
}
inline bool AiService::_internal_has_executetimestatistic() const {
  return value_case() == kExecuteTimeStatistic;
}
inline void AiService::set_has_executetimestatistic() {
  _impl_._oneof_case_[0] = kExecuteTimeStatistic;
}
inline void AiService::clear_executetimestatistic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kExecuteTimeStatistic) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.executetimestatistic_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiExecuteTimeStatistic* AiService::release_executetimestatistic() {
  // @@protoc_insertion_point(field_release:cfg.AiService.ExecuteTimeStatistic)
  if (value_case() == kExecuteTimeStatistic) {
    clear_has_value();
    ::cfg::AiExecuteTimeStatistic* temp = _impl_.value_.executetimestatistic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.executetimestatistic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiExecuteTimeStatistic& AiService::_internal_executetimestatistic() const {
  return value_case() == kExecuteTimeStatistic ? *_impl_.value_.executetimestatistic_ : reinterpret_cast<::cfg::AiExecuteTimeStatistic&>(::cfg::_AiExecuteTimeStatistic_default_instance_);
}
inline const ::cfg::AiExecuteTimeStatistic& AiService::executetimestatistic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiService.ExecuteTimeStatistic)
  return _internal_executetimestatistic();
}
inline ::cfg::AiExecuteTimeStatistic* AiService::unsafe_arena_release_executetimestatistic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiService.ExecuteTimeStatistic)
  if (value_case() == kExecuteTimeStatistic) {
    clear_has_value();
    ::cfg::AiExecuteTimeStatistic* temp = _impl_.value_.executetimestatistic_;
    _impl_.value_.executetimestatistic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiService::unsafe_arena_set_allocated_executetimestatistic(::cfg::AiExecuteTimeStatistic* executetimestatistic) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (executetimestatistic) {
    set_has_executetimestatistic();
    _impl_.value_.executetimestatistic_ = executetimestatistic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiService.ExecuteTimeStatistic)
}
inline ::cfg::AiExecuteTimeStatistic* AiService::_internal_mutable_executetimestatistic() {
  if (value_case() != kExecuteTimeStatistic) {
    clear_value();
    set_has_executetimestatistic();
    _impl_.value_.executetimestatistic_ =
        CreateMaybeMessage<::cfg::AiExecuteTimeStatistic>(GetArenaForAllocation());
  }
  return _impl_.value_.executetimestatistic_;
}
inline ::cfg::AiExecuteTimeStatistic* AiService::mutable_executetimestatistic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiExecuteTimeStatistic* _msg = _internal_mutable_executetimestatistic();
  // @@protoc_insertion_point(field_mutable:cfg.AiService.ExecuteTimeStatistic)
  return _msg;
}

// .cfg.AiChooseTarget ChooseTarget = 3;
inline bool AiService::has_choosetarget() const {
  return value_case() == kChooseTarget;
}
inline bool AiService::_internal_has_choosetarget() const {
  return value_case() == kChooseTarget;
}
inline void AiService::set_has_choosetarget() {
  _impl_._oneof_case_[0] = kChooseTarget;
}
inline void AiService::clear_choosetarget() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kChooseTarget) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.choosetarget_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiChooseTarget* AiService::release_choosetarget() {
  // @@protoc_insertion_point(field_release:cfg.AiService.ChooseTarget)
  if (value_case() == kChooseTarget) {
    clear_has_value();
    ::cfg::AiChooseTarget* temp = _impl_.value_.choosetarget_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.choosetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiChooseTarget& AiService::_internal_choosetarget() const {
  return value_case() == kChooseTarget ? *_impl_.value_.choosetarget_ : reinterpret_cast<::cfg::AiChooseTarget&>(::cfg::_AiChooseTarget_default_instance_);
}
inline const ::cfg::AiChooseTarget& AiService::choosetarget() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiService.ChooseTarget)
  return _internal_choosetarget();
}
inline ::cfg::AiChooseTarget* AiService::unsafe_arena_release_choosetarget() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiService.ChooseTarget)
  if (value_case() == kChooseTarget) {
    clear_has_value();
    ::cfg::AiChooseTarget* temp = _impl_.value_.choosetarget_;
    _impl_.value_.choosetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiService::unsafe_arena_set_allocated_choosetarget(::cfg::AiChooseTarget* choosetarget) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (choosetarget) {
    set_has_choosetarget();
    _impl_.value_.choosetarget_ = choosetarget;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiService.ChooseTarget)
}
inline ::cfg::AiChooseTarget* AiService::_internal_mutable_choosetarget() {
  if (value_case() != kChooseTarget) {
    clear_value();
    set_has_choosetarget();
    _impl_.value_.choosetarget_ =
        CreateMaybeMessage<::cfg::AiChooseTarget>(GetArenaForAllocation());
  }
  return _impl_.value_.choosetarget_;
}
inline ::cfg::AiChooseTarget* AiService::mutable_choosetarget() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiChooseTarget* _msg = _internal_mutable_choosetarget();
  // @@protoc_insertion_point(field_mutable:cfg.AiService.ChooseTarget)
  return _msg;
}

// .cfg.AiKeepFaceTarget KeepFaceTarget = 4;
inline bool AiService::has_keepfacetarget() const {
  return value_case() == kKeepFaceTarget;
}
inline bool AiService::_internal_has_keepfacetarget() const {
  return value_case() == kKeepFaceTarget;
}
inline void AiService::set_has_keepfacetarget() {
  _impl_._oneof_case_[0] = kKeepFaceTarget;
}
inline void AiService::clear_keepfacetarget() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kKeepFaceTarget) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.keepfacetarget_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiKeepFaceTarget* AiService::release_keepfacetarget() {
  // @@protoc_insertion_point(field_release:cfg.AiService.KeepFaceTarget)
  if (value_case() == kKeepFaceTarget) {
    clear_has_value();
    ::cfg::AiKeepFaceTarget* temp = _impl_.value_.keepfacetarget_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.keepfacetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiKeepFaceTarget& AiService::_internal_keepfacetarget() const {
  return value_case() == kKeepFaceTarget ? *_impl_.value_.keepfacetarget_ : reinterpret_cast<::cfg::AiKeepFaceTarget&>(::cfg::_AiKeepFaceTarget_default_instance_);
}
inline const ::cfg::AiKeepFaceTarget& AiService::keepfacetarget() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiService.KeepFaceTarget)
  return _internal_keepfacetarget();
}
inline ::cfg::AiKeepFaceTarget* AiService::unsafe_arena_release_keepfacetarget() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiService.KeepFaceTarget)
  if (value_case() == kKeepFaceTarget) {
    clear_has_value();
    ::cfg::AiKeepFaceTarget* temp = _impl_.value_.keepfacetarget_;
    _impl_.value_.keepfacetarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiService::unsafe_arena_set_allocated_keepfacetarget(::cfg::AiKeepFaceTarget* keepfacetarget) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (keepfacetarget) {
    set_has_keepfacetarget();
    _impl_.value_.keepfacetarget_ = keepfacetarget;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiService.KeepFaceTarget)
}
inline ::cfg::AiKeepFaceTarget* AiService::_internal_mutable_keepfacetarget() {
  if (value_case() != kKeepFaceTarget) {
    clear_value();
    set_has_keepfacetarget();
    _impl_.value_.keepfacetarget_ =
        CreateMaybeMessage<::cfg::AiKeepFaceTarget>(GetArenaForAllocation());
  }
  return _impl_.value_.keepfacetarget_;
}
inline ::cfg::AiKeepFaceTarget* AiService::mutable_keepfacetarget() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiKeepFaceTarget* _msg = _internal_mutable_keepfacetarget();
  // @@protoc_insertion_point(field_mutable:cfg.AiService.KeepFaceTarget)
  return _msg;
}

// .cfg.AiGetOwnerPlayer GetOwnerPlayer = 5;
inline bool AiService::has_getownerplayer() const {
  return value_case() == kGetOwnerPlayer;
}
inline bool AiService::_internal_has_getownerplayer() const {
  return value_case() == kGetOwnerPlayer;
}
inline void AiService::set_has_getownerplayer() {
  _impl_._oneof_case_[0] = kGetOwnerPlayer;
}
inline void AiService::clear_getownerplayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kGetOwnerPlayer) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.getownerplayer_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiGetOwnerPlayer* AiService::release_getownerplayer() {
  // @@protoc_insertion_point(field_release:cfg.AiService.GetOwnerPlayer)
  if (value_case() == kGetOwnerPlayer) {
    clear_has_value();
    ::cfg::AiGetOwnerPlayer* temp = _impl_.value_.getownerplayer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.getownerplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiGetOwnerPlayer& AiService::_internal_getownerplayer() const {
  return value_case() == kGetOwnerPlayer ? *_impl_.value_.getownerplayer_ : reinterpret_cast<::cfg::AiGetOwnerPlayer&>(::cfg::_AiGetOwnerPlayer_default_instance_);
}
inline const ::cfg::AiGetOwnerPlayer& AiService::getownerplayer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiService.GetOwnerPlayer)
  return _internal_getownerplayer();
}
inline ::cfg::AiGetOwnerPlayer* AiService::unsafe_arena_release_getownerplayer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiService.GetOwnerPlayer)
  if (value_case() == kGetOwnerPlayer) {
    clear_has_value();
    ::cfg::AiGetOwnerPlayer* temp = _impl_.value_.getownerplayer_;
    _impl_.value_.getownerplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiService::unsafe_arena_set_allocated_getownerplayer(::cfg::AiGetOwnerPlayer* getownerplayer) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (getownerplayer) {
    set_has_getownerplayer();
    _impl_.value_.getownerplayer_ = getownerplayer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiService.GetOwnerPlayer)
}
inline ::cfg::AiGetOwnerPlayer* AiService::_internal_mutable_getownerplayer() {
  if (value_case() != kGetOwnerPlayer) {
    clear_value();
    set_has_getownerplayer();
    _impl_.value_.getownerplayer_ =
        CreateMaybeMessage<::cfg::AiGetOwnerPlayer>(GetArenaForAllocation());
  }
  return _impl_.value_.getownerplayer_;
}
inline ::cfg::AiGetOwnerPlayer* AiService::mutable_getownerplayer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiGetOwnerPlayer* _msg = _internal_mutable_getownerplayer();
  // @@protoc_insertion_point(field_mutable:cfg.AiService.GetOwnerPlayer)
  return _msg;
}

// .cfg.AiUpdateDailyBehaviorProps UpdateDailyBehaviorProps = 6;
inline bool AiService::has_updatedailybehaviorprops() const {
  return value_case() == kUpdateDailyBehaviorProps;
}
inline bool AiService::_internal_has_updatedailybehaviorprops() const {
  return value_case() == kUpdateDailyBehaviorProps;
}
inline void AiService::set_has_updatedailybehaviorprops() {
  _impl_._oneof_case_[0] = kUpdateDailyBehaviorProps;
}
inline void AiService::clear_updatedailybehaviorprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUpdateDailyBehaviorProps) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.updatedailybehaviorprops_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiService::release_updatedailybehaviorprops() {
  // @@protoc_insertion_point(field_release:cfg.AiService.UpdateDailyBehaviorProps)
  if (value_case() == kUpdateDailyBehaviorProps) {
    clear_has_value();
    ::cfg::AiUpdateDailyBehaviorProps* temp = _impl_.value_.updatedailybehaviorprops_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.updatedailybehaviorprops_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUpdateDailyBehaviorProps& AiService::_internal_updatedailybehaviorprops() const {
  return value_case() == kUpdateDailyBehaviorProps ? *_impl_.value_.updatedailybehaviorprops_ : reinterpret_cast<::cfg::AiUpdateDailyBehaviorProps&>(::cfg::_AiUpdateDailyBehaviorProps_default_instance_);
}
inline const ::cfg::AiUpdateDailyBehaviorProps& AiService::updatedailybehaviorprops() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiService.UpdateDailyBehaviorProps)
  return _internal_updatedailybehaviorprops();
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiService::unsafe_arena_release_updatedailybehaviorprops() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiService.UpdateDailyBehaviorProps)
  if (value_case() == kUpdateDailyBehaviorProps) {
    clear_has_value();
    ::cfg::AiUpdateDailyBehaviorProps* temp = _impl_.value_.updatedailybehaviorprops_;
    _impl_.value_.updatedailybehaviorprops_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiService::unsafe_arena_set_allocated_updatedailybehaviorprops(::cfg::AiUpdateDailyBehaviorProps* updatedailybehaviorprops) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (updatedailybehaviorprops) {
    set_has_updatedailybehaviorprops();
    _impl_.value_.updatedailybehaviorprops_ = updatedailybehaviorprops;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiService.UpdateDailyBehaviorProps)
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiService::_internal_mutable_updatedailybehaviorprops() {
  if (value_case() != kUpdateDailyBehaviorProps) {
    clear_value();
    set_has_updatedailybehaviorprops();
    _impl_.value_.updatedailybehaviorprops_ =
        CreateMaybeMessage<::cfg::AiUpdateDailyBehaviorProps>(GetArenaForAllocation());
  }
  return _impl_.value_.updatedailybehaviorprops_;
}
inline ::cfg::AiUpdateDailyBehaviorProps* AiService::mutable_updatedailybehaviorprops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUpdateDailyBehaviorProps* _msg = _internal_mutable_updatedailybehaviorprops();
  // @@protoc_insertion_point(field_mutable:cfg.AiService.UpdateDailyBehaviorProps)
  return _msg;
}

inline bool AiService::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiService::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiService::ValueCase AiService::value_case() const {
  return AiService::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiUeSetDefaultFocus

// int32 id = 1;
inline void AiUeSetDefaultFocus::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeSetDefaultFocus::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeSetDefaultFocus.id)
  return _internal_id();
}
inline void AiUeSetDefaultFocus::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeSetDefaultFocus.id)
}
inline ::int32_t AiUeSetDefaultFocus::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeSetDefaultFocus::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeSetDefaultFocus::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeSetDefaultFocus::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeSetDefaultFocus.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeSetDefaultFocus::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeSetDefaultFocus.node_name)
}
inline std::string* AiUeSetDefaultFocus::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeSetDefaultFocus.node_name)
  return _s;
}
inline const std::string& AiUeSetDefaultFocus::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeSetDefaultFocus::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeSetDefaultFocus::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeSetDefaultFocus::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeSetDefaultFocus.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeSetDefaultFocus::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeSetDefaultFocus.node_name)
}

// string keyboard_key = 3;
inline void AiUeSetDefaultFocus::clear_keyboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keyboard_key_.ClearToEmpty();
}
inline const std::string& AiUeSetDefaultFocus::keyboard_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeSetDefaultFocus.keyboard_key)
  return _internal_keyboard_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeSetDefaultFocus::set_keyboard_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keyboard_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeSetDefaultFocus.keyboard_key)
}
inline std::string* AiUeSetDefaultFocus::mutable_keyboard_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_keyboard_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeSetDefaultFocus.keyboard_key)
  return _s;
}
inline const std::string& AiUeSetDefaultFocus::_internal_keyboard_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keyboard_key_.Get();
}
inline void AiUeSetDefaultFocus::_internal_set_keyboard_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keyboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeSetDefaultFocus::_internal_mutable_keyboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.keyboard_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeSetDefaultFocus::release_keyboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeSetDefaultFocus.keyboard_key)
  return _impl_.keyboard_key_.Release();
}
inline void AiUeSetDefaultFocus::set_allocated_keyboard_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keyboard_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.keyboard_key_.IsDefault()) {
          _impl_.keyboard_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeSetDefaultFocus.keyboard_key)
}

// -------------------------------------------------------------------

// AiExecuteTimeStatistic

// int32 id = 1;
inline void AiExecuteTimeStatistic::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiExecuteTimeStatistic::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiExecuteTimeStatistic.id)
  return _internal_id();
}
inline void AiExecuteTimeStatistic::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiExecuteTimeStatistic.id)
}
inline ::int32_t AiExecuteTimeStatistic::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiExecuteTimeStatistic::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiExecuteTimeStatistic::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiExecuteTimeStatistic::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiExecuteTimeStatistic.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiExecuteTimeStatistic::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiExecuteTimeStatistic.node_name)
}
inline std::string* AiExecuteTimeStatistic::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiExecuteTimeStatistic.node_name)
  return _s;
}
inline const std::string& AiExecuteTimeStatistic::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiExecuteTimeStatistic::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiExecuteTimeStatistic::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiExecuteTimeStatistic::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiExecuteTimeStatistic.node_name)
  return _impl_.node_name_.Release();
}
inline void AiExecuteTimeStatistic::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiExecuteTimeStatistic.node_name)
}

// -------------------------------------------------------------------

// AiChooseTarget

// int32 id = 1;
inline void AiChooseTarget::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiChooseTarget::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiChooseTarget.id)
  return _internal_id();
}
inline void AiChooseTarget::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiChooseTarget.id)
}
inline ::int32_t AiChooseTarget::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiChooseTarget::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiChooseTarget::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiChooseTarget::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiChooseTarget.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiChooseTarget::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiChooseTarget.node_name)
}
inline std::string* AiChooseTarget::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiChooseTarget.node_name)
  return _s;
}
inline const std::string& AiChooseTarget::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiChooseTarget::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiChooseTarget::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiChooseTarget::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiChooseTarget.node_name)
  return _impl_.node_name_.Release();
}
inline void AiChooseTarget::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiChooseTarget.node_name)
}

// string result_target_key = 3;
inline void AiChooseTarget::clear_result_target_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_target_key_.ClearToEmpty();
}
inline const std::string& AiChooseTarget::result_target_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiChooseTarget.result_target_key)
  return _internal_result_target_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiChooseTarget::set_result_target_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_target_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiChooseTarget.result_target_key)
}
inline std::string* AiChooseTarget::mutable_result_target_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_result_target_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiChooseTarget.result_target_key)
  return _s;
}
inline const std::string& AiChooseTarget::_internal_result_target_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_target_key_.Get();
}
inline void AiChooseTarget::_internal_set_result_target_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_target_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiChooseTarget::_internal_mutable_result_target_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.result_target_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiChooseTarget::release_result_target_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiChooseTarget.result_target_key)
  return _impl_.result_target_key_.Release();
}
inline void AiChooseTarget::set_allocated_result_target_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_target_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.result_target_key_.IsDefault()) {
          _impl_.result_target_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiChooseTarget.result_target_key)
}

// -------------------------------------------------------------------

// AiKeepFaceTarget

// int32 id = 1;
inline void AiKeepFaceTarget::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiKeepFaceTarget::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiKeepFaceTarget.id)
  return _internal_id();
}
inline void AiKeepFaceTarget::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiKeepFaceTarget.id)
}
inline ::int32_t AiKeepFaceTarget::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiKeepFaceTarget::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiKeepFaceTarget::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiKeepFaceTarget::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeepFaceTarget.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiKeepFaceTarget::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiKeepFaceTarget.node_name)
}
inline std::string* AiKeepFaceTarget::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeepFaceTarget.node_name)
  return _s;
}
inline const std::string& AiKeepFaceTarget::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiKeepFaceTarget::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiKeepFaceTarget::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiKeepFaceTarget::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiKeepFaceTarget.node_name)
  return _impl_.node_name_.Release();
}
inline void AiKeepFaceTarget::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiKeepFaceTarget.node_name)
}

// string target_actor_key = 3;
inline void AiKeepFaceTarget::clear_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_actor_key_.ClearToEmpty();
}
inline const std::string& AiKeepFaceTarget::target_actor_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeepFaceTarget.target_actor_key)
  return _internal_target_actor_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiKeepFaceTarget::set_target_actor_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_actor_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiKeepFaceTarget.target_actor_key)
}
inline std::string* AiKeepFaceTarget::mutable_target_actor_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_actor_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeepFaceTarget.target_actor_key)
  return _s;
}
inline const std::string& AiKeepFaceTarget::_internal_target_actor_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_actor_key_.Get();
}
inline void AiKeepFaceTarget::_internal_set_target_actor_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_actor_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiKeepFaceTarget::_internal_mutable_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_actor_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiKeepFaceTarget::release_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiKeepFaceTarget.target_actor_key)
  return _impl_.target_actor_key_.Release();
}
inline void AiKeepFaceTarget::set_allocated_target_actor_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_actor_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_actor_key_.IsDefault()) {
          _impl_.target_actor_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiKeepFaceTarget.target_actor_key)
}

// -------------------------------------------------------------------

// AiGetOwnerPlayer

// int32 id = 1;
inline void AiGetOwnerPlayer::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiGetOwnerPlayer::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiGetOwnerPlayer.id)
  return _internal_id();
}
inline void AiGetOwnerPlayer::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiGetOwnerPlayer.id)
}
inline ::int32_t AiGetOwnerPlayer::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiGetOwnerPlayer::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiGetOwnerPlayer::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiGetOwnerPlayer::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiGetOwnerPlayer.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiGetOwnerPlayer::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiGetOwnerPlayer.node_name)
}
inline std::string* AiGetOwnerPlayer::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiGetOwnerPlayer.node_name)
  return _s;
}
inline const std::string& AiGetOwnerPlayer::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiGetOwnerPlayer::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiGetOwnerPlayer::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiGetOwnerPlayer::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiGetOwnerPlayer.node_name)
  return _impl_.node_name_.Release();
}
inline void AiGetOwnerPlayer::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiGetOwnerPlayer.node_name)
}

// string player_actor_key = 3;
inline void AiGetOwnerPlayer::clear_player_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_actor_key_.ClearToEmpty();
}
inline const std::string& AiGetOwnerPlayer::player_actor_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiGetOwnerPlayer.player_actor_key)
  return _internal_player_actor_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiGetOwnerPlayer::set_player_actor_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_actor_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiGetOwnerPlayer.player_actor_key)
}
inline std::string* AiGetOwnerPlayer::mutable_player_actor_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_actor_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiGetOwnerPlayer.player_actor_key)
  return _s;
}
inline const std::string& AiGetOwnerPlayer::_internal_player_actor_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_actor_key_.Get();
}
inline void AiGetOwnerPlayer::_internal_set_player_actor_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_actor_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiGetOwnerPlayer::_internal_mutable_player_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_actor_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiGetOwnerPlayer::release_player_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiGetOwnerPlayer.player_actor_key)
  return _impl_.player_actor_key_.Release();
}
inline void AiGetOwnerPlayer::set_allocated_player_actor_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_actor_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_actor_key_.IsDefault()) {
          _impl_.player_actor_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiGetOwnerPlayer.player_actor_key)
}

// -------------------------------------------------------------------

// AiUpdateDailyBehaviorProps

// int32 id = 1;
inline void AiUpdateDailyBehaviorProps::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUpdateDailyBehaviorProps::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.id)
  return _internal_id();
}
inline void AiUpdateDailyBehaviorProps::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.id)
}
inline ::int32_t AiUpdateDailyBehaviorProps::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUpdateDailyBehaviorProps::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUpdateDailyBehaviorProps::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.node_name)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.node_name)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.node_name)
}

// string satiety_key = 3;
inline void AiUpdateDailyBehaviorProps::clear_satiety_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satiety_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::satiety_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.satiety_key)
  return _internal_satiety_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_satiety_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.satiety_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.satiety_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_satiety_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_satiety_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.satiety_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_satiety_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.satiety_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_satiety_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.satiety_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_satiety_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.satiety_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_satiety_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.satiety_key)
  return _impl_.satiety_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_satiety_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satiety_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.satiety_key_.IsDefault()) {
          _impl_.satiety_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.satiety_key)
}

// string energy_key = 4;
inline void AiUpdateDailyBehaviorProps::clear_energy_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.energy_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::energy_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.energy_key)
  return _internal_energy_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_energy_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.energy_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.energy_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_energy_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_energy_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.energy_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_energy_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.energy_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_energy_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.energy_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_energy_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.energy_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_energy_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.energy_key)
  return _impl_.energy_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_energy_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.energy_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.energy_key_.IsDefault()) {
          _impl_.energy_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.energy_key)
}

// string mood_key = 5;
inline void AiUpdateDailyBehaviorProps::clear_mood_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mood_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::mood_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.mood_key)
  return _internal_mood_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_mood_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mood_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.mood_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_mood_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mood_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.mood_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_mood_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mood_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_mood_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mood_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_mood_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mood_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_mood_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.mood_key)
  return _impl_.mood_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_mood_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mood_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mood_key_.IsDefault()) {
          _impl_.mood_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.mood_key)
}

// string satiety_lower_threshold_key = 6;
inline void AiUpdateDailyBehaviorProps::clear_satiety_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satiety_lower_threshold_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::satiety_lower_threshold_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.satiety_lower_threshold_key)
  return _internal_satiety_lower_threshold_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_satiety_lower_threshold_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.satiety_lower_threshold_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.satiety_lower_threshold_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_satiety_lower_threshold_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_satiety_lower_threshold_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.satiety_lower_threshold_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_satiety_lower_threshold_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.satiety_lower_threshold_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_satiety_lower_threshold_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.satiety_lower_threshold_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_satiety_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.satiety_lower_threshold_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_satiety_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.satiety_lower_threshold_key)
  return _impl_.satiety_lower_threshold_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_satiety_lower_threshold_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satiety_lower_threshold_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.satiety_lower_threshold_key_.IsDefault()) {
          _impl_.satiety_lower_threshold_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.satiety_lower_threshold_key)
}

// string satiety_upper_threshold_key = 7;
inline void AiUpdateDailyBehaviorProps::clear_satiety_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satiety_upper_threshold_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::satiety_upper_threshold_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.satiety_upper_threshold_key)
  return _internal_satiety_upper_threshold_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_satiety_upper_threshold_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.satiety_upper_threshold_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.satiety_upper_threshold_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_satiety_upper_threshold_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_satiety_upper_threshold_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.satiety_upper_threshold_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_satiety_upper_threshold_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.satiety_upper_threshold_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_satiety_upper_threshold_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.satiety_upper_threshold_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_satiety_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.satiety_upper_threshold_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_satiety_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.satiety_upper_threshold_key)
  return _impl_.satiety_upper_threshold_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_satiety_upper_threshold_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satiety_upper_threshold_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.satiety_upper_threshold_key_.IsDefault()) {
          _impl_.satiety_upper_threshold_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.satiety_upper_threshold_key)
}

// string energy_lower_threshold_key = 8;
inline void AiUpdateDailyBehaviorProps::clear_energy_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.energy_lower_threshold_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::energy_lower_threshold_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.energy_lower_threshold_key)
  return _internal_energy_lower_threshold_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_energy_lower_threshold_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.energy_lower_threshold_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.energy_lower_threshold_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_energy_lower_threshold_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_energy_lower_threshold_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.energy_lower_threshold_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_energy_lower_threshold_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.energy_lower_threshold_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_energy_lower_threshold_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.energy_lower_threshold_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_energy_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.energy_lower_threshold_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_energy_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.energy_lower_threshold_key)
  return _impl_.energy_lower_threshold_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_energy_lower_threshold_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.energy_lower_threshold_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.energy_lower_threshold_key_.IsDefault()) {
          _impl_.energy_lower_threshold_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.energy_lower_threshold_key)
}

// string energy_upper_threshold_key = 9;
inline void AiUpdateDailyBehaviorProps::clear_energy_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.energy_upper_threshold_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::energy_upper_threshold_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.energy_upper_threshold_key)
  return _internal_energy_upper_threshold_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_energy_upper_threshold_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.energy_upper_threshold_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.energy_upper_threshold_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_energy_upper_threshold_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_energy_upper_threshold_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.energy_upper_threshold_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_energy_upper_threshold_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.energy_upper_threshold_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_energy_upper_threshold_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.energy_upper_threshold_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_energy_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.energy_upper_threshold_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_energy_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.energy_upper_threshold_key)
  return _impl_.energy_upper_threshold_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_energy_upper_threshold_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.energy_upper_threshold_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.energy_upper_threshold_key_.IsDefault()) {
          _impl_.energy_upper_threshold_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.energy_upper_threshold_key)
}

// string mood_lower_threshold_key = 10;
inline void AiUpdateDailyBehaviorProps::clear_mood_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mood_lower_threshold_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::mood_lower_threshold_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.mood_lower_threshold_key)
  return _internal_mood_lower_threshold_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_mood_lower_threshold_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mood_lower_threshold_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.mood_lower_threshold_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_mood_lower_threshold_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mood_lower_threshold_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.mood_lower_threshold_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_mood_lower_threshold_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mood_lower_threshold_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_mood_lower_threshold_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mood_lower_threshold_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_mood_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mood_lower_threshold_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_mood_lower_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.mood_lower_threshold_key)
  return _impl_.mood_lower_threshold_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_mood_lower_threshold_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mood_lower_threshold_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mood_lower_threshold_key_.IsDefault()) {
          _impl_.mood_lower_threshold_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.mood_lower_threshold_key)
}

// string mood_upper_threshold_key = 11;
inline void AiUpdateDailyBehaviorProps::clear_mood_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mood_upper_threshold_key_.ClearToEmpty();
}
inline const std::string& AiUpdateDailyBehaviorProps::mood_upper_threshold_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUpdateDailyBehaviorProps.mood_upper_threshold_key)
  return _internal_mood_upper_threshold_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUpdateDailyBehaviorProps::set_mood_upper_threshold_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mood_upper_threshold_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUpdateDailyBehaviorProps.mood_upper_threshold_key)
}
inline std::string* AiUpdateDailyBehaviorProps::mutable_mood_upper_threshold_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mood_upper_threshold_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUpdateDailyBehaviorProps.mood_upper_threshold_key)
  return _s;
}
inline const std::string& AiUpdateDailyBehaviorProps::_internal_mood_upper_threshold_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mood_upper_threshold_key_.Get();
}
inline void AiUpdateDailyBehaviorProps::_internal_set_mood_upper_threshold_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mood_upper_threshold_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::_internal_mutable_mood_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mood_upper_threshold_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUpdateDailyBehaviorProps::release_mood_upper_threshold_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUpdateDailyBehaviorProps.mood_upper_threshold_key)
  return _impl_.mood_upper_threshold_key_.Release();
}
inline void AiUpdateDailyBehaviorProps::set_allocated_mood_upper_threshold_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mood_upper_threshold_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mood_upper_threshold_key_.IsDefault()) {
          _impl_.mood_upper_threshold_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUpdateDailyBehaviorProps.mood_upper_threshold_key)
}

// -------------------------------------------------------------------

// AiDecorator

// .cfg.AiUeLoop UeLoop = 7;
inline bool AiDecorator::has_ueloop() const {
  return value_case() == kUeLoop;
}
inline bool AiDecorator::_internal_has_ueloop() const {
  return value_case() == kUeLoop;
}
inline void AiDecorator::set_has_ueloop() {
  _impl_._oneof_case_[0] = kUeLoop;
}
inline void AiDecorator::clear_ueloop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeLoop) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.ueloop_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeLoop* AiDecorator::release_ueloop() {
  // @@protoc_insertion_point(field_release:cfg.AiDecorator.UeLoop)
  if (value_case() == kUeLoop) {
    clear_has_value();
    ::cfg::AiUeLoop* temp = _impl_.value_.ueloop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ueloop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeLoop& AiDecorator::_internal_ueloop() const {
  return value_case() == kUeLoop ? *_impl_.value_.ueloop_ : reinterpret_cast<::cfg::AiUeLoop&>(::cfg::_AiUeLoop_default_instance_);
}
inline const ::cfg::AiUeLoop& AiDecorator::ueloop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDecorator.UeLoop)
  return _internal_ueloop();
}
inline ::cfg::AiUeLoop* AiDecorator::unsafe_arena_release_ueloop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiDecorator.UeLoop)
  if (value_case() == kUeLoop) {
    clear_has_value();
    ::cfg::AiUeLoop* temp = _impl_.value_.ueloop_;
    _impl_.value_.ueloop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiDecorator::unsafe_arena_set_allocated_ueloop(::cfg::AiUeLoop* ueloop) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (ueloop) {
    set_has_ueloop();
    _impl_.value_.ueloop_ = ueloop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiDecorator.UeLoop)
}
inline ::cfg::AiUeLoop* AiDecorator::_internal_mutable_ueloop() {
  if (value_case() != kUeLoop) {
    clear_value();
    set_has_ueloop();
    _impl_.value_.ueloop_ =
        CreateMaybeMessage<::cfg::AiUeLoop>(GetArenaForAllocation());
  }
  return _impl_.value_.ueloop_;
}
inline ::cfg::AiUeLoop* AiDecorator::mutable_ueloop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeLoop* _msg = _internal_mutable_ueloop();
  // @@protoc_insertion_point(field_mutable:cfg.AiDecorator.UeLoop)
  return _msg;
}

// .cfg.AiUeCooldown UeCooldown = 8;
inline bool AiDecorator::has_uecooldown() const {
  return value_case() == kUeCooldown;
}
inline bool AiDecorator::_internal_has_uecooldown() const {
  return value_case() == kUeCooldown;
}
inline void AiDecorator::set_has_uecooldown() {
  _impl_._oneof_case_[0] = kUeCooldown;
}
inline void AiDecorator::clear_uecooldown() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeCooldown) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uecooldown_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeCooldown* AiDecorator::release_uecooldown() {
  // @@protoc_insertion_point(field_release:cfg.AiDecorator.UeCooldown)
  if (value_case() == kUeCooldown) {
    clear_has_value();
    ::cfg::AiUeCooldown* temp = _impl_.value_.uecooldown_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uecooldown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeCooldown& AiDecorator::_internal_uecooldown() const {
  return value_case() == kUeCooldown ? *_impl_.value_.uecooldown_ : reinterpret_cast<::cfg::AiUeCooldown&>(::cfg::_AiUeCooldown_default_instance_);
}
inline const ::cfg::AiUeCooldown& AiDecorator::uecooldown() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDecorator.UeCooldown)
  return _internal_uecooldown();
}
inline ::cfg::AiUeCooldown* AiDecorator::unsafe_arena_release_uecooldown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiDecorator.UeCooldown)
  if (value_case() == kUeCooldown) {
    clear_has_value();
    ::cfg::AiUeCooldown* temp = _impl_.value_.uecooldown_;
    _impl_.value_.uecooldown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiDecorator::unsafe_arena_set_allocated_uecooldown(::cfg::AiUeCooldown* uecooldown) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uecooldown) {
    set_has_uecooldown();
    _impl_.value_.uecooldown_ = uecooldown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiDecorator.UeCooldown)
}
inline ::cfg::AiUeCooldown* AiDecorator::_internal_mutable_uecooldown() {
  if (value_case() != kUeCooldown) {
    clear_value();
    set_has_uecooldown();
    _impl_.value_.uecooldown_ =
        CreateMaybeMessage<::cfg::AiUeCooldown>(GetArenaForAllocation());
  }
  return _impl_.value_.uecooldown_;
}
inline ::cfg::AiUeCooldown* AiDecorator::mutable_uecooldown() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeCooldown* _msg = _internal_mutable_uecooldown();
  // @@protoc_insertion_point(field_mutable:cfg.AiDecorator.UeCooldown)
  return _msg;
}

// .cfg.AiUeTimeLimit UeTimeLimit = 9;
inline bool AiDecorator::has_uetimelimit() const {
  return value_case() == kUeTimeLimit;
}
inline bool AiDecorator::_internal_has_uetimelimit() const {
  return value_case() == kUeTimeLimit;
}
inline void AiDecorator::set_has_uetimelimit() {
  _impl_._oneof_case_[0] = kUeTimeLimit;
}
inline void AiDecorator::clear_uetimelimit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeTimeLimit) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uetimelimit_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeTimeLimit* AiDecorator::release_uetimelimit() {
  // @@protoc_insertion_point(field_release:cfg.AiDecorator.UeTimeLimit)
  if (value_case() == kUeTimeLimit) {
    clear_has_value();
    ::cfg::AiUeTimeLimit* temp = _impl_.value_.uetimelimit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uetimelimit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeTimeLimit& AiDecorator::_internal_uetimelimit() const {
  return value_case() == kUeTimeLimit ? *_impl_.value_.uetimelimit_ : reinterpret_cast<::cfg::AiUeTimeLimit&>(::cfg::_AiUeTimeLimit_default_instance_);
}
inline const ::cfg::AiUeTimeLimit& AiDecorator::uetimelimit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDecorator.UeTimeLimit)
  return _internal_uetimelimit();
}
inline ::cfg::AiUeTimeLimit* AiDecorator::unsafe_arena_release_uetimelimit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiDecorator.UeTimeLimit)
  if (value_case() == kUeTimeLimit) {
    clear_has_value();
    ::cfg::AiUeTimeLimit* temp = _impl_.value_.uetimelimit_;
    _impl_.value_.uetimelimit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiDecorator::unsafe_arena_set_allocated_uetimelimit(::cfg::AiUeTimeLimit* uetimelimit) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uetimelimit) {
    set_has_uetimelimit();
    _impl_.value_.uetimelimit_ = uetimelimit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiDecorator.UeTimeLimit)
}
inline ::cfg::AiUeTimeLimit* AiDecorator::_internal_mutable_uetimelimit() {
  if (value_case() != kUeTimeLimit) {
    clear_value();
    set_has_uetimelimit();
    _impl_.value_.uetimelimit_ =
        CreateMaybeMessage<::cfg::AiUeTimeLimit>(GetArenaForAllocation());
  }
  return _impl_.value_.uetimelimit_;
}
inline ::cfg::AiUeTimeLimit* AiDecorator::mutable_uetimelimit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeTimeLimit* _msg = _internal_mutable_uetimelimit();
  // @@protoc_insertion_point(field_mutable:cfg.AiDecorator.UeTimeLimit)
  return _msg;
}

// .cfg.AiUeBlackboard UeBlackboard = 10;
inline bool AiDecorator::has_ueblackboard() const {
  return value_case() == kUeBlackboard;
}
inline bool AiDecorator::_internal_has_ueblackboard() const {
  return value_case() == kUeBlackboard;
}
inline void AiDecorator::set_has_ueblackboard() {
  _impl_._oneof_case_[0] = kUeBlackboard;
}
inline void AiDecorator::clear_ueblackboard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeBlackboard) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.ueblackboard_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeBlackboard* AiDecorator::release_ueblackboard() {
  // @@protoc_insertion_point(field_release:cfg.AiDecorator.UeBlackboard)
  if (value_case() == kUeBlackboard) {
    clear_has_value();
    ::cfg::AiUeBlackboard* temp = _impl_.value_.ueblackboard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ueblackboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeBlackboard& AiDecorator::_internal_ueblackboard() const {
  return value_case() == kUeBlackboard ? *_impl_.value_.ueblackboard_ : reinterpret_cast<::cfg::AiUeBlackboard&>(::cfg::_AiUeBlackboard_default_instance_);
}
inline const ::cfg::AiUeBlackboard& AiDecorator::ueblackboard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDecorator.UeBlackboard)
  return _internal_ueblackboard();
}
inline ::cfg::AiUeBlackboard* AiDecorator::unsafe_arena_release_ueblackboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiDecorator.UeBlackboard)
  if (value_case() == kUeBlackboard) {
    clear_has_value();
    ::cfg::AiUeBlackboard* temp = _impl_.value_.ueblackboard_;
    _impl_.value_.ueblackboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiDecorator::unsafe_arena_set_allocated_ueblackboard(::cfg::AiUeBlackboard* ueblackboard) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (ueblackboard) {
    set_has_ueblackboard();
    _impl_.value_.ueblackboard_ = ueblackboard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiDecorator.UeBlackboard)
}
inline ::cfg::AiUeBlackboard* AiDecorator::_internal_mutable_ueblackboard() {
  if (value_case() != kUeBlackboard) {
    clear_value();
    set_has_ueblackboard();
    _impl_.value_.ueblackboard_ =
        CreateMaybeMessage<::cfg::AiUeBlackboard>(GetArenaForAllocation());
  }
  return _impl_.value_.ueblackboard_;
}
inline ::cfg::AiUeBlackboard* AiDecorator::mutable_ueblackboard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeBlackboard* _msg = _internal_mutable_ueblackboard();
  // @@protoc_insertion_point(field_mutable:cfg.AiDecorator.UeBlackboard)
  return _msg;
}

// .cfg.AiUeForceSuccess UeForceSuccess = 11;
inline bool AiDecorator::has_ueforcesuccess() const {
  return value_case() == kUeForceSuccess;
}
inline bool AiDecorator::_internal_has_ueforcesuccess() const {
  return value_case() == kUeForceSuccess;
}
inline void AiDecorator::set_has_ueforcesuccess() {
  _impl_._oneof_case_[0] = kUeForceSuccess;
}
inline void AiDecorator::clear_ueforcesuccess() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeForceSuccess) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.ueforcesuccess_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeForceSuccess* AiDecorator::release_ueforcesuccess() {
  // @@protoc_insertion_point(field_release:cfg.AiDecorator.UeForceSuccess)
  if (value_case() == kUeForceSuccess) {
    clear_has_value();
    ::cfg::AiUeForceSuccess* temp = _impl_.value_.ueforcesuccess_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ueforcesuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeForceSuccess& AiDecorator::_internal_ueforcesuccess() const {
  return value_case() == kUeForceSuccess ? *_impl_.value_.ueforcesuccess_ : reinterpret_cast<::cfg::AiUeForceSuccess&>(::cfg::_AiUeForceSuccess_default_instance_);
}
inline const ::cfg::AiUeForceSuccess& AiDecorator::ueforcesuccess() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDecorator.UeForceSuccess)
  return _internal_ueforcesuccess();
}
inline ::cfg::AiUeForceSuccess* AiDecorator::unsafe_arena_release_ueforcesuccess() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiDecorator.UeForceSuccess)
  if (value_case() == kUeForceSuccess) {
    clear_has_value();
    ::cfg::AiUeForceSuccess* temp = _impl_.value_.ueforcesuccess_;
    _impl_.value_.ueforcesuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiDecorator::unsafe_arena_set_allocated_ueforcesuccess(::cfg::AiUeForceSuccess* ueforcesuccess) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (ueforcesuccess) {
    set_has_ueforcesuccess();
    _impl_.value_.ueforcesuccess_ = ueforcesuccess;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiDecorator.UeForceSuccess)
}
inline ::cfg::AiUeForceSuccess* AiDecorator::_internal_mutable_ueforcesuccess() {
  if (value_case() != kUeForceSuccess) {
    clear_value();
    set_has_ueforcesuccess();
    _impl_.value_.ueforcesuccess_ =
        CreateMaybeMessage<::cfg::AiUeForceSuccess>(GetArenaForAllocation());
  }
  return _impl_.value_.ueforcesuccess_;
}
inline ::cfg::AiUeForceSuccess* AiDecorator::mutable_ueforcesuccess() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeForceSuccess* _msg = _internal_mutable_ueforcesuccess();
  // @@protoc_insertion_point(field_mutable:cfg.AiDecorator.UeForceSuccess)
  return _msg;
}

// .cfg.AiIsAtLocation IsAtLocation = 12;
inline bool AiDecorator::has_isatlocation() const {
  return value_case() == kIsAtLocation;
}
inline bool AiDecorator::_internal_has_isatlocation() const {
  return value_case() == kIsAtLocation;
}
inline void AiDecorator::set_has_isatlocation() {
  _impl_._oneof_case_[0] = kIsAtLocation;
}
inline void AiDecorator::clear_isatlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kIsAtLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.isatlocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiIsAtLocation* AiDecorator::release_isatlocation() {
  // @@protoc_insertion_point(field_release:cfg.AiDecorator.IsAtLocation)
  if (value_case() == kIsAtLocation) {
    clear_has_value();
    ::cfg::AiIsAtLocation* temp = _impl_.value_.isatlocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.isatlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiIsAtLocation& AiDecorator::_internal_isatlocation() const {
  return value_case() == kIsAtLocation ? *_impl_.value_.isatlocation_ : reinterpret_cast<::cfg::AiIsAtLocation&>(::cfg::_AiIsAtLocation_default_instance_);
}
inline const ::cfg::AiIsAtLocation& AiDecorator::isatlocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDecorator.IsAtLocation)
  return _internal_isatlocation();
}
inline ::cfg::AiIsAtLocation* AiDecorator::unsafe_arena_release_isatlocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiDecorator.IsAtLocation)
  if (value_case() == kIsAtLocation) {
    clear_has_value();
    ::cfg::AiIsAtLocation* temp = _impl_.value_.isatlocation_;
    _impl_.value_.isatlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiDecorator::unsafe_arena_set_allocated_isatlocation(::cfg::AiIsAtLocation* isatlocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (isatlocation) {
    set_has_isatlocation();
    _impl_.value_.isatlocation_ = isatlocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiDecorator.IsAtLocation)
}
inline ::cfg::AiIsAtLocation* AiDecorator::_internal_mutable_isatlocation() {
  if (value_case() != kIsAtLocation) {
    clear_value();
    set_has_isatlocation();
    _impl_.value_.isatlocation_ =
        CreateMaybeMessage<::cfg::AiIsAtLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.isatlocation_;
}
inline ::cfg::AiIsAtLocation* AiDecorator::mutable_isatlocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiIsAtLocation* _msg = _internal_mutable_isatlocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiDecorator.IsAtLocation)
  return _msg;
}

// .cfg.AiDistanceLessThan DistanceLessThan = 13;
inline bool AiDecorator::has_distancelessthan() const {
  return value_case() == kDistanceLessThan;
}
inline bool AiDecorator::_internal_has_distancelessthan() const {
  return value_case() == kDistanceLessThan;
}
inline void AiDecorator::set_has_distancelessthan() {
  _impl_._oneof_case_[0] = kDistanceLessThan;
}
inline void AiDecorator::clear_distancelessthan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDistanceLessThan) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.distancelessthan_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiDistanceLessThan* AiDecorator::release_distancelessthan() {
  // @@protoc_insertion_point(field_release:cfg.AiDecorator.DistanceLessThan)
  if (value_case() == kDistanceLessThan) {
    clear_has_value();
    ::cfg::AiDistanceLessThan* temp = _impl_.value_.distancelessthan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.distancelessthan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiDistanceLessThan& AiDecorator::_internal_distancelessthan() const {
  return value_case() == kDistanceLessThan ? *_impl_.value_.distancelessthan_ : reinterpret_cast<::cfg::AiDistanceLessThan&>(::cfg::_AiDistanceLessThan_default_instance_);
}
inline const ::cfg::AiDistanceLessThan& AiDecorator::distancelessthan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDecorator.DistanceLessThan)
  return _internal_distancelessthan();
}
inline ::cfg::AiDistanceLessThan* AiDecorator::unsafe_arena_release_distancelessthan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiDecorator.DistanceLessThan)
  if (value_case() == kDistanceLessThan) {
    clear_has_value();
    ::cfg::AiDistanceLessThan* temp = _impl_.value_.distancelessthan_;
    _impl_.value_.distancelessthan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiDecorator::unsafe_arena_set_allocated_distancelessthan(::cfg::AiDistanceLessThan* distancelessthan) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (distancelessthan) {
    set_has_distancelessthan();
    _impl_.value_.distancelessthan_ = distancelessthan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiDecorator.DistanceLessThan)
}
inline ::cfg::AiDistanceLessThan* AiDecorator::_internal_mutable_distancelessthan() {
  if (value_case() != kDistanceLessThan) {
    clear_value();
    set_has_distancelessthan();
    _impl_.value_.distancelessthan_ =
        CreateMaybeMessage<::cfg::AiDistanceLessThan>(GetArenaForAllocation());
  }
  return _impl_.value_.distancelessthan_;
}
inline ::cfg::AiDistanceLessThan* AiDecorator::mutable_distancelessthan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiDistanceLessThan* _msg = _internal_mutable_distancelessthan();
  // @@protoc_insertion_point(field_mutable:cfg.AiDecorator.DistanceLessThan)
  return _msg;
}

inline bool AiDecorator::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiDecorator::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiDecorator::ValueCase AiDecorator::value_case() const {
  return AiDecorator::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiUeLoop

// int32 id = 1;
inline void AiUeLoop::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeLoop::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeLoop.id)
  return _internal_id();
}
inline void AiUeLoop::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeLoop.id)
}
inline ::int32_t AiUeLoop::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeLoop::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeLoop::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeLoop::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeLoop.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeLoop::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeLoop.node_name)
}
inline std::string* AiUeLoop::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeLoop.node_name)
  return _s;
}
inline const std::string& AiUeLoop::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeLoop::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeLoop::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeLoop::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeLoop.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeLoop::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeLoop.node_name)
}

// .cfg.AiEFlowAbortMode flow_abort_mode = 3;
inline void AiUeLoop::clear_flow_abort_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flow_abort_mode_ = 0;
}
inline ::cfg::AiEFlowAbortMode AiUeLoop::flow_abort_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeLoop.flow_abort_mode)
  return _internal_flow_abort_mode();
}
inline void AiUeLoop::set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  _internal_set_flow_abort_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeLoop.flow_abort_mode)
}
inline ::cfg::AiEFlowAbortMode AiUeLoop::_internal_flow_abort_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFlowAbortMode>(_impl_.flow_abort_mode_);
}
inline void AiUeLoop::_internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_abort_mode_ = value;
}

// int32 num_loops = 4;
inline void AiUeLoop::clear_num_loops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_loops_ = 0;
}
inline ::int32_t AiUeLoop::num_loops() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeLoop.num_loops)
  return _internal_num_loops();
}
inline void AiUeLoop::set_num_loops(::int32_t value) {
  _internal_set_num_loops(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeLoop.num_loops)
}
inline ::int32_t AiUeLoop::_internal_num_loops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_loops_;
}
inline void AiUeLoop::_internal_set_num_loops(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_loops_ = value;
}

// bool infinite_loop = 5;
inline void AiUeLoop::clear_infinite_loop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.infinite_loop_ = false;
}
inline bool AiUeLoop::infinite_loop() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeLoop.infinite_loop)
  return _internal_infinite_loop();
}
inline void AiUeLoop::set_infinite_loop(bool value) {
  _internal_set_infinite_loop(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeLoop.infinite_loop)
}
inline bool AiUeLoop::_internal_infinite_loop() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infinite_loop_;
}
inline void AiUeLoop::_internal_set_infinite_loop(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.infinite_loop_ = value;
}

// float infinite_loop_timeout_time = 6;
inline void AiUeLoop::clear_infinite_loop_timeout_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.infinite_loop_timeout_time_ = 0;
}
inline float AiUeLoop::infinite_loop_timeout_time() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeLoop.infinite_loop_timeout_time)
  return _internal_infinite_loop_timeout_time();
}
inline void AiUeLoop::set_infinite_loop_timeout_time(float value) {
  _internal_set_infinite_loop_timeout_time(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeLoop.infinite_loop_timeout_time)
}
inline float AiUeLoop::_internal_infinite_loop_timeout_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infinite_loop_timeout_time_;
}
inline void AiUeLoop::_internal_set_infinite_loop_timeout_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.infinite_loop_timeout_time_ = value;
}

// -------------------------------------------------------------------

// AiUeCooldown

// int32 id = 1;
inline void AiUeCooldown::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeCooldown::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeCooldown.id)
  return _internal_id();
}
inline void AiUeCooldown::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeCooldown.id)
}
inline ::int32_t AiUeCooldown::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeCooldown::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeCooldown::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeCooldown::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeCooldown.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeCooldown::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeCooldown.node_name)
}
inline std::string* AiUeCooldown::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeCooldown.node_name)
  return _s;
}
inline const std::string& AiUeCooldown::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeCooldown::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeCooldown::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeCooldown::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeCooldown.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeCooldown::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeCooldown.node_name)
}

// .cfg.AiEFlowAbortMode flow_abort_mode = 3;
inline void AiUeCooldown::clear_flow_abort_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flow_abort_mode_ = 0;
}
inline ::cfg::AiEFlowAbortMode AiUeCooldown::flow_abort_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeCooldown.flow_abort_mode)
  return _internal_flow_abort_mode();
}
inline void AiUeCooldown::set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  _internal_set_flow_abort_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeCooldown.flow_abort_mode)
}
inline ::cfg::AiEFlowAbortMode AiUeCooldown::_internal_flow_abort_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFlowAbortMode>(_impl_.flow_abort_mode_);
}
inline void AiUeCooldown::_internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_abort_mode_ = value;
}

// float cooldown_time = 4;
inline void AiUeCooldown::clear_cooldown_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cooldown_time_ = 0;
}
inline float AiUeCooldown::cooldown_time() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeCooldown.cooldown_time)
  return _internal_cooldown_time();
}
inline void AiUeCooldown::set_cooldown_time(float value) {
  _internal_set_cooldown_time(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeCooldown.cooldown_time)
}
inline float AiUeCooldown::_internal_cooldown_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cooldown_time_;
}
inline void AiUeCooldown::_internal_set_cooldown_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cooldown_time_ = value;
}

// -------------------------------------------------------------------

// AiUeTimeLimit

// int32 id = 1;
inline void AiUeTimeLimit::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeTimeLimit::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeTimeLimit.id)
  return _internal_id();
}
inline void AiUeTimeLimit::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeTimeLimit.id)
}
inline ::int32_t AiUeTimeLimit::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeTimeLimit::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeTimeLimit::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeTimeLimit::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeTimeLimit.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeTimeLimit::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeTimeLimit.node_name)
}
inline std::string* AiUeTimeLimit::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeTimeLimit.node_name)
  return _s;
}
inline const std::string& AiUeTimeLimit::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeTimeLimit::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeTimeLimit::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeTimeLimit::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeTimeLimit.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeTimeLimit::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeTimeLimit.node_name)
}

// .cfg.AiEFlowAbortMode flow_abort_mode = 3;
inline void AiUeTimeLimit::clear_flow_abort_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flow_abort_mode_ = 0;
}
inline ::cfg::AiEFlowAbortMode AiUeTimeLimit::flow_abort_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeTimeLimit.flow_abort_mode)
  return _internal_flow_abort_mode();
}
inline void AiUeTimeLimit::set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  _internal_set_flow_abort_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeTimeLimit.flow_abort_mode)
}
inline ::cfg::AiEFlowAbortMode AiUeTimeLimit::_internal_flow_abort_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFlowAbortMode>(_impl_.flow_abort_mode_);
}
inline void AiUeTimeLimit::_internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_abort_mode_ = value;
}

// float limit_time = 4;
inline void AiUeTimeLimit::clear_limit_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.limit_time_ = 0;
}
inline float AiUeTimeLimit::limit_time() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeTimeLimit.limit_time)
  return _internal_limit_time();
}
inline void AiUeTimeLimit::set_limit_time(float value) {
  _internal_set_limit_time(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeTimeLimit.limit_time)
}
inline float AiUeTimeLimit::_internal_limit_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_time_;
}
inline void AiUeTimeLimit::_internal_set_limit_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.limit_time_ = value;
}

// -------------------------------------------------------------------

// AiUeBlackboard

// int32 id = 1;
inline void AiUeBlackboard::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeBlackboard::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeBlackboard.id)
  return _internal_id();
}
inline void AiUeBlackboard::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeBlackboard.id)
}
inline ::int32_t AiUeBlackboard::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeBlackboard::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeBlackboard::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeBlackboard::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeBlackboard.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeBlackboard::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeBlackboard.node_name)
}
inline std::string* AiUeBlackboard::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeBlackboard.node_name)
  return _s;
}
inline const std::string& AiUeBlackboard::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeBlackboard::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeBlackboard::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeBlackboard::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeBlackboard.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeBlackboard::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeBlackboard.node_name)
}

// .cfg.AiEFlowAbortMode flow_abort_mode = 3;
inline void AiUeBlackboard::clear_flow_abort_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flow_abort_mode_ = 0;
}
inline ::cfg::AiEFlowAbortMode AiUeBlackboard::flow_abort_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeBlackboard.flow_abort_mode)
  return _internal_flow_abort_mode();
}
inline void AiUeBlackboard::set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  _internal_set_flow_abort_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeBlackboard.flow_abort_mode)
}
inline ::cfg::AiEFlowAbortMode AiUeBlackboard::_internal_flow_abort_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFlowAbortMode>(_impl_.flow_abort_mode_);
}
inline void AiUeBlackboard::_internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_abort_mode_ = value;
}

// .cfg.AiENotifyObserverMode notify_observer = 4;
inline void AiUeBlackboard::clear_notify_observer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notify_observer_ = 0;
}
inline ::cfg::AiENotifyObserverMode AiUeBlackboard::notify_observer() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeBlackboard.notify_observer)
  return _internal_notify_observer();
}
inline void AiUeBlackboard::set_notify_observer(::cfg::AiENotifyObserverMode value) {
  _internal_set_notify_observer(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeBlackboard.notify_observer)
}
inline ::cfg::AiENotifyObserverMode AiUeBlackboard::_internal_notify_observer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiENotifyObserverMode>(_impl_.notify_observer_);
}
inline void AiUeBlackboard::_internal_set_notify_observer(::cfg::AiENotifyObserverMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.notify_observer_ = value;
}

// string blackboard_key = 5;
inline void AiUeBlackboard::clear_blackboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blackboard_key_.ClearToEmpty();
}
inline const std::string& AiUeBlackboard::blackboard_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeBlackboard.blackboard_key)
  return _internal_blackboard_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeBlackboard::set_blackboard_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blackboard_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeBlackboard.blackboard_key)
}
inline std::string* AiUeBlackboard::mutable_blackboard_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_blackboard_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeBlackboard.blackboard_key)
  return _s;
}
inline const std::string& AiUeBlackboard::_internal_blackboard_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blackboard_key_.Get();
}
inline void AiUeBlackboard::_internal_set_blackboard_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeBlackboard::_internal_mutable_blackboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.blackboard_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeBlackboard::release_blackboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeBlackboard.blackboard_key)
  return _impl_.blackboard_key_.Release();
}
inline void AiUeBlackboard::set_allocated_blackboard_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blackboard_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.blackboard_key_.IsDefault()) {
          _impl_.blackboard_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeBlackboard.blackboard_key)
}

// .cfg.AiKeyQueryOperator key_query = 6;
inline bool AiUeBlackboard::has_key_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_query_ != nullptr);
  return value;
}
inline void AiUeBlackboard::clear_key_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.key_query_ != nullptr) _impl_.key_query_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::AiKeyQueryOperator& AiUeBlackboard::_internal_key_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::AiKeyQueryOperator* p = _impl_.key_query_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::AiKeyQueryOperator&>(::cfg::_AiKeyQueryOperator_default_instance_);
}
inline const ::cfg::AiKeyQueryOperator& AiUeBlackboard::key_query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeBlackboard.key_query)
  return _internal_key_query();
}
inline void AiUeBlackboard::unsafe_arena_set_allocated_key_query(::cfg::AiKeyQueryOperator* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_query_);
  }
  _impl_.key_query_ = reinterpret_cast<::cfg::AiKeyQueryOperator*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiUeBlackboard.key_query)
}
inline ::cfg::AiKeyQueryOperator* AiUeBlackboard::release_key_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiKeyQueryOperator* released = _impl_.key_query_;
  _impl_.key_query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::AiKeyQueryOperator* AiUeBlackboard::unsafe_arena_release_key_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeBlackboard.key_query)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiKeyQueryOperator* temp = _impl_.key_query_;
  _impl_.key_query_ = nullptr;
  return temp;
}
inline ::cfg::AiKeyQueryOperator* AiUeBlackboard::_internal_mutable_key_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_query_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::AiKeyQueryOperator>(GetArenaForAllocation());
    _impl_.key_query_ = reinterpret_cast<::cfg::AiKeyQueryOperator*>(p);
  }
  return _impl_.key_query_;
}
inline ::cfg::AiKeyQueryOperator* AiUeBlackboard::mutable_key_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiKeyQueryOperator* _msg = _internal_mutable_key_query();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeBlackboard.key_query)
  return _msg;
}
inline void AiUeBlackboard::set_allocated_key_query(::cfg::AiKeyQueryOperator* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::AiKeyQueryOperator*>(_impl_.key_query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::AiKeyQueryOperator*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_query_ = reinterpret_cast<::cfg::AiKeyQueryOperator*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeBlackboard.key_query)
}

// -------------------------------------------------------------------

// AiKeyQueryOperator

// .cfg.AiIsSet IsSet = 1;
inline bool AiKeyQueryOperator::has_isset() const {
  return value_case() == kIsSet;
}
inline bool AiKeyQueryOperator::_internal_has_isset() const {
  return value_case() == kIsSet;
}
inline void AiKeyQueryOperator::set_has_isset() {
  _impl_._oneof_case_[0] = kIsSet;
}
inline void AiKeyQueryOperator::clear_isset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kIsSet) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.isset_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiIsSet* AiKeyQueryOperator::release_isset() {
  // @@protoc_insertion_point(field_release:cfg.AiKeyQueryOperator.IsSet)
  if (value_case() == kIsSet) {
    clear_has_value();
    ::cfg::AiIsSet* temp = _impl_.value_.isset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.isset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiIsSet& AiKeyQueryOperator::_internal_isset() const {
  return value_case() == kIsSet ? *_impl_.value_.isset_ : reinterpret_cast<::cfg::AiIsSet&>(::cfg::_AiIsSet_default_instance_);
}
inline const ::cfg::AiIsSet& AiKeyQueryOperator::isset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeyQueryOperator.IsSet)
  return _internal_isset();
}
inline ::cfg::AiIsSet* AiKeyQueryOperator::unsafe_arena_release_isset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiKeyQueryOperator.IsSet)
  if (value_case() == kIsSet) {
    clear_has_value();
    ::cfg::AiIsSet* temp = _impl_.value_.isset_;
    _impl_.value_.isset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiKeyQueryOperator::unsafe_arena_set_allocated_isset(::cfg::AiIsSet* isset) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (isset) {
    set_has_isset();
    _impl_.value_.isset_ = isset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiKeyQueryOperator.IsSet)
}
inline ::cfg::AiIsSet* AiKeyQueryOperator::_internal_mutable_isset() {
  if (value_case() != kIsSet) {
    clear_value();
    set_has_isset();
    _impl_.value_.isset_ =
        CreateMaybeMessage<::cfg::AiIsSet>(GetArenaForAllocation());
  }
  return _impl_.value_.isset_;
}
inline ::cfg::AiIsSet* AiKeyQueryOperator::mutable_isset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiIsSet* _msg = _internal_mutable_isset();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeyQueryOperator.IsSet)
  return _msg;
}

// .cfg.AiIsNotSet IsNotSet = 2;
inline bool AiKeyQueryOperator::has_isnotset() const {
  return value_case() == kIsNotSet;
}
inline bool AiKeyQueryOperator::_internal_has_isnotset() const {
  return value_case() == kIsNotSet;
}
inline void AiKeyQueryOperator::set_has_isnotset() {
  _impl_._oneof_case_[0] = kIsNotSet;
}
inline void AiKeyQueryOperator::clear_isnotset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kIsNotSet) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.isnotset_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiIsNotSet* AiKeyQueryOperator::release_isnotset() {
  // @@protoc_insertion_point(field_release:cfg.AiKeyQueryOperator.IsNotSet)
  if (value_case() == kIsNotSet) {
    clear_has_value();
    ::cfg::AiIsNotSet* temp = _impl_.value_.isnotset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.isnotset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiIsNotSet& AiKeyQueryOperator::_internal_isnotset() const {
  return value_case() == kIsNotSet ? *_impl_.value_.isnotset_ : reinterpret_cast<::cfg::AiIsNotSet&>(::cfg::_AiIsNotSet_default_instance_);
}
inline const ::cfg::AiIsNotSet& AiKeyQueryOperator::isnotset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeyQueryOperator.IsNotSet)
  return _internal_isnotset();
}
inline ::cfg::AiIsNotSet* AiKeyQueryOperator::unsafe_arena_release_isnotset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiKeyQueryOperator.IsNotSet)
  if (value_case() == kIsNotSet) {
    clear_has_value();
    ::cfg::AiIsNotSet* temp = _impl_.value_.isnotset_;
    _impl_.value_.isnotset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiKeyQueryOperator::unsafe_arena_set_allocated_isnotset(::cfg::AiIsNotSet* isnotset) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (isnotset) {
    set_has_isnotset();
    _impl_.value_.isnotset_ = isnotset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiKeyQueryOperator.IsNotSet)
}
inline ::cfg::AiIsNotSet* AiKeyQueryOperator::_internal_mutable_isnotset() {
  if (value_case() != kIsNotSet) {
    clear_value();
    set_has_isnotset();
    _impl_.value_.isnotset_ =
        CreateMaybeMessage<::cfg::AiIsNotSet>(GetArenaForAllocation());
  }
  return _impl_.value_.isnotset_;
}
inline ::cfg::AiIsNotSet* AiKeyQueryOperator::mutable_isnotset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiIsNotSet* _msg = _internal_mutable_isnotset();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeyQueryOperator.IsNotSet)
  return _msg;
}

// .cfg.AiBinaryOperator BinaryOperator = 3;
inline bool AiKeyQueryOperator::has_binaryoperator() const {
  return value_case() == kBinaryOperator;
}
inline bool AiKeyQueryOperator::_internal_has_binaryoperator() const {
  return value_case() == kBinaryOperator;
}
inline void AiKeyQueryOperator::set_has_binaryoperator() {
  _impl_._oneof_case_[0] = kBinaryOperator;
}
inline void AiKeyQueryOperator::clear_binaryoperator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBinaryOperator) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.binaryoperator_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiBinaryOperator* AiKeyQueryOperator::release_binaryoperator() {
  // @@protoc_insertion_point(field_release:cfg.AiKeyQueryOperator.BinaryOperator)
  if (value_case() == kBinaryOperator) {
    clear_has_value();
    ::cfg::AiBinaryOperator* temp = _impl_.value_.binaryoperator_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.binaryoperator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiBinaryOperator& AiKeyQueryOperator::_internal_binaryoperator() const {
  return value_case() == kBinaryOperator ? *_impl_.value_.binaryoperator_ : reinterpret_cast<::cfg::AiBinaryOperator&>(::cfg::_AiBinaryOperator_default_instance_);
}
inline const ::cfg::AiBinaryOperator& AiKeyQueryOperator::binaryoperator() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeyQueryOperator.BinaryOperator)
  return _internal_binaryoperator();
}
inline ::cfg::AiBinaryOperator* AiKeyQueryOperator::unsafe_arena_release_binaryoperator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiKeyQueryOperator.BinaryOperator)
  if (value_case() == kBinaryOperator) {
    clear_has_value();
    ::cfg::AiBinaryOperator* temp = _impl_.value_.binaryoperator_;
    _impl_.value_.binaryoperator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiKeyQueryOperator::unsafe_arena_set_allocated_binaryoperator(::cfg::AiBinaryOperator* binaryoperator) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (binaryoperator) {
    set_has_binaryoperator();
    _impl_.value_.binaryoperator_ = binaryoperator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiKeyQueryOperator.BinaryOperator)
}
inline ::cfg::AiBinaryOperator* AiKeyQueryOperator::_internal_mutable_binaryoperator() {
  if (value_case() != kBinaryOperator) {
    clear_value();
    set_has_binaryoperator();
    _impl_.value_.binaryoperator_ =
        CreateMaybeMessage<::cfg::AiBinaryOperator>(GetArenaForAllocation());
  }
  return _impl_.value_.binaryoperator_;
}
inline ::cfg::AiBinaryOperator* AiKeyQueryOperator::mutable_binaryoperator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiBinaryOperator* _msg = _internal_mutable_binaryoperator();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeyQueryOperator.BinaryOperator)
  return _msg;
}

inline bool AiKeyQueryOperator::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiKeyQueryOperator::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiKeyQueryOperator::ValueCase AiKeyQueryOperator::value_case() const {
  return AiKeyQueryOperator::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiIsSet

// -------------------------------------------------------------------

// AiIsNotSet

// -------------------------------------------------------------------

// AiBinaryOperator

// .cfg.AiEOperator oper = 1;
inline void AiBinaryOperator::clear_oper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oper_ = 0;
}
inline ::cfg::AiEOperator AiBinaryOperator::oper() const {
  // @@protoc_insertion_point(field_get:cfg.AiBinaryOperator.oper)
  return _internal_oper();
}
inline void AiBinaryOperator::set_oper(::cfg::AiEOperator value) {
  _internal_set_oper(value);
  // @@protoc_insertion_point(field_set:cfg.AiBinaryOperator.oper)
}
inline ::cfg::AiEOperator AiBinaryOperator::_internal_oper() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEOperator>(_impl_.oper_);
}
inline void AiBinaryOperator::_internal_set_oper(::cfg::AiEOperator value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.oper_ = value;
}

// .cfg.AiKeyData data = 2;
inline bool AiBinaryOperator::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void AiBinaryOperator::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::AiKeyData& AiBinaryOperator::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::AiKeyData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::AiKeyData&>(::cfg::_AiKeyData_default_instance_);
}
inline const ::cfg::AiKeyData& AiBinaryOperator::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBinaryOperator.data)
  return _internal_data();
}
inline void AiBinaryOperator::unsafe_arena_set_allocated_data(::cfg::AiKeyData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::cfg::AiKeyData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiBinaryOperator.data)
}
inline ::cfg::AiKeyData* AiBinaryOperator::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiKeyData* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::AiKeyData* AiBinaryOperator::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBinaryOperator.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiKeyData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::cfg::AiKeyData* AiBinaryOperator::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::AiKeyData>(GetArenaForAllocation());
    _impl_.data_ = reinterpret_cast<::cfg::AiKeyData*>(p);
  }
  return _impl_.data_;
}
inline ::cfg::AiKeyData* AiBinaryOperator::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiKeyData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:cfg.AiBinaryOperator.data)
  return _msg;
}
inline void AiBinaryOperator::set_allocated_data(::cfg::AiKeyData* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::AiKeyData*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::AiKeyData*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::cfg::AiKeyData*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBinaryOperator.data)
}

// -------------------------------------------------------------------

// AiKeyData

// .cfg.AiFloatKeyData FloatKeyData = 1;
inline bool AiKeyData::has_floatkeydata() const {
  return value_case() == kFloatKeyData;
}
inline bool AiKeyData::_internal_has_floatkeydata() const {
  return value_case() == kFloatKeyData;
}
inline void AiKeyData::set_has_floatkeydata() {
  _impl_._oneof_case_[0] = kFloatKeyData;
}
inline void AiKeyData::clear_floatkeydata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFloatKeyData) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.floatkeydata_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiFloatKeyData* AiKeyData::release_floatkeydata() {
  // @@protoc_insertion_point(field_release:cfg.AiKeyData.FloatKeyData)
  if (value_case() == kFloatKeyData) {
    clear_has_value();
    ::cfg::AiFloatKeyData* temp = _impl_.value_.floatkeydata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.floatkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiFloatKeyData& AiKeyData::_internal_floatkeydata() const {
  return value_case() == kFloatKeyData ? *_impl_.value_.floatkeydata_ : reinterpret_cast<::cfg::AiFloatKeyData&>(::cfg::_AiFloatKeyData_default_instance_);
}
inline const ::cfg::AiFloatKeyData& AiKeyData::floatkeydata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeyData.FloatKeyData)
  return _internal_floatkeydata();
}
inline ::cfg::AiFloatKeyData* AiKeyData::unsafe_arena_release_floatkeydata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiKeyData.FloatKeyData)
  if (value_case() == kFloatKeyData) {
    clear_has_value();
    ::cfg::AiFloatKeyData* temp = _impl_.value_.floatkeydata_;
    _impl_.value_.floatkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiKeyData::unsafe_arena_set_allocated_floatkeydata(::cfg::AiFloatKeyData* floatkeydata) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (floatkeydata) {
    set_has_floatkeydata();
    _impl_.value_.floatkeydata_ = floatkeydata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiKeyData.FloatKeyData)
}
inline ::cfg::AiFloatKeyData* AiKeyData::_internal_mutable_floatkeydata() {
  if (value_case() != kFloatKeyData) {
    clear_value();
    set_has_floatkeydata();
    _impl_.value_.floatkeydata_ =
        CreateMaybeMessage<::cfg::AiFloatKeyData>(GetArenaForAllocation());
  }
  return _impl_.value_.floatkeydata_;
}
inline ::cfg::AiFloatKeyData* AiKeyData::mutable_floatkeydata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiFloatKeyData* _msg = _internal_mutable_floatkeydata();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeyData.FloatKeyData)
  return _msg;
}

// .cfg.AiIntKeyData IntKeyData = 2;
inline bool AiKeyData::has_intkeydata() const {
  return value_case() == kIntKeyData;
}
inline bool AiKeyData::_internal_has_intkeydata() const {
  return value_case() == kIntKeyData;
}
inline void AiKeyData::set_has_intkeydata() {
  _impl_._oneof_case_[0] = kIntKeyData;
}
inline void AiKeyData::clear_intkeydata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kIntKeyData) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.intkeydata_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiIntKeyData* AiKeyData::release_intkeydata() {
  // @@protoc_insertion_point(field_release:cfg.AiKeyData.IntKeyData)
  if (value_case() == kIntKeyData) {
    clear_has_value();
    ::cfg::AiIntKeyData* temp = _impl_.value_.intkeydata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.intkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiIntKeyData& AiKeyData::_internal_intkeydata() const {
  return value_case() == kIntKeyData ? *_impl_.value_.intkeydata_ : reinterpret_cast<::cfg::AiIntKeyData&>(::cfg::_AiIntKeyData_default_instance_);
}
inline const ::cfg::AiIntKeyData& AiKeyData::intkeydata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeyData.IntKeyData)
  return _internal_intkeydata();
}
inline ::cfg::AiIntKeyData* AiKeyData::unsafe_arena_release_intkeydata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiKeyData.IntKeyData)
  if (value_case() == kIntKeyData) {
    clear_has_value();
    ::cfg::AiIntKeyData* temp = _impl_.value_.intkeydata_;
    _impl_.value_.intkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiKeyData::unsafe_arena_set_allocated_intkeydata(::cfg::AiIntKeyData* intkeydata) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (intkeydata) {
    set_has_intkeydata();
    _impl_.value_.intkeydata_ = intkeydata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiKeyData.IntKeyData)
}
inline ::cfg::AiIntKeyData* AiKeyData::_internal_mutable_intkeydata() {
  if (value_case() != kIntKeyData) {
    clear_value();
    set_has_intkeydata();
    _impl_.value_.intkeydata_ =
        CreateMaybeMessage<::cfg::AiIntKeyData>(GetArenaForAllocation());
  }
  return _impl_.value_.intkeydata_;
}
inline ::cfg::AiIntKeyData* AiKeyData::mutable_intkeydata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiIntKeyData* _msg = _internal_mutable_intkeydata();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeyData.IntKeyData)
  return _msg;
}

// .cfg.AiStringKeyData StringKeyData = 3;
inline bool AiKeyData::has_stringkeydata() const {
  return value_case() == kStringKeyData;
}
inline bool AiKeyData::_internal_has_stringkeydata() const {
  return value_case() == kStringKeyData;
}
inline void AiKeyData::set_has_stringkeydata() {
  _impl_._oneof_case_[0] = kStringKeyData;
}
inline void AiKeyData::clear_stringkeydata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kStringKeyData) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.stringkeydata_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiStringKeyData* AiKeyData::release_stringkeydata() {
  // @@protoc_insertion_point(field_release:cfg.AiKeyData.StringKeyData)
  if (value_case() == kStringKeyData) {
    clear_has_value();
    ::cfg::AiStringKeyData* temp = _impl_.value_.stringkeydata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.stringkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiStringKeyData& AiKeyData::_internal_stringkeydata() const {
  return value_case() == kStringKeyData ? *_impl_.value_.stringkeydata_ : reinterpret_cast<::cfg::AiStringKeyData&>(::cfg::_AiStringKeyData_default_instance_);
}
inline const ::cfg::AiStringKeyData& AiKeyData::stringkeydata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeyData.StringKeyData)
  return _internal_stringkeydata();
}
inline ::cfg::AiStringKeyData* AiKeyData::unsafe_arena_release_stringkeydata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiKeyData.StringKeyData)
  if (value_case() == kStringKeyData) {
    clear_has_value();
    ::cfg::AiStringKeyData* temp = _impl_.value_.stringkeydata_;
    _impl_.value_.stringkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiKeyData::unsafe_arena_set_allocated_stringkeydata(::cfg::AiStringKeyData* stringkeydata) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (stringkeydata) {
    set_has_stringkeydata();
    _impl_.value_.stringkeydata_ = stringkeydata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiKeyData.StringKeyData)
}
inline ::cfg::AiStringKeyData* AiKeyData::_internal_mutable_stringkeydata() {
  if (value_case() != kStringKeyData) {
    clear_value();
    set_has_stringkeydata();
    _impl_.value_.stringkeydata_ =
        CreateMaybeMessage<::cfg::AiStringKeyData>(GetArenaForAllocation());
  }
  return _impl_.value_.stringkeydata_;
}
inline ::cfg::AiStringKeyData* AiKeyData::mutable_stringkeydata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiStringKeyData* _msg = _internal_mutable_stringkeydata();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeyData.StringKeyData)
  return _msg;
}

// .cfg.AiBlackboardKeyData BlackboardKeyData = 4;
inline bool AiKeyData::has_blackboardkeydata() const {
  return value_case() == kBlackboardKeyData;
}
inline bool AiKeyData::_internal_has_blackboardkeydata() const {
  return value_case() == kBlackboardKeyData;
}
inline void AiKeyData::set_has_blackboardkeydata() {
  _impl_._oneof_case_[0] = kBlackboardKeyData;
}
inline void AiKeyData::clear_blackboardkeydata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBlackboardKeyData) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.blackboardkeydata_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiBlackboardKeyData* AiKeyData::release_blackboardkeydata() {
  // @@protoc_insertion_point(field_release:cfg.AiKeyData.BlackboardKeyData)
  if (value_case() == kBlackboardKeyData) {
    clear_has_value();
    ::cfg::AiBlackboardKeyData* temp = _impl_.value_.blackboardkeydata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.blackboardkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiBlackboardKeyData& AiKeyData::_internal_blackboardkeydata() const {
  return value_case() == kBlackboardKeyData ? *_impl_.value_.blackboardkeydata_ : reinterpret_cast<::cfg::AiBlackboardKeyData&>(::cfg::_AiBlackboardKeyData_default_instance_);
}
inline const ::cfg::AiBlackboardKeyData& AiKeyData::blackboardkeydata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiKeyData.BlackboardKeyData)
  return _internal_blackboardkeydata();
}
inline ::cfg::AiBlackboardKeyData* AiKeyData::unsafe_arena_release_blackboardkeydata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiKeyData.BlackboardKeyData)
  if (value_case() == kBlackboardKeyData) {
    clear_has_value();
    ::cfg::AiBlackboardKeyData* temp = _impl_.value_.blackboardkeydata_;
    _impl_.value_.blackboardkeydata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiKeyData::unsafe_arena_set_allocated_blackboardkeydata(::cfg::AiBlackboardKeyData* blackboardkeydata) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (blackboardkeydata) {
    set_has_blackboardkeydata();
    _impl_.value_.blackboardkeydata_ = blackboardkeydata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiKeyData.BlackboardKeyData)
}
inline ::cfg::AiBlackboardKeyData* AiKeyData::_internal_mutable_blackboardkeydata() {
  if (value_case() != kBlackboardKeyData) {
    clear_value();
    set_has_blackboardkeydata();
    _impl_.value_.blackboardkeydata_ =
        CreateMaybeMessage<::cfg::AiBlackboardKeyData>(GetArenaForAllocation());
  }
  return _impl_.value_.blackboardkeydata_;
}
inline ::cfg::AiBlackboardKeyData* AiKeyData::mutable_blackboardkeydata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiBlackboardKeyData* _msg = _internal_mutable_blackboardkeydata();
  // @@protoc_insertion_point(field_mutable:cfg.AiKeyData.BlackboardKeyData)
  return _msg;
}

inline bool AiKeyData::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiKeyData::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiKeyData::ValueCase AiKeyData::value_case() const {
  return AiKeyData::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiFloatKeyData

// float value = 1;
inline void AiFloatKeyData::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline float AiFloatKeyData::value() const {
  // @@protoc_insertion_point(field_get:cfg.AiFloatKeyData.value)
  return _internal_value();
}
inline void AiFloatKeyData::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cfg.AiFloatKeyData.value)
}
inline float AiFloatKeyData::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void AiFloatKeyData::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// AiIntKeyData

// int32 value = 1;
inline void AiIntKeyData::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t AiIntKeyData::value() const {
  // @@protoc_insertion_point(field_get:cfg.AiIntKeyData.value)
  return _internal_value();
}
inline void AiIntKeyData::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cfg.AiIntKeyData.value)
}
inline ::int32_t AiIntKeyData::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void AiIntKeyData::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// AiStringKeyData

// string value = 1;
inline void AiStringKeyData::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& AiStringKeyData::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiStringKeyData.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiStringKeyData::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiStringKeyData.value)
}
inline std::string* AiStringKeyData::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cfg.AiStringKeyData.value)
  return _s;
}
inline const std::string& AiStringKeyData::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void AiStringKeyData::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* AiStringKeyData::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* AiStringKeyData::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiStringKeyData.value)
  return _impl_.value_.Release();
}
inline void AiStringKeyData::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiStringKeyData.value)
}

// -------------------------------------------------------------------

// AiBlackboardKeyData

// string value = 1;
inline void AiBlackboardKeyData::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& AiBlackboardKeyData::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiBlackboardKeyData.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiBlackboardKeyData::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiBlackboardKeyData.value)
}
inline std::string* AiBlackboardKeyData::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cfg.AiBlackboardKeyData.value)
  return _s;
}
inline const std::string& AiBlackboardKeyData::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void AiBlackboardKeyData::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* AiBlackboardKeyData::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* AiBlackboardKeyData::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiBlackboardKeyData.value)
  return _impl_.value_.Release();
}
inline void AiBlackboardKeyData::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiBlackboardKeyData.value)
}

// -------------------------------------------------------------------

// AiUeForceSuccess

// int32 id = 1;
inline void AiUeForceSuccess::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeForceSuccess::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeForceSuccess.id)
  return _internal_id();
}
inline void AiUeForceSuccess::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeForceSuccess.id)
}
inline ::int32_t AiUeForceSuccess::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeForceSuccess::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeForceSuccess::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeForceSuccess::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeForceSuccess.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeForceSuccess::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeForceSuccess.node_name)
}
inline std::string* AiUeForceSuccess::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeForceSuccess.node_name)
  return _s;
}
inline const std::string& AiUeForceSuccess::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeForceSuccess::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeForceSuccess::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeForceSuccess::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeForceSuccess.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeForceSuccess::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeForceSuccess.node_name)
}

// .cfg.AiEFlowAbortMode flow_abort_mode = 3;
inline void AiUeForceSuccess::clear_flow_abort_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flow_abort_mode_ = 0;
}
inline ::cfg::AiEFlowAbortMode AiUeForceSuccess::flow_abort_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeForceSuccess.flow_abort_mode)
  return _internal_flow_abort_mode();
}
inline void AiUeForceSuccess::set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  _internal_set_flow_abort_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeForceSuccess.flow_abort_mode)
}
inline ::cfg::AiEFlowAbortMode AiUeForceSuccess::_internal_flow_abort_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFlowAbortMode>(_impl_.flow_abort_mode_);
}
inline void AiUeForceSuccess::_internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_abort_mode_ = value;
}

// -------------------------------------------------------------------

// AiIsAtLocation

// int32 id = 1;
inline void AiIsAtLocation::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiIsAtLocation::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiIsAtLocation.id)
  return _internal_id();
}
inline void AiIsAtLocation::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiIsAtLocation.id)
}
inline ::int32_t AiIsAtLocation::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiIsAtLocation::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiIsAtLocation::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiIsAtLocation::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiIsAtLocation.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiIsAtLocation::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiIsAtLocation.node_name)
}
inline std::string* AiIsAtLocation::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiIsAtLocation.node_name)
  return _s;
}
inline const std::string& AiIsAtLocation::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiIsAtLocation::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiIsAtLocation::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiIsAtLocation::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiIsAtLocation.node_name)
  return _impl_.node_name_.Release();
}
inline void AiIsAtLocation::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiIsAtLocation.node_name)
}

// .cfg.AiEFlowAbortMode flow_abort_mode = 3;
inline void AiIsAtLocation::clear_flow_abort_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flow_abort_mode_ = 0;
}
inline ::cfg::AiEFlowAbortMode AiIsAtLocation::flow_abort_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiIsAtLocation.flow_abort_mode)
  return _internal_flow_abort_mode();
}
inline void AiIsAtLocation::set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  _internal_set_flow_abort_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiIsAtLocation.flow_abort_mode)
}
inline ::cfg::AiEFlowAbortMode AiIsAtLocation::_internal_flow_abort_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFlowAbortMode>(_impl_.flow_abort_mode_);
}
inline void AiIsAtLocation::_internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_abort_mode_ = value;
}

// float acceptable_radius = 4;
inline void AiIsAtLocation::clear_acceptable_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptable_radius_ = 0;
}
inline float AiIsAtLocation::acceptable_radius() const {
  // @@protoc_insertion_point(field_get:cfg.AiIsAtLocation.acceptable_radius)
  return _internal_acceptable_radius();
}
inline void AiIsAtLocation::set_acceptable_radius(float value) {
  _internal_set_acceptable_radius(value);
  // @@protoc_insertion_point(field_set:cfg.AiIsAtLocation.acceptable_radius)
}
inline float AiIsAtLocation::_internal_acceptable_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceptable_radius_;
}
inline void AiIsAtLocation::_internal_set_acceptable_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptable_radius_ = value;
}

// string keyboard_key = 5;
inline void AiIsAtLocation::clear_keyboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keyboard_key_.ClearToEmpty();
}
inline const std::string& AiIsAtLocation::keyboard_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiIsAtLocation.keyboard_key)
  return _internal_keyboard_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiIsAtLocation::set_keyboard_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keyboard_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiIsAtLocation.keyboard_key)
}
inline std::string* AiIsAtLocation::mutable_keyboard_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_keyboard_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiIsAtLocation.keyboard_key)
  return _s;
}
inline const std::string& AiIsAtLocation::_internal_keyboard_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keyboard_key_.Get();
}
inline void AiIsAtLocation::_internal_set_keyboard_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keyboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiIsAtLocation::_internal_mutable_keyboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.keyboard_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiIsAtLocation::release_keyboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiIsAtLocation.keyboard_key)
  return _impl_.keyboard_key_.Release();
}
inline void AiIsAtLocation::set_allocated_keyboard_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keyboard_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.keyboard_key_.IsDefault()) {
          _impl_.keyboard_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiIsAtLocation.keyboard_key)
}

// bool inverse_condition = 6;
inline void AiIsAtLocation::clear_inverse_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inverse_condition_ = false;
}
inline bool AiIsAtLocation::inverse_condition() const {
  // @@protoc_insertion_point(field_get:cfg.AiIsAtLocation.inverse_condition)
  return _internal_inverse_condition();
}
inline void AiIsAtLocation::set_inverse_condition(bool value) {
  _internal_set_inverse_condition(value);
  // @@protoc_insertion_point(field_set:cfg.AiIsAtLocation.inverse_condition)
}
inline bool AiIsAtLocation::_internal_inverse_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inverse_condition_;
}
inline void AiIsAtLocation::_internal_set_inverse_condition(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inverse_condition_ = value;
}

// -------------------------------------------------------------------

// AiDistanceLessThan

// int32 id = 1;
inline void AiDistanceLessThan::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiDistanceLessThan::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiDistanceLessThan.id)
  return _internal_id();
}
inline void AiDistanceLessThan::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiDistanceLessThan.id)
}
inline ::int32_t AiDistanceLessThan::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiDistanceLessThan::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiDistanceLessThan::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiDistanceLessThan::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDistanceLessThan.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiDistanceLessThan::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiDistanceLessThan.node_name)
}
inline std::string* AiDistanceLessThan::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiDistanceLessThan.node_name)
  return _s;
}
inline const std::string& AiDistanceLessThan::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiDistanceLessThan::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiDistanceLessThan::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiDistanceLessThan::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiDistanceLessThan.node_name)
  return _impl_.node_name_.Release();
}
inline void AiDistanceLessThan::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiDistanceLessThan.node_name)
}

// .cfg.AiEFlowAbortMode flow_abort_mode = 3;
inline void AiDistanceLessThan::clear_flow_abort_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flow_abort_mode_ = 0;
}
inline ::cfg::AiEFlowAbortMode AiDistanceLessThan::flow_abort_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiDistanceLessThan.flow_abort_mode)
  return _internal_flow_abort_mode();
}
inline void AiDistanceLessThan::set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  _internal_set_flow_abort_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiDistanceLessThan.flow_abort_mode)
}
inline ::cfg::AiEFlowAbortMode AiDistanceLessThan::_internal_flow_abort_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFlowAbortMode>(_impl_.flow_abort_mode_);
}
inline void AiDistanceLessThan::_internal_set_flow_abort_mode(::cfg::AiEFlowAbortMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_abort_mode_ = value;
}

// string actor1_key = 4;
inline void AiDistanceLessThan::clear_actor1_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actor1_key_.ClearToEmpty();
}
inline const std::string& AiDistanceLessThan::actor1_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDistanceLessThan.actor1_key)
  return _internal_actor1_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiDistanceLessThan::set_actor1_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.actor1_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiDistanceLessThan.actor1_key)
}
inline std::string* AiDistanceLessThan::mutable_actor1_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_actor1_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiDistanceLessThan.actor1_key)
  return _s;
}
inline const std::string& AiDistanceLessThan::_internal_actor1_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actor1_key_.Get();
}
inline void AiDistanceLessThan::_internal_set_actor1_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.actor1_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiDistanceLessThan::_internal_mutable_actor1_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.actor1_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiDistanceLessThan::release_actor1_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiDistanceLessThan.actor1_key)
  return _impl_.actor1_key_.Release();
}
inline void AiDistanceLessThan::set_allocated_actor1_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actor1_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.actor1_key_.IsDefault()) {
          _impl_.actor1_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiDistanceLessThan.actor1_key)
}

// string actor2_key = 5;
inline void AiDistanceLessThan::clear_actor2_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actor2_key_.ClearToEmpty();
}
inline const std::string& AiDistanceLessThan::actor2_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDistanceLessThan.actor2_key)
  return _internal_actor2_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiDistanceLessThan::set_actor2_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.actor2_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiDistanceLessThan.actor2_key)
}
inline std::string* AiDistanceLessThan::mutable_actor2_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_actor2_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiDistanceLessThan.actor2_key)
  return _s;
}
inline const std::string& AiDistanceLessThan::_internal_actor2_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actor2_key_.Get();
}
inline void AiDistanceLessThan::_internal_set_actor2_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.actor2_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiDistanceLessThan::_internal_mutable_actor2_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.actor2_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiDistanceLessThan::release_actor2_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiDistanceLessThan.actor2_key)
  return _impl_.actor2_key_.Release();
}
inline void AiDistanceLessThan::set_allocated_actor2_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actor2_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.actor2_key_.IsDefault()) {
          _impl_.actor2_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiDistanceLessThan.actor2_key)
}

// float distance = 6;
inline void AiDistanceLessThan::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_ = 0;
}
inline float AiDistanceLessThan::distance() const {
  // @@protoc_insertion_point(field_get:cfg.AiDistanceLessThan.distance)
  return _internal_distance();
}
inline void AiDistanceLessThan::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:cfg.AiDistanceLessThan.distance)
}
inline float AiDistanceLessThan::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void AiDistanceLessThan::_internal_set_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_ = value;
}

// bool reverse_result = 7;
inline void AiDistanceLessThan::clear_reverse_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reverse_result_ = false;
}
inline bool AiDistanceLessThan::reverse_result() const {
  // @@protoc_insertion_point(field_get:cfg.AiDistanceLessThan.reverse_result)
  return _internal_reverse_result();
}
inline void AiDistanceLessThan::set_reverse_result(bool value) {
  _internal_set_reverse_result(value);
  // @@protoc_insertion_point(field_set:cfg.AiDistanceLessThan.reverse_result)
}
inline bool AiDistanceLessThan::_internal_reverse_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reverse_result_;
}
inline void AiDistanceLessThan::_internal_set_reverse_result(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reverse_result_ = value;
}

// -------------------------------------------------------------------

// AiFlowNode

// .cfg.AiSequence Sequence = 14;
inline bool AiFlowNode::has_sequence() const {
  return value_case() == kSequence;
}
inline bool AiFlowNode::_internal_has_sequence() const {
  return value_case() == kSequence;
}
inline void AiFlowNode::set_has_sequence() {
  _impl_._oneof_case_[0] = kSequence;
}
inline void AiFlowNode::clear_sequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSequence) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sequence_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSequence* AiFlowNode::release_sequence() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.Sequence)
  if (value_case() == kSequence) {
    clear_has_value();
    ::cfg::AiSequence* temp = _impl_.value_.sequence_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSequence& AiFlowNode::_internal_sequence() const {
  return value_case() == kSequence ? *_impl_.value_.sequence_ : reinterpret_cast<::cfg::AiSequence&>(::cfg::_AiSequence_default_instance_);
}
inline const ::cfg::AiSequence& AiFlowNode::sequence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.Sequence)
  return _internal_sequence();
}
inline ::cfg::AiSequence* AiFlowNode::unsafe_arena_release_sequence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.Sequence)
  if (value_case() == kSequence) {
    clear_has_value();
    ::cfg::AiSequence* temp = _impl_.value_.sequence_;
    _impl_.value_.sequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_sequence(::cfg::AiSequence* sequence) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (sequence) {
    set_has_sequence();
    _impl_.value_.sequence_ = sequence;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.Sequence)
}
inline ::cfg::AiSequence* AiFlowNode::_internal_mutable_sequence() {
  if (value_case() != kSequence) {
    clear_value();
    set_has_sequence();
    _impl_.value_.sequence_ =
        CreateMaybeMessage<::cfg::AiSequence>(GetArenaForAllocation());
  }
  return _impl_.value_.sequence_;
}
inline ::cfg::AiSequence* AiFlowNode::mutable_sequence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSequence* _msg = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.Sequence)
  return _msg;
}

// .cfg.AiSelector Selector = 15;
inline bool AiFlowNode::has_selector() const {
  return value_case() == kSelector;
}
inline bool AiFlowNode::_internal_has_selector() const {
  return value_case() == kSelector;
}
inline void AiFlowNode::set_has_selector() {
  _impl_._oneof_case_[0] = kSelector;
}
inline void AiFlowNode::clear_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSelector) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.selector_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSelector* AiFlowNode::release_selector() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.Selector)
  if (value_case() == kSelector) {
    clear_has_value();
    ::cfg::AiSelector* temp = _impl_.value_.selector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSelector& AiFlowNode::_internal_selector() const {
  return value_case() == kSelector ? *_impl_.value_.selector_ : reinterpret_cast<::cfg::AiSelector&>(::cfg::_AiSelector_default_instance_);
}
inline const ::cfg::AiSelector& AiFlowNode::selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.Selector)
  return _internal_selector();
}
inline ::cfg::AiSelector* AiFlowNode::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.Selector)
  if (value_case() == kSelector) {
    clear_has_value();
    ::cfg::AiSelector* temp = _impl_.value_.selector_;
    _impl_.value_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_selector(::cfg::AiSelector* selector) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (selector) {
    set_has_selector();
    _impl_.value_.selector_ = selector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.Selector)
}
inline ::cfg::AiSelector* AiFlowNode::_internal_mutable_selector() {
  if (value_case() != kSelector) {
    clear_value();
    set_has_selector();
    _impl_.value_.selector_ =
        CreateMaybeMessage<::cfg::AiSelector>(GetArenaForAllocation());
  }
  return _impl_.value_.selector_;
}
inline ::cfg::AiSelector* AiFlowNode::mutable_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSelector* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.Selector)
  return _msg;
}

// .cfg.AiSimpleParallel SimpleParallel = 16;
inline bool AiFlowNode::has_simpleparallel() const {
  return value_case() == kSimpleParallel;
}
inline bool AiFlowNode::_internal_has_simpleparallel() const {
  return value_case() == kSimpleParallel;
}
inline void AiFlowNode::set_has_simpleparallel() {
  _impl_._oneof_case_[0] = kSimpleParallel;
}
inline void AiFlowNode::clear_simpleparallel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSimpleParallel) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.simpleparallel_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSimpleParallel* AiFlowNode::release_simpleparallel() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.SimpleParallel)
  if (value_case() == kSimpleParallel) {
    clear_has_value();
    ::cfg::AiSimpleParallel* temp = _impl_.value_.simpleparallel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.simpleparallel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSimpleParallel& AiFlowNode::_internal_simpleparallel() const {
  return value_case() == kSimpleParallel ? *_impl_.value_.simpleparallel_ : reinterpret_cast<::cfg::AiSimpleParallel&>(::cfg::_AiSimpleParallel_default_instance_);
}
inline const ::cfg::AiSimpleParallel& AiFlowNode::simpleparallel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.SimpleParallel)
  return _internal_simpleparallel();
}
inline ::cfg::AiSimpleParallel* AiFlowNode::unsafe_arena_release_simpleparallel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.SimpleParallel)
  if (value_case() == kSimpleParallel) {
    clear_has_value();
    ::cfg::AiSimpleParallel* temp = _impl_.value_.simpleparallel_;
    _impl_.value_.simpleparallel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_simpleparallel(::cfg::AiSimpleParallel* simpleparallel) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (simpleparallel) {
    set_has_simpleparallel();
    _impl_.value_.simpleparallel_ = simpleparallel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.SimpleParallel)
}
inline ::cfg::AiSimpleParallel* AiFlowNode::_internal_mutable_simpleparallel() {
  if (value_case() != kSimpleParallel) {
    clear_value();
    set_has_simpleparallel();
    _impl_.value_.simpleparallel_ =
        CreateMaybeMessage<::cfg::AiSimpleParallel>(GetArenaForAllocation());
  }
  return _impl_.value_.simpleparallel_;
}
inline ::cfg::AiSimpleParallel* AiFlowNode::mutable_simpleparallel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSimpleParallel* _msg = _internal_mutable_simpleparallel();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.SimpleParallel)
  return _msg;
}

// .cfg.AiUeWait UeWait = 17;
inline bool AiFlowNode::has_uewait() const {
  return value_case() == kUeWait;
}
inline bool AiFlowNode::_internal_has_uewait() const {
  return value_case() == kUeWait;
}
inline void AiFlowNode::set_has_uewait() {
  _impl_._oneof_case_[0] = kUeWait;
}
inline void AiFlowNode::clear_uewait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeWait) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uewait_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeWait* AiFlowNode::release_uewait() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.UeWait)
  if (value_case() == kUeWait) {
    clear_has_value();
    ::cfg::AiUeWait* temp = _impl_.value_.uewait_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uewait_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeWait& AiFlowNode::_internal_uewait() const {
  return value_case() == kUeWait ? *_impl_.value_.uewait_ : reinterpret_cast<::cfg::AiUeWait&>(::cfg::_AiUeWait_default_instance_);
}
inline const ::cfg::AiUeWait& AiFlowNode::uewait() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.UeWait)
  return _internal_uewait();
}
inline ::cfg::AiUeWait* AiFlowNode::unsafe_arena_release_uewait() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.UeWait)
  if (value_case() == kUeWait) {
    clear_has_value();
    ::cfg::AiUeWait* temp = _impl_.value_.uewait_;
    _impl_.value_.uewait_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_uewait(::cfg::AiUeWait* uewait) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uewait) {
    set_has_uewait();
    _impl_.value_.uewait_ = uewait;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.UeWait)
}
inline ::cfg::AiUeWait* AiFlowNode::_internal_mutable_uewait() {
  if (value_case() != kUeWait) {
    clear_value();
    set_has_uewait();
    _impl_.value_.uewait_ =
        CreateMaybeMessage<::cfg::AiUeWait>(GetArenaForAllocation());
  }
  return _impl_.value_.uewait_;
}
inline ::cfg::AiUeWait* AiFlowNode::mutable_uewait() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeWait* _msg = _internal_mutable_uewait();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.UeWait)
  return _msg;
}

// .cfg.AiUeWaitBlackboardTime UeWaitBlackboardTime = 18;
inline bool AiFlowNode::has_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime;
}
inline bool AiFlowNode::_internal_has_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime;
}
inline void AiFlowNode::set_has_uewaitblackboardtime() {
  _impl_._oneof_case_[0] = kUeWaitBlackboardTime;
}
inline void AiFlowNode::clear_uewaitblackboardtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeWaitBlackboardTime) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uewaitblackboardtime_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeWaitBlackboardTime* AiFlowNode::release_uewaitblackboardtime() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.UeWaitBlackboardTime)
  if (value_case() == kUeWaitBlackboardTime) {
    clear_has_value();
    ::cfg::AiUeWaitBlackboardTime* temp = _impl_.value_.uewaitblackboardtime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uewaitblackboardtime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeWaitBlackboardTime& AiFlowNode::_internal_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime ? *_impl_.value_.uewaitblackboardtime_ : reinterpret_cast<::cfg::AiUeWaitBlackboardTime&>(::cfg::_AiUeWaitBlackboardTime_default_instance_);
}
inline const ::cfg::AiUeWaitBlackboardTime& AiFlowNode::uewaitblackboardtime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.UeWaitBlackboardTime)
  return _internal_uewaitblackboardtime();
}
inline ::cfg::AiUeWaitBlackboardTime* AiFlowNode::unsafe_arena_release_uewaitblackboardtime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.UeWaitBlackboardTime)
  if (value_case() == kUeWaitBlackboardTime) {
    clear_has_value();
    ::cfg::AiUeWaitBlackboardTime* temp = _impl_.value_.uewaitblackboardtime_;
    _impl_.value_.uewaitblackboardtime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* uewaitblackboardtime) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uewaitblackboardtime) {
    set_has_uewaitblackboardtime();
    _impl_.value_.uewaitblackboardtime_ = uewaitblackboardtime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.UeWaitBlackboardTime)
}
inline ::cfg::AiUeWaitBlackboardTime* AiFlowNode::_internal_mutable_uewaitblackboardtime() {
  if (value_case() != kUeWaitBlackboardTime) {
    clear_value();
    set_has_uewaitblackboardtime();
    _impl_.value_.uewaitblackboardtime_ =
        CreateMaybeMessage<::cfg::AiUeWaitBlackboardTime>(GetArenaForAllocation());
  }
  return _impl_.value_.uewaitblackboardtime_;
}
inline ::cfg::AiUeWaitBlackboardTime* AiFlowNode::mutable_uewaitblackboardtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeWaitBlackboardTime* _msg = _internal_mutable_uewaitblackboardtime();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.UeWaitBlackboardTime)
  return _msg;
}

// .cfg.AiMoveToTarget MoveToTarget = 19;
inline bool AiFlowNode::has_movetotarget() const {
  return value_case() == kMoveToTarget;
}
inline bool AiFlowNode::_internal_has_movetotarget() const {
  return value_case() == kMoveToTarget;
}
inline void AiFlowNode::set_has_movetotarget() {
  _impl_._oneof_case_[0] = kMoveToTarget;
}
inline void AiFlowNode::clear_movetotarget() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToTarget) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetotarget_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToTarget* AiFlowNode::release_movetotarget() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.MoveToTarget)
  if (value_case() == kMoveToTarget) {
    clear_has_value();
    ::cfg::AiMoveToTarget* temp = _impl_.value_.movetotarget_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetotarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToTarget& AiFlowNode::_internal_movetotarget() const {
  return value_case() == kMoveToTarget ? *_impl_.value_.movetotarget_ : reinterpret_cast<::cfg::AiMoveToTarget&>(::cfg::_AiMoveToTarget_default_instance_);
}
inline const ::cfg::AiMoveToTarget& AiFlowNode::movetotarget() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.MoveToTarget)
  return _internal_movetotarget();
}
inline ::cfg::AiMoveToTarget* AiFlowNode::unsafe_arena_release_movetotarget() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.MoveToTarget)
  if (value_case() == kMoveToTarget) {
    clear_has_value();
    ::cfg::AiMoveToTarget* temp = _impl_.value_.movetotarget_;
    _impl_.value_.movetotarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_movetotarget(::cfg::AiMoveToTarget* movetotarget) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetotarget) {
    set_has_movetotarget();
    _impl_.value_.movetotarget_ = movetotarget;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.MoveToTarget)
}
inline ::cfg::AiMoveToTarget* AiFlowNode::_internal_mutable_movetotarget() {
  if (value_case() != kMoveToTarget) {
    clear_value();
    set_has_movetotarget();
    _impl_.value_.movetotarget_ =
        CreateMaybeMessage<::cfg::AiMoveToTarget>(GetArenaForAllocation());
  }
  return _impl_.value_.movetotarget_;
}
inline ::cfg::AiMoveToTarget* AiFlowNode::mutable_movetotarget() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToTarget* _msg = _internal_mutable_movetotarget();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.MoveToTarget)
  return _msg;
}

// .cfg.AiChooseSkill ChooseSkill = 20;
inline bool AiFlowNode::has_chooseskill() const {
  return value_case() == kChooseSkill;
}
inline bool AiFlowNode::_internal_has_chooseskill() const {
  return value_case() == kChooseSkill;
}
inline void AiFlowNode::set_has_chooseskill() {
  _impl_._oneof_case_[0] = kChooseSkill;
}
inline void AiFlowNode::clear_chooseskill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kChooseSkill) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.chooseskill_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiChooseSkill* AiFlowNode::release_chooseskill() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.ChooseSkill)
  if (value_case() == kChooseSkill) {
    clear_has_value();
    ::cfg::AiChooseSkill* temp = _impl_.value_.chooseskill_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.chooseskill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiChooseSkill& AiFlowNode::_internal_chooseskill() const {
  return value_case() == kChooseSkill ? *_impl_.value_.chooseskill_ : reinterpret_cast<::cfg::AiChooseSkill&>(::cfg::_AiChooseSkill_default_instance_);
}
inline const ::cfg::AiChooseSkill& AiFlowNode::chooseskill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.ChooseSkill)
  return _internal_chooseskill();
}
inline ::cfg::AiChooseSkill* AiFlowNode::unsafe_arena_release_chooseskill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.ChooseSkill)
  if (value_case() == kChooseSkill) {
    clear_has_value();
    ::cfg::AiChooseSkill* temp = _impl_.value_.chooseskill_;
    _impl_.value_.chooseskill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_chooseskill(::cfg::AiChooseSkill* chooseskill) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (chooseskill) {
    set_has_chooseskill();
    _impl_.value_.chooseskill_ = chooseskill;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.ChooseSkill)
}
inline ::cfg::AiChooseSkill* AiFlowNode::_internal_mutable_chooseskill() {
  if (value_case() != kChooseSkill) {
    clear_value();
    set_has_chooseskill();
    _impl_.value_.chooseskill_ =
        CreateMaybeMessage<::cfg::AiChooseSkill>(GetArenaForAllocation());
  }
  return _impl_.value_.chooseskill_;
}
inline ::cfg::AiChooseSkill* AiFlowNode::mutable_chooseskill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiChooseSkill* _msg = _internal_mutable_chooseskill();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.ChooseSkill)
  return _msg;
}

// .cfg.AiMoveToRandomLocation MoveToRandomLocation = 21;
inline bool AiFlowNode::has_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation;
}
inline bool AiFlowNode::_internal_has_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation;
}
inline void AiFlowNode::set_has_movetorandomlocation() {
  _impl_._oneof_case_[0] = kMoveToRandomLocation;
}
inline void AiFlowNode::clear_movetorandomlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToRandomLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetorandomlocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToRandomLocation* AiFlowNode::release_movetorandomlocation() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.MoveToRandomLocation)
  if (value_case() == kMoveToRandomLocation) {
    clear_has_value();
    ::cfg::AiMoveToRandomLocation* temp = _impl_.value_.movetorandomlocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetorandomlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToRandomLocation& AiFlowNode::_internal_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation ? *_impl_.value_.movetorandomlocation_ : reinterpret_cast<::cfg::AiMoveToRandomLocation&>(::cfg::_AiMoveToRandomLocation_default_instance_);
}
inline const ::cfg::AiMoveToRandomLocation& AiFlowNode::movetorandomlocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.MoveToRandomLocation)
  return _internal_movetorandomlocation();
}
inline ::cfg::AiMoveToRandomLocation* AiFlowNode::unsafe_arena_release_movetorandomlocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.MoveToRandomLocation)
  if (value_case() == kMoveToRandomLocation) {
    clear_has_value();
    ::cfg::AiMoveToRandomLocation* temp = _impl_.value_.movetorandomlocation_;
    _impl_.value_.movetorandomlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* movetorandomlocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetorandomlocation) {
    set_has_movetorandomlocation();
    _impl_.value_.movetorandomlocation_ = movetorandomlocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.MoveToRandomLocation)
}
inline ::cfg::AiMoveToRandomLocation* AiFlowNode::_internal_mutable_movetorandomlocation() {
  if (value_case() != kMoveToRandomLocation) {
    clear_value();
    set_has_movetorandomlocation();
    _impl_.value_.movetorandomlocation_ =
        CreateMaybeMessage<::cfg::AiMoveToRandomLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.movetorandomlocation_;
}
inline ::cfg::AiMoveToRandomLocation* AiFlowNode::mutable_movetorandomlocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToRandomLocation* _msg = _internal_mutable_movetorandomlocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.MoveToRandomLocation)
  return _msg;
}

// .cfg.AiMoveToLocation MoveToLocation = 22;
inline bool AiFlowNode::has_movetolocation() const {
  return value_case() == kMoveToLocation;
}
inline bool AiFlowNode::_internal_has_movetolocation() const {
  return value_case() == kMoveToLocation;
}
inline void AiFlowNode::set_has_movetolocation() {
  _impl_._oneof_case_[0] = kMoveToLocation;
}
inline void AiFlowNode::clear_movetolocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetolocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToLocation* AiFlowNode::release_movetolocation() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.MoveToLocation)
  if (value_case() == kMoveToLocation) {
    clear_has_value();
    ::cfg::AiMoveToLocation* temp = _impl_.value_.movetolocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetolocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToLocation& AiFlowNode::_internal_movetolocation() const {
  return value_case() == kMoveToLocation ? *_impl_.value_.movetolocation_ : reinterpret_cast<::cfg::AiMoveToLocation&>(::cfg::_AiMoveToLocation_default_instance_);
}
inline const ::cfg::AiMoveToLocation& AiFlowNode::movetolocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.MoveToLocation)
  return _internal_movetolocation();
}
inline ::cfg::AiMoveToLocation* AiFlowNode::unsafe_arena_release_movetolocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.MoveToLocation)
  if (value_case() == kMoveToLocation) {
    clear_has_value();
    ::cfg::AiMoveToLocation* temp = _impl_.value_.movetolocation_;
    _impl_.value_.movetolocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_movetolocation(::cfg::AiMoveToLocation* movetolocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetolocation) {
    set_has_movetolocation();
    _impl_.value_.movetolocation_ = movetolocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.MoveToLocation)
}
inline ::cfg::AiMoveToLocation* AiFlowNode::_internal_mutable_movetolocation() {
  if (value_case() != kMoveToLocation) {
    clear_value();
    set_has_movetolocation();
    _impl_.value_.movetolocation_ =
        CreateMaybeMessage<::cfg::AiMoveToLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.movetolocation_;
}
inline ::cfg::AiMoveToLocation* AiFlowNode::mutable_movetolocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToLocation* _msg = _internal_mutable_movetolocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.MoveToLocation)
  return _msg;
}

// .cfg.AiDebugPrint DebugPrint = 23;
inline bool AiFlowNode::has_debugprint() const {
  return value_case() == kDebugPrint;
}
inline bool AiFlowNode::_internal_has_debugprint() const {
  return value_case() == kDebugPrint;
}
inline void AiFlowNode::set_has_debugprint() {
  _impl_._oneof_case_[0] = kDebugPrint;
}
inline void AiFlowNode::clear_debugprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDebugPrint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.debugprint_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiDebugPrint* AiFlowNode::release_debugprint() {
  // @@protoc_insertion_point(field_release:cfg.AiFlowNode.DebugPrint)
  if (value_case() == kDebugPrint) {
    clear_has_value();
    ::cfg::AiDebugPrint* temp = _impl_.value_.debugprint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.debugprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiDebugPrint& AiFlowNode::_internal_debugprint() const {
  return value_case() == kDebugPrint ? *_impl_.value_.debugprint_ : reinterpret_cast<::cfg::AiDebugPrint&>(::cfg::_AiDebugPrint_default_instance_);
}
inline const ::cfg::AiDebugPrint& AiFlowNode::debugprint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiFlowNode.DebugPrint)
  return _internal_debugprint();
}
inline ::cfg::AiDebugPrint* AiFlowNode::unsafe_arena_release_debugprint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiFlowNode.DebugPrint)
  if (value_case() == kDebugPrint) {
    clear_has_value();
    ::cfg::AiDebugPrint* temp = _impl_.value_.debugprint_;
    _impl_.value_.debugprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiFlowNode::unsafe_arena_set_allocated_debugprint(::cfg::AiDebugPrint* debugprint) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (debugprint) {
    set_has_debugprint();
    _impl_.value_.debugprint_ = debugprint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiFlowNode.DebugPrint)
}
inline ::cfg::AiDebugPrint* AiFlowNode::_internal_mutable_debugprint() {
  if (value_case() != kDebugPrint) {
    clear_value();
    set_has_debugprint();
    _impl_.value_.debugprint_ =
        CreateMaybeMessage<::cfg::AiDebugPrint>(GetArenaForAllocation());
  }
  return _impl_.value_.debugprint_;
}
inline ::cfg::AiDebugPrint* AiFlowNode::mutable_debugprint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiDebugPrint* _msg = _internal_mutable_debugprint();
  // @@protoc_insertion_point(field_mutable:cfg.AiFlowNode.DebugPrint)
  return _msg;
}

inline bool AiFlowNode::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiFlowNode::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiFlowNode::ValueCase AiFlowNode::value_case() const {
  return AiFlowNode::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiComposeNode

// .cfg.AiSequence Sequence = 14;
inline bool AiComposeNode::has_sequence() const {
  return value_case() == kSequence;
}
inline bool AiComposeNode::_internal_has_sequence() const {
  return value_case() == kSequence;
}
inline void AiComposeNode::set_has_sequence() {
  _impl_._oneof_case_[0] = kSequence;
}
inline void AiComposeNode::clear_sequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSequence) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sequence_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSequence* AiComposeNode::release_sequence() {
  // @@protoc_insertion_point(field_release:cfg.AiComposeNode.Sequence)
  if (value_case() == kSequence) {
    clear_has_value();
    ::cfg::AiSequence* temp = _impl_.value_.sequence_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSequence& AiComposeNode::_internal_sequence() const {
  return value_case() == kSequence ? *_impl_.value_.sequence_ : reinterpret_cast<::cfg::AiSequence&>(::cfg::_AiSequence_default_instance_);
}
inline const ::cfg::AiSequence& AiComposeNode::sequence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiComposeNode.Sequence)
  return _internal_sequence();
}
inline ::cfg::AiSequence* AiComposeNode::unsafe_arena_release_sequence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiComposeNode.Sequence)
  if (value_case() == kSequence) {
    clear_has_value();
    ::cfg::AiSequence* temp = _impl_.value_.sequence_;
    _impl_.value_.sequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiComposeNode::unsafe_arena_set_allocated_sequence(::cfg::AiSequence* sequence) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (sequence) {
    set_has_sequence();
    _impl_.value_.sequence_ = sequence;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiComposeNode.Sequence)
}
inline ::cfg::AiSequence* AiComposeNode::_internal_mutable_sequence() {
  if (value_case() != kSequence) {
    clear_value();
    set_has_sequence();
    _impl_.value_.sequence_ =
        CreateMaybeMessage<::cfg::AiSequence>(GetArenaForAllocation());
  }
  return _impl_.value_.sequence_;
}
inline ::cfg::AiSequence* AiComposeNode::mutable_sequence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSequence* _msg = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:cfg.AiComposeNode.Sequence)
  return _msg;
}

// .cfg.AiSelector Selector = 15;
inline bool AiComposeNode::has_selector() const {
  return value_case() == kSelector;
}
inline bool AiComposeNode::_internal_has_selector() const {
  return value_case() == kSelector;
}
inline void AiComposeNode::set_has_selector() {
  _impl_._oneof_case_[0] = kSelector;
}
inline void AiComposeNode::clear_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSelector) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.selector_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSelector* AiComposeNode::release_selector() {
  // @@protoc_insertion_point(field_release:cfg.AiComposeNode.Selector)
  if (value_case() == kSelector) {
    clear_has_value();
    ::cfg::AiSelector* temp = _impl_.value_.selector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSelector& AiComposeNode::_internal_selector() const {
  return value_case() == kSelector ? *_impl_.value_.selector_ : reinterpret_cast<::cfg::AiSelector&>(::cfg::_AiSelector_default_instance_);
}
inline const ::cfg::AiSelector& AiComposeNode::selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiComposeNode.Selector)
  return _internal_selector();
}
inline ::cfg::AiSelector* AiComposeNode::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiComposeNode.Selector)
  if (value_case() == kSelector) {
    clear_has_value();
    ::cfg::AiSelector* temp = _impl_.value_.selector_;
    _impl_.value_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiComposeNode::unsafe_arena_set_allocated_selector(::cfg::AiSelector* selector) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (selector) {
    set_has_selector();
    _impl_.value_.selector_ = selector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiComposeNode.Selector)
}
inline ::cfg::AiSelector* AiComposeNode::_internal_mutable_selector() {
  if (value_case() != kSelector) {
    clear_value();
    set_has_selector();
    _impl_.value_.selector_ =
        CreateMaybeMessage<::cfg::AiSelector>(GetArenaForAllocation());
  }
  return _impl_.value_.selector_;
}
inline ::cfg::AiSelector* AiComposeNode::mutable_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSelector* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:cfg.AiComposeNode.Selector)
  return _msg;
}

// .cfg.AiSimpleParallel SimpleParallel = 16;
inline bool AiComposeNode::has_simpleparallel() const {
  return value_case() == kSimpleParallel;
}
inline bool AiComposeNode::_internal_has_simpleparallel() const {
  return value_case() == kSimpleParallel;
}
inline void AiComposeNode::set_has_simpleparallel() {
  _impl_._oneof_case_[0] = kSimpleParallel;
}
inline void AiComposeNode::clear_simpleparallel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSimpleParallel) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.simpleparallel_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiSimpleParallel* AiComposeNode::release_simpleparallel() {
  // @@protoc_insertion_point(field_release:cfg.AiComposeNode.SimpleParallel)
  if (value_case() == kSimpleParallel) {
    clear_has_value();
    ::cfg::AiSimpleParallel* temp = _impl_.value_.simpleparallel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.simpleparallel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiSimpleParallel& AiComposeNode::_internal_simpleparallel() const {
  return value_case() == kSimpleParallel ? *_impl_.value_.simpleparallel_ : reinterpret_cast<::cfg::AiSimpleParallel&>(::cfg::_AiSimpleParallel_default_instance_);
}
inline const ::cfg::AiSimpleParallel& AiComposeNode::simpleparallel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiComposeNode.SimpleParallel)
  return _internal_simpleparallel();
}
inline ::cfg::AiSimpleParallel* AiComposeNode::unsafe_arena_release_simpleparallel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiComposeNode.SimpleParallel)
  if (value_case() == kSimpleParallel) {
    clear_has_value();
    ::cfg::AiSimpleParallel* temp = _impl_.value_.simpleparallel_;
    _impl_.value_.simpleparallel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiComposeNode::unsafe_arena_set_allocated_simpleparallel(::cfg::AiSimpleParallel* simpleparallel) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (simpleparallel) {
    set_has_simpleparallel();
    _impl_.value_.simpleparallel_ = simpleparallel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiComposeNode.SimpleParallel)
}
inline ::cfg::AiSimpleParallel* AiComposeNode::_internal_mutable_simpleparallel() {
  if (value_case() != kSimpleParallel) {
    clear_value();
    set_has_simpleparallel();
    _impl_.value_.simpleparallel_ =
        CreateMaybeMessage<::cfg::AiSimpleParallel>(GetArenaForAllocation());
  }
  return _impl_.value_.simpleparallel_;
}
inline ::cfg::AiSimpleParallel* AiComposeNode::mutable_simpleparallel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiSimpleParallel* _msg = _internal_mutable_simpleparallel();
  // @@protoc_insertion_point(field_mutable:cfg.AiComposeNode.SimpleParallel)
  return _msg;
}

inline bool AiComposeNode::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiComposeNode::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiComposeNode::ValueCase AiComposeNode::value_case() const {
  return AiComposeNode::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiSequence

// int32 id = 1;
inline void AiSequence::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiSequence::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiSequence.id)
  return _internal_id();
}
inline void AiSequence::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiSequence.id)
}
inline ::int32_t AiSequence::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiSequence::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiSequence::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiSequence::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSequence.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiSequence::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiSequence.node_name)
}
inline std::string* AiSequence::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiSequence.node_name)
  return _s;
}
inline const std::string& AiSequence::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiSequence::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiSequence::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiSequence::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiSequence.node_name)
  return _impl_.node_name_.Release();
}
inline void AiSequence::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiSequence.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiSequence::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiSequence::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiSequence::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiSequence::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSequence.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiSequence::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSequence.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiSequence::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSequence.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiSequence::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSequence.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiSequence::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSequence.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiSequence::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiSequence::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiSequence::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiSequence::services_size() const {
  return _internal_services_size();
}
inline void AiSequence::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiSequence::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSequence.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiSequence::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSequence.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiSequence::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSequence.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiSequence::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSequence.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiSequence::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSequence.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiSequence::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiSequence::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// repeated .cfg.AiFlowNode children = 5 [packed = false];
inline int AiSequence::_internal_children_size() const {
  return _internal_children().size();
}
inline int AiSequence::children_size() const {
  return _internal_children_size();
}
inline void AiSequence::clear_children() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.children_.Clear();
}
inline ::cfg::AiFlowNode* AiSequence::mutable_children(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSequence.children)
  return _internal_mutable_children()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>* AiSequence::mutable_children()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSequence.children)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_children();
}
inline const ::cfg::AiFlowNode& AiSequence::children(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSequence.children)
  return _internal_children().Get(index);
}
inline ::cfg::AiFlowNode* AiSequence::add_children() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiFlowNode* _add = _internal_mutable_children()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSequence.children)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>& AiSequence::children() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSequence.children)
  return _internal_children();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>&
AiSequence::_internal_children() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.children_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>*
AiSequence::_internal_mutable_children() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.children_;
}

// -------------------------------------------------------------------

// AiSelector

// int32 id = 1;
inline void AiSelector::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiSelector::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiSelector.id)
  return _internal_id();
}
inline void AiSelector::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiSelector.id)
}
inline ::int32_t AiSelector::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiSelector::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiSelector::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiSelector::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSelector.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiSelector::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiSelector.node_name)
}
inline std::string* AiSelector::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiSelector.node_name)
  return _s;
}
inline const std::string& AiSelector::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiSelector::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiSelector::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiSelector::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiSelector.node_name)
  return _impl_.node_name_.Release();
}
inline void AiSelector::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiSelector.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiSelector::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiSelector::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiSelector::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiSelector::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSelector.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiSelector::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSelector.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiSelector::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSelector.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiSelector::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSelector.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiSelector::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSelector.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiSelector::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiSelector::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiSelector::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiSelector::services_size() const {
  return _internal_services_size();
}
inline void AiSelector::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiSelector::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSelector.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiSelector::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSelector.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiSelector::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSelector.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiSelector::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSelector.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiSelector::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSelector.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiSelector::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiSelector::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// repeated .cfg.AiFlowNode children = 5 [packed = false];
inline int AiSelector::_internal_children_size() const {
  return _internal_children().size();
}
inline int AiSelector::children_size() const {
  return _internal_children_size();
}
inline void AiSelector::clear_children() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.children_.Clear();
}
inline ::cfg::AiFlowNode* AiSelector::mutable_children(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSelector.children)
  return _internal_mutable_children()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>* AiSelector::mutable_children()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSelector.children)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_children();
}
inline const ::cfg::AiFlowNode& AiSelector::children(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSelector.children)
  return _internal_children().Get(index);
}
inline ::cfg::AiFlowNode* AiSelector::add_children() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiFlowNode* _add = _internal_mutable_children()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSelector.children)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>& AiSelector::children() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSelector.children)
  return _internal_children();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>&
AiSelector::_internal_children() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.children_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiFlowNode>*
AiSelector::_internal_mutable_children() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.children_;
}

// -------------------------------------------------------------------

// AiSimpleParallel

// int32 id = 1;
inline void AiSimpleParallel::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiSimpleParallel::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiSimpleParallel.id)
  return _internal_id();
}
inline void AiSimpleParallel::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiSimpleParallel.id)
}
inline ::int32_t AiSimpleParallel::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiSimpleParallel::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiSimpleParallel::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiSimpleParallel::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSimpleParallel.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiSimpleParallel::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiSimpleParallel.node_name)
}
inline std::string* AiSimpleParallel::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiSimpleParallel.node_name)
  return _s;
}
inline const std::string& AiSimpleParallel::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiSimpleParallel::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiSimpleParallel::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiSimpleParallel::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiSimpleParallel.node_name)
  return _impl_.node_name_.Release();
}
inline void AiSimpleParallel::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiSimpleParallel.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiSimpleParallel::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiSimpleParallel::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiSimpleParallel::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiSimpleParallel::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSimpleParallel.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiSimpleParallel::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSimpleParallel.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiSimpleParallel::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSimpleParallel.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiSimpleParallel::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSimpleParallel.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiSimpleParallel::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSimpleParallel.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiSimpleParallel::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiSimpleParallel::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiSimpleParallel::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiSimpleParallel::services_size() const {
  return _internal_services_size();
}
inline void AiSimpleParallel::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiSimpleParallel::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiSimpleParallel.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiSimpleParallel::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiSimpleParallel.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiSimpleParallel::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSimpleParallel.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiSimpleParallel::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiSimpleParallel.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiSimpleParallel::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiSimpleParallel.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiSimpleParallel::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiSimpleParallel::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// .cfg.AiEFinishMode finish_mode = 5;
inline void AiSimpleParallel::clear_finish_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.finish_mode_ = 0;
}
inline ::cfg::AiEFinishMode AiSimpleParallel::finish_mode() const {
  // @@protoc_insertion_point(field_get:cfg.AiSimpleParallel.finish_mode)
  return _internal_finish_mode();
}
inline void AiSimpleParallel::set_finish_mode(::cfg::AiEFinishMode value) {
  _internal_set_finish_mode(value);
  // @@protoc_insertion_point(field_set:cfg.AiSimpleParallel.finish_mode)
}
inline ::cfg::AiEFinishMode AiSimpleParallel::_internal_finish_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AiEFinishMode>(_impl_.finish_mode_);
}
inline void AiSimpleParallel::_internal_set_finish_mode(::cfg::AiEFinishMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.finish_mode_ = value;
}

// .cfg.AiTask main_task = 6;
inline bool AiSimpleParallel::has_main_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.main_task_ != nullptr);
  return value;
}
inline void AiSimpleParallel::clear_main_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.main_task_ != nullptr) _impl_.main_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::AiTask& AiSimpleParallel::_internal_main_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::AiTask* p = _impl_.main_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::AiTask&>(::cfg::_AiTask_default_instance_);
}
inline const ::cfg::AiTask& AiSimpleParallel::main_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSimpleParallel.main_task)
  return _internal_main_task();
}
inline void AiSimpleParallel::unsafe_arena_set_allocated_main_task(::cfg::AiTask* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.main_task_);
  }
  _impl_.main_task_ = reinterpret_cast<::cfg::AiTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiSimpleParallel.main_task)
}
inline ::cfg::AiTask* AiSimpleParallel::release_main_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiTask* released = _impl_.main_task_;
  _impl_.main_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::AiTask* AiSimpleParallel::unsafe_arena_release_main_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiSimpleParallel.main_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::AiTask* temp = _impl_.main_task_;
  _impl_.main_task_ = nullptr;
  return temp;
}
inline ::cfg::AiTask* AiSimpleParallel::_internal_mutable_main_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.main_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::AiTask>(GetArenaForAllocation());
    _impl_.main_task_ = reinterpret_cast<::cfg::AiTask*>(p);
  }
  return _impl_.main_task_;
}
inline ::cfg::AiTask* AiSimpleParallel::mutable_main_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiTask* _msg = _internal_mutable_main_task();
  // @@protoc_insertion_point(field_mutable:cfg.AiSimpleParallel.main_task)
  return _msg;
}
inline void AiSimpleParallel::set_allocated_main_task(::cfg::AiTask* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::AiTask*>(_impl_.main_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::AiTask*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.main_task_ = reinterpret_cast<::cfg::AiTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.AiSimpleParallel.main_task)
}

// .cfg.AiFlowNode background_node = 7;
inline bool AiSimpleParallel::has_background_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.background_node_ != nullptr);
  return value;
}
inline void AiSimpleParallel::clear_background_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.background_node_ != nullptr) _impl_.background_node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::AiFlowNode& AiSimpleParallel::_internal_background_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::AiFlowNode* p = _impl_.background_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::AiFlowNode&>(::cfg::_AiFlowNode_default_instance_);
}
inline const ::cfg::AiFlowNode& AiSimpleParallel::background_node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiSimpleParallel.background_node)
  return _internal_background_node();
}
inline void AiSimpleParallel::unsafe_arena_set_allocated_background_node(::cfg::AiFlowNode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.background_node_);
  }
  _impl_.background_node_ = reinterpret_cast<::cfg::AiFlowNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiSimpleParallel.background_node)
}
inline ::cfg::AiFlowNode* AiSimpleParallel::release_background_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::AiFlowNode* released = _impl_.background_node_;
  _impl_.background_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::AiFlowNode* AiSimpleParallel::unsafe_arena_release_background_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiSimpleParallel.background_node)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::AiFlowNode* temp = _impl_.background_node_;
  _impl_.background_node_ = nullptr;
  return temp;
}
inline ::cfg::AiFlowNode* AiSimpleParallel::_internal_mutable_background_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.background_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::AiFlowNode>(GetArenaForAllocation());
    _impl_.background_node_ = reinterpret_cast<::cfg::AiFlowNode*>(p);
  }
  return _impl_.background_node_;
}
inline ::cfg::AiFlowNode* AiSimpleParallel::mutable_background_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiFlowNode* _msg = _internal_mutable_background_node();
  // @@protoc_insertion_point(field_mutable:cfg.AiSimpleParallel.background_node)
  return _msg;
}
inline void AiSimpleParallel::set_allocated_background_node(::cfg::AiFlowNode* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::AiFlowNode*>(_impl_.background_node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::AiFlowNode*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.background_node_ = reinterpret_cast<::cfg::AiFlowNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.AiSimpleParallel.background_node)
}

// -------------------------------------------------------------------

// AiTask

// .cfg.AiUeWait UeWait = 17;
inline bool AiTask::has_uewait() const {
  return value_case() == kUeWait;
}
inline bool AiTask::_internal_has_uewait() const {
  return value_case() == kUeWait;
}
inline void AiTask::set_has_uewait() {
  _impl_._oneof_case_[0] = kUeWait;
}
inline void AiTask::clear_uewait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeWait) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uewait_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeWait* AiTask::release_uewait() {
  // @@protoc_insertion_point(field_release:cfg.AiTask.UeWait)
  if (value_case() == kUeWait) {
    clear_has_value();
    ::cfg::AiUeWait* temp = _impl_.value_.uewait_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uewait_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeWait& AiTask::_internal_uewait() const {
  return value_case() == kUeWait ? *_impl_.value_.uewait_ : reinterpret_cast<::cfg::AiUeWait&>(::cfg::_AiUeWait_default_instance_);
}
inline const ::cfg::AiUeWait& AiTask::uewait() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTask.UeWait)
  return _internal_uewait();
}
inline ::cfg::AiUeWait* AiTask::unsafe_arena_release_uewait() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiTask.UeWait)
  if (value_case() == kUeWait) {
    clear_has_value();
    ::cfg::AiUeWait* temp = _impl_.value_.uewait_;
    _impl_.value_.uewait_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiTask::unsafe_arena_set_allocated_uewait(::cfg::AiUeWait* uewait) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uewait) {
    set_has_uewait();
    _impl_.value_.uewait_ = uewait;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiTask.UeWait)
}
inline ::cfg::AiUeWait* AiTask::_internal_mutable_uewait() {
  if (value_case() != kUeWait) {
    clear_value();
    set_has_uewait();
    _impl_.value_.uewait_ =
        CreateMaybeMessage<::cfg::AiUeWait>(GetArenaForAllocation());
  }
  return _impl_.value_.uewait_;
}
inline ::cfg::AiUeWait* AiTask::mutable_uewait() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeWait* _msg = _internal_mutable_uewait();
  // @@protoc_insertion_point(field_mutable:cfg.AiTask.UeWait)
  return _msg;
}

// .cfg.AiUeWaitBlackboardTime UeWaitBlackboardTime = 18;
inline bool AiTask::has_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime;
}
inline bool AiTask::_internal_has_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime;
}
inline void AiTask::set_has_uewaitblackboardtime() {
  _impl_._oneof_case_[0] = kUeWaitBlackboardTime;
}
inline void AiTask::clear_uewaitblackboardtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUeWaitBlackboardTime) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uewaitblackboardtime_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiUeWaitBlackboardTime* AiTask::release_uewaitblackboardtime() {
  // @@protoc_insertion_point(field_release:cfg.AiTask.UeWaitBlackboardTime)
  if (value_case() == kUeWaitBlackboardTime) {
    clear_has_value();
    ::cfg::AiUeWaitBlackboardTime* temp = _impl_.value_.uewaitblackboardtime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uewaitblackboardtime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiUeWaitBlackboardTime& AiTask::_internal_uewaitblackboardtime() const {
  return value_case() == kUeWaitBlackboardTime ? *_impl_.value_.uewaitblackboardtime_ : reinterpret_cast<::cfg::AiUeWaitBlackboardTime&>(::cfg::_AiUeWaitBlackboardTime_default_instance_);
}
inline const ::cfg::AiUeWaitBlackboardTime& AiTask::uewaitblackboardtime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTask.UeWaitBlackboardTime)
  return _internal_uewaitblackboardtime();
}
inline ::cfg::AiUeWaitBlackboardTime* AiTask::unsafe_arena_release_uewaitblackboardtime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiTask.UeWaitBlackboardTime)
  if (value_case() == kUeWaitBlackboardTime) {
    clear_has_value();
    ::cfg::AiUeWaitBlackboardTime* temp = _impl_.value_.uewaitblackboardtime_;
    _impl_.value_.uewaitblackboardtime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiTask::unsafe_arena_set_allocated_uewaitblackboardtime(::cfg::AiUeWaitBlackboardTime* uewaitblackboardtime) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (uewaitblackboardtime) {
    set_has_uewaitblackboardtime();
    _impl_.value_.uewaitblackboardtime_ = uewaitblackboardtime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiTask.UeWaitBlackboardTime)
}
inline ::cfg::AiUeWaitBlackboardTime* AiTask::_internal_mutable_uewaitblackboardtime() {
  if (value_case() != kUeWaitBlackboardTime) {
    clear_value();
    set_has_uewaitblackboardtime();
    _impl_.value_.uewaitblackboardtime_ =
        CreateMaybeMessage<::cfg::AiUeWaitBlackboardTime>(GetArenaForAllocation());
  }
  return _impl_.value_.uewaitblackboardtime_;
}
inline ::cfg::AiUeWaitBlackboardTime* AiTask::mutable_uewaitblackboardtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiUeWaitBlackboardTime* _msg = _internal_mutable_uewaitblackboardtime();
  // @@protoc_insertion_point(field_mutable:cfg.AiTask.UeWaitBlackboardTime)
  return _msg;
}

// .cfg.AiMoveToTarget MoveToTarget = 19;
inline bool AiTask::has_movetotarget() const {
  return value_case() == kMoveToTarget;
}
inline bool AiTask::_internal_has_movetotarget() const {
  return value_case() == kMoveToTarget;
}
inline void AiTask::set_has_movetotarget() {
  _impl_._oneof_case_[0] = kMoveToTarget;
}
inline void AiTask::clear_movetotarget() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToTarget) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetotarget_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToTarget* AiTask::release_movetotarget() {
  // @@protoc_insertion_point(field_release:cfg.AiTask.MoveToTarget)
  if (value_case() == kMoveToTarget) {
    clear_has_value();
    ::cfg::AiMoveToTarget* temp = _impl_.value_.movetotarget_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetotarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToTarget& AiTask::_internal_movetotarget() const {
  return value_case() == kMoveToTarget ? *_impl_.value_.movetotarget_ : reinterpret_cast<::cfg::AiMoveToTarget&>(::cfg::_AiMoveToTarget_default_instance_);
}
inline const ::cfg::AiMoveToTarget& AiTask::movetotarget() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTask.MoveToTarget)
  return _internal_movetotarget();
}
inline ::cfg::AiMoveToTarget* AiTask::unsafe_arena_release_movetotarget() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiTask.MoveToTarget)
  if (value_case() == kMoveToTarget) {
    clear_has_value();
    ::cfg::AiMoveToTarget* temp = _impl_.value_.movetotarget_;
    _impl_.value_.movetotarget_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiTask::unsafe_arena_set_allocated_movetotarget(::cfg::AiMoveToTarget* movetotarget) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetotarget) {
    set_has_movetotarget();
    _impl_.value_.movetotarget_ = movetotarget;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiTask.MoveToTarget)
}
inline ::cfg::AiMoveToTarget* AiTask::_internal_mutable_movetotarget() {
  if (value_case() != kMoveToTarget) {
    clear_value();
    set_has_movetotarget();
    _impl_.value_.movetotarget_ =
        CreateMaybeMessage<::cfg::AiMoveToTarget>(GetArenaForAllocation());
  }
  return _impl_.value_.movetotarget_;
}
inline ::cfg::AiMoveToTarget* AiTask::mutable_movetotarget() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToTarget* _msg = _internal_mutable_movetotarget();
  // @@protoc_insertion_point(field_mutable:cfg.AiTask.MoveToTarget)
  return _msg;
}

// .cfg.AiChooseSkill ChooseSkill = 20;
inline bool AiTask::has_chooseskill() const {
  return value_case() == kChooseSkill;
}
inline bool AiTask::_internal_has_chooseskill() const {
  return value_case() == kChooseSkill;
}
inline void AiTask::set_has_chooseskill() {
  _impl_._oneof_case_[0] = kChooseSkill;
}
inline void AiTask::clear_chooseskill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kChooseSkill) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.chooseskill_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiChooseSkill* AiTask::release_chooseskill() {
  // @@protoc_insertion_point(field_release:cfg.AiTask.ChooseSkill)
  if (value_case() == kChooseSkill) {
    clear_has_value();
    ::cfg::AiChooseSkill* temp = _impl_.value_.chooseskill_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.chooseskill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiChooseSkill& AiTask::_internal_chooseskill() const {
  return value_case() == kChooseSkill ? *_impl_.value_.chooseskill_ : reinterpret_cast<::cfg::AiChooseSkill&>(::cfg::_AiChooseSkill_default_instance_);
}
inline const ::cfg::AiChooseSkill& AiTask::chooseskill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTask.ChooseSkill)
  return _internal_chooseskill();
}
inline ::cfg::AiChooseSkill* AiTask::unsafe_arena_release_chooseskill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiTask.ChooseSkill)
  if (value_case() == kChooseSkill) {
    clear_has_value();
    ::cfg::AiChooseSkill* temp = _impl_.value_.chooseskill_;
    _impl_.value_.chooseskill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiTask::unsafe_arena_set_allocated_chooseskill(::cfg::AiChooseSkill* chooseskill) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (chooseskill) {
    set_has_chooseskill();
    _impl_.value_.chooseskill_ = chooseskill;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiTask.ChooseSkill)
}
inline ::cfg::AiChooseSkill* AiTask::_internal_mutable_chooseskill() {
  if (value_case() != kChooseSkill) {
    clear_value();
    set_has_chooseskill();
    _impl_.value_.chooseskill_ =
        CreateMaybeMessage<::cfg::AiChooseSkill>(GetArenaForAllocation());
  }
  return _impl_.value_.chooseskill_;
}
inline ::cfg::AiChooseSkill* AiTask::mutable_chooseskill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiChooseSkill* _msg = _internal_mutable_chooseskill();
  // @@protoc_insertion_point(field_mutable:cfg.AiTask.ChooseSkill)
  return _msg;
}

// .cfg.AiMoveToRandomLocation MoveToRandomLocation = 21;
inline bool AiTask::has_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation;
}
inline bool AiTask::_internal_has_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation;
}
inline void AiTask::set_has_movetorandomlocation() {
  _impl_._oneof_case_[0] = kMoveToRandomLocation;
}
inline void AiTask::clear_movetorandomlocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToRandomLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetorandomlocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToRandomLocation* AiTask::release_movetorandomlocation() {
  // @@protoc_insertion_point(field_release:cfg.AiTask.MoveToRandomLocation)
  if (value_case() == kMoveToRandomLocation) {
    clear_has_value();
    ::cfg::AiMoveToRandomLocation* temp = _impl_.value_.movetorandomlocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetorandomlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToRandomLocation& AiTask::_internal_movetorandomlocation() const {
  return value_case() == kMoveToRandomLocation ? *_impl_.value_.movetorandomlocation_ : reinterpret_cast<::cfg::AiMoveToRandomLocation&>(::cfg::_AiMoveToRandomLocation_default_instance_);
}
inline const ::cfg::AiMoveToRandomLocation& AiTask::movetorandomlocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTask.MoveToRandomLocation)
  return _internal_movetorandomlocation();
}
inline ::cfg::AiMoveToRandomLocation* AiTask::unsafe_arena_release_movetorandomlocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiTask.MoveToRandomLocation)
  if (value_case() == kMoveToRandomLocation) {
    clear_has_value();
    ::cfg::AiMoveToRandomLocation* temp = _impl_.value_.movetorandomlocation_;
    _impl_.value_.movetorandomlocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiTask::unsafe_arena_set_allocated_movetorandomlocation(::cfg::AiMoveToRandomLocation* movetorandomlocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetorandomlocation) {
    set_has_movetorandomlocation();
    _impl_.value_.movetorandomlocation_ = movetorandomlocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiTask.MoveToRandomLocation)
}
inline ::cfg::AiMoveToRandomLocation* AiTask::_internal_mutable_movetorandomlocation() {
  if (value_case() != kMoveToRandomLocation) {
    clear_value();
    set_has_movetorandomlocation();
    _impl_.value_.movetorandomlocation_ =
        CreateMaybeMessage<::cfg::AiMoveToRandomLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.movetorandomlocation_;
}
inline ::cfg::AiMoveToRandomLocation* AiTask::mutable_movetorandomlocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToRandomLocation* _msg = _internal_mutable_movetorandomlocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiTask.MoveToRandomLocation)
  return _msg;
}

// .cfg.AiMoveToLocation MoveToLocation = 22;
inline bool AiTask::has_movetolocation() const {
  return value_case() == kMoveToLocation;
}
inline bool AiTask::_internal_has_movetolocation() const {
  return value_case() == kMoveToLocation;
}
inline void AiTask::set_has_movetolocation() {
  _impl_._oneof_case_[0] = kMoveToLocation;
}
inline void AiTask::clear_movetolocation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kMoveToLocation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.movetolocation_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiMoveToLocation* AiTask::release_movetolocation() {
  // @@protoc_insertion_point(field_release:cfg.AiTask.MoveToLocation)
  if (value_case() == kMoveToLocation) {
    clear_has_value();
    ::cfg::AiMoveToLocation* temp = _impl_.value_.movetolocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.movetolocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiMoveToLocation& AiTask::_internal_movetolocation() const {
  return value_case() == kMoveToLocation ? *_impl_.value_.movetolocation_ : reinterpret_cast<::cfg::AiMoveToLocation&>(::cfg::_AiMoveToLocation_default_instance_);
}
inline const ::cfg::AiMoveToLocation& AiTask::movetolocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTask.MoveToLocation)
  return _internal_movetolocation();
}
inline ::cfg::AiMoveToLocation* AiTask::unsafe_arena_release_movetolocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiTask.MoveToLocation)
  if (value_case() == kMoveToLocation) {
    clear_has_value();
    ::cfg::AiMoveToLocation* temp = _impl_.value_.movetolocation_;
    _impl_.value_.movetolocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiTask::unsafe_arena_set_allocated_movetolocation(::cfg::AiMoveToLocation* movetolocation) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (movetolocation) {
    set_has_movetolocation();
    _impl_.value_.movetolocation_ = movetolocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiTask.MoveToLocation)
}
inline ::cfg::AiMoveToLocation* AiTask::_internal_mutable_movetolocation() {
  if (value_case() != kMoveToLocation) {
    clear_value();
    set_has_movetolocation();
    _impl_.value_.movetolocation_ =
        CreateMaybeMessage<::cfg::AiMoveToLocation>(GetArenaForAllocation());
  }
  return _impl_.value_.movetolocation_;
}
inline ::cfg::AiMoveToLocation* AiTask::mutable_movetolocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiMoveToLocation* _msg = _internal_mutable_movetolocation();
  // @@protoc_insertion_point(field_mutable:cfg.AiTask.MoveToLocation)
  return _msg;
}

// .cfg.AiDebugPrint DebugPrint = 23;
inline bool AiTask::has_debugprint() const {
  return value_case() == kDebugPrint;
}
inline bool AiTask::_internal_has_debugprint() const {
  return value_case() == kDebugPrint;
}
inline void AiTask::set_has_debugprint() {
  _impl_._oneof_case_[0] = kDebugPrint;
}
inline void AiTask::clear_debugprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDebugPrint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.debugprint_;
    }
    clear_has_value();
  }
}
inline ::cfg::AiDebugPrint* AiTask::release_debugprint() {
  // @@protoc_insertion_point(field_release:cfg.AiTask.DebugPrint)
  if (value_case() == kDebugPrint) {
    clear_has_value();
    ::cfg::AiDebugPrint* temp = _impl_.value_.debugprint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.debugprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::AiDebugPrint& AiTask::_internal_debugprint() const {
  return value_case() == kDebugPrint ? *_impl_.value_.debugprint_ : reinterpret_cast<::cfg::AiDebugPrint&>(::cfg::_AiDebugPrint_default_instance_);
}
inline const ::cfg::AiDebugPrint& AiTask::debugprint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTask.DebugPrint)
  return _internal_debugprint();
}
inline ::cfg::AiDebugPrint* AiTask::unsafe_arena_release_debugprint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.AiTask.DebugPrint)
  if (value_case() == kDebugPrint) {
    clear_has_value();
    ::cfg::AiDebugPrint* temp = _impl_.value_.debugprint_;
    _impl_.value_.debugprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AiTask::unsafe_arena_set_allocated_debugprint(::cfg::AiDebugPrint* debugprint) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (debugprint) {
    set_has_debugprint();
    _impl_.value_.debugprint_ = debugprint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.AiTask.DebugPrint)
}
inline ::cfg::AiDebugPrint* AiTask::_internal_mutable_debugprint() {
  if (value_case() != kDebugPrint) {
    clear_value();
    set_has_debugprint();
    _impl_.value_.debugprint_ =
        CreateMaybeMessage<::cfg::AiDebugPrint>(GetArenaForAllocation());
  }
  return _impl_.value_.debugprint_;
}
inline ::cfg::AiDebugPrint* AiTask::mutable_debugprint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::AiDebugPrint* _msg = _internal_mutable_debugprint();
  // @@protoc_insertion_point(field_mutable:cfg.AiTask.DebugPrint)
  return _msg;
}

inline bool AiTask::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AiTask::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AiTask::ValueCase AiTask::value_case() const {
  return AiTask::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AiUeWait

// int32 id = 1;
inline void AiUeWait::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeWait::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeWait.id)
  return _internal_id();
}
inline void AiUeWait::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeWait.id)
}
inline ::int32_t AiUeWait::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeWait::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeWait::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeWait::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeWait.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeWait::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeWait.node_name)
}
inline std::string* AiUeWait::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeWait.node_name)
  return _s;
}
inline const std::string& AiUeWait::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeWait::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeWait::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeWait::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeWait.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeWait::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeWait.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiUeWait::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiUeWait::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiUeWait::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiUeWait::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiUeWait.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiUeWait::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiUeWait.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiUeWait::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeWait.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiUeWait::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiUeWait.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiUeWait::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiUeWait.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiUeWait::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiUeWait::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiUeWait::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiUeWait::services_size() const {
  return _internal_services_size();
}
inline void AiUeWait::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiUeWait::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiUeWait.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiUeWait::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiUeWait.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiUeWait::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeWait.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiUeWait::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiUeWait.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiUeWait::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiUeWait.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiUeWait::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiUeWait::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// bool ignore_restart_self = 5;
inline void AiUeWait::clear_ignore_restart_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_restart_self_ = false;
}
inline bool AiUeWait::ignore_restart_self() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeWait.ignore_restart_self)
  return _internal_ignore_restart_self();
}
inline void AiUeWait::set_ignore_restart_self(bool value) {
  _internal_set_ignore_restart_self(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeWait.ignore_restart_self)
}
inline bool AiUeWait::_internal_ignore_restart_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_restart_self_;
}
inline void AiUeWait::_internal_set_ignore_restart_self(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_restart_self_ = value;
}

// float wait_time = 6;
inline void AiUeWait::clear_wait_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wait_time_ = 0;
}
inline float AiUeWait::wait_time() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeWait.wait_time)
  return _internal_wait_time();
}
inline void AiUeWait::set_wait_time(float value) {
  _internal_set_wait_time(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeWait.wait_time)
}
inline float AiUeWait::_internal_wait_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wait_time_;
}
inline void AiUeWait::_internal_set_wait_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wait_time_ = value;
}

// float random_deviation = 7;
inline void AiUeWait::clear_random_deviation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.random_deviation_ = 0;
}
inline float AiUeWait::random_deviation() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeWait.random_deviation)
  return _internal_random_deviation();
}
inline void AiUeWait::set_random_deviation(float value) {
  _internal_set_random_deviation(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeWait.random_deviation)
}
inline float AiUeWait::_internal_random_deviation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.random_deviation_;
}
inline void AiUeWait::_internal_set_random_deviation(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.random_deviation_ = value;
}

// -------------------------------------------------------------------

// AiUeWaitBlackboardTime

// int32 id = 1;
inline void AiUeWaitBlackboardTime::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiUeWaitBlackboardTime::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeWaitBlackboardTime.id)
  return _internal_id();
}
inline void AiUeWaitBlackboardTime::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeWaitBlackboardTime.id)
}
inline ::int32_t AiUeWaitBlackboardTime::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiUeWaitBlackboardTime::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiUeWaitBlackboardTime::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiUeWaitBlackboardTime::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeWaitBlackboardTime.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeWaitBlackboardTime::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeWaitBlackboardTime.node_name)
}
inline std::string* AiUeWaitBlackboardTime::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeWaitBlackboardTime.node_name)
  return _s;
}
inline const std::string& AiUeWaitBlackboardTime::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiUeWaitBlackboardTime::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeWaitBlackboardTime::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeWaitBlackboardTime::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeWaitBlackboardTime.node_name)
  return _impl_.node_name_.Release();
}
inline void AiUeWaitBlackboardTime::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeWaitBlackboardTime.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiUeWaitBlackboardTime::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiUeWaitBlackboardTime::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiUeWaitBlackboardTime::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiUeWaitBlackboardTime::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiUeWaitBlackboardTime.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiUeWaitBlackboardTime::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiUeWaitBlackboardTime.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiUeWaitBlackboardTime::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeWaitBlackboardTime.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiUeWaitBlackboardTime::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiUeWaitBlackboardTime.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiUeWaitBlackboardTime::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiUeWaitBlackboardTime.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiUeWaitBlackboardTime::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiUeWaitBlackboardTime::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiUeWaitBlackboardTime::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiUeWaitBlackboardTime::services_size() const {
  return _internal_services_size();
}
inline void AiUeWaitBlackboardTime::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiUeWaitBlackboardTime::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiUeWaitBlackboardTime.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiUeWaitBlackboardTime::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiUeWaitBlackboardTime.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiUeWaitBlackboardTime::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeWaitBlackboardTime.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiUeWaitBlackboardTime::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiUeWaitBlackboardTime.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiUeWaitBlackboardTime::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiUeWaitBlackboardTime.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiUeWaitBlackboardTime::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiUeWaitBlackboardTime::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// bool ignore_restart_self = 5;
inline void AiUeWaitBlackboardTime::clear_ignore_restart_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_restart_self_ = false;
}
inline bool AiUeWaitBlackboardTime::ignore_restart_self() const {
  // @@protoc_insertion_point(field_get:cfg.AiUeWaitBlackboardTime.ignore_restart_self)
  return _internal_ignore_restart_self();
}
inline void AiUeWaitBlackboardTime::set_ignore_restart_self(bool value) {
  _internal_set_ignore_restart_self(value);
  // @@protoc_insertion_point(field_set:cfg.AiUeWaitBlackboardTime.ignore_restart_self)
}
inline bool AiUeWaitBlackboardTime::_internal_ignore_restart_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_restart_self_;
}
inline void AiUeWaitBlackboardTime::_internal_set_ignore_restart_self(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_restart_self_ = value;
}

// string blackboard_key = 6;
inline void AiUeWaitBlackboardTime::clear_blackboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blackboard_key_.ClearToEmpty();
}
inline const std::string& AiUeWaitBlackboardTime::blackboard_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiUeWaitBlackboardTime.blackboard_key)
  return _internal_blackboard_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiUeWaitBlackboardTime::set_blackboard_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blackboard_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiUeWaitBlackboardTime.blackboard_key)
}
inline std::string* AiUeWaitBlackboardTime::mutable_blackboard_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_blackboard_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiUeWaitBlackboardTime.blackboard_key)
  return _s;
}
inline const std::string& AiUeWaitBlackboardTime::_internal_blackboard_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blackboard_key_.Get();
}
inline void AiUeWaitBlackboardTime::_internal_set_blackboard_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blackboard_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiUeWaitBlackboardTime::_internal_mutable_blackboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.blackboard_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiUeWaitBlackboardTime::release_blackboard_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiUeWaitBlackboardTime.blackboard_key)
  return _impl_.blackboard_key_.Release();
}
inline void AiUeWaitBlackboardTime::set_allocated_blackboard_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blackboard_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.blackboard_key_.IsDefault()) {
          _impl_.blackboard_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiUeWaitBlackboardTime.blackboard_key)
}

// -------------------------------------------------------------------

// AiMoveToTarget

// int32 id = 1;
inline void AiMoveToTarget::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiMoveToTarget::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToTarget.id)
  return _internal_id();
}
inline void AiMoveToTarget::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToTarget.id)
}
inline ::int32_t AiMoveToTarget::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiMoveToTarget::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiMoveToTarget::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiMoveToTarget::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToTarget.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiMoveToTarget::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiMoveToTarget.node_name)
}
inline std::string* AiMoveToTarget::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToTarget.node_name)
  return _s;
}
inline const std::string& AiMoveToTarget::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiMoveToTarget::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiMoveToTarget::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiMoveToTarget::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiMoveToTarget.node_name)
  return _impl_.node_name_.Release();
}
inline void AiMoveToTarget::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiMoveToTarget.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiMoveToTarget::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiMoveToTarget::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiMoveToTarget::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiMoveToTarget::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToTarget.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiMoveToTarget::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiMoveToTarget.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiMoveToTarget::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToTarget.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiMoveToTarget::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiMoveToTarget.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiMoveToTarget::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiMoveToTarget.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiMoveToTarget::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiMoveToTarget::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiMoveToTarget::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiMoveToTarget::services_size() const {
  return _internal_services_size();
}
inline void AiMoveToTarget::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiMoveToTarget::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToTarget.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiMoveToTarget::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiMoveToTarget.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiMoveToTarget::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToTarget.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiMoveToTarget::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiMoveToTarget.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiMoveToTarget::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiMoveToTarget.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiMoveToTarget::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiMoveToTarget::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// bool ignore_restart_self = 5;
inline void AiMoveToTarget::clear_ignore_restart_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_restart_self_ = false;
}
inline bool AiMoveToTarget::ignore_restart_self() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToTarget.ignore_restart_self)
  return _internal_ignore_restart_self();
}
inline void AiMoveToTarget::set_ignore_restart_self(bool value) {
  _internal_set_ignore_restart_self(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToTarget.ignore_restart_self)
}
inline bool AiMoveToTarget::_internal_ignore_restart_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_restart_self_;
}
inline void AiMoveToTarget::_internal_set_ignore_restart_self(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_restart_self_ = value;
}

// string target_actor_key = 6;
inline void AiMoveToTarget::clear_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_actor_key_.ClearToEmpty();
}
inline const std::string& AiMoveToTarget::target_actor_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToTarget.target_actor_key)
  return _internal_target_actor_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiMoveToTarget::set_target_actor_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_actor_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiMoveToTarget.target_actor_key)
}
inline std::string* AiMoveToTarget::mutable_target_actor_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_actor_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToTarget.target_actor_key)
  return _s;
}
inline const std::string& AiMoveToTarget::_internal_target_actor_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_actor_key_.Get();
}
inline void AiMoveToTarget::_internal_set_target_actor_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_actor_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiMoveToTarget::_internal_mutable_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_actor_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiMoveToTarget::release_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiMoveToTarget.target_actor_key)
  return _impl_.target_actor_key_.Release();
}
inline void AiMoveToTarget::set_allocated_target_actor_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_actor_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_actor_key_.IsDefault()) {
          _impl_.target_actor_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiMoveToTarget.target_actor_key)
}

// float acceptable_radius = 7;
inline void AiMoveToTarget::clear_acceptable_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptable_radius_ = 0;
}
inline float AiMoveToTarget::acceptable_radius() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToTarget.acceptable_radius)
  return _internal_acceptable_radius();
}
inline void AiMoveToTarget::set_acceptable_radius(float value) {
  _internal_set_acceptable_radius(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToTarget.acceptable_radius)
}
inline float AiMoveToTarget::_internal_acceptable_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceptable_radius_;
}
inline void AiMoveToTarget::_internal_set_acceptable_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptable_radius_ = value;
}

// -------------------------------------------------------------------

// AiChooseSkill

// int32 id = 1;
inline void AiChooseSkill::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiChooseSkill::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiChooseSkill.id)
  return _internal_id();
}
inline void AiChooseSkill::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiChooseSkill.id)
}
inline ::int32_t AiChooseSkill::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiChooseSkill::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiChooseSkill::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiChooseSkill::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiChooseSkill.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiChooseSkill::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiChooseSkill.node_name)
}
inline std::string* AiChooseSkill::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiChooseSkill.node_name)
  return _s;
}
inline const std::string& AiChooseSkill::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiChooseSkill::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiChooseSkill::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiChooseSkill::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiChooseSkill.node_name)
  return _impl_.node_name_.Release();
}
inline void AiChooseSkill::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiChooseSkill.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiChooseSkill::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiChooseSkill::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiChooseSkill::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiChooseSkill::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiChooseSkill.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiChooseSkill::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiChooseSkill.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiChooseSkill::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiChooseSkill.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiChooseSkill::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiChooseSkill.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiChooseSkill::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiChooseSkill.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiChooseSkill::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiChooseSkill::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiChooseSkill::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiChooseSkill::services_size() const {
  return _internal_services_size();
}
inline void AiChooseSkill::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiChooseSkill::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiChooseSkill.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiChooseSkill::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiChooseSkill.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiChooseSkill::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiChooseSkill.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiChooseSkill::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiChooseSkill.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiChooseSkill::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiChooseSkill.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiChooseSkill::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiChooseSkill::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// bool ignore_restart_self = 5;
inline void AiChooseSkill::clear_ignore_restart_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_restart_self_ = false;
}
inline bool AiChooseSkill::ignore_restart_self() const {
  // @@protoc_insertion_point(field_get:cfg.AiChooseSkill.ignore_restart_self)
  return _internal_ignore_restart_self();
}
inline void AiChooseSkill::set_ignore_restart_self(bool value) {
  _internal_set_ignore_restart_self(value);
  // @@protoc_insertion_point(field_set:cfg.AiChooseSkill.ignore_restart_self)
}
inline bool AiChooseSkill::_internal_ignore_restart_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_restart_self_;
}
inline void AiChooseSkill::_internal_set_ignore_restart_self(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_restart_self_ = value;
}

// string target_actor_key = 6;
inline void AiChooseSkill::clear_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_actor_key_.ClearToEmpty();
}
inline const std::string& AiChooseSkill::target_actor_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiChooseSkill.target_actor_key)
  return _internal_target_actor_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiChooseSkill::set_target_actor_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_actor_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiChooseSkill.target_actor_key)
}
inline std::string* AiChooseSkill::mutable_target_actor_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_actor_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiChooseSkill.target_actor_key)
  return _s;
}
inline const std::string& AiChooseSkill::_internal_target_actor_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_actor_key_.Get();
}
inline void AiChooseSkill::_internal_set_target_actor_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_actor_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiChooseSkill::_internal_mutable_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_actor_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiChooseSkill::release_target_actor_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiChooseSkill.target_actor_key)
  return _impl_.target_actor_key_.Release();
}
inline void AiChooseSkill::set_allocated_target_actor_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_actor_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_actor_key_.IsDefault()) {
          _impl_.target_actor_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiChooseSkill.target_actor_key)
}

// string result_skill_id_key = 7;
inline void AiChooseSkill::clear_result_skill_id_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_skill_id_key_.ClearToEmpty();
}
inline const std::string& AiChooseSkill::result_skill_id_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiChooseSkill.result_skill_id_key)
  return _internal_result_skill_id_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiChooseSkill::set_result_skill_id_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_skill_id_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiChooseSkill.result_skill_id_key)
}
inline std::string* AiChooseSkill::mutable_result_skill_id_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_result_skill_id_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiChooseSkill.result_skill_id_key)
  return _s;
}
inline const std::string& AiChooseSkill::_internal_result_skill_id_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_skill_id_key_.Get();
}
inline void AiChooseSkill::_internal_set_result_skill_id_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_skill_id_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiChooseSkill::_internal_mutable_result_skill_id_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.result_skill_id_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiChooseSkill::release_result_skill_id_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiChooseSkill.result_skill_id_key)
  return _impl_.result_skill_id_key_.Release();
}
inline void AiChooseSkill::set_allocated_result_skill_id_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_skill_id_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.result_skill_id_key_.IsDefault()) {
          _impl_.result_skill_id_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiChooseSkill.result_skill_id_key)
}

// -------------------------------------------------------------------

// AiMoveToRandomLocation

// int32 id = 1;
inline void AiMoveToRandomLocation::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiMoveToRandomLocation::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToRandomLocation.id)
  return _internal_id();
}
inline void AiMoveToRandomLocation::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToRandomLocation.id)
}
inline ::int32_t AiMoveToRandomLocation::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiMoveToRandomLocation::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiMoveToRandomLocation::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiMoveToRandomLocation::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToRandomLocation.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiMoveToRandomLocation::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiMoveToRandomLocation.node_name)
}
inline std::string* AiMoveToRandomLocation::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToRandomLocation.node_name)
  return _s;
}
inline const std::string& AiMoveToRandomLocation::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiMoveToRandomLocation::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiMoveToRandomLocation::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiMoveToRandomLocation::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiMoveToRandomLocation.node_name)
  return _impl_.node_name_.Release();
}
inline void AiMoveToRandomLocation::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiMoveToRandomLocation.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiMoveToRandomLocation::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiMoveToRandomLocation::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiMoveToRandomLocation::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiMoveToRandomLocation::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToRandomLocation.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiMoveToRandomLocation::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiMoveToRandomLocation.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiMoveToRandomLocation::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToRandomLocation.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiMoveToRandomLocation::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiMoveToRandomLocation.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiMoveToRandomLocation::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiMoveToRandomLocation.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiMoveToRandomLocation::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiMoveToRandomLocation::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiMoveToRandomLocation::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiMoveToRandomLocation::services_size() const {
  return _internal_services_size();
}
inline void AiMoveToRandomLocation::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiMoveToRandomLocation::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToRandomLocation.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiMoveToRandomLocation::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiMoveToRandomLocation.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiMoveToRandomLocation::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToRandomLocation.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiMoveToRandomLocation::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiMoveToRandomLocation.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiMoveToRandomLocation::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiMoveToRandomLocation.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiMoveToRandomLocation::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiMoveToRandomLocation::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// bool ignore_restart_self = 5;
inline void AiMoveToRandomLocation::clear_ignore_restart_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_restart_self_ = false;
}
inline bool AiMoveToRandomLocation::ignore_restart_self() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToRandomLocation.ignore_restart_self)
  return _internal_ignore_restart_self();
}
inline void AiMoveToRandomLocation::set_ignore_restart_self(bool value) {
  _internal_set_ignore_restart_self(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToRandomLocation.ignore_restart_self)
}
inline bool AiMoveToRandomLocation::_internal_ignore_restart_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_restart_self_;
}
inline void AiMoveToRandomLocation::_internal_set_ignore_restart_self(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_restart_self_ = value;
}

// string origin_position_key = 6;
inline void AiMoveToRandomLocation::clear_origin_position_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.origin_position_key_.ClearToEmpty();
}
inline const std::string& AiMoveToRandomLocation::origin_position_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToRandomLocation.origin_position_key)
  return _internal_origin_position_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiMoveToRandomLocation::set_origin_position_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.origin_position_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiMoveToRandomLocation.origin_position_key)
}
inline std::string* AiMoveToRandomLocation::mutable_origin_position_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_origin_position_key();
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToRandomLocation.origin_position_key)
  return _s;
}
inline const std::string& AiMoveToRandomLocation::_internal_origin_position_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.origin_position_key_.Get();
}
inline void AiMoveToRandomLocation::_internal_set_origin_position_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.origin_position_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AiMoveToRandomLocation::_internal_mutable_origin_position_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.origin_position_key_.Mutable( GetArenaForAllocation());
}
inline std::string* AiMoveToRandomLocation::release_origin_position_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiMoveToRandomLocation.origin_position_key)
  return _impl_.origin_position_key_.Release();
}
inline void AiMoveToRandomLocation::set_allocated_origin_position_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.origin_position_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.origin_position_key_.IsDefault()) {
          _impl_.origin_position_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiMoveToRandomLocation.origin_position_key)
}

// float radius = 7;
inline void AiMoveToRandomLocation::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline float AiMoveToRandomLocation::radius() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToRandomLocation.radius)
  return _internal_radius();
}
inline void AiMoveToRandomLocation::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToRandomLocation.radius)
}
inline float AiMoveToRandomLocation::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void AiMoveToRandomLocation::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// AiMoveToLocation

// int32 id = 1;
inline void AiMoveToLocation::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiMoveToLocation::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToLocation.id)
  return _internal_id();
}
inline void AiMoveToLocation::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToLocation.id)
}
inline ::int32_t AiMoveToLocation::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiMoveToLocation::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiMoveToLocation::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiMoveToLocation::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToLocation.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiMoveToLocation::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiMoveToLocation.node_name)
}
inline std::string* AiMoveToLocation::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToLocation.node_name)
  return _s;
}
inline const std::string& AiMoveToLocation::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiMoveToLocation::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiMoveToLocation::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiMoveToLocation::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiMoveToLocation.node_name)
  return _impl_.node_name_.Release();
}
inline void AiMoveToLocation::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiMoveToLocation.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiMoveToLocation::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiMoveToLocation::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiMoveToLocation::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiMoveToLocation::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToLocation.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiMoveToLocation::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiMoveToLocation.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiMoveToLocation::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToLocation.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiMoveToLocation::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiMoveToLocation.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiMoveToLocation::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiMoveToLocation.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiMoveToLocation::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiMoveToLocation::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiMoveToLocation::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiMoveToLocation::services_size() const {
  return _internal_services_size();
}
inline void AiMoveToLocation::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiMoveToLocation::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiMoveToLocation.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiMoveToLocation::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiMoveToLocation.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiMoveToLocation::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToLocation.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiMoveToLocation::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiMoveToLocation.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiMoveToLocation::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiMoveToLocation.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiMoveToLocation::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiMoveToLocation::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// bool ignore_restart_self = 5;
inline void AiMoveToLocation::clear_ignore_restart_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_restart_self_ = false;
}
inline bool AiMoveToLocation::ignore_restart_self() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToLocation.ignore_restart_self)
  return _internal_ignore_restart_self();
}
inline void AiMoveToLocation::set_ignore_restart_self(bool value) {
  _internal_set_ignore_restart_self(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToLocation.ignore_restart_self)
}
inline bool AiMoveToLocation::_internal_ignore_restart_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_restart_self_;
}
inline void AiMoveToLocation::_internal_set_ignore_restart_self(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_restart_self_ = value;
}

// float acceptable_radius = 6;
inline void AiMoveToLocation::clear_acceptable_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceptable_radius_ = 0;
}
inline float AiMoveToLocation::acceptable_radius() const {
  // @@protoc_insertion_point(field_get:cfg.AiMoveToLocation.acceptable_radius)
  return _internal_acceptable_radius();
}
inline void AiMoveToLocation::set_acceptable_radius(float value) {
  _internal_set_acceptable_radius(value);
  // @@protoc_insertion_point(field_set:cfg.AiMoveToLocation.acceptable_radius)
}
inline float AiMoveToLocation::_internal_acceptable_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceptable_radius_;
}
inline void AiMoveToLocation::_internal_set_acceptable_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acceptable_radius_ = value;
}

// -------------------------------------------------------------------

// AiDebugPrint

// int32 id = 1;
inline void AiDebugPrint::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t AiDebugPrint::id() const {
  // @@protoc_insertion_point(field_get:cfg.AiDebugPrint.id)
  return _internal_id();
}
inline void AiDebugPrint::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.AiDebugPrint.id)
}
inline ::int32_t AiDebugPrint::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void AiDebugPrint::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string node_name = 2;
inline void AiDebugPrint::clear_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.ClearToEmpty();
}
inline const std::string& AiDebugPrint::node_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDebugPrint.node_name)
  return _internal_node_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiDebugPrint::set_node_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiDebugPrint.node_name)
}
inline std::string* AiDebugPrint::mutable_node_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:cfg.AiDebugPrint.node_name)
  return _s;
}
inline const std::string& AiDebugPrint::_internal_node_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_name_.Get();
}
inline void AiDebugPrint::_internal_set_node_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiDebugPrint::_internal_mutable_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiDebugPrint::release_node_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiDebugPrint.node_name)
  return _impl_.node_name_.Release();
}
inline void AiDebugPrint::set_allocated_node_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_name_.IsDefault()) {
          _impl_.node_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiDebugPrint.node_name)
}

// repeated .cfg.AiDecorator decorators = 3 [packed = false];
inline int AiDebugPrint::_internal_decorators_size() const {
  return _internal_decorators().size();
}
inline int AiDebugPrint::decorators_size() const {
  return _internal_decorators_size();
}
inline void AiDebugPrint::clear_decorators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decorators_.Clear();
}
inline ::cfg::AiDecorator* AiDebugPrint::mutable_decorators(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiDebugPrint.decorators)
  return _internal_mutable_decorators()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>* AiDebugPrint::mutable_decorators()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiDebugPrint.decorators)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_decorators();
}
inline const ::cfg::AiDecorator& AiDebugPrint::decorators(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDebugPrint.decorators)
  return _internal_decorators().Get(index);
}
inline ::cfg::AiDecorator* AiDebugPrint::add_decorators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiDecorator* _add = _internal_mutable_decorators()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiDebugPrint.decorators)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>& AiDebugPrint::decorators() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiDebugPrint.decorators)
  return _internal_decorators();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>&
AiDebugPrint::_internal_decorators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decorators_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiDecorator>*
AiDebugPrint::_internal_mutable_decorators() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.decorators_;
}

// repeated .cfg.AiService services = 4 [packed = false];
inline int AiDebugPrint::_internal_services_size() const {
  return _internal_services().size();
}
inline int AiDebugPrint::services_size() const {
  return _internal_services_size();
}
inline void AiDebugPrint::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::cfg::AiService* AiDebugPrint::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiDebugPrint.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>* AiDebugPrint::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiDebugPrint.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::cfg::AiService& AiDebugPrint::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDebugPrint.services)
  return _internal_services().Get(index);
}
inline ::cfg::AiService* AiDebugPrint::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiService* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiDebugPrint.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>& AiDebugPrint::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiDebugPrint.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiService>&
AiDebugPrint::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiService>*
AiDebugPrint::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// bool ignore_restart_self = 5;
inline void AiDebugPrint::clear_ignore_restart_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_restart_self_ = false;
}
inline bool AiDebugPrint::ignore_restart_self() const {
  // @@protoc_insertion_point(field_get:cfg.AiDebugPrint.ignore_restart_self)
  return _internal_ignore_restart_self();
}
inline void AiDebugPrint::set_ignore_restart_self(bool value) {
  _internal_set_ignore_restart_self(value);
  // @@protoc_insertion_point(field_set:cfg.AiDebugPrint.ignore_restart_self)
}
inline bool AiDebugPrint::_internal_ignore_restart_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_restart_self_;
}
inline void AiDebugPrint::_internal_set_ignore_restart_self(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_restart_self_ = value;
}

// string text = 6;
inline void AiDebugPrint::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& AiDebugPrint::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiDebugPrint.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiDebugPrint::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.AiDebugPrint.text)
}
inline std::string* AiDebugPrint::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:cfg.AiDebugPrint.text)
  return _s;
}
inline const std::string& AiDebugPrint::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void AiDebugPrint::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* AiDebugPrint::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* AiDebugPrint::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.AiDebugPrint.text)
  return _impl_.text_.Release();
}
inline void AiDebugPrint::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.AiDebugPrint.text)
}

// -------------------------------------------------------------------

// CommonGlobalConfig

// int32 x1 = 1;
inline void CommonGlobalConfig::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::int32_t CommonGlobalConfig::x1() const {
  // @@protoc_insertion_point(field_get:cfg.CommonGlobalConfig.x1)
  return _internal_x1();
}
inline void CommonGlobalConfig::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.CommonGlobalConfig.x1)
}
inline ::int32_t CommonGlobalConfig::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void CommonGlobalConfig::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int32 x2 = 2;
inline void CommonGlobalConfig::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_ = 0;
}
inline ::int32_t CommonGlobalConfig::x2() const {
  // @@protoc_insertion_point(field_get:cfg.CommonGlobalConfig.x2)
  return _internal_x2();
}
inline void CommonGlobalConfig::set_x2(::int32_t value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:cfg.CommonGlobalConfig.x2)
}
inline ::int32_t CommonGlobalConfig::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline void CommonGlobalConfig::_internal_set_x2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x2_ = value;
}

// int32 x3 = 3;
inline void CommonGlobalConfig::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_ = 0;
}
inline ::int32_t CommonGlobalConfig::x3() const {
  // @@protoc_insertion_point(field_get:cfg.CommonGlobalConfig.x3)
  return _internal_x3();
}
inline void CommonGlobalConfig::set_x3(::int32_t value) {
  _internal_set_x3(value);
  // @@protoc_insertion_point(field_set:cfg.CommonGlobalConfig.x3)
}
inline ::int32_t CommonGlobalConfig::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline void CommonGlobalConfig::_internal_set_x3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x3_ = value;
}

// int32 x4 = 4;
inline void CommonGlobalConfig::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_ = 0;
}
inline ::int32_t CommonGlobalConfig::x4() const {
  // @@protoc_insertion_point(field_get:cfg.CommonGlobalConfig.x4)
  return _internal_x4();
}
inline void CommonGlobalConfig::set_x4(::int32_t value) {
  _internal_set_x4(value);
  // @@protoc_insertion_point(field_set:cfg.CommonGlobalConfig.x4)
}
inline ::int32_t CommonGlobalConfig::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline void CommonGlobalConfig::_internal_set_x4(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x4_ = value;
}

// int32 x5 = 5;
inline void CommonGlobalConfig::clear_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x5_ = 0;
}
inline ::int32_t CommonGlobalConfig::x5() const {
  // @@protoc_insertion_point(field_get:cfg.CommonGlobalConfig.x5)
  return _internal_x5();
}
inline void CommonGlobalConfig::set_x5(::int32_t value) {
  _internal_set_x5(value);
  // @@protoc_insertion_point(field_set:cfg.CommonGlobalConfig.x5)
}
inline ::int32_t CommonGlobalConfig::_internal_x5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x5_;
}
inline void CommonGlobalConfig::_internal_set_x5(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x5_ = value;
}

// int32 x6 = 6;
inline void CommonGlobalConfig::clear_x6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x6_ = 0;
}
inline ::int32_t CommonGlobalConfig::x6() const {
  // @@protoc_insertion_point(field_get:cfg.CommonGlobalConfig.x6)
  return _internal_x6();
}
inline void CommonGlobalConfig::set_x6(::int32_t value) {
  _internal_set_x6(value);
  // @@protoc_insertion_point(field_set:cfg.CommonGlobalConfig.x6)
}
inline ::int32_t CommonGlobalConfig::_internal_x6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x6_;
}
inline void CommonGlobalConfig::_internal_set_x6(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x6_ = value;
}

// repeated int32 x7 = 7 [packed = true];
inline int CommonGlobalConfig::_internal_x7_size() const {
  return _internal_x7().size();
}
inline int CommonGlobalConfig::x7_size() const {
  return _internal_x7_size();
}
inline void CommonGlobalConfig::clear_x7() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x7_.Clear();
}
inline ::int32_t CommonGlobalConfig::x7(int index) const {
  // @@protoc_insertion_point(field_get:cfg.CommonGlobalConfig.x7)
  return _internal_x7().Get(index);
}
inline void CommonGlobalConfig::set_x7(int index, ::int32_t value) {
  _internal_mutable_x7()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.CommonGlobalConfig.x7)
}
inline void CommonGlobalConfig::add_x7(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x7()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.CommonGlobalConfig.x7)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CommonGlobalConfig::x7() const {
  // @@protoc_insertion_point(field_list:cfg.CommonGlobalConfig.x7)
  return _internal_x7();
}
inline ::google::protobuf::RepeatedField<::int32_t>* CommonGlobalConfig::mutable_x7() {
  // @@protoc_insertion_point(field_mutable_list:cfg.CommonGlobalConfig.x7)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x7();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CommonGlobalConfig::_internal_x7()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x7_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* CommonGlobalConfig::_internal_mutable_x7() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x7_;
}

// -------------------------------------------------------------------

// ItemItem

// int32 id = 1;
inline void ItemItem::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t ItemItem::id() const {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.id)
  return _internal_id();
}
inline void ItemItem::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.ItemItem.id)
}
inline ::int32_t ItemItem::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void ItemItem::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void ItemItem::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ItemItem::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemItem::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.ItemItem.name)
}
inline std::string* ItemItem::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.ItemItem.name)
  return _s;
}
inline const std::string& ItemItem::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ItemItem::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemItem::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* ItemItem::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.ItemItem.name)
  return _impl_.name_.Release();
}
inline void ItemItem::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.ItemItem.name)
}

// .cfg.ItemEMinorType minor_type = 4;
inline void ItemItem::clear_minor_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minor_type_ = 0;
}
inline ::cfg::ItemEMinorType ItemItem::minor_type() const {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.minor_type)
  return _internal_minor_type();
}
inline void ItemItem::set_minor_type(::cfg::ItemEMinorType value) {
  _internal_set_minor_type(value);
  // @@protoc_insertion_point(field_set:cfg.ItemItem.minor_type)
}
inline ::cfg::ItemEMinorType ItemItem::_internal_minor_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::ItemEMinorType>(_impl_.minor_type_);
}
inline void ItemItem::_internal_set_minor_type(::cfg::ItemEMinorType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.minor_type_ = value;
}

// .cfg.ItemEItemQuality quality = 6;
inline void ItemItem::clear_quality() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quality_ = 0;
}
inline ::cfg::ItemEItemQuality ItemItem::quality() const {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.quality)
  return _internal_quality();
}
inline void ItemItem::set_quality(::cfg::ItemEItemQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:cfg.ItemItem.quality)
}
inline ::cfg::ItemEItemQuality ItemItem::_internal_quality() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::ItemEItemQuality>(_impl_.quality_);
}
inline void ItemItem::_internal_set_quality(::cfg::ItemEItemQuality value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quality_ = value;
}

// string icon_backgroud = 8;
inline void ItemItem::clear_icon_backgroud() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_backgroud_.ClearToEmpty();
}
inline const std::string& ItemItem::icon_backgroud() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.icon_backgroud)
  return _internal_icon_backgroud();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemItem::set_icon_backgroud(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_backgroud_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.ItemItem.icon_backgroud)
}
inline std::string* ItemItem::mutable_icon_backgroud() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_icon_backgroud();
  // @@protoc_insertion_point(field_mutable:cfg.ItemItem.icon_backgroud)
  return _s;
}
inline const std::string& ItemItem::_internal_icon_backgroud() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.icon_backgroud_.Get();
}
inline void ItemItem::_internal_set_icon_backgroud(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_backgroud_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemItem::_internal_mutable_icon_backgroud() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.icon_backgroud_.Mutable( GetArenaForAllocation());
}
inline std::string* ItemItem::release_icon_backgroud() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.ItemItem.icon_backgroud)
  return _impl_.icon_backgroud_.Release();
}
inline void ItemItem::set_allocated_icon_backgroud(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_backgroud_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.icon_backgroud_.IsDefault()) {
          _impl_.icon_backgroud_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.ItemItem.icon_backgroud)
}

// string icon_mask = 9;
inline void ItemItem::clear_icon_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_mask_.ClearToEmpty();
}
inline const std::string& ItemItem::icon_mask() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.icon_mask)
  return _internal_icon_mask();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemItem::set_icon_mask(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_mask_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.ItemItem.icon_mask)
}
inline std::string* ItemItem::mutable_icon_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_icon_mask();
  // @@protoc_insertion_point(field_mutable:cfg.ItemItem.icon_mask)
  return _s;
}
inline const std::string& ItemItem::_internal_icon_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.icon_mask_.Get();
}
inline void ItemItem::_internal_set_icon_mask(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_mask_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemItem::_internal_mutable_icon_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.icon_mask_.Mutable( GetArenaForAllocation());
}
inline std::string* ItemItem::release_icon_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.ItemItem.icon_mask)
  return _impl_.icon_mask_.Release();
}
inline void ItemItem::set_allocated_icon_mask(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_mask_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.icon_mask_.IsDefault()) {
          _impl_.icon_mask_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.ItemItem.icon_mask)
}

// string desc = 10;
inline void ItemItem::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& ItemItem::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemItem::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.ItemItem.desc)
}
inline std::string* ItemItem::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.ItemItem.desc)
  return _s;
}
inline const std::string& ItemItem::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void ItemItem::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemItem::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* ItemItem::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.ItemItem.desc)
  return _impl_.desc_.Release();
}
inline void ItemItem::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.ItemItem.desc)
}

// int32 show_order = 11;
inline void ItemItem::clear_show_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.show_order_ = 0;
}
inline ::int32_t ItemItem::show_order() const {
  // @@protoc_insertion_point(field_get:cfg.ItemItem.show_order)
  return _internal_show_order();
}
inline void ItemItem::set_show_order(::int32_t value) {
  _internal_set_show_order(value);
  // @@protoc_insertion_point(field_set:cfg.ItemItem.show_order)
}
inline ::int32_t ItemItem::_internal_show_order() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.show_order_;
}
inline void ItemItem::_internal_set_show_order(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.show_order_ = value;
}

// -------------------------------------------------------------------

// L10nL10NDemo

// int32 id = 1;
inline void L10nL10NDemo::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t L10nL10NDemo::id() const {
  // @@protoc_insertion_point(field_get:cfg.L10nL10NDemo.id)
  return _internal_id();
}
inline void L10nL10NDemo::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.L10nL10NDemo.id)
}
inline ::int32_t L10nL10NDemo::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void L10nL10NDemo::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string text = 2;
inline void L10nL10NDemo::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& L10nL10NDemo::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.L10nL10NDemo.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void L10nL10NDemo::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.L10nL10NDemo.text)
}
inline std::string* L10nL10NDemo::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:cfg.L10nL10NDemo.text)
  return _s;
}
inline const std::string& L10nL10NDemo::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void L10nL10NDemo::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* L10nL10NDemo::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArenaForAllocation());
}
inline std::string* L10nL10NDemo::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.L10nL10NDemo.text)
  return _impl_.text_.Release();
}
inline void L10nL10NDemo::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.L10nL10NDemo.text)
}

// -------------------------------------------------------------------

// L10nPatchDemo

// int32 id = 1;
inline void L10nPatchDemo::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t L10nPatchDemo::id() const {
  // @@protoc_insertion_point(field_get:cfg.L10nPatchDemo.id)
  return _internal_id();
}
inline void L10nPatchDemo::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.L10nPatchDemo.id)
}
inline ::int32_t L10nPatchDemo::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void L10nPatchDemo::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 value = 2;
inline void L10nPatchDemo::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t L10nPatchDemo::value() const {
  // @@protoc_insertion_point(field_get:cfg.L10nPatchDemo.value)
  return _internal_value();
}
inline void L10nPatchDemo::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cfg.L10nPatchDemo.value)
}
inline ::int32_t L10nPatchDemo::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void L10nPatchDemo::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// TagTestTag

// int32 id = 1;
inline void TagTestTag::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TagTestTag::id() const {
  // @@protoc_insertion_point(field_get:cfg.TagTestTag.id)
  return _internal_id();
}
inline void TagTestTag::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TagTestTag.id)
}
inline ::int32_t TagTestTag::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TagTestTag::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string value = 2;
inline void TagTestTag::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& TagTestTag::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TagTestTag.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TagTestTag::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TagTestTag.value)
}
inline std::string* TagTestTag::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cfg.TagTestTag.value)
  return _s;
}
inline const std::string& TagTestTag::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void TagTestTag::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* TagTestTag::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* TagTestTag::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TagTestTag.value)
  return _impl_.value_.Release();
}
inline void TagTestTag::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TagTestTag.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestDemoType2

// int32 x4 = 1;
inline void TestDemoType2::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_ = 0;
}
inline ::int32_t TestDemoType2::x4() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x4)
  return _internal_x4();
}
inline void TestDemoType2::set_x4(::int32_t value) {
  _internal_set_x4(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x4)
}
inline ::int32_t TestDemoType2::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline void TestDemoType2::_internal_set_x4(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x4_ = value;
}

// bool x1 = 2;
inline void TestDemoType2::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = false;
}
inline bool TestDemoType2::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x1)
  return _internal_x1();
}
inline void TestDemoType2::set_x1(bool value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x1)
}
inline bool TestDemoType2::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestDemoType2::_internal_set_x1(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int32 x2 = 3;
inline void TestDemoType2::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_ = 0;
}
inline ::int32_t TestDemoType2::x2() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x2)
  return _internal_x2();
}
inline void TestDemoType2::set_x2(::int32_t value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x2)
}
inline ::int32_t TestDemoType2::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline void TestDemoType2::_internal_set_x2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x2_ = value;
}

// int32 x3 = 4;
inline void TestDemoType2::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_ = 0;
}
inline ::int32_t TestDemoType2::x3() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x3)
  return _internal_x3();
}
inline void TestDemoType2::set_x3(::int32_t value) {
  _internal_set_x3(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x3)
}
inline ::int32_t TestDemoType2::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline void TestDemoType2::_internal_set_x3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x3_ = value;
}

// int64 x5 = 5;
inline void TestDemoType2::clear_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x5_ = ::int64_t{0};
}
inline ::int64_t TestDemoType2::x5() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x5)
  return _internal_x5();
}
inline void TestDemoType2::set_x5(::int64_t value) {
  _internal_set_x5(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x5)
}
inline ::int64_t TestDemoType2::_internal_x5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x5_;
}
inline void TestDemoType2::_internal_set_x5(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x5_ = value;
}

// float x6 = 6;
inline void TestDemoType2::clear_x6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x6_ = 0;
}
inline float TestDemoType2::x6() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x6)
  return _internal_x6();
}
inline void TestDemoType2::set_x6(float value) {
  _internal_set_x6(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x6)
}
inline float TestDemoType2::_internal_x6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x6_;
}
inline void TestDemoType2::_internal_set_x6(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x6_ = value;
}

// double x7 = 7;
inline void TestDemoType2::clear_x7() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x7_ = 0;
}
inline double TestDemoType2::x7() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x7)
  return _internal_x7();
}
inline void TestDemoType2::set_x7(double value) {
  _internal_set_x7(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x7)
}
inline double TestDemoType2::_internal_x7() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x7_;
}
inline void TestDemoType2::_internal_set_x7(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x7_ = value;
}

// int32 x8_0 = 8;
inline void TestDemoType2::clear_x8_0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x8_0_ = 0;
}
inline ::int32_t TestDemoType2::x8_0() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x8_0)
  return _internal_x8_0();
}
inline void TestDemoType2::set_x8_0(::int32_t value) {
  _internal_set_x8_0(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x8_0)
}
inline ::int32_t TestDemoType2::_internal_x8_0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x8_0_;
}
inline void TestDemoType2::_internal_set_x8_0(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x8_0_ = value;
}

// int32 x8 = 9;
inline void TestDemoType2::clear_x8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x8_ = 0;
}
inline ::int32_t TestDemoType2::x8() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x8)
  return _internal_x8();
}
inline void TestDemoType2::set_x8(::int32_t value) {
  _internal_set_x8(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x8)
}
inline ::int32_t TestDemoType2::_internal_x8() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x8_;
}
inline void TestDemoType2::_internal_set_x8(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x8_ = value;
}

// int64 x9 = 10;
inline void TestDemoType2::clear_x9() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x9_ = ::int64_t{0};
}
inline ::int64_t TestDemoType2::x9() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x9)
  return _internal_x9();
}
inline void TestDemoType2::set_x9(::int64_t value) {
  _internal_set_x9(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x9)
}
inline ::int64_t TestDemoType2::_internal_x9() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x9_;
}
inline void TestDemoType2::_internal_set_x9(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x9_ = value;
}

// string x10 = 11;
inline void TestDemoType2::clear_x10() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x10_.ClearToEmpty();
}
inline const std::string& TestDemoType2::x10() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x10)
  return _internal_x10();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDemoType2::set_x10(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x10_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x10)
}
inline std::string* TestDemoType2::mutable_x10() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_x10();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoType2.x10)
  return _s;
}
inline const std::string& TestDemoType2::_internal_x10() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x10_.Get();
}
inline void TestDemoType2::_internal_set_x10(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x10_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDemoType2::_internal_mutable_x10() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.x10_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDemoType2::release_x10() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoType2.x10)
  return _impl_.x10_.Release();
}
inline void TestDemoType2::set_allocated_x10(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x10_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.x10_.IsDefault()) {
          _impl_.x10_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoType2.x10)
}

// .cfg.TestDemoType1 x12 = 12;
inline bool TestDemoType2::has_x12() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x12_ != nullptr);
  return value;
}
inline void TestDemoType2::clear_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x12_ != nullptr) _impl_.x12_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestDemoType1& TestDemoType2::_internal_x12() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoType1* p = _impl_.x12_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoType1&>(::cfg::_TestDemoType1_default_instance_);
}
inline const ::cfg::TestDemoType1& TestDemoType2::x12() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x12)
  return _internal_x12();
}
inline void TestDemoType2::unsafe_arena_set_allocated_x12(::cfg::TestDemoType1* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x12_);
  }
  _impl_.x12_ = reinterpret_cast<::cfg::TestDemoType1*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoType2.x12)
}
inline ::cfg::TestDemoType1* TestDemoType2::release_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoType1* released = _impl_.x12_;
  _impl_.x12_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoType1* TestDemoType2::unsafe_arena_release_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoType2.x12)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoType1* temp = _impl_.x12_;
  _impl_.x12_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoType1* TestDemoType2::_internal_mutable_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x12_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoType1>(GetArenaForAllocation());
    _impl_.x12_ = reinterpret_cast<::cfg::TestDemoType1*>(p);
  }
  return _impl_.x12_;
}
inline ::cfg::TestDemoType1* TestDemoType2::mutable_x12() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoType1* _msg = _internal_mutable_x12();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoType2.x12)
  return _msg;
}
inline void TestDemoType2::set_allocated_x12(::cfg::TestDemoType1* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoType1*>(_impl_.x12_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoType1*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x12_ = reinterpret_cast<::cfg::TestDemoType1*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoType2.x12)
}

// .cfg.TestDemoEnum x13 = 13;
inline void TestDemoType2::clear_x13() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x13_ = 0;
}
inline ::cfg::TestDemoEnum TestDemoType2::x13() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x13)
  return _internal_x13();
}
inline void TestDemoType2::set_x13(::cfg::TestDemoEnum value) {
  _internal_set_x13(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.x13)
}
inline ::cfg::TestDemoEnum TestDemoType2::_internal_x13() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::TestDemoEnum>(_impl_.x13_);
}
inline void TestDemoType2::_internal_set_x13(::cfg::TestDemoEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x13_ = value;
}

// .cfg.TestDemoDynamic x14 = 14;
inline bool TestDemoType2::has_x14() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x14_ != nullptr);
  return value;
}
inline void TestDemoType2::clear_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x14_ != nullptr) _impl_.x14_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::TestDemoDynamic& TestDemoType2::_internal_x14() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoDynamic* p = _impl_.x14_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoDynamic&>(::cfg::_TestDemoDynamic_default_instance_);
}
inline const ::cfg::TestDemoDynamic& TestDemoType2::x14() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.x14)
  return _internal_x14();
}
inline void TestDemoType2::unsafe_arena_set_allocated_x14(::cfg::TestDemoDynamic* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x14_);
  }
  _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoType2.x14)
}
inline ::cfg::TestDemoDynamic* TestDemoType2::release_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestDemoDynamic* released = _impl_.x14_;
  _impl_.x14_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoDynamic* TestDemoType2::unsafe_arena_release_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoType2.x14)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestDemoDynamic* temp = _impl_.x14_;
  _impl_.x14_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoDynamic* TestDemoType2::_internal_mutable_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.x14_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoDynamic>(GetArenaForAllocation());
    _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(p);
  }
  return _impl_.x14_;
}
inline ::cfg::TestDemoDynamic* TestDemoType2::mutable_x14() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoDynamic* _msg = _internal_mutable_x14();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoType2.x14)
  return _msg;
}
inline void TestDemoType2::set_allocated_x14(::cfg::TestDemoDynamic* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoDynamic*>(_impl_.x14_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoDynamic*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoType2.x14)
}

// string s1 = 15;
inline void TestDemoType2::clear_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.ClearToEmpty();
}
inline const std::string& TestDemoType2::s1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.s1)
  return _internal_s1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDemoType2::set_s1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.s1)
}
inline std::string* TestDemoType2::mutable_s1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoType2.s1)
  return _s;
}
inline const std::string& TestDemoType2::_internal_s1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s1_.Get();
}
inline void TestDemoType2::_internal_set_s1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDemoType2::_internal_mutable_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s1_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDemoType2::release_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoType2.s1)
  return _impl_.s1_.Release();
}
inline void TestDemoType2::set_allocated_s1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s1_.IsDefault()) {
          _impl_.s1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoType2.s1)
}

// int64 t1 = 16;
inline void TestDemoType2::clear_t1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.t1_ = ::int64_t{0};
}
inline ::int64_t TestDemoType2::t1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.t1)
  return _internal_t1();
}
inline void TestDemoType2::set_t1(::int64_t value) {
  _internal_set_t1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.t1)
}
inline ::int64_t TestDemoType2::_internal_t1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.t1_;
}
inline void TestDemoType2::_internal_set_t1(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.t1_ = value;
}

// repeated int32 k1 = 17 [packed = true];
inline int TestDemoType2::_internal_k1_size() const {
  return _internal_k1().size();
}
inline int TestDemoType2::k1_size() const {
  return _internal_k1_size();
}
inline void TestDemoType2::clear_k1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k1_.Clear();
}
inline ::int32_t TestDemoType2::k1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.k1)
  return _internal_k1().Get(index);
}
inline void TestDemoType2::set_k1(int index, ::int32_t value) {
  _internal_mutable_k1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.k1)
}
inline void TestDemoType2::add_k1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_k1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestDemoType2.k1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestDemoType2::k1() const {
  // @@protoc_insertion_point(field_list:cfg.TestDemoType2.k1)
  return _internal_k1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestDemoType2::mutable_k1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestDemoType2.k1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestDemoType2::_internal_k1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestDemoType2::_internal_mutable_k1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k1_;
}

// repeated int32 k2 = 18 [packed = true];
inline int TestDemoType2::_internal_k2_size() const {
  return _internal_k2().size();
}
inline int TestDemoType2::k2_size() const {
  return _internal_k2_size();
}
inline void TestDemoType2::clear_k2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k2_.Clear();
}
inline ::int32_t TestDemoType2::k2(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.k2)
  return _internal_k2().Get(index);
}
inline void TestDemoType2::set_k2(int index, ::int32_t value) {
  _internal_mutable_k2()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.k2)
}
inline void TestDemoType2::add_k2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_k2()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestDemoType2.k2)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestDemoType2::k2() const {
  // @@protoc_insertion_point(field_list:cfg.TestDemoType2.k2)
  return _internal_k2();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestDemoType2::mutable_k2() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestDemoType2.k2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k2();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestDemoType2::_internal_k2()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k2_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestDemoType2::_internal_mutable_k2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k2_;
}

// repeated int32 k5 = 19 [packed = true];
inline int TestDemoType2::_internal_k5_size() const {
  return _internal_k5().size();
}
inline int TestDemoType2::k5_size() const {
  return _internal_k5_size();
}
inline void TestDemoType2::clear_k5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k5_.Clear();
}
inline ::int32_t TestDemoType2::k5(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.k5)
  return _internal_k5().Get(index);
}
inline void TestDemoType2::set_k5(int index, ::int32_t value) {
  _internal_mutable_k5()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType2.k5)
}
inline void TestDemoType2::add_k5(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_k5()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestDemoType2.k5)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestDemoType2::k5() const {
  // @@protoc_insertion_point(field_list:cfg.TestDemoType2.k5)
  return _internal_k5();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestDemoType2::mutable_k5() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestDemoType2.k5)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k5();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestDemoType2::_internal_k5()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k5_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestDemoType2::_internal_mutable_k5() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k5_;
}

// map<int32, int32> k8 = 20;
inline int TestDemoType2::_internal_k8_size() const {
  return _internal_k8().size();
}
inline int TestDemoType2::k8_size() const {
  return _internal_k8_size();
}
inline void TestDemoType2::clear_k8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k8_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestDemoType2::_internal_k8() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k8_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestDemoType2::k8() const {
  // @@protoc_insertion_point(field_map:cfg.TestDemoType2.k8)
  return _internal_k8();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestDemoType2::_internal_mutable_k8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.k8_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestDemoType2::mutable_k8() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestDemoType2.k8)
  return _internal_mutable_k8();
}

// repeated .cfg.TestDemoE2 k9 = 21 [packed = false];
inline int TestDemoType2::_internal_k9_size() const {
  return _internal_k9().size();
}
inline int TestDemoType2::k9_size() const {
  return _internal_k9_size();
}
inline void TestDemoType2::clear_k9() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k9_.Clear();
}
inline ::cfg::TestDemoE2* TestDemoType2::mutable_k9(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoType2.k9)
  return _internal_mutable_k9()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>* TestDemoType2::mutable_k9()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestDemoType2.k9)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k9();
}
inline const ::cfg::TestDemoE2& TestDemoType2::k9(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.k9)
  return _internal_k9().Get(index);
}
inline ::cfg::TestDemoE2* TestDemoType2::add_k9() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoE2* _add = _internal_mutable_k9()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestDemoType2.k9)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>& TestDemoType2::k9() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestDemoType2.k9)
  return _internal_k9();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>&
TestDemoType2::_internal_k9() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k9_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>*
TestDemoType2::_internal_mutable_k9() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k9_;
}

// repeated .cfg.TestDemoDynamic k15 = 22 [packed = false];
inline int TestDemoType2::_internal_k15_size() const {
  return _internal_k15().size();
}
inline int TestDemoType2::k15_size() const {
  return _internal_k15_size();
}
inline void TestDemoType2::clear_k15() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k15_.Clear();
}
inline ::cfg::TestDemoDynamic* TestDemoType2::mutable_k15(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoType2.k15)
  return _internal_mutable_k15()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>* TestDemoType2::mutable_k15()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestDemoType2.k15)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k15();
}
inline const ::cfg::TestDemoDynamic& TestDemoType2::k15(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType2.k15)
  return _internal_k15().Get(index);
}
inline ::cfg::TestDemoDynamic* TestDemoType2::add_k15() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoDynamic* _add = _internal_mutable_k15()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestDemoType2.k15)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>& TestDemoType2::k15() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestDemoType2.k15)
  return _internal_k15();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>&
TestDemoType2::_internal_k15() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k15_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>*
TestDemoType2::_internal_mutable_k15() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k15_;
}

// -------------------------------------------------------------------

// TestDemoType1

// int32 x1 = 1;
inline void TestDemoType1::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::int32_t TestDemoType1::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoType1.x1)
  return _internal_x1();
}
inline void TestDemoType1::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoType1.x1)
}
inline ::int32_t TestDemoType1::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestDemoType1::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// -------------------------------------------------------------------

// TestDemoDynamic

// .cfg.TestDemoD2 DemoD2 = 1;
inline bool TestDemoDynamic::has_demod2() const {
  return value_case() == kDemoD2;
}
inline bool TestDemoDynamic::_internal_has_demod2() const {
  return value_case() == kDemoD2;
}
inline void TestDemoDynamic::set_has_demod2() {
  _impl_._oneof_case_[0] = kDemoD2;
}
inline void TestDemoDynamic::clear_demod2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDemoD2) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.demod2_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestDemoD2* TestDemoDynamic::release_demod2() {
  // @@protoc_insertion_point(field_release:cfg.TestDemoDynamic.DemoD2)
  if (value_case() == kDemoD2) {
    clear_has_value();
    ::cfg::TestDemoD2* temp = _impl_.value_.demod2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.demod2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestDemoD2& TestDemoDynamic::_internal_demod2() const {
  return value_case() == kDemoD2 ? *_impl_.value_.demod2_ : reinterpret_cast<::cfg::TestDemoD2&>(::cfg::_TestDemoD2_default_instance_);
}
inline const ::cfg::TestDemoD2& TestDemoDynamic::demod2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoDynamic.DemoD2)
  return _internal_demod2();
}
inline ::cfg::TestDemoD2* TestDemoDynamic::unsafe_arena_release_demod2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestDemoDynamic.DemoD2)
  if (value_case() == kDemoD2) {
    clear_has_value();
    ::cfg::TestDemoD2* temp = _impl_.value_.demod2_;
    _impl_.value_.demod2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestDemoDynamic::unsafe_arena_set_allocated_demod2(::cfg::TestDemoD2* demod2) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (demod2) {
    set_has_demod2();
    _impl_.value_.demod2_ = demod2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoDynamic.DemoD2)
}
inline ::cfg::TestDemoD2* TestDemoDynamic::_internal_mutable_demod2() {
  if (value_case() != kDemoD2) {
    clear_value();
    set_has_demod2();
    _impl_.value_.demod2_ =
        CreateMaybeMessage<::cfg::TestDemoD2>(GetArenaForAllocation());
  }
  return _impl_.value_.demod2_;
}
inline ::cfg::TestDemoD2* TestDemoDynamic::mutable_demod2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoD2* _msg = _internal_mutable_demod2();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoDynamic.DemoD2)
  return _msg;
}

// .cfg.TestDemoE1 DemoE1 = 2;
inline bool TestDemoDynamic::has_demoe1() const {
  return value_case() == kDemoE1;
}
inline bool TestDemoDynamic::_internal_has_demoe1() const {
  return value_case() == kDemoE1;
}
inline void TestDemoDynamic::set_has_demoe1() {
  _impl_._oneof_case_[0] = kDemoE1;
}
inline void TestDemoDynamic::clear_demoe1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDemoE1) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.demoe1_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestDemoE1* TestDemoDynamic::release_demoe1() {
  // @@protoc_insertion_point(field_release:cfg.TestDemoDynamic.DemoE1)
  if (value_case() == kDemoE1) {
    clear_has_value();
    ::cfg::TestDemoE1* temp = _impl_.value_.demoe1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.demoe1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestDemoE1& TestDemoDynamic::_internal_demoe1() const {
  return value_case() == kDemoE1 ? *_impl_.value_.demoe1_ : reinterpret_cast<::cfg::TestDemoE1&>(::cfg::_TestDemoE1_default_instance_);
}
inline const ::cfg::TestDemoE1& TestDemoDynamic::demoe1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoDynamic.DemoE1)
  return _internal_demoe1();
}
inline ::cfg::TestDemoE1* TestDemoDynamic::unsafe_arena_release_demoe1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestDemoDynamic.DemoE1)
  if (value_case() == kDemoE1) {
    clear_has_value();
    ::cfg::TestDemoE1* temp = _impl_.value_.demoe1_;
    _impl_.value_.demoe1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestDemoDynamic::unsafe_arena_set_allocated_demoe1(::cfg::TestDemoE1* demoe1) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (demoe1) {
    set_has_demoe1();
    _impl_.value_.demoe1_ = demoe1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoDynamic.DemoE1)
}
inline ::cfg::TestDemoE1* TestDemoDynamic::_internal_mutable_demoe1() {
  if (value_case() != kDemoE1) {
    clear_value();
    set_has_demoe1();
    _impl_.value_.demoe1_ =
        CreateMaybeMessage<::cfg::TestDemoE1>(GetArenaForAllocation());
  }
  return _impl_.value_.demoe1_;
}
inline ::cfg::TestDemoE1* TestDemoDynamic::mutable_demoe1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoE1* _msg = _internal_mutable_demoe1();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoDynamic.DemoE1)
  return _msg;
}

// .cfg.TestLoginRoleInfo RoleInfo = 3;
inline bool TestDemoDynamic::has_roleinfo() const {
  return value_case() == kRoleInfo;
}
inline bool TestDemoDynamic::_internal_has_roleinfo() const {
  return value_case() == kRoleInfo;
}
inline void TestDemoDynamic::set_has_roleinfo() {
  _impl_._oneof_case_[0] = kRoleInfo;
}
inline void TestDemoDynamic::clear_roleinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kRoleInfo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.roleinfo_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestLoginRoleInfo* TestDemoDynamic::release_roleinfo() {
  // @@protoc_insertion_point(field_release:cfg.TestDemoDynamic.RoleInfo)
  if (value_case() == kRoleInfo) {
    clear_has_value();
    ::cfg::TestLoginRoleInfo* temp = _impl_.value_.roleinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.roleinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestLoginRoleInfo& TestDemoDynamic::_internal_roleinfo() const {
  return value_case() == kRoleInfo ? *_impl_.value_.roleinfo_ : reinterpret_cast<::cfg::TestLoginRoleInfo&>(::cfg::_TestLoginRoleInfo_default_instance_);
}
inline const ::cfg::TestLoginRoleInfo& TestDemoDynamic::roleinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoDynamic.RoleInfo)
  return _internal_roleinfo();
}
inline ::cfg::TestLoginRoleInfo* TestDemoDynamic::unsafe_arena_release_roleinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestDemoDynamic.RoleInfo)
  if (value_case() == kRoleInfo) {
    clear_has_value();
    ::cfg::TestLoginRoleInfo* temp = _impl_.value_.roleinfo_;
    _impl_.value_.roleinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestDemoDynamic::unsafe_arena_set_allocated_roleinfo(::cfg::TestLoginRoleInfo* roleinfo) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (roleinfo) {
    set_has_roleinfo();
    _impl_.value_.roleinfo_ = roleinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoDynamic.RoleInfo)
}
inline ::cfg::TestLoginRoleInfo* TestDemoDynamic::_internal_mutable_roleinfo() {
  if (value_case() != kRoleInfo) {
    clear_value();
    set_has_roleinfo();
    _impl_.value_.roleinfo_ =
        CreateMaybeMessage<::cfg::TestLoginRoleInfo>(GetArenaForAllocation());
  }
  return _impl_.value_.roleinfo_;
}
inline ::cfg::TestLoginRoleInfo* TestDemoDynamic::mutable_roleinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestLoginRoleInfo* _msg = _internal_mutable_roleinfo();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoDynamic.RoleInfo)
  return _msg;
}

// .cfg.TestDemoD5 DemoD5 = 4;
inline bool TestDemoDynamic::has_demod5() const {
  return value_case() == kDemoD5;
}
inline bool TestDemoDynamic::_internal_has_demod5() const {
  return value_case() == kDemoD5;
}
inline void TestDemoDynamic::set_has_demod5() {
  _impl_._oneof_case_[0] = kDemoD5;
}
inline void TestDemoDynamic::clear_demod5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDemoD5) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.demod5_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestDemoD5* TestDemoDynamic::release_demod5() {
  // @@protoc_insertion_point(field_release:cfg.TestDemoDynamic.DemoD5)
  if (value_case() == kDemoD5) {
    clear_has_value();
    ::cfg::TestDemoD5* temp = _impl_.value_.demod5_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.demod5_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestDemoD5& TestDemoDynamic::_internal_demod5() const {
  return value_case() == kDemoD5 ? *_impl_.value_.demod5_ : reinterpret_cast<::cfg::TestDemoD5&>(::cfg::_TestDemoD5_default_instance_);
}
inline const ::cfg::TestDemoD5& TestDemoDynamic::demod5() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoDynamic.DemoD5)
  return _internal_demod5();
}
inline ::cfg::TestDemoD5* TestDemoDynamic::unsafe_arena_release_demod5() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestDemoDynamic.DemoD5)
  if (value_case() == kDemoD5) {
    clear_has_value();
    ::cfg::TestDemoD5* temp = _impl_.value_.demod5_;
    _impl_.value_.demod5_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestDemoDynamic::unsafe_arena_set_allocated_demod5(::cfg::TestDemoD5* demod5) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (demod5) {
    set_has_demod5();
    _impl_.value_.demod5_ = demod5;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoDynamic.DemoD5)
}
inline ::cfg::TestDemoD5* TestDemoDynamic::_internal_mutable_demod5() {
  if (value_case() != kDemoD5) {
    clear_value();
    set_has_demod5();
    _impl_.value_.demod5_ =
        CreateMaybeMessage<::cfg::TestDemoD5>(GetArenaForAllocation());
  }
  return _impl_.value_.demod5_;
}
inline ::cfg::TestDemoD5* TestDemoDynamic::mutable_demod5() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoD5* _msg = _internal_mutable_demod5();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoDynamic.DemoD5)
  return _msg;
}

inline bool TestDemoDynamic::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TestDemoDynamic::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline TestDemoDynamic::ValueCase TestDemoDynamic::value_case() const {
  return TestDemoDynamic::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestDemoD2

// int32 x1 = 1;
inline void TestDemoD2::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::int32_t TestDemoD2::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoD2.x1)
  return _internal_x1();
}
inline void TestDemoD2::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoD2.x1)
}
inline ::int32_t TestDemoD2::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestDemoD2::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int32 x2 = 2;
inline void TestDemoD2::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_ = 0;
}
inline ::int32_t TestDemoD2::x2() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoD2.x2)
  return _internal_x2();
}
inline void TestDemoD2::set_x2(::int32_t value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoD2.x2)
}
inline ::int32_t TestDemoD2::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline void TestDemoD2::_internal_set_x2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x2_ = value;
}

// -------------------------------------------------------------------

// TestDemoD3

// .cfg.TestDemoE1 DemoE1 = 2;
inline bool TestDemoD3::has_demoe1() const {
  return value_case() == kDemoE1;
}
inline bool TestDemoD3::_internal_has_demoe1() const {
  return value_case() == kDemoE1;
}
inline void TestDemoD3::set_has_demoe1() {
  _impl_._oneof_case_[0] = kDemoE1;
}
inline void TestDemoD3::clear_demoe1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDemoE1) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.demoe1_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestDemoE1* TestDemoD3::release_demoe1() {
  // @@protoc_insertion_point(field_release:cfg.TestDemoD3.DemoE1)
  if (value_case() == kDemoE1) {
    clear_has_value();
    ::cfg::TestDemoE1* temp = _impl_.value_.demoe1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.demoe1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestDemoE1& TestDemoD3::_internal_demoe1() const {
  return value_case() == kDemoE1 ? *_impl_.value_.demoe1_ : reinterpret_cast<::cfg::TestDemoE1&>(::cfg::_TestDemoE1_default_instance_);
}
inline const ::cfg::TestDemoE1& TestDemoD3::demoe1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoD3.DemoE1)
  return _internal_demoe1();
}
inline ::cfg::TestDemoE1* TestDemoD3::unsafe_arena_release_demoe1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestDemoD3.DemoE1)
  if (value_case() == kDemoE1) {
    clear_has_value();
    ::cfg::TestDemoE1* temp = _impl_.value_.demoe1_;
    _impl_.value_.demoe1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestDemoD3::unsafe_arena_set_allocated_demoe1(::cfg::TestDemoE1* demoe1) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (demoe1) {
    set_has_demoe1();
    _impl_.value_.demoe1_ = demoe1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoD3.DemoE1)
}
inline ::cfg::TestDemoE1* TestDemoD3::_internal_mutable_demoe1() {
  if (value_case() != kDemoE1) {
    clear_value();
    set_has_demoe1();
    _impl_.value_.demoe1_ =
        CreateMaybeMessage<::cfg::TestDemoE1>(GetArenaForAllocation());
  }
  return _impl_.value_.demoe1_;
}
inline ::cfg::TestDemoE1* TestDemoD3::mutable_demoe1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoE1* _msg = _internal_mutable_demoe1();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoD3.DemoE1)
  return _msg;
}

// .cfg.TestLoginRoleInfo RoleInfo = 3;
inline bool TestDemoD3::has_roleinfo() const {
  return value_case() == kRoleInfo;
}
inline bool TestDemoD3::_internal_has_roleinfo() const {
  return value_case() == kRoleInfo;
}
inline void TestDemoD3::set_has_roleinfo() {
  _impl_._oneof_case_[0] = kRoleInfo;
}
inline void TestDemoD3::clear_roleinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kRoleInfo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.roleinfo_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestLoginRoleInfo* TestDemoD3::release_roleinfo() {
  // @@protoc_insertion_point(field_release:cfg.TestDemoD3.RoleInfo)
  if (value_case() == kRoleInfo) {
    clear_has_value();
    ::cfg::TestLoginRoleInfo* temp = _impl_.value_.roleinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.roleinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestLoginRoleInfo& TestDemoD3::_internal_roleinfo() const {
  return value_case() == kRoleInfo ? *_impl_.value_.roleinfo_ : reinterpret_cast<::cfg::TestLoginRoleInfo&>(::cfg::_TestLoginRoleInfo_default_instance_);
}
inline const ::cfg::TestLoginRoleInfo& TestDemoD3::roleinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoD3.RoleInfo)
  return _internal_roleinfo();
}
inline ::cfg::TestLoginRoleInfo* TestDemoD3::unsafe_arena_release_roleinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestDemoD3.RoleInfo)
  if (value_case() == kRoleInfo) {
    clear_has_value();
    ::cfg::TestLoginRoleInfo* temp = _impl_.value_.roleinfo_;
    _impl_.value_.roleinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestDemoD3::unsafe_arena_set_allocated_roleinfo(::cfg::TestLoginRoleInfo* roleinfo) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (roleinfo) {
    set_has_roleinfo();
    _impl_.value_.roleinfo_ = roleinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoD3.RoleInfo)
}
inline ::cfg::TestLoginRoleInfo* TestDemoD3::_internal_mutable_roleinfo() {
  if (value_case() != kRoleInfo) {
    clear_value();
    set_has_roleinfo();
    _impl_.value_.roleinfo_ =
        CreateMaybeMessage<::cfg::TestLoginRoleInfo>(GetArenaForAllocation());
  }
  return _impl_.value_.roleinfo_;
}
inline ::cfg::TestLoginRoleInfo* TestDemoD3::mutable_roleinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestLoginRoleInfo* _msg = _internal_mutable_roleinfo();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoD3.RoleInfo)
  return _msg;
}

inline bool TestDemoD3::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TestDemoD3::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline TestDemoD3::ValueCase TestDemoD3::value_case() const {
  return TestDemoD3::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestDemoE1

// int32 x1 = 1;
inline void TestDemoE1::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::int32_t TestDemoE1::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoE1.x1)
  return _internal_x1();
}
inline void TestDemoE1::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoE1.x1)
}
inline ::int32_t TestDemoE1::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestDemoE1::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int32 x3 = 2;
inline void TestDemoE1::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_ = 0;
}
inline ::int32_t TestDemoE1::x3() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoE1.x3)
  return _internal_x3();
}
inline void TestDemoE1::set_x3(::int32_t value) {
  _internal_set_x3(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoE1.x3)
}
inline ::int32_t TestDemoE1::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline void TestDemoE1::_internal_set_x3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x3_ = value;
}

// int32 x4 = 3;
inline void TestDemoE1::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_ = 0;
}
inline ::int32_t TestDemoE1::x4() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoE1.x4)
  return _internal_x4();
}
inline void TestDemoE1::set_x4(::int32_t value) {
  _internal_set_x4(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoE1.x4)
}
inline ::int32_t TestDemoE1::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline void TestDemoE1::_internal_set_x4(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x4_ = value;
}

// -------------------------------------------------------------------

// TestLoginRoleInfo

// int32 x1 = 1;
inline void TestLoginRoleInfo::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::int32_t TestLoginRoleInfo::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestLoginRoleInfo.x1)
  return _internal_x1();
}
inline void TestLoginRoleInfo::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestLoginRoleInfo.x1)
}
inline ::int32_t TestLoginRoleInfo::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestLoginRoleInfo::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int32 x3 = 2;
inline void TestLoginRoleInfo::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_ = 0;
}
inline ::int32_t TestLoginRoleInfo::x3() const {
  // @@protoc_insertion_point(field_get:cfg.TestLoginRoleInfo.x3)
  return _internal_x3();
}
inline void TestLoginRoleInfo::set_x3(::int32_t value) {
  _internal_set_x3(value);
  // @@protoc_insertion_point(field_set:cfg.TestLoginRoleInfo.x3)
}
inline ::int32_t TestLoginRoleInfo::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline void TestLoginRoleInfo::_internal_set_x3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x3_ = value;
}

// int64 role_id = 3;
inline void TestLoginRoleInfo::clear_role_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.role_id_ = ::int64_t{0};
}
inline ::int64_t TestLoginRoleInfo::role_id() const {
  // @@protoc_insertion_point(field_get:cfg.TestLoginRoleInfo.role_id)
  return _internal_role_id();
}
inline void TestLoginRoleInfo::set_role_id(::int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestLoginRoleInfo.role_id)
}
inline ::int64_t TestLoginRoleInfo::_internal_role_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.role_id_;
}
inline void TestLoginRoleInfo::_internal_set_role_id(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.role_id_ = value;
}

// -------------------------------------------------------------------

// TestDemoD5

// int32 x1 = 1;
inline void TestDemoD5::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::int32_t TestDemoD5::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoD5.x1)
  return _internal_x1();
}
inline void TestDemoD5::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoD5.x1)
}
inline ::int32_t TestDemoD5::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestDemoD5::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// .cfg.TestDateTimeRange time = 2;
inline bool TestDemoD5::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline void TestDemoD5::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestDateTimeRange& TestDemoD5::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDateTimeRange* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDateTimeRange&>(::cfg::_TestDateTimeRange_default_instance_);
}
inline const ::cfg::TestDateTimeRange& TestDemoD5::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoD5.time)
  return _internal_time();
}
inline void TestDemoD5::unsafe_arena_set_allocated_time(::cfg::TestDateTimeRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::cfg::TestDateTimeRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoD5.time)
}
inline ::cfg::TestDateTimeRange* TestDemoD5::release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDateTimeRange* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDateTimeRange* TestDemoD5::unsafe_arena_release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoD5.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDateTimeRange* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::cfg::TestDateTimeRange* TestDemoD5::_internal_mutable_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDateTimeRange>(GetArenaForAllocation());
    _impl_.time_ = reinterpret_cast<::cfg::TestDateTimeRange*>(p);
  }
  return _impl_.time_;
}
inline ::cfg::TestDateTimeRange* TestDemoD5::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDateTimeRange* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoD5.time)
  return _msg;
}
inline void TestDemoD5::set_allocated_time(::cfg::TestDateTimeRange* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDateTimeRange*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDateTimeRange*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::cfg::TestDateTimeRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoD5.time)
}

// -------------------------------------------------------------------

// TestDateTimeRange

// int64 start_time = 1;
inline void TestDateTimeRange::clear_start_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t TestDateTimeRange::start_time() const {
  // @@protoc_insertion_point(field_get:cfg.TestDateTimeRange.start_time)
  return _internal_start_time();
}
inline void TestDateTimeRange::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:cfg.TestDateTimeRange.start_time)
}
inline ::int64_t TestDateTimeRange::_internal_start_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_time_;
}
inline void TestDateTimeRange::_internal_set_start_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_time_ = value;
}

// int64 end_time = 2;
inline void TestDateTimeRange::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t TestDateTimeRange::end_time() const {
  // @@protoc_insertion_point(field_get:cfg.TestDateTimeRange.end_time)
  return _internal_end_time();
}
inline void TestDateTimeRange::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:cfg.TestDateTimeRange.end_time)
}
inline ::int64_t TestDateTimeRange::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void TestDateTimeRange::_internal_set_end_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_time_ = value;
}

// -------------------------------------------------------------------

// TestDemoE2

// optional int32 y1 = 1;
inline bool TestDemoE2::has_y1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TestDemoE2::clear_y1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t TestDemoE2::y1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoE2.y1)
  return _internal_y1();
}
inline void TestDemoE2::set_y1(::int32_t value) {
  _internal_set_y1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoE2.y1)
}
inline ::int32_t TestDemoE2::_internal_y1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y1_;
}
inline void TestDemoE2::_internal_set_y1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.y1_ = value;
}

// bool y2 = 2;
inline void TestDemoE2::clear_y2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y2_ = false;
}
inline bool TestDemoE2::y2() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoE2.y2)
  return _internal_y2();
}
inline void TestDemoE2::set_y2(bool value) {
  _internal_set_y2(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoE2.y2)
}
inline bool TestDemoE2::_internal_y2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y2_;
}
inline void TestDemoE2::_internal_set_y2(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y2_ = value;
}

// -------------------------------------------------------------------

// TestDemoSingletonType

// int32 id = 1;
inline void TestDemoSingletonType::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestDemoSingletonType::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoSingletonType.id)
  return _internal_id();
}
inline void TestDemoSingletonType::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoSingletonType.id)
}
inline ::int32_t TestDemoSingletonType::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestDemoSingletonType::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void TestDemoSingletonType::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestDemoSingletonType::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoSingletonType.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDemoSingletonType::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDemoSingletonType.name)
}
inline std::string* TestDemoSingletonType::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoSingletonType.name)
  return _s;
}
inline const std::string& TestDemoSingletonType::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TestDemoSingletonType::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDemoSingletonType::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDemoSingletonType::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoSingletonType.name)
  return _impl_.name_.Release();
}
inline void TestDemoSingletonType::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoSingletonType.name)
}

// .cfg.TestDemoDynamic date = 3;
inline bool TestDemoSingletonType::has_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.date_ != nullptr);
  return value;
}
inline void TestDemoSingletonType::clear_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.date_ != nullptr) _impl_.date_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestDemoDynamic& TestDemoSingletonType::_internal_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoDynamic* p = _impl_.date_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoDynamic&>(::cfg::_TestDemoDynamic_default_instance_);
}
inline const ::cfg::TestDemoDynamic& TestDemoSingletonType::date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoSingletonType.date)
  return _internal_date();
}
inline void TestDemoSingletonType::unsafe_arena_set_allocated_date(::cfg::TestDemoDynamic* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.date_);
  }
  _impl_.date_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoSingletonType.date)
}
inline ::cfg::TestDemoDynamic* TestDemoSingletonType::release_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoDynamic* released = _impl_.date_;
  _impl_.date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoDynamic* TestDemoSingletonType::unsafe_arena_release_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoSingletonType.date)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoDynamic* temp = _impl_.date_;
  _impl_.date_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoDynamic* TestDemoSingletonType::_internal_mutable_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.date_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoDynamic>(GetArenaForAllocation());
    _impl_.date_ = reinterpret_cast<::cfg::TestDemoDynamic*>(p);
  }
  return _impl_.date_;
}
inline ::cfg::TestDemoDynamic* TestDemoSingletonType::mutable_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoDynamic* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoSingletonType.date)
  return _msg;
}
inline void TestDemoSingletonType::set_allocated_date(::cfg::TestDemoDynamic* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoDynamic*>(_impl_.date_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoDynamic*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.date_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoSingletonType.date)
}

// -------------------------------------------------------------------

// TestNotIndexList

// int32 x = 1;
inline void TestNotIndexList::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t TestNotIndexList::x() const {
  // @@protoc_insertion_point(field_get:cfg.TestNotIndexList.x)
  return _internal_x();
}
inline void TestNotIndexList::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.TestNotIndexList.x)
}
inline ::int32_t TestNotIndexList::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TestNotIndexList::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// int32 y = 2;
inline void TestNotIndexList::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t TestNotIndexList::y() const {
  // @@protoc_insertion_point(field_get:cfg.TestNotIndexList.y)
  return _internal_y();
}
inline void TestNotIndexList::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.TestNotIndexList.y)
}
inline ::int32_t TestNotIndexList::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void TestNotIndexList::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TestMultiUnionIndexList

// int32 id1 = 1;
inline void TestMultiUnionIndexList::clear_id1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id1_ = 0;
}
inline ::int32_t TestMultiUnionIndexList::id1() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiUnionIndexList.id1)
  return _internal_id1();
}
inline void TestMultiUnionIndexList::set_id1(::int32_t value) {
  _internal_set_id1(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiUnionIndexList.id1)
}
inline ::int32_t TestMultiUnionIndexList::_internal_id1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id1_;
}
inline void TestMultiUnionIndexList::_internal_set_id1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id1_ = value;
}

// int64 id2 = 2;
inline void TestMultiUnionIndexList::clear_id2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id2_ = ::int64_t{0};
}
inline ::int64_t TestMultiUnionIndexList::id2() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiUnionIndexList.id2)
  return _internal_id2();
}
inline void TestMultiUnionIndexList::set_id2(::int64_t value) {
  _internal_set_id2(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiUnionIndexList.id2)
}
inline ::int64_t TestMultiUnionIndexList::_internal_id2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id2_;
}
inline void TestMultiUnionIndexList::_internal_set_id2(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id2_ = value;
}

// string id3 = 3;
inline void TestMultiUnionIndexList::clear_id3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id3_.ClearToEmpty();
}
inline const std::string& TestMultiUnionIndexList::id3() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiUnionIndexList.id3)
  return _internal_id3();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMultiUnionIndexList::set_id3(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id3_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestMultiUnionIndexList.id3)
}
inline std::string* TestMultiUnionIndexList::mutable_id3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id3();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiUnionIndexList.id3)
  return _s;
}
inline const std::string& TestMultiUnionIndexList::_internal_id3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id3_.Get();
}
inline void TestMultiUnionIndexList::_internal_set_id3(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id3_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMultiUnionIndexList::_internal_mutable_id3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id3_.Mutable( GetArenaForAllocation());
}
inline std::string* TestMultiUnionIndexList::release_id3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiUnionIndexList.id3)
  return _impl_.id3_.Release();
}
inline void TestMultiUnionIndexList::set_allocated_id3(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id3_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id3_.IsDefault()) {
          _impl_.id3_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiUnionIndexList.id3)
}

// int32 num = 4;
inline void TestMultiUnionIndexList::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
}
inline ::int32_t TestMultiUnionIndexList::num() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiUnionIndexList.num)
  return _internal_num();
}
inline void TestMultiUnionIndexList::set_num(::int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiUnionIndexList.num)
}
inline ::int32_t TestMultiUnionIndexList::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void TestMultiUnionIndexList::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_ = value;
}

// string desc = 5;
inline void TestMultiUnionIndexList::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& TestMultiUnionIndexList::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiUnionIndexList.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMultiUnionIndexList::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestMultiUnionIndexList.desc)
}
inline std::string* TestMultiUnionIndexList::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiUnionIndexList.desc)
  return _s;
}
inline const std::string& TestMultiUnionIndexList::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void TestMultiUnionIndexList::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMultiUnionIndexList::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* TestMultiUnionIndexList::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiUnionIndexList.desc)
  return _impl_.desc_.Release();
}
inline void TestMultiUnionIndexList::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiUnionIndexList.desc)
}

// -------------------------------------------------------------------

// TestMultiIndexList

// int32 id1 = 1;
inline void TestMultiIndexList::clear_id1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id1_ = 0;
}
inline ::int32_t TestMultiIndexList::id1() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiIndexList.id1)
  return _internal_id1();
}
inline void TestMultiIndexList::set_id1(::int32_t value) {
  _internal_set_id1(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiIndexList.id1)
}
inline ::int32_t TestMultiIndexList::_internal_id1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id1_;
}
inline void TestMultiIndexList::_internal_set_id1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id1_ = value;
}

// int64 id2 = 2;
inline void TestMultiIndexList::clear_id2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id2_ = ::int64_t{0};
}
inline ::int64_t TestMultiIndexList::id2() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiIndexList.id2)
  return _internal_id2();
}
inline void TestMultiIndexList::set_id2(::int64_t value) {
  _internal_set_id2(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiIndexList.id2)
}
inline ::int64_t TestMultiIndexList::_internal_id2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id2_;
}
inline void TestMultiIndexList::_internal_set_id2(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id2_ = value;
}

// string id3 = 3;
inline void TestMultiIndexList::clear_id3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id3_.ClearToEmpty();
}
inline const std::string& TestMultiIndexList::id3() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiIndexList.id3)
  return _internal_id3();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMultiIndexList::set_id3(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id3_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestMultiIndexList.id3)
}
inline std::string* TestMultiIndexList::mutable_id3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id3();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiIndexList.id3)
  return _s;
}
inline const std::string& TestMultiIndexList::_internal_id3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id3_.Get();
}
inline void TestMultiIndexList::_internal_set_id3(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id3_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMultiIndexList::_internal_mutable_id3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id3_.Mutable( GetArenaForAllocation());
}
inline std::string* TestMultiIndexList::release_id3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiIndexList.id3)
  return _impl_.id3_.Release();
}
inline void TestMultiIndexList::set_allocated_id3(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id3_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id3_.IsDefault()) {
          _impl_.id3_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiIndexList.id3)
}

// int32 num = 4;
inline void TestMultiIndexList::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
}
inline ::int32_t TestMultiIndexList::num() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiIndexList.num)
  return _internal_num();
}
inline void TestMultiIndexList::set_num(::int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiIndexList.num)
}
inline ::int32_t TestMultiIndexList::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void TestMultiIndexList::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_ = value;
}

// string desc = 5;
inline void TestMultiIndexList::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& TestMultiIndexList::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiIndexList.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMultiIndexList::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestMultiIndexList.desc)
}
inline std::string* TestMultiIndexList::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiIndexList.desc)
  return _s;
}
inline const std::string& TestMultiIndexList::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void TestMultiIndexList::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMultiIndexList::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* TestMultiIndexList::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiIndexList.desc)
  return _impl_.desc_.Release();
}
inline void TestMultiIndexList::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiIndexList.desc)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestMultiRowRecord

// int32 id = 1;
inline void TestMultiRowRecord::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestMultiRowRecord::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowRecord.id)
  return _internal_id();
}
inline void TestMultiRowRecord::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowRecord.id)
}
inline ::int32_t TestMultiRowRecord::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestMultiRowRecord::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void TestMultiRowRecord::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestMultiRowRecord::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowRecord.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMultiRowRecord::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowRecord.name)
}
inline std::string* TestMultiRowRecord::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowRecord.name)
  return _s;
}
inline const std::string& TestMultiRowRecord::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TestMultiRowRecord::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMultiRowRecord::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestMultiRowRecord::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiRowRecord.name)
  return _impl_.name_.Release();
}
inline void TestMultiRowRecord::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiRowRecord.name)
}

// repeated .cfg.TestMultiRowType1 one_rows = 3 [packed = false];
inline int TestMultiRowRecord::_internal_one_rows_size() const {
  return _internal_one_rows().size();
}
inline int TestMultiRowRecord::one_rows_size() const {
  return _internal_one_rows_size();
}
inline void TestMultiRowRecord::clear_one_rows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.one_rows_.Clear();
}
inline ::cfg::TestMultiRowType1* TestMultiRowRecord::mutable_one_rows(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowRecord.one_rows)
  return _internal_mutable_one_rows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* TestMultiRowRecord::mutable_one_rows()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowRecord.one_rows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_one_rows();
}
inline const ::cfg::TestMultiRowType1& TestMultiRowRecord::one_rows(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowRecord.one_rows)
  return _internal_one_rows().Get(index);
}
inline ::cfg::TestMultiRowType1* TestMultiRowRecord::add_one_rows() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiRowType1* _add = _internal_mutable_one_rows()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowRecord.one_rows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& TestMultiRowRecord::one_rows() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowRecord.one_rows)
  return _internal_one_rows();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>&
TestMultiRowRecord::_internal_one_rows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.one_rows_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>*
TestMultiRowRecord::_internal_mutable_one_rows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.one_rows_;
}

// repeated .cfg.TestMultiRowType1 multi_rows1 = 4 [packed = false];
inline int TestMultiRowRecord::_internal_multi_rows1_size() const {
  return _internal_multi_rows1().size();
}
inline int TestMultiRowRecord::multi_rows1_size() const {
  return _internal_multi_rows1_size();
}
inline void TestMultiRowRecord::clear_multi_rows1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multi_rows1_.Clear();
}
inline ::cfg::TestMultiRowType1* TestMultiRowRecord::mutable_multi_rows1(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowRecord.multi_rows1)
  return _internal_mutable_multi_rows1()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* TestMultiRowRecord::mutable_multi_rows1()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowRecord.multi_rows1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_multi_rows1();
}
inline const ::cfg::TestMultiRowType1& TestMultiRowRecord::multi_rows1(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowRecord.multi_rows1)
  return _internal_multi_rows1().Get(index);
}
inline ::cfg::TestMultiRowType1* TestMultiRowRecord::add_multi_rows1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiRowType1* _add = _internal_mutable_multi_rows1()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowRecord.multi_rows1)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& TestMultiRowRecord::multi_rows1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowRecord.multi_rows1)
  return _internal_multi_rows1();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>&
TestMultiRowRecord::_internal_multi_rows1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multi_rows1_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>*
TestMultiRowRecord::_internal_mutable_multi_rows1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.multi_rows1_;
}

// repeated .cfg.TestMultiRowType1 multi_rows2 = 5 [packed = false];
inline int TestMultiRowRecord::_internal_multi_rows2_size() const {
  return _internal_multi_rows2().size();
}
inline int TestMultiRowRecord::multi_rows2_size() const {
  return _internal_multi_rows2_size();
}
inline void TestMultiRowRecord::clear_multi_rows2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multi_rows2_.Clear();
}
inline ::cfg::TestMultiRowType1* TestMultiRowRecord::mutable_multi_rows2(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowRecord.multi_rows2)
  return _internal_mutable_multi_rows2()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* TestMultiRowRecord::mutable_multi_rows2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowRecord.multi_rows2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_multi_rows2();
}
inline const ::cfg::TestMultiRowType1& TestMultiRowRecord::multi_rows2(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowRecord.multi_rows2)
  return _internal_multi_rows2().Get(index);
}
inline ::cfg::TestMultiRowType1* TestMultiRowRecord::add_multi_rows2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiRowType1* _add = _internal_mutable_multi_rows2()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowRecord.multi_rows2)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& TestMultiRowRecord::multi_rows2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowRecord.multi_rows2)
  return _internal_multi_rows2();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>&
TestMultiRowRecord::_internal_multi_rows2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multi_rows2_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>*
TestMultiRowRecord::_internal_mutable_multi_rows2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.multi_rows2_;
}

// map<int32, .cfg.TestMultiRowType2> multi_rows4 = 6;
inline int TestMultiRowRecord::_internal_multi_rows4_size() const {
  return _internal_multi_rows4().size();
}
inline int TestMultiRowRecord::multi_rows4_size() const {
  return _internal_multi_rows4_size();
}
inline void TestMultiRowRecord::clear_multi_rows4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multi_rows4_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& TestMultiRowRecord::_internal_multi_rows4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multi_rows4_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& TestMultiRowRecord::multi_rows4() const {
  // @@protoc_insertion_point(field_map:cfg.TestMultiRowRecord.multi_rows4)
  return _internal_multi_rows4();
}
inline ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* TestMultiRowRecord::_internal_mutable_multi_rows4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.multi_rows4_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* TestMultiRowRecord::mutable_multi_rows4() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestMultiRowRecord.multi_rows4)
  return _internal_mutable_multi_rows4();
}

// repeated .cfg.TestMultiRowType3 multi_rows5 = 7 [packed = false];
inline int TestMultiRowRecord::_internal_multi_rows5_size() const {
  return _internal_multi_rows5().size();
}
inline int TestMultiRowRecord::multi_rows5_size() const {
  return _internal_multi_rows5_size();
}
inline void TestMultiRowRecord::clear_multi_rows5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multi_rows5_.Clear();
}
inline ::cfg::TestMultiRowType3* TestMultiRowRecord::mutable_multi_rows5(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowRecord.multi_rows5)
  return _internal_mutable_multi_rows5()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType3>* TestMultiRowRecord::mutable_multi_rows5()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowRecord.multi_rows5)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_multi_rows5();
}
inline const ::cfg::TestMultiRowType3& TestMultiRowRecord::multi_rows5(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowRecord.multi_rows5)
  return _internal_multi_rows5().Get(index);
}
inline ::cfg::TestMultiRowType3* TestMultiRowRecord::add_multi_rows5() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiRowType3* _add = _internal_mutable_multi_rows5()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowRecord.multi_rows5)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType3>& TestMultiRowRecord::multi_rows5() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowRecord.multi_rows5)
  return _internal_multi_rows5();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType3>&
TestMultiRowRecord::_internal_multi_rows5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multi_rows5_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType3>*
TestMultiRowRecord::_internal_mutable_multi_rows5() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.multi_rows5_;
}

// map<int32, .cfg.TestMultiRowType2> multi_rows6 = 8;
inline int TestMultiRowRecord::_internal_multi_rows6_size() const {
  return _internal_multi_rows6().size();
}
inline int TestMultiRowRecord::multi_rows6_size() const {
  return _internal_multi_rows6_size();
}
inline void TestMultiRowRecord::clear_multi_rows6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multi_rows6_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& TestMultiRowRecord::_internal_multi_rows6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multi_rows6_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>& TestMultiRowRecord::multi_rows6() const {
  // @@protoc_insertion_point(field_map:cfg.TestMultiRowRecord.multi_rows6)
  return _internal_multi_rows6();
}
inline ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* TestMultiRowRecord::_internal_mutable_multi_rows6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.multi_rows6_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::cfg::TestMultiRowType2>* TestMultiRowRecord::mutable_multi_rows6() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestMultiRowRecord.multi_rows6)
  return _internal_mutable_multi_rows6();
}

// map<int32, int32> multi_rows7 = 9;
inline int TestMultiRowRecord::_internal_multi_rows7_size() const {
  return _internal_multi_rows7().size();
}
inline int TestMultiRowRecord::multi_rows7_size() const {
  return _internal_multi_rows7_size();
}
inline void TestMultiRowRecord::clear_multi_rows7() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multi_rows7_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestMultiRowRecord::_internal_multi_rows7() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multi_rows7_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestMultiRowRecord::multi_rows7() const {
  // @@protoc_insertion_point(field_map:cfg.TestMultiRowRecord.multi_rows7)
  return _internal_multi_rows7();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestMultiRowRecord::_internal_mutable_multi_rows7() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.multi_rows7_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestMultiRowRecord::mutable_multi_rows7() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestMultiRowRecord.multi_rows7)
  return _internal_mutable_multi_rows7();
}

// -------------------------------------------------------------------

// TestMultiRowType1

// int32 id = 1;
inline void TestMultiRowType1::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestMultiRowType1::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowType1.id)
  return _internal_id();
}
inline void TestMultiRowType1::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowType1.id)
}
inline ::int32_t TestMultiRowType1::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestMultiRowType1::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 x = 2;
inline void TestMultiRowType1::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t TestMultiRowType1::x() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowType1.x)
  return _internal_x();
}
inline void TestMultiRowType1::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowType1.x)
}
inline ::int32_t TestMultiRowType1::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TestMultiRowType1::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// -------------------------------------------------------------------

// TestMultiRowType2

// int32 id = 1;
inline void TestMultiRowType2::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestMultiRowType2::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowType2.id)
  return _internal_id();
}
inline void TestMultiRowType2::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowType2.id)
}
inline ::int32_t TestMultiRowType2::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestMultiRowType2::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 x = 2;
inline void TestMultiRowType2::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t TestMultiRowType2::x() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowType2.x)
  return _internal_x();
}
inline void TestMultiRowType2::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowType2.x)
}
inline ::int32_t TestMultiRowType2::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TestMultiRowType2::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 3;
inline void TestMultiRowType2::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float TestMultiRowType2::y() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowType2.y)
  return _internal_y();
}
inline void TestMultiRowType2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowType2.y)
}
inline float TestMultiRowType2::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void TestMultiRowType2::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TestMultiRowType3

// int32 id = 1;
inline void TestMultiRowType3::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestMultiRowType3::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowType3.id)
  return _internal_id();
}
inline void TestMultiRowType3::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowType3.id)
}
inline ::int32_t TestMultiRowType3::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestMultiRowType3::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// repeated .cfg.TestMultiRowType1 items = 2 [packed = false];
inline int TestMultiRowType3::_internal_items_size() const {
  return _internal_items().size();
}
inline int TestMultiRowType3::items_size() const {
  return _internal_items_size();
}
inline void TestMultiRowType3::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::cfg::TestMultiRowType1* TestMultiRowType3::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowType3.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>* TestMultiRowType3::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowType3.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::cfg::TestMultiRowType1& TestMultiRowType3::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowType3.items)
  return _internal_items().Get(index);
}
inline ::cfg::TestMultiRowType1* TestMultiRowType3::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiRowType1* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowType3.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>& TestMultiRowType3::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowType3.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>&
TestMultiRowType3::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowType1>*
TestMultiRowType3::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// TestTestMultiColumn

// int32 id = 1;
inline void TestTestMultiColumn::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestMultiColumn::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestMultiColumn.id)
  return _internal_id();
}
inline void TestTestMultiColumn::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestMultiColumn.id)
}
inline ::int32_t TestTestMultiColumn::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestMultiColumn::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .cfg.TestFoo a = 2;
inline bool TestTestMultiColumn::has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.a_ != nullptr);
  return value;
}
inline void TestTestMultiColumn::clear_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.a_ != nullptr) _impl_.a_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestFoo& TestTestMultiColumn::_internal_a() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestFoo* p = _impl_.a_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestFoo&>(::cfg::_TestFoo_default_instance_);
}
inline const ::cfg::TestFoo& TestTestMultiColumn::a() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestMultiColumn.a)
  return _internal_a();
}
inline void TestTestMultiColumn::unsafe_arena_set_allocated_a(::cfg::TestFoo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.a_);
  }
  _impl_.a_ = reinterpret_cast<::cfg::TestFoo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestMultiColumn.a)
}
inline ::cfg::TestFoo* TestTestMultiColumn::release_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestFoo* released = _impl_.a_;
  _impl_.a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestFoo* TestTestMultiColumn::unsafe_arena_release_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestMultiColumn.a)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestFoo* temp = _impl_.a_;
  _impl_.a_ = nullptr;
  return temp;
}
inline ::cfg::TestFoo* TestTestMultiColumn::_internal_mutable_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.a_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestFoo>(GetArenaForAllocation());
    _impl_.a_ = reinterpret_cast<::cfg::TestFoo*>(p);
  }
  return _impl_.a_;
}
inline ::cfg::TestFoo* TestTestMultiColumn::mutable_a() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestFoo* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestMultiColumn.a)
  return _msg;
}
inline void TestTestMultiColumn::set_allocated_a(::cfg::TestFoo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestFoo*>(_impl_.a_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestFoo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.a_ = reinterpret_cast<::cfg::TestFoo*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestMultiColumn.a)
}

// .cfg.TestFoo b = 3;
inline bool TestTestMultiColumn::has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.b_ != nullptr);
  return value;
}
inline void TestTestMultiColumn::clear_b() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.b_ != nullptr) _impl_.b_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::TestFoo& TestTestMultiColumn::_internal_b() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestFoo* p = _impl_.b_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestFoo&>(::cfg::_TestFoo_default_instance_);
}
inline const ::cfg::TestFoo& TestTestMultiColumn::b() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestMultiColumn.b)
  return _internal_b();
}
inline void TestTestMultiColumn::unsafe_arena_set_allocated_b(::cfg::TestFoo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.b_);
  }
  _impl_.b_ = reinterpret_cast<::cfg::TestFoo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestMultiColumn.b)
}
inline ::cfg::TestFoo* TestTestMultiColumn::release_b() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestFoo* released = _impl_.b_;
  _impl_.b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestFoo* TestTestMultiColumn::unsafe_arena_release_b() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestMultiColumn.b)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestFoo* temp = _impl_.b_;
  _impl_.b_ = nullptr;
  return temp;
}
inline ::cfg::TestFoo* TestTestMultiColumn::_internal_mutable_b() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.b_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestFoo>(GetArenaForAllocation());
    _impl_.b_ = reinterpret_cast<::cfg::TestFoo*>(p);
  }
  return _impl_.b_;
}
inline ::cfg::TestFoo* TestTestMultiColumn::mutable_b() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestFoo* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestMultiColumn.b)
  return _msg;
}
inline void TestTestMultiColumn::set_allocated_b(::cfg::TestFoo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestFoo*>(_impl_.b_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestFoo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.b_ = reinterpret_cast<::cfg::TestFoo*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestMultiColumn.b)
}

// .cfg.TestFoo c = 4;
inline bool TestTestMultiColumn::has_c() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.c_ != nullptr);
  return value;
}
inline void TestTestMultiColumn::clear_c() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.c_ != nullptr) _impl_.c_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cfg::TestFoo& TestTestMultiColumn::_internal_c() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestFoo* p = _impl_.c_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestFoo&>(::cfg::_TestFoo_default_instance_);
}
inline const ::cfg::TestFoo& TestTestMultiColumn::c() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestMultiColumn.c)
  return _internal_c();
}
inline void TestTestMultiColumn::unsafe_arena_set_allocated_c(::cfg::TestFoo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.c_);
  }
  _impl_.c_ = reinterpret_cast<::cfg::TestFoo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestMultiColumn.c)
}
inline ::cfg::TestFoo* TestTestMultiColumn::release_c() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::TestFoo* released = _impl_.c_;
  _impl_.c_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestFoo* TestTestMultiColumn::unsafe_arena_release_c() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestMultiColumn.c)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::TestFoo* temp = _impl_.c_;
  _impl_.c_ = nullptr;
  return temp;
}
inline ::cfg::TestFoo* TestTestMultiColumn::_internal_mutable_c() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.c_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestFoo>(GetArenaForAllocation());
    _impl_.c_ = reinterpret_cast<::cfg::TestFoo*>(p);
  }
  return _impl_.c_;
}
inline ::cfg::TestFoo* TestTestMultiColumn::mutable_c() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestFoo* _msg = _internal_mutable_c();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestMultiColumn.c)
  return _msg;
}
inline void TestTestMultiColumn::set_allocated_c(::cfg::TestFoo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestFoo*>(_impl_.c_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestFoo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.c_ = reinterpret_cast<::cfg::TestFoo*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestMultiColumn.c)
}

// -------------------------------------------------------------------

// TestFoo

// int32 y1 = 1;
inline void TestFoo::clear_y1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y1_ = 0;
}
inline ::int32_t TestFoo::y1() const {
  // @@protoc_insertion_point(field_get:cfg.TestFoo.y1)
  return _internal_y1();
}
inline void TestFoo::set_y1(::int32_t value) {
  _internal_set_y1(value);
  // @@protoc_insertion_point(field_set:cfg.TestFoo.y1)
}
inline ::int32_t TestFoo::_internal_y1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y1_;
}
inline void TestFoo::_internal_set_y1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y1_ = value;
}

// int32 y2 = 2;
inline void TestFoo::clear_y2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y2_ = 0;
}
inline ::int32_t TestFoo::y2() const {
  // @@protoc_insertion_point(field_get:cfg.TestFoo.y2)
  return _internal_y2();
}
inline void TestFoo::set_y2(::int32_t value) {
  _internal_set_y2(value);
  // @@protoc_insertion_point(field_set:cfg.TestFoo.y2)
}
inline ::int32_t TestFoo::_internal_y2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y2_;
}
inline void TestFoo::_internal_set_y2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y2_ = value;
}

// int32 y3 = 3;
inline void TestFoo::clear_y3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y3_ = 0;
}
inline ::int32_t TestFoo::y3() const {
  // @@protoc_insertion_point(field_get:cfg.TestFoo.y3)
  return _internal_y3();
}
inline void TestFoo::set_y3(::int32_t value) {
  _internal_set_y3(value);
  // @@protoc_insertion_point(field_set:cfg.TestFoo.y3)
}
inline ::int32_t TestFoo::_internal_y3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y3_;
}
inline void TestFoo::_internal_set_y3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y3_ = value;
}

// -------------------------------------------------------------------

// TestMultiRowTitle

// int32 id = 1;
inline void TestMultiRowTitle::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestMultiRowTitle::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowTitle.id)
  return _internal_id();
}
inline void TestMultiRowTitle::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowTitle.id)
}
inline ::int32_t TestMultiRowTitle::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestMultiRowTitle::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void TestMultiRowTitle::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestMultiRowTitle::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowTitle.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMultiRowTitle::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestMultiRowTitle.name)
}
inline std::string* TestMultiRowTitle::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowTitle.name)
  return _s;
}
inline const std::string& TestMultiRowTitle::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TestMultiRowTitle::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMultiRowTitle::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestMultiRowTitle::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiRowTitle.name)
  return _impl_.name_.Release();
}
inline void TestMultiRowTitle::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiRowTitle.name)
}

// .cfg.TestH1 x1 = 3;
inline bool TestMultiRowTitle::has_x1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x1_ != nullptr);
  return value;
}
inline void TestMultiRowTitle::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x1_ != nullptr) _impl_.x1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestH1& TestMultiRowTitle::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestH1* p = _impl_.x1_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestH1&>(::cfg::_TestH1_default_instance_);
}
inline const ::cfg::TestH1& TestMultiRowTitle::x1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowTitle.x1)
  return _internal_x1();
}
inline void TestMultiRowTitle::unsafe_arena_set_allocated_x1(::cfg::TestH1* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x1_);
  }
  _impl_.x1_ = reinterpret_cast<::cfg::TestH1*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestMultiRowTitle.x1)
}
inline ::cfg::TestH1* TestMultiRowTitle::release_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestH1* released = _impl_.x1_;
  _impl_.x1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestH1* TestMultiRowTitle::unsafe_arena_release_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiRowTitle.x1)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestH1* temp = _impl_.x1_;
  _impl_.x1_ = nullptr;
  return temp;
}
inline ::cfg::TestH1* TestMultiRowTitle::_internal_mutable_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x1_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestH1>(GetArenaForAllocation());
    _impl_.x1_ = reinterpret_cast<::cfg::TestH1*>(p);
  }
  return _impl_.x1_;
}
inline ::cfg::TestH1* TestMultiRowTitle::mutable_x1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestH1* _msg = _internal_mutable_x1();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowTitle.x1)
  return _msg;
}
inline void TestMultiRowTitle::set_allocated_x1(::cfg::TestH1* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestH1*>(_impl_.x1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestH1*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x1_ = reinterpret_cast<::cfg::TestH1*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiRowTitle.x1)
}

// optional .cfg.TestH2 x2_0 = 4;
inline bool TestMultiRowTitle::has_x2_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x2_0_ != nullptr);
  return value;
}
inline void TestMultiRowTitle::clear_x2_0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x2_0_ != nullptr) _impl_.x2_0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::TestH2& TestMultiRowTitle::_internal_x2_0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestH2* p = _impl_.x2_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestH2&>(::cfg::_TestH2_default_instance_);
}
inline const ::cfg::TestH2& TestMultiRowTitle::x2_0() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowTitle.x2_0)
  return _internal_x2_0();
}
inline void TestMultiRowTitle::unsafe_arena_set_allocated_x2_0(::cfg::TestH2* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x2_0_);
  }
  _impl_.x2_0_ = reinterpret_cast<::cfg::TestH2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestMultiRowTitle.x2_0)
}
inline ::cfg::TestH2* TestMultiRowTitle::release_x2_0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestH2* released = _impl_.x2_0_;
  _impl_.x2_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestH2* TestMultiRowTitle::unsafe_arena_release_x2_0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestMultiRowTitle.x2_0)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestH2* temp = _impl_.x2_0_;
  _impl_.x2_0_ = nullptr;
  return temp;
}
inline ::cfg::TestH2* TestMultiRowTitle::_internal_mutable_x2_0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.x2_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestH2>(GetArenaForAllocation());
    _impl_.x2_0_ = reinterpret_cast<::cfg::TestH2*>(p);
  }
  return _impl_.x2_0_;
}
inline ::cfg::TestH2* TestMultiRowTitle::mutable_x2_0() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestH2* _msg = _internal_mutable_x2_0();
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowTitle.x2_0)
  return _msg;
}
inline void TestMultiRowTitle::set_allocated_x2_0(::cfg::TestH2* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestH2*>(_impl_.x2_0_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestH2*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.x2_0_ = reinterpret_cast<::cfg::TestH2*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestMultiRowTitle.x2_0)
}

// repeated .cfg.TestH2 x2 = 5 [packed = false];
inline int TestMultiRowTitle::_internal_x2_size() const {
  return _internal_x2().size();
}
inline int TestMultiRowTitle::x2_size() const {
  return _internal_x2_size();
}
inline void TestMultiRowTitle::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_.Clear();
}
inline ::cfg::TestH2* TestMultiRowTitle::mutable_x2(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowTitle.x2)
  return _internal_mutable_x2()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestH2>* TestMultiRowTitle::mutable_x2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowTitle.x2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x2();
}
inline const ::cfg::TestH2& TestMultiRowTitle::x2(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowTitle.x2)
  return _internal_x2().Get(index);
}
inline ::cfg::TestH2* TestMultiRowTitle::add_x2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestH2* _add = _internal_mutable_x2()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowTitle.x2)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>& TestMultiRowTitle::x2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowTitle.x2)
  return _internal_x2();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>&
TestMultiRowTitle::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestH2>*
TestMultiRowTitle::_internal_mutable_x2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x2_;
}

// repeated .cfg.TestH2 x3 = 6 [packed = false];
inline int TestMultiRowTitle::_internal_x3_size() const {
  return _internal_x3().size();
}
inline int TestMultiRowTitle::x3_size() const {
  return _internal_x3_size();
}
inline void TestMultiRowTitle::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_.Clear();
}
inline ::cfg::TestH2* TestMultiRowTitle::mutable_x3(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowTitle.x3)
  return _internal_mutable_x3()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestH2>* TestMultiRowTitle::mutable_x3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowTitle.x3)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x3();
}
inline const ::cfg::TestH2& TestMultiRowTitle::x3(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowTitle.x3)
  return _internal_x3().Get(index);
}
inline ::cfg::TestH2* TestMultiRowTitle::add_x3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestH2* _add = _internal_mutable_x3()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowTitle.x3)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>& TestMultiRowTitle::x3() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowTitle.x3)
  return _internal_x3();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>&
TestMultiRowTitle::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestH2>*
TestMultiRowTitle::_internal_mutable_x3() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x3_;
}

// repeated .cfg.TestH2 x4 = 7 [packed = false];
inline int TestMultiRowTitle::_internal_x4_size() const {
  return _internal_x4().size();
}
inline int TestMultiRowTitle::x4_size() const {
  return _internal_x4_size();
}
inline void TestMultiRowTitle::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_.Clear();
}
inline ::cfg::TestH2* TestMultiRowTitle::mutable_x4(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestMultiRowTitle.x4)
  return _internal_mutable_x4()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestH2>* TestMultiRowTitle::mutable_x4()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestMultiRowTitle.x4)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x4();
}
inline const ::cfg::TestH2& TestMultiRowTitle::x4(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestMultiRowTitle.x4)
  return _internal_x4().Get(index);
}
inline ::cfg::TestH2* TestMultiRowTitle::add_x4() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestH2* _add = _internal_mutable_x4()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestMultiRowTitle.x4)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>& TestMultiRowTitle::x4() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestMultiRowTitle.x4)
  return _internal_x4();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestH2>&
TestMultiRowTitle::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestH2>*
TestMultiRowTitle::_internal_mutable_x4() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x4_;
}

// -------------------------------------------------------------------

// TestH1

// .cfg.TestH2 y2 = 1;
inline bool TestH1::has_y2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y2_ != nullptr);
  return value;
}
inline void TestH1::clear_y2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.y2_ != nullptr) _impl_.y2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestH2& TestH1::_internal_y2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestH2* p = _impl_.y2_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestH2&>(::cfg::_TestH2_default_instance_);
}
inline const ::cfg::TestH2& TestH1::y2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestH1.y2)
  return _internal_y2();
}
inline void TestH1::unsafe_arena_set_allocated_y2(::cfg::TestH2* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y2_);
  }
  _impl_.y2_ = reinterpret_cast<::cfg::TestH2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestH1.y2)
}
inline ::cfg::TestH2* TestH1::release_y2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestH2* released = _impl_.y2_;
  _impl_.y2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestH2* TestH1::unsafe_arena_release_y2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestH1.y2)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestH2* temp = _impl_.y2_;
  _impl_.y2_ = nullptr;
  return temp;
}
inline ::cfg::TestH2* TestH1::_internal_mutable_y2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.y2_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestH2>(GetArenaForAllocation());
    _impl_.y2_ = reinterpret_cast<::cfg::TestH2*>(p);
  }
  return _impl_.y2_;
}
inline ::cfg::TestH2* TestH1::mutable_y2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestH2* _msg = _internal_mutable_y2();
  // @@protoc_insertion_point(field_mutable:cfg.TestH1.y2)
  return _msg;
}
inline void TestH1::set_allocated_y2(::cfg::TestH2* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestH2*>(_impl_.y2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestH2*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.y2_ = reinterpret_cast<::cfg::TestH2*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestH1.y2)
}

// int32 y3 = 2;
inline void TestH1::clear_y3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y3_ = 0;
}
inline ::int32_t TestH1::y3() const {
  // @@protoc_insertion_point(field_get:cfg.TestH1.y3)
  return _internal_y3();
}
inline void TestH1::set_y3(::int32_t value) {
  _internal_set_y3(value);
  // @@protoc_insertion_point(field_set:cfg.TestH1.y3)
}
inline ::int32_t TestH1::_internal_y3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y3_;
}
inline void TestH1::_internal_set_y3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y3_ = value;
}

// -------------------------------------------------------------------

// TestH2

// int32 z2 = 1;
inline void TestH2::clear_z2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z2_ = 0;
}
inline ::int32_t TestH2::z2() const {
  // @@protoc_insertion_point(field_get:cfg.TestH2.z2)
  return _internal_z2();
}
inline void TestH2::set_z2(::int32_t value) {
  _internal_set_z2(value);
  // @@protoc_insertion_point(field_set:cfg.TestH2.z2)
}
inline ::int32_t TestH2::_internal_z2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z2_;
}
inline void TestH2::_internal_set_z2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z2_ = value;
}

// int32 z3 = 2;
inline void TestH2::clear_z3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z3_ = 0;
}
inline ::int32_t TestH2::z3() const {
  // @@protoc_insertion_point(field_get:cfg.TestH2.z3)
  return _internal_z3();
}
inline void TestH2::set_z3(::int32_t value) {
  _internal_set_z3(value);
  // @@protoc_insertion_point(field_set:cfg.TestH2.z3)
}
inline ::int32_t TestH2::_internal_z3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z3_;
}
inline void TestH2::_internal_set_z3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z3_ = value;
}

// -------------------------------------------------------------------

// TestTestNull

// int32 id = 1;
inline void TestTestNull::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestNull::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestNull.id)
  return _internal_id();
}
inline void TestTestNull::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestNull.id)
}
inline ::int32_t TestTestNull::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestNull::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// optional int32 x1 = 2;
inline bool TestTestNull::has_x1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TestTestNull::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t TestTestNull::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestNull.x1)
  return _internal_x1();
}
inline void TestTestNull::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestNull.x1)
}
inline ::int32_t TestTestNull::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestTestNull::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.x1_ = value;
}

// optional .cfg.TestDemoEnum x2 = 3;
inline bool TestTestNull::has_x2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TestTestNull::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::cfg::TestDemoEnum TestTestNull::x2() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestNull.x2)
  return _internal_x2();
}
inline void TestTestNull::set_x2(::cfg::TestDemoEnum value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestNull.x2)
}
inline ::cfg::TestDemoEnum TestTestNull::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::TestDemoEnum>(_impl_.x2_);
}
inline void TestTestNull::_internal_set_x2(::cfg::TestDemoEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.x2_ = value;
}

// optional .cfg.TestDemoType1 x3 = 4;
inline bool TestTestNull::has_x3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x3_ != nullptr);
  return value;
}
inline void TestTestNull::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x3_ != nullptr) _impl_.x3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cfg::TestDemoType1& TestTestNull::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoType1* p = _impl_.x3_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoType1&>(::cfg::_TestDemoType1_default_instance_);
}
inline const ::cfg::TestDemoType1& TestTestNull::x3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestNull.x3)
  return _internal_x3();
}
inline void TestTestNull::unsafe_arena_set_allocated_x3(::cfg::TestDemoType1* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x3_);
  }
  _impl_.x3_ = reinterpret_cast<::cfg::TestDemoType1*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestNull.x3)
}
inline ::cfg::TestDemoType1* TestTestNull::release_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::TestDemoType1* released = _impl_.x3_;
  _impl_.x3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoType1* TestTestNull::unsafe_arena_release_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestNull.x3)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::TestDemoType1* temp = _impl_.x3_;
  _impl_.x3_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoType1* TestTestNull::_internal_mutable_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.x3_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoType1>(GetArenaForAllocation());
    _impl_.x3_ = reinterpret_cast<::cfg::TestDemoType1*>(p);
  }
  return _impl_.x3_;
}
inline ::cfg::TestDemoType1* TestTestNull::mutable_x3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoType1* _msg = _internal_mutable_x3();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestNull.x3)
  return _msg;
}
inline void TestTestNull::set_allocated_x3(::cfg::TestDemoType1* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoType1*>(_impl_.x3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoType1*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.x3_ = reinterpret_cast<::cfg::TestDemoType1*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestNull.x3)
}

// optional .cfg.TestDemoDynamic x4 = 5;
inline bool TestTestNull::has_x4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x4_ != nullptr);
  return value;
}
inline void TestTestNull::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x4_ != nullptr) _impl_.x4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::cfg::TestDemoDynamic& TestTestNull::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoDynamic* p = _impl_.x4_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoDynamic&>(::cfg::_TestDemoDynamic_default_instance_);
}
inline const ::cfg::TestDemoDynamic& TestTestNull::x4() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestNull.x4)
  return _internal_x4();
}
inline void TestTestNull::unsafe_arena_set_allocated_x4(::cfg::TestDemoDynamic* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x4_);
  }
  _impl_.x4_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestNull.x4)
}
inline ::cfg::TestDemoDynamic* TestTestNull::release_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cfg::TestDemoDynamic* released = _impl_.x4_;
  _impl_.x4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoDynamic* TestTestNull::unsafe_arena_release_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestNull.x4)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cfg::TestDemoDynamic* temp = _impl_.x4_;
  _impl_.x4_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoDynamic* TestTestNull::_internal_mutable_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.x4_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoDynamic>(GetArenaForAllocation());
    _impl_.x4_ = reinterpret_cast<::cfg::TestDemoDynamic*>(p);
  }
  return _impl_.x4_;
}
inline ::cfg::TestDemoDynamic* TestTestNull::mutable_x4() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoDynamic* _msg = _internal_mutable_x4();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestNull.x4)
  return _msg;
}
inline void TestTestNull::set_allocated_x4(::cfg::TestDemoDynamic* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoDynamic*>(_impl_.x4_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoDynamic*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.x4_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestNull.x4)
}

// optional string s1 = 6;
inline bool TestTestNull::has_s1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TestTestNull::clear_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestTestNull::s1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestNull.s1)
  return _internal_s1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestNull::set_s1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestNull.s1)
}
inline std::string* TestTestNull::mutable_s1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestNull.s1)
  return _s;
}
inline const std::string& TestTestNull::_internal_s1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s1_.Get();
}
inline void TestTestNull::_internal_set_s1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s1_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestNull::_internal_mutable_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.s1_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestNull::release_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestNull.s1)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.s1_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.s1_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TestTestNull::set_allocated_s1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.s1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s1_.IsDefault()) {
          _impl_.s1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestNull.s1)
}

// optional string s2 = 7;
inline bool TestTestNull::has_s2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TestTestNull::clear_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TestTestNull::s2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestNull.s2)
  return _internal_s2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestNull::set_s2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestNull.s2)
}
inline std::string* TestTestNull::mutable_s2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestNull.s2)
  return _s;
}
inline const std::string& TestTestNull::_internal_s2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s2_.Get();
}
inline void TestTestNull::_internal_set_s2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s2_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestNull::_internal_mutable_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.s2_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestNull::release_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestNull.s2)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.s2_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.s2_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TestTestNull::set_allocated_s2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.s2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s2_.IsDefault()) {
          _impl_.s2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestNull.s2)
}

// -------------------------------------------------------------------

// TestDemoPrimitiveTypesTable

// bool x1 = 1;
inline void TestDemoPrimitiveTypesTable::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = false;
}
inline bool TestDemoPrimitiveTypesTable::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.x1)
  return _internal_x1();
}
inline void TestDemoPrimitiveTypesTable::set_x1(bool value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.x1)
}
inline bool TestDemoPrimitiveTypesTable::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_x1(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int32 x2 = 2;
inline void TestDemoPrimitiveTypesTable::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_ = 0;
}
inline ::int32_t TestDemoPrimitiveTypesTable::x2() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.x2)
  return _internal_x2();
}
inline void TestDemoPrimitiveTypesTable::set_x2(::int32_t value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.x2)
}
inline ::int32_t TestDemoPrimitiveTypesTable::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_x2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x2_ = value;
}

// int32 x3 = 3;
inline void TestDemoPrimitiveTypesTable::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_ = 0;
}
inline ::int32_t TestDemoPrimitiveTypesTable::x3() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.x3)
  return _internal_x3();
}
inline void TestDemoPrimitiveTypesTable::set_x3(::int32_t value) {
  _internal_set_x3(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.x3)
}
inline ::int32_t TestDemoPrimitiveTypesTable::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_x3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x3_ = value;
}

// int32 x4 = 4;
inline void TestDemoPrimitiveTypesTable::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_ = 0;
}
inline ::int32_t TestDemoPrimitiveTypesTable::x4() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.x4)
  return _internal_x4();
}
inline void TestDemoPrimitiveTypesTable::set_x4(::int32_t value) {
  _internal_set_x4(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.x4)
}
inline ::int32_t TestDemoPrimitiveTypesTable::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_x4(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x4_ = value;
}

// int64 x5 = 5;
inline void TestDemoPrimitiveTypesTable::clear_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x5_ = ::int64_t{0};
}
inline ::int64_t TestDemoPrimitiveTypesTable::x5() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.x5)
  return _internal_x5();
}
inline void TestDemoPrimitiveTypesTable::set_x5(::int64_t value) {
  _internal_set_x5(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.x5)
}
inline ::int64_t TestDemoPrimitiveTypesTable::_internal_x5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x5_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_x5(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x5_ = value;
}

// float x6 = 6;
inline void TestDemoPrimitiveTypesTable::clear_x6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x6_ = 0;
}
inline float TestDemoPrimitiveTypesTable::x6() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.x6)
  return _internal_x6();
}
inline void TestDemoPrimitiveTypesTable::set_x6(float value) {
  _internal_set_x6(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.x6)
}
inline float TestDemoPrimitiveTypesTable::_internal_x6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x6_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_x6(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x6_ = value;
}

// double x7 = 7;
inline void TestDemoPrimitiveTypesTable::clear_x7() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x7_ = 0;
}
inline double TestDemoPrimitiveTypesTable::x7() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.x7)
  return _internal_x7();
}
inline void TestDemoPrimitiveTypesTable::set_x7(double value) {
  _internal_set_x7(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.x7)
}
inline double TestDemoPrimitiveTypesTable::_internal_x7() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x7_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_x7(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x7_ = value;
}

// string s1 = 8;
inline void TestDemoPrimitiveTypesTable::clear_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.ClearToEmpty();
}
inline const std::string& TestDemoPrimitiveTypesTable::s1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.s1)
  return _internal_s1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDemoPrimitiveTypesTable::set_s1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.s1)
}
inline std::string* TestDemoPrimitiveTypesTable::mutable_s1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoPrimitiveTypesTable.s1)
  return _s;
}
inline const std::string& TestDemoPrimitiveTypesTable::_internal_s1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s1_.Get();
}
inline void TestDemoPrimitiveTypesTable::_internal_set_s1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDemoPrimitiveTypesTable::_internal_mutable_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s1_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDemoPrimitiveTypesTable::release_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoPrimitiveTypesTable.s1)
  return _impl_.s1_.Release();
}
inline void TestDemoPrimitiveTypesTable::set_allocated_s1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s1_.IsDefault()) {
          _impl_.s1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoPrimitiveTypesTable.s1)
}

// string s2 = 9;
inline void TestDemoPrimitiveTypesTable::clear_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.ClearToEmpty();
}
inline const std::string& TestDemoPrimitiveTypesTable::s2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.s2)
  return _internal_s2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDemoPrimitiveTypesTable::set_s2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.s2)
}
inline std::string* TestDemoPrimitiveTypesTable::mutable_s2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoPrimitiveTypesTable.s2)
  return _s;
}
inline const std::string& TestDemoPrimitiveTypesTable::_internal_s2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s2_.Get();
}
inline void TestDemoPrimitiveTypesTable::_internal_set_s2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDemoPrimitiveTypesTable::_internal_mutable_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s2_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDemoPrimitiveTypesTable::release_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoPrimitiveTypesTable.s2)
  return _impl_.s2_.Release();
}
inline void TestDemoPrimitiveTypesTable::set_allocated_s2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s2_.IsDefault()) {
          _impl_.s2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoPrimitiveTypesTable.s2)
}

// .cfg.vec2 v2 = 10;
inline bool TestDemoPrimitiveTypesTable::has_v2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v2_ != nullptr);
  return value;
}
inline void TestDemoPrimitiveTypesTable::clear_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v2_ != nullptr) _impl_.v2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::vec2& TestDemoPrimitiveTypesTable::_internal_v2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec2* p = _impl_.v2_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec2&>(::cfg::_vec2_default_instance_);
}
inline const ::cfg::vec2& TestDemoPrimitiveTypesTable::v2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.v2)
  return _internal_v2();
}
inline void TestDemoPrimitiveTypesTable::unsafe_arena_set_allocated_v2(::cfg::vec2* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v2_);
  }
  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoPrimitiveTypesTable.v2)
}
inline ::cfg::vec2* TestDemoPrimitiveTypesTable::release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::vec2* released = _impl_.v2_;
  _impl_.v2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec2* TestDemoPrimitiveTypesTable::unsafe_arena_release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoPrimitiveTypesTable.v2)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::vec2* temp = _impl_.v2_;
  _impl_.v2_ = nullptr;
  return temp;
}
inline ::cfg::vec2* TestDemoPrimitiveTypesTable::_internal_mutable_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.v2_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec2>(GetArenaForAllocation());
    _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(p);
  }
  return _impl_.v2_;
}
inline ::cfg::vec2* TestDemoPrimitiveTypesTable::mutable_v2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec2* _msg = _internal_mutable_v2();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoPrimitiveTypesTable.v2)
  return _msg;
}
inline void TestDemoPrimitiveTypesTable::set_allocated_v2(::cfg::vec2* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec2*>(_impl_.v2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec2*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoPrimitiveTypesTable.v2)
}

// .cfg.vec3 v3 = 11;
inline bool TestDemoPrimitiveTypesTable::has_v3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v3_ != nullptr);
  return value;
}
inline void TestDemoPrimitiveTypesTable::clear_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v3_ != nullptr) _impl_.v3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::vec3& TestDemoPrimitiveTypesTable::_internal_v3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec3* p = _impl_.v3_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec3&>(::cfg::_vec3_default_instance_);
}
inline const ::cfg::vec3& TestDemoPrimitiveTypesTable::v3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.v3)
  return _internal_v3();
}
inline void TestDemoPrimitiveTypesTable::unsafe_arena_set_allocated_v3(::cfg::vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v3_);
  }
  _impl_.v3_ = reinterpret_cast<::cfg::vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoPrimitiveTypesTable.v3)
}
inline ::cfg::vec3* TestDemoPrimitiveTypesTable::release_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::vec3* released = _impl_.v3_;
  _impl_.v3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec3* TestDemoPrimitiveTypesTable::unsafe_arena_release_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoPrimitiveTypesTable.v3)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::vec3* temp = _impl_.v3_;
  _impl_.v3_ = nullptr;
  return temp;
}
inline ::cfg::vec3* TestDemoPrimitiveTypesTable::_internal_mutable_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.v3_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec3>(GetArenaForAllocation());
    _impl_.v3_ = reinterpret_cast<::cfg::vec3*>(p);
  }
  return _impl_.v3_;
}
inline ::cfg::vec3* TestDemoPrimitiveTypesTable::mutable_v3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec3* _msg = _internal_mutable_v3();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoPrimitiveTypesTable.v3)
  return _msg;
}
inline void TestDemoPrimitiveTypesTable::set_allocated_v3(::cfg::vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec3*>(_impl_.v3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec3*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.v3_ = reinterpret_cast<::cfg::vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoPrimitiveTypesTable.v3)
}

// .cfg.vec4 v4 = 12;
inline bool TestDemoPrimitiveTypesTable::has_v4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v4_ != nullptr);
  return value;
}
inline void TestDemoPrimitiveTypesTable::clear_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v4_ != nullptr) _impl_.v4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cfg::vec4& TestDemoPrimitiveTypesTable::_internal_v4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec4* p = _impl_.v4_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec4&>(::cfg::_vec4_default_instance_);
}
inline const ::cfg::vec4& TestDemoPrimitiveTypesTable::v4() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.v4)
  return _internal_v4();
}
inline void TestDemoPrimitiveTypesTable::unsafe_arena_set_allocated_v4(::cfg::vec4* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v4_);
  }
  _impl_.v4_ = reinterpret_cast<::cfg::vec4*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoPrimitiveTypesTable.v4)
}
inline ::cfg::vec4* TestDemoPrimitiveTypesTable::release_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::vec4* released = _impl_.v4_;
  _impl_.v4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec4* TestDemoPrimitiveTypesTable::unsafe_arena_release_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoPrimitiveTypesTable.v4)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::vec4* temp = _impl_.v4_;
  _impl_.v4_ = nullptr;
  return temp;
}
inline ::cfg::vec4* TestDemoPrimitiveTypesTable::_internal_mutable_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.v4_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec4>(GetArenaForAllocation());
    _impl_.v4_ = reinterpret_cast<::cfg::vec4*>(p);
  }
  return _impl_.v4_;
}
inline ::cfg::vec4* TestDemoPrimitiveTypesTable::mutable_v4() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec4* _msg = _internal_mutable_v4();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoPrimitiveTypesTable.v4)
  return _msg;
}
inline void TestDemoPrimitiveTypesTable::set_allocated_v4(::cfg::vec4* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec4*>(_impl_.v4_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec4*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.v4_ = reinterpret_cast<::cfg::vec4*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoPrimitiveTypesTable.v4)
}

// int64 t1 = 13;
inline void TestDemoPrimitiveTypesTable::clear_t1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.t1_ = ::int64_t{0};
}
inline ::int64_t TestDemoPrimitiveTypesTable::t1() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoPrimitiveTypesTable.t1)
  return _internal_t1();
}
inline void TestDemoPrimitiveTypesTable::set_t1(::int64_t value) {
  _internal_set_t1(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoPrimitiveTypesTable.t1)
}
inline ::int64_t TestDemoPrimitiveTypesTable::_internal_t1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.t1_;
}
inline void TestDemoPrimitiveTypesTable::_internal_set_t1(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.t1_ = value;
}

// -------------------------------------------------------------------

// vec2

// float x = 1;
inline void vec2::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float vec2::x() const {
  // @@protoc_insertion_point(field_get:cfg.vec2.x)
  return _internal_x();
}
inline void vec2::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.vec2.x)
}
inline float vec2::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void vec2::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void vec2::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float vec2::y() const {
  // @@protoc_insertion_point(field_get:cfg.vec2.y)
  return _internal_y();
}
inline void vec2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.vec2.y)
}
inline float vec2::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void vec2::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// vec3

// float x = 1;
inline void vec3::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float vec3::x() const {
  // @@protoc_insertion_point(field_get:cfg.vec3.x)
  return _internal_x();
}
inline void vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.vec3.x)
}
inline float vec3::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void vec3::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void vec3::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float vec3::y() const {
  // @@protoc_insertion_point(field_get:cfg.vec3.y)
  return _internal_y();
}
inline void vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.vec3.y)
}
inline float vec3::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void vec3::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// float z = 3;
inline void vec3::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline float vec3::z() const {
  // @@protoc_insertion_point(field_get:cfg.vec3.z)
  return _internal_z();
}
inline void vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:cfg.vec3.z)
}
inline float vec3::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void vec3::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// vec4

// float x = 1;
inline void vec4::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float vec4::x() const {
  // @@protoc_insertion_point(field_get:cfg.vec4.x)
  return _internal_x();
}
inline void vec4::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.vec4.x)
}
inline float vec4::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void vec4::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void vec4::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float vec4::y() const {
  // @@protoc_insertion_point(field_get:cfg.vec4.y)
  return _internal_y();
}
inline void vec4::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.vec4.y)
}
inline float vec4::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void vec4::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// float z = 3;
inline void vec4::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline float vec4::z() const {
  // @@protoc_insertion_point(field_get:cfg.vec4.z)
  return _internal_z();
}
inline void vec4::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:cfg.vec4.z)
}
inline float vec4::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void vec4::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// float w = 4;
inline void vec4::clear_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.w_ = 0;
}
inline float vec4::w() const {
  // @@protoc_insertion_point(field_get:cfg.vec4.w)
  return _internal_w();
}
inline void vec4::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:cfg.vec4.w)
}
inline float vec4::_internal_w() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.w_;
}
inline void vec4::_internal_set_w(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.w_ = value;
}

// -------------------------------------------------------------------

// TestTestString

// string id = 1;
inline void TestTestString::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TestTestString::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestString.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestString::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestString.id)
}
inline std::string* TestTestString::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestString.id)
  return _s;
}
inline const std::string& TestTestString::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TestTestString::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestString::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestString::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestString.id)
  return _impl_.id_.Release();
}
inline void TestTestString::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestString.id)
}

// string s1 = 2;
inline void TestTestString::clear_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.ClearToEmpty();
}
inline const std::string& TestTestString::s1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestString.s1)
  return _internal_s1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestString::set_s1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestString.s1)
}
inline std::string* TestTestString::mutable_s1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestString.s1)
  return _s;
}
inline const std::string& TestTestString::_internal_s1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s1_.Get();
}
inline void TestTestString::_internal_set_s1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestString::_internal_mutable_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s1_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestString::release_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestString.s1)
  return _impl_.s1_.Release();
}
inline void TestTestString::set_allocated_s1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s1_.IsDefault()) {
          _impl_.s1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestString.s1)
}

// string s2 = 3;
inline void TestTestString::clear_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.ClearToEmpty();
}
inline const std::string& TestTestString::s2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestString.s2)
  return _internal_s2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestString::set_s2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestString.s2)
}
inline std::string* TestTestString::mutable_s2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestString.s2)
  return _s;
}
inline const std::string& TestTestString::_internal_s2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s2_.Get();
}
inline void TestTestString::_internal_set_s2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestString::_internal_mutable_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s2_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestString::release_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestString.s2)
  return _impl_.s2_.Release();
}
inline void TestTestString::set_allocated_s2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s2_.IsDefault()) {
          _impl_.s2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestString.s2)
}

// .cfg.TestCompactString cs1 = 4;
inline bool TestTestString::has_cs1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cs1_ != nullptr);
  return value;
}
inline void TestTestString::clear_cs1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cs1_ != nullptr) _impl_.cs1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestCompactString& TestTestString::_internal_cs1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestCompactString* p = _impl_.cs1_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestCompactString&>(::cfg::_TestCompactString_default_instance_);
}
inline const ::cfg::TestCompactString& TestTestString::cs1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestString.cs1)
  return _internal_cs1();
}
inline void TestTestString::unsafe_arena_set_allocated_cs1(::cfg::TestCompactString* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cs1_);
  }
  _impl_.cs1_ = reinterpret_cast<::cfg::TestCompactString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestString.cs1)
}
inline ::cfg::TestCompactString* TestTestString::release_cs1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestCompactString* released = _impl_.cs1_;
  _impl_.cs1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestCompactString* TestTestString::unsafe_arena_release_cs1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestString.cs1)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestCompactString* temp = _impl_.cs1_;
  _impl_.cs1_ = nullptr;
  return temp;
}
inline ::cfg::TestCompactString* TestTestString::_internal_mutable_cs1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cs1_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestCompactString>(GetArenaForAllocation());
    _impl_.cs1_ = reinterpret_cast<::cfg::TestCompactString*>(p);
  }
  return _impl_.cs1_;
}
inline ::cfg::TestCompactString* TestTestString::mutable_cs1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestCompactString* _msg = _internal_mutable_cs1();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestString.cs1)
  return _msg;
}
inline void TestTestString::set_allocated_cs1(::cfg::TestCompactString* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestCompactString*>(_impl_.cs1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestCompactString*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.cs1_ = reinterpret_cast<::cfg::TestCompactString*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestString.cs1)
}

// .cfg.TestCompactString cs2 = 5;
inline bool TestTestString::has_cs2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cs2_ != nullptr);
  return value;
}
inline void TestTestString::clear_cs2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cs2_ != nullptr) _impl_.cs2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::TestCompactString& TestTestString::_internal_cs2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestCompactString* p = _impl_.cs2_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestCompactString&>(::cfg::_TestCompactString_default_instance_);
}
inline const ::cfg::TestCompactString& TestTestString::cs2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestString.cs2)
  return _internal_cs2();
}
inline void TestTestString::unsafe_arena_set_allocated_cs2(::cfg::TestCompactString* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cs2_);
  }
  _impl_.cs2_ = reinterpret_cast<::cfg::TestCompactString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestString.cs2)
}
inline ::cfg::TestCompactString* TestTestString::release_cs2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestCompactString* released = _impl_.cs2_;
  _impl_.cs2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestCompactString* TestTestString::unsafe_arena_release_cs2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestString.cs2)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestCompactString* temp = _impl_.cs2_;
  _impl_.cs2_ = nullptr;
  return temp;
}
inline ::cfg::TestCompactString* TestTestString::_internal_mutable_cs2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cs2_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestCompactString>(GetArenaForAllocation());
    _impl_.cs2_ = reinterpret_cast<::cfg::TestCompactString*>(p);
  }
  return _impl_.cs2_;
}
inline ::cfg::TestCompactString* TestTestString::mutable_cs2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestCompactString* _msg = _internal_mutable_cs2();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestString.cs2)
  return _msg;
}
inline void TestTestString::set_allocated_cs2(::cfg::TestCompactString* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestCompactString*>(_impl_.cs2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestCompactString*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cs2_ = reinterpret_cast<::cfg::TestCompactString*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestString.cs2)
}

// -------------------------------------------------------------------

// TestCompactString

// int32 id = 1;
inline void TestCompactString::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestCompactString::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestCompactString.id)
  return _internal_id();
}
inline void TestCompactString::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestCompactString.id)
}
inline ::int32_t TestCompactString::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestCompactString::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string s2 = 2;
inline void TestCompactString::clear_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.ClearToEmpty();
}
inline const std::string& TestCompactString::s2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestCompactString.s2)
  return _internal_s2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestCompactString::set_s2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestCompactString.s2)
}
inline std::string* TestCompactString::mutable_s2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:cfg.TestCompactString.s2)
  return _s;
}
inline const std::string& TestCompactString::_internal_s2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s2_.Get();
}
inline void TestCompactString::_internal_set_s2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(value, GetArenaForAllocation());
}
inline std::string* TestCompactString::_internal_mutable_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s2_.Mutable( GetArenaForAllocation());
}
inline std::string* TestCompactString::release_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestCompactString.s2)
  return _impl_.s2_.Release();
}
inline void TestCompactString::set_allocated_s2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s2_.IsDefault()) {
          _impl_.s2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestCompactString.s2)
}

// string s3 = 3;
inline void TestCompactString::clear_s3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s3_.ClearToEmpty();
}
inline const std::string& TestCompactString::s3() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestCompactString.s3)
  return _internal_s3();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestCompactString::set_s3(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s3_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestCompactString.s3)
}
inline std::string* TestCompactString::mutable_s3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:cfg.TestCompactString.s3)
  return _s;
}
inline const std::string& TestCompactString::_internal_s3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s3_.Get();
}
inline void TestCompactString::_internal_set_s3(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s3_.Set(value, GetArenaForAllocation());
}
inline std::string* TestCompactString::_internal_mutable_s3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s3_.Mutable( GetArenaForAllocation());
}
inline std::string* TestCompactString::release_s3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestCompactString.s3)
  return _impl_.s3_.Release();
}
inline void TestCompactString::set_allocated_s3(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s3_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s3_.IsDefault()) {
          _impl_.s3_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestCompactString.s3)
}

// -------------------------------------------------------------------

// TestDemoGroup

// int32 id = 1;
inline void TestDemoGroup::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestDemoGroup::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestDemoGroup.id)
  return _internal_id();
}
inline void TestDemoGroup::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestDemoGroup.id)
}
inline ::int32_t TestDemoGroup::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestDemoGroup::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .cfg.TestInnerGroup x5 = 6;
inline bool TestDemoGroup::has_x5() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x5_ != nullptr);
  return value;
}
inline void TestDemoGroup::clear_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x5_ != nullptr) _impl_.x5_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestInnerGroup& TestDemoGroup::_internal_x5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestInnerGroup* p = _impl_.x5_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestInnerGroup&>(::cfg::_TestInnerGroup_default_instance_);
}
inline const ::cfg::TestInnerGroup& TestDemoGroup::x5() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDemoGroup.x5)
  return _internal_x5();
}
inline void TestDemoGroup::unsafe_arena_set_allocated_x5(::cfg::TestInnerGroup* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x5_);
  }
  _impl_.x5_ = reinterpret_cast<::cfg::TestInnerGroup*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestDemoGroup.x5)
}
inline ::cfg::TestInnerGroup* TestDemoGroup::release_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestInnerGroup* released = _impl_.x5_;
  _impl_.x5_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestInnerGroup* TestDemoGroup::unsafe_arena_release_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDemoGroup.x5)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestInnerGroup* temp = _impl_.x5_;
  _impl_.x5_ = nullptr;
  return temp;
}
inline ::cfg::TestInnerGroup* TestDemoGroup::_internal_mutable_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x5_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestInnerGroup>(GetArenaForAllocation());
    _impl_.x5_ = reinterpret_cast<::cfg::TestInnerGroup*>(p);
  }
  return _impl_.x5_;
}
inline ::cfg::TestInnerGroup* TestDemoGroup::mutable_x5() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestInnerGroup* _msg = _internal_mutable_x5();
  // @@protoc_insertion_point(field_mutable:cfg.TestDemoGroup.x5)
  return _msg;
}
inline void TestDemoGroup::set_allocated_x5(::cfg::TestInnerGroup* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestInnerGroup*>(_impl_.x5_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestInnerGroup*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x5_ = reinterpret_cast<::cfg::TestInnerGroup*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDemoGroup.x5)
}

// -------------------------------------------------------------------

// TestInnerGroup

// int32 y1 = 1;
inline void TestInnerGroup::clear_y1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y1_ = 0;
}
inline ::int32_t TestInnerGroup::y1() const {
  // @@protoc_insertion_point(field_get:cfg.TestInnerGroup.y1)
  return _internal_y1();
}
inline void TestInnerGroup::set_y1(::int32_t value) {
  _internal_set_y1(value);
  // @@protoc_insertion_point(field_set:cfg.TestInnerGroup.y1)
}
inline ::int32_t TestInnerGroup::_internal_y1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y1_;
}
inline void TestInnerGroup::_internal_set_y1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y1_ = value;
}

// -------------------------------------------------------------------

// TestTestGlobal

// int32 unlock_equip = 1;
inline void TestTestGlobal::clear_unlock_equip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unlock_equip_ = 0;
}
inline ::int32_t TestTestGlobal::unlock_equip() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestGlobal.unlock_equip)
  return _internal_unlock_equip();
}
inline void TestTestGlobal::set_unlock_equip(::int32_t value) {
  _internal_set_unlock_equip(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestGlobal.unlock_equip)
}
inline ::int32_t TestTestGlobal::_internal_unlock_equip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unlock_equip_;
}
inline void TestTestGlobal::_internal_set_unlock_equip(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unlock_equip_ = value;
}

// int32 unlock_hero = 2;
inline void TestTestGlobal::clear_unlock_hero() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unlock_hero_ = 0;
}
inline ::int32_t TestTestGlobal::unlock_hero() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestGlobal.unlock_hero)
  return _internal_unlock_hero();
}
inline void TestTestGlobal::set_unlock_hero(::int32_t value) {
  _internal_set_unlock_hero(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestGlobal.unlock_hero)
}
inline ::int32_t TestTestGlobal::_internal_unlock_hero() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unlock_hero_;
}
inline void TestTestGlobal::_internal_set_unlock_hero(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unlock_hero_ = value;
}

// -------------------------------------------------------------------

// TestTestBeRef

// int32 id = 1;
inline void TestTestBeRef::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestBeRef::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestBeRef.id)
  return _internal_id();
}
inline void TestTestBeRef::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestBeRef.id)
}
inline ::int32_t TestTestBeRef::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestBeRef::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 count = 2;
inline void TestTestBeRef::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0;
}
inline ::int32_t TestTestBeRef::count() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestBeRef.count)
  return _internal_count();
}
inline void TestTestBeRef::set_count(::int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestBeRef.count)
}
inline ::int32_t TestTestBeRef::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TestTestBeRef::_internal_set_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestTestRef

// int32 id = 1;
inline void TestTestRef::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestRef::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.id)
  return _internal_id();
}
inline void TestTestRef::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.id)
}
inline ::int32_t TestTestRef::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestRef::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 x1 = 2;
inline void TestTestRef::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::int32_t TestTestRef::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.x1)
  return _internal_x1();
}
inline void TestTestRef::set_x1(::int32_t value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.x1)
}
inline ::int32_t TestTestRef::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestTestRef::_internal_set_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int32 x1_2 = 3;
inline void TestTestRef::clear_x1_2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_2_ = 0;
}
inline ::int32_t TestTestRef::x1_2() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.x1_2)
  return _internal_x1_2();
}
inline void TestTestRef::set_x1_2(::int32_t value) {
  _internal_set_x1_2(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.x1_2)
}
inline ::int32_t TestTestRef::_internal_x1_2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_2_;
}
inline void TestTestRef::_internal_set_x1_2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_2_ = value;
}

// int32 x2 = 4;
inline void TestTestRef::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_ = 0;
}
inline ::int32_t TestTestRef::x2() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.x2)
  return _internal_x2();
}
inline void TestTestRef::set_x2(::int32_t value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.x2)
}
inline ::int32_t TestTestRef::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline void TestTestRef::_internal_set_x2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x2_ = value;
}

// int32 x3 = 5;
inline void TestTestRef::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_ = 0;
}
inline ::int32_t TestTestRef::x3() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.x3)
  return _internal_x3();
}
inline void TestTestRef::set_x3(::int32_t value) {
  _internal_set_x3(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.x3)
}
inline ::int32_t TestTestRef::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline void TestTestRef::_internal_set_x3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x3_ = value;
}

// int32 x4 = 6;
inline void TestTestRef::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_ = 0;
}
inline ::int32_t TestTestRef::x4() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.x4)
  return _internal_x4();
}
inline void TestTestRef::set_x4(::int32_t value) {
  _internal_set_x4(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.x4)
}
inline ::int32_t TestTestRef::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline void TestTestRef::_internal_set_x4(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x4_ = value;
}

// repeated int32 a1 = 7 [packed = true];
inline int TestTestRef::_internal_a1_size() const {
  return _internal_a1().size();
}
inline int TestTestRef::a1_size() const {
  return _internal_a1_size();
}
inline void TestTestRef::clear_a1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.a1_.Clear();
}
inline ::int32_t TestTestRef::a1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.a1)
  return _internal_a1().Get(index);
}
inline void TestTestRef::set_a1(int index, ::int32_t value) {
  _internal_mutable_a1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.a1)
}
inline void TestTestRef::add_a1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_a1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestRef.a1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::a1() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestRef.a1)
  return _internal_a1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::mutable_a1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestRef.a1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_a1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::_internal_a1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.a1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::_internal_mutable_a1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.a1_;
}

// repeated int32 a2 = 8 [packed = true];
inline int TestTestRef::_internal_a2_size() const {
  return _internal_a2().size();
}
inline int TestTestRef::a2_size() const {
  return _internal_a2_size();
}
inline void TestTestRef::clear_a2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.a2_.Clear();
}
inline ::int32_t TestTestRef::a2(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.a2)
  return _internal_a2().Get(index);
}
inline void TestTestRef::set_a2(int index, ::int32_t value) {
  _internal_mutable_a2()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.a2)
}
inline void TestTestRef::add_a2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_a2()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestRef.a2)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::a2() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestRef.a2)
  return _internal_a2();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::mutable_a2() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestRef.a2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_a2();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::_internal_a2()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.a2_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::_internal_mutable_a2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.a2_;
}

// repeated int32 b1 = 9 [packed = true];
inline int TestTestRef::_internal_b1_size() const {
  return _internal_b1().size();
}
inline int TestTestRef::b1_size() const {
  return _internal_b1_size();
}
inline void TestTestRef::clear_b1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.b1_.Clear();
}
inline ::int32_t TestTestRef::b1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.b1)
  return _internal_b1().Get(index);
}
inline void TestTestRef::set_b1(int index, ::int32_t value) {
  _internal_mutable_b1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.b1)
}
inline void TestTestRef::add_b1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_b1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestRef.b1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::b1() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestRef.b1)
  return _internal_b1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::mutable_b1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestRef.b1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_b1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::_internal_b1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.b1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::_internal_mutable_b1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.b1_;
}

// repeated int32 b2 = 10 [packed = true];
inline int TestTestRef::_internal_b2_size() const {
  return _internal_b2().size();
}
inline int TestTestRef::b2_size() const {
  return _internal_b2_size();
}
inline void TestTestRef::clear_b2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.b2_.Clear();
}
inline ::int32_t TestTestRef::b2(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.b2)
  return _internal_b2().Get(index);
}
inline void TestTestRef::set_b2(int index, ::int32_t value) {
  _internal_mutable_b2()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.b2)
}
inline void TestTestRef::add_b2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_b2()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestRef.b2)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::b2() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestRef.b2)
  return _internal_b2();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::mutable_b2() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestRef.b2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_b2();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::_internal_b2()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.b2_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::_internal_mutable_b2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.b2_;
}

// repeated int32 c1 = 11 [packed = true];
inline int TestTestRef::_internal_c1_size() const {
  return _internal_c1().size();
}
inline int TestTestRef::c1_size() const {
  return _internal_c1_size();
}
inline void TestTestRef::clear_c1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.c1_.Clear();
}
inline ::int32_t TestTestRef::c1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.c1)
  return _internal_c1().Get(index);
}
inline void TestTestRef::set_c1(int index, ::int32_t value) {
  _internal_mutable_c1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.c1)
}
inline void TestTestRef::add_c1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_c1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestRef.c1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::c1() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestRef.c1)
  return _internal_c1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::mutable_c1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestRef.c1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_c1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::_internal_c1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.c1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::_internal_mutable_c1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.c1_;
}

// repeated int32 c2 = 12 [packed = true];
inline int TestTestRef::_internal_c2_size() const {
  return _internal_c2().size();
}
inline int TestTestRef::c2_size() const {
  return _internal_c2_size();
}
inline void TestTestRef::clear_c2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.c2_.Clear();
}
inline ::int32_t TestTestRef::c2(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.c2)
  return _internal_c2().Get(index);
}
inline void TestTestRef::set_c2(int index, ::int32_t value) {
  _internal_mutable_c2()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.c2)
}
inline void TestTestRef::add_c2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_c2()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestRef.c2)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::c2() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestRef.c2)
  return _internal_c2();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::mutable_c2() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestRef.c2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_c2();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRef::_internal_c2()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.c2_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRef::_internal_mutable_c2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.c2_;
}

// map<int32, int32> d1 = 13;
inline int TestTestRef::_internal_d1_size() const {
  return _internal_d1().size();
}
inline int TestTestRef::d1_size() const {
  return _internal_d1_size();
}
inline void TestTestRef::clear_d1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.d1_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestRef::_internal_d1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.d1_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestRef::d1() const {
  // @@protoc_insertion_point(field_map:cfg.TestTestRef.d1)
  return _internal_d1();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestRef::_internal_mutable_d1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.d1_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestRef::mutable_d1() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestTestRef.d1)
  return _internal_mutable_d1();
}

// map<int32, int32> d2 = 14;
inline int TestTestRef::_internal_d2_size() const {
  return _internal_d2().size();
}
inline int TestTestRef::d2_size() const {
  return _internal_d2_size();
}
inline void TestTestRef::clear_d2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.d2_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestRef::_internal_d2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.d2_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestRef::d2() const {
  // @@protoc_insertion_point(field_map:cfg.TestTestRef.d2)
  return _internal_d2();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestRef::_internal_mutable_d2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.d2_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestRef::mutable_d2() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestTestRef.d2)
  return _internal_mutable_d2();
}

// int32 e1 = 15;
inline void TestTestRef::clear_e1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.e1_ = 0;
}
inline ::int32_t TestTestRef::e1() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.e1)
  return _internal_e1();
}
inline void TestTestRef::set_e1(::int32_t value) {
  _internal_set_e1(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.e1)
}
inline ::int32_t TestTestRef::_internal_e1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.e1_;
}
inline void TestTestRef::_internal_set_e1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.e1_ = value;
}

// int64 e2 = 16;
inline void TestTestRef::clear_e2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.e2_ = ::int64_t{0};
}
inline ::int64_t TestTestRef::e2() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.e2)
  return _internal_e2();
}
inline void TestTestRef::set_e2(::int64_t value) {
  _internal_set_e2(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.e2)
}
inline ::int64_t TestTestRef::_internal_e2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.e2_;
}
inline void TestTestRef::_internal_set_e2(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.e2_ = value;
}

// string e3 = 17;
inline void TestTestRef::clear_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.e3_.ClearToEmpty();
}
inline const std::string& TestTestRef::e3() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.e3)
  return _internal_e3();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestRef::set_e3(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.e3_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.e3)
}
inline std::string* TestTestRef::mutable_e3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_e3();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestRef.e3)
  return _s;
}
inline const std::string& TestTestRef::_internal_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.e3_.Get();
}
inline void TestTestRef::_internal_set_e3(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.e3_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestRef::_internal_mutable_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.e3_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestRef::release_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestRef.e3)
  return _impl_.e3_.Release();
}
inline void TestTestRef::set_allocated_e3(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.e3_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.e3_.IsDefault()) {
          _impl_.e3_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestRef.e3)
}

// int32 f1 = 18;
inline void TestTestRef::clear_f1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.f1_ = 0;
}
inline ::int32_t TestTestRef::f1() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.f1)
  return _internal_f1();
}
inline void TestTestRef::set_f1(::int32_t value) {
  _internal_set_f1(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.f1)
}
inline ::int32_t TestTestRef::_internal_f1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.f1_;
}
inline void TestTestRef::_internal_set_f1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.f1_ = value;
}

// int64 f2 = 19;
inline void TestTestRef::clear_f2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.f2_ = ::int64_t{0};
}
inline ::int64_t TestTestRef::f2() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.f2)
  return _internal_f2();
}
inline void TestTestRef::set_f2(::int64_t value) {
  _internal_set_f2(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.f2)
}
inline ::int64_t TestTestRef::_internal_f2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.f2_;
}
inline void TestTestRef::_internal_set_f2(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.f2_ = value;
}

// string f3 = 20;
inline void TestTestRef::clear_f3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.f3_.ClearToEmpty();
}
inline const std::string& TestTestRef::f3() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.f3)
  return _internal_f3();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestRef::set_f3(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.f3_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestRef.f3)
}
inline std::string* TestTestRef::mutable_f3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_f3();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestRef.f3)
  return _s;
}
inline const std::string& TestTestRef::_internal_f3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.f3_.Get();
}
inline void TestTestRef::_internal_set_f3(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.f3_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestRef::_internal_mutable_f3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.f3_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestRef::release_f3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestRef.f3)
  return _impl_.f3_.Release();
}
inline void TestTestRef::set_allocated_f3(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.f3_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.f3_.IsDefault()) {
          _impl_.f3_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestRef.f3)
}

// .cfg.TestRefDynamicBase s1 = 21;
inline bool TestTestRef::has_s1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.s1_ != nullptr);
  return value;
}
inline void TestTestRef::clear_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.s1_ != nullptr) _impl_.s1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestRefDynamicBase& TestTestRef::_internal_s1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestRefDynamicBase* p = _impl_.s1_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestRefDynamicBase&>(::cfg::_TestRefDynamicBase_default_instance_);
}
inline const ::cfg::TestRefDynamicBase& TestTestRef::s1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestRef.s1)
  return _internal_s1();
}
inline void TestTestRef::unsafe_arena_set_allocated_s1(::cfg::TestRefDynamicBase* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.s1_);
  }
  _impl_.s1_ = reinterpret_cast<::cfg::TestRefDynamicBase*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestRef.s1)
}
inline ::cfg::TestRefDynamicBase* TestTestRef::release_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestRefDynamicBase* released = _impl_.s1_;
  _impl_.s1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestRefDynamicBase* TestTestRef::unsafe_arena_release_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestRef.s1)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestRefDynamicBase* temp = _impl_.s1_;
  _impl_.s1_ = nullptr;
  return temp;
}
inline ::cfg::TestRefDynamicBase* TestTestRef::_internal_mutable_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.s1_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestRefDynamicBase>(GetArenaForAllocation());
    _impl_.s1_ = reinterpret_cast<::cfg::TestRefDynamicBase*>(p);
  }
  return _impl_.s1_;
}
inline ::cfg::TestRefDynamicBase* TestTestRef::mutable_s1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestRefDynamicBase* _msg = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestRef.s1)
  return _msg;
}
inline void TestTestRef::set_allocated_s1(::cfg::TestRefDynamicBase* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestRefDynamicBase*>(_impl_.s1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestRefDynamicBase*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.s1_ = reinterpret_cast<::cfg::TestRefDynamicBase*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestRef.s1)
}

// -------------------------------------------------------------------

// TestRefDynamicBase

// .cfg.TestRefBean RefBean = 1;
inline bool TestRefDynamicBase::has_refbean() const {
  return value_case() == kRefBean;
}
inline bool TestRefDynamicBase::_internal_has_refbean() const {
  return value_case() == kRefBean;
}
inline void TestRefDynamicBase::set_has_refbean() {
  _impl_._oneof_case_[0] = kRefBean;
}
inline void TestRefDynamicBase::clear_refbean() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kRefBean) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.refbean_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestRefBean* TestRefDynamicBase::release_refbean() {
  // @@protoc_insertion_point(field_release:cfg.TestRefDynamicBase.RefBean)
  if (value_case() == kRefBean) {
    clear_has_value();
    ::cfg::TestRefBean* temp = _impl_.value_.refbean_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.refbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestRefBean& TestRefDynamicBase::_internal_refbean() const {
  return value_case() == kRefBean ? *_impl_.value_.refbean_ : reinterpret_cast<::cfg::TestRefBean&>(::cfg::_TestRefBean_default_instance_);
}
inline const ::cfg::TestRefBean& TestRefDynamicBase::refbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestRefDynamicBase.RefBean)
  return _internal_refbean();
}
inline ::cfg::TestRefBean* TestRefDynamicBase::unsafe_arena_release_refbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestRefDynamicBase.RefBean)
  if (value_case() == kRefBean) {
    clear_has_value();
    ::cfg::TestRefBean* temp = _impl_.value_.refbean_;
    _impl_.value_.refbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestRefDynamicBase::unsafe_arena_set_allocated_refbean(::cfg::TestRefBean* refbean) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (refbean) {
    set_has_refbean();
    _impl_.value_.refbean_ = refbean;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestRefDynamicBase.RefBean)
}
inline ::cfg::TestRefBean* TestRefDynamicBase::_internal_mutable_refbean() {
  if (value_case() != kRefBean) {
    clear_value();
    set_has_refbean();
    _impl_.value_.refbean_ =
        CreateMaybeMessage<::cfg::TestRefBean>(GetArenaForAllocation());
  }
  return _impl_.value_.refbean_;
}
inline ::cfg::TestRefBean* TestRefDynamicBase::mutable_refbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestRefBean* _msg = _internal_mutable_refbean();
  // @@protoc_insertion_point(field_mutable:cfg.TestRefDynamicBase.RefBean)
  return _msg;
}

inline bool TestRefDynamicBase::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TestRefDynamicBase::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline TestRefDynamicBase::ValueCase TestRefDynamicBase::value_case() const {
  return TestRefDynamicBase::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestRefBean

// int32 x = 1;
inline void TestRefBean::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t TestRefBean::x() const {
  // @@protoc_insertion_point(field_get:cfg.TestRefBean.x)
  return _internal_x();
}
inline void TestRefBean::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.TestRefBean.x)
}
inline ::int32_t TestRefBean::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TestRefBean::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// repeated int32 arr = 2 [packed = true];
inline int TestRefBean::_internal_arr_size() const {
  return _internal_arr().size();
}
inline int TestRefBean::arr_size() const {
  return _internal_arr_size();
}
inline void TestRefBean::clear_arr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arr_.Clear();
}
inline ::int32_t TestRefBean::arr(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestRefBean.arr)
  return _internal_arr().Get(index);
}
inline void TestRefBean::set_arr(int index, ::int32_t value) {
  _internal_mutable_arr()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestRefBean.arr)
}
inline void TestRefBean::add_arr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_arr()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestRefBean.arr)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestRefBean::arr() const {
  // @@protoc_insertion_point(field_list:cfg.TestRefBean.arr)
  return _internal_arr();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestRefBean::mutable_arr() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestRefBean.arr)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_arr();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestRefBean::_internal_arr()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arr_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestRefBean::_internal_mutable_arr() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.arr_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestTestSize

// int32 id = 1;
inline void TestTestSize::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestSize::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSize.id)
  return _internal_id();
}
inline void TestTestSize::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSize.id)
}
inline ::int32_t TestTestSize::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestSize::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// repeated int32 x1 = 2 [packed = true];
inline int TestTestSize::_internal_x1_size() const {
  return _internal_x1().size();
}
inline int TestTestSize::x1_size() const {
  return _internal_x1_size();
}
inline void TestTestSize::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_.Clear();
}
inline ::int32_t TestTestSize::x1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSize.x1)
  return _internal_x1().Get(index);
}
inline void TestTestSize::set_x1(int index, ::int32_t value) {
  _internal_mutable_x1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSize.x1)
}
inline void TestTestSize::add_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestSize.x1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSize::x1() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestSize.x1)
  return _internal_x1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSize::mutable_x1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestSize.x1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSize::_internal_x1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSize::_internal_mutable_x1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x1_;
}

// repeated int32 x2 = 3 [packed = true];
inline int TestTestSize::_internal_x2_size() const {
  return _internal_x2().size();
}
inline int TestTestSize::x2_size() const {
  return _internal_x2_size();
}
inline void TestTestSize::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_.Clear();
}
inline ::int32_t TestTestSize::x2(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSize.x2)
  return _internal_x2().Get(index);
}
inline void TestTestSize::set_x2(int index, ::int32_t value) {
  _internal_mutable_x2()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSize.x2)
}
inline void TestTestSize::add_x2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x2()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestSize.x2)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSize::x2() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestSize.x2)
  return _internal_x2();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSize::mutable_x2() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestSize.x2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x2();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSize::_internal_x2()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSize::_internal_mutable_x2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x2_;
}

// repeated int32 x3 = 4 [packed = true];
inline int TestTestSize::_internal_x3_size() const {
  return _internal_x3().size();
}
inline int TestTestSize::x3_size() const {
  return _internal_x3_size();
}
inline void TestTestSize::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_.Clear();
}
inline ::int32_t TestTestSize::x3(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSize.x3)
  return _internal_x3().Get(index);
}
inline void TestTestSize::set_x3(int index, ::int32_t value) {
  _internal_mutable_x3()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSize.x3)
}
inline void TestTestSize::add_x3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x3()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestSize.x3)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSize::x3() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestSize.x3)
  return _internal_x3();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSize::mutable_x3() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestSize.x3)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x3();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSize::_internal_x3()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSize::_internal_mutable_x3() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x3_;
}

// map<int32, int32> x4 = 5;
inline int TestTestSize::_internal_x4_size() const {
  return _internal_x4().size();
}
inline int TestTestSize::x4_size() const {
  return _internal_x4_size();
}
inline void TestTestSize::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestSize::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestSize::x4() const {
  // @@protoc_insertion_point(field_map:cfg.TestTestSize.x4)
  return _internal_x4();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestSize::_internal_mutable_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.x4_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestSize::mutable_x4() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestTestSize.x4)
  return _internal_mutable_x4();
}

// -------------------------------------------------------------------

// TestTestSet

// int32 id = 1;
inline void TestTestSet::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestSet::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSet.id)
  return _internal_id();
}
inline void TestTestSet::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSet.id)
}
inline ::int32_t TestTestSet::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestSet::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string x0 = 2;
inline void TestTestSet::clear_x0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x0_.ClearToEmpty();
}
inline const std::string& TestTestSet::x0() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestSet.x0)
  return _internal_x0();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestSet::set_x0(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x0_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestSet.x0)
}
inline std::string* TestTestSet::mutable_x0() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_x0();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestSet.x0)
  return _s;
}
inline const std::string& TestTestSet::_internal_x0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x0_.Get();
}
inline void TestTestSet::_internal_set_x0(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x0_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestSet::_internal_mutable_x0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.x0_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestSet::release_x0() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestSet.x0)
  return _impl_.x0_.Release();
}
inline void TestTestSet::set_allocated_x0(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x0_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.x0_.IsDefault()) {
          _impl_.x0_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestSet.x0)
}

// repeated int32 x1 = 3 [packed = true];
inline int TestTestSet::_internal_x1_size() const {
  return _internal_x1().size();
}
inline int TestTestSet::x1_size() const {
  return _internal_x1_size();
}
inline void TestTestSet::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_.Clear();
}
inline ::int32_t TestTestSet::x1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSet.x1)
  return _internal_x1().Get(index);
}
inline void TestTestSet::set_x1(int index, ::int32_t value) {
  _internal_mutable_x1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSet.x1)
}
inline void TestTestSet::add_x1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestSet.x1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSet::x1() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestSet.x1)
  return _internal_x1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSet::mutable_x1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestSet.x1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestSet::_internal_x1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestSet::_internal_mutable_x1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x1_;
}

// repeated int64 x2 = 4 [packed = true];
inline int TestTestSet::_internal_x2_size() const {
  return _internal_x2().size();
}
inline int TestTestSet::x2_size() const {
  return _internal_x2_size();
}
inline void TestTestSet::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_.Clear();
}
inline ::int64_t TestTestSet::x2(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSet.x2)
  return _internal_x2().Get(index);
}
inline void TestTestSet::set_x2(int index, ::int64_t value) {
  _internal_mutable_x2()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSet.x2)
}
inline void TestTestSet::add_x2(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x2()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestSet.x2)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TestTestSet::x2() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestSet.x2)
  return _internal_x2();
}
inline ::google::protobuf::RepeatedField<::int64_t>* TestTestSet::mutable_x2() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestSet.x2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x2();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TestTestSet::_internal_x2()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* TestTestSet::_internal_mutable_x2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x2_;
}

// repeated string x3 = 5 [packed = false];
inline int TestTestSet::_internal_x3_size() const {
  return _internal_x3().size();
}
inline int TestTestSet::x3_size() const {
  return _internal_x3_size();
}
inline void TestTestSet::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_.Clear();
}
inline std::string* TestTestSet::add_x3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_x3()->Add();
  // @@protoc_insertion_point(field_add_mutable:cfg.TestTestSet.x3)
  return _s;
}
inline const std::string& TestTestSet::x3(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestSet.x3)
  return _internal_x3().Get(index);
}
inline std::string* TestTestSet::mutable_x3(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTestSet.x3)
  return _internal_mutable_x3()->Mutable(index);
}
inline void TestTestSet::set_x3(int index, const std::string& value) {
  _internal_mutable_x3()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSet.x3)
}
inline void TestTestSet::set_x3(int index, std::string&& value) {
  _internal_mutable_x3()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cfg.TestTestSet.x3)
}
inline void TestTestSet::set_x3(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_x3()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cfg.TestTestSet.x3)
}
inline void TestTestSet::set_x3(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_x3()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cfg.TestTestSet.x3)
}
inline void TestTestSet::set_x3(int index, absl::string_view value) {
  _internal_mutable_x3()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:cfg.TestTestSet.x3)
}
inline void TestTestSet::add_x3(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x3()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestSet.x3)
}
inline void TestTestSet::add_x3(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x3()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:cfg.TestTestSet.x3)
}
inline void TestTestSet::add_x3(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x3()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cfg.TestTestSet.x3)
}
inline void TestTestSet::add_x3(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x3()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cfg.TestTestSet.x3)
}
inline void TestTestSet::add_x3(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x3()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:cfg.TestTestSet.x3)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestTestSet::x3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTestSet.x3)
  return _internal_x3();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestTestSet::mutable_x3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestSet.x3)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x3();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestTestSet::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestTestSet::_internal_mutable_x3() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x3_;
}

// repeated .cfg.TestDemoEnum x4 = 6 [packed = false];
inline int TestTestSet::_internal_x4_size() const {
  return _internal_x4().size();
}
inline int TestTestSet::x4_size() const {
  return _internal_x4_size();
}
inline void TestTestSet::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_.Clear();
}
inline ::cfg::TestDemoEnum TestTestSet::x4(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestSet.x4)
  return static_cast<::cfg::TestDemoEnum>(_internal_x4().Get(index));
}
inline void TestTestSet::set_x4(int index, ::cfg::TestDemoEnum value) {
  _internal_mutable_x4()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestSet.x4)
}
inline void TestTestSet::add_x4(::cfg::TestDemoEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_x4()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestSet.x4)
}
inline const ::google::protobuf::RepeatedField<int>& TestTestSet::x4() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestSet.x4)
  return _internal_x4();
}
inline ::google::protobuf::RepeatedField<int>* TestTestSet::mutable_x4() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestSet.x4)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_x4();
}
inline const ::google::protobuf::RepeatedField<int>& TestTestSet::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline ::google::protobuf::RepeatedField<int>* TestTestSet::_internal_mutable_x4() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.x4_;
}

// -------------------------------------------------------------------

// TestDetectEncoding

// int32 id = 1;
inline void TestDetectEncoding::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestDetectEncoding::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestDetectEncoding.id)
  return _internal_id();
}
inline void TestDetectEncoding::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestDetectEncoding.id)
}
inline ::int32_t TestDetectEncoding::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestDetectEncoding::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void TestDetectEncoding::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestDetectEncoding::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDetectEncoding.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDetectEncoding::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDetectEncoding.name)
}
inline std::string* TestDetectEncoding::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.TestDetectEncoding.name)
  return _s;
}
inline const std::string& TestDetectEncoding::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TestDetectEncoding::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDetectEncoding::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDetectEncoding::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDetectEncoding.name)
  return _impl_.name_.Release();
}
inline void TestDetectEncoding::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDetectEncoding.name)
}

// -------------------------------------------------------------------

// TestItemBase

// .cfg.TestItem Item = 1;
inline bool TestItemBase::has_item() const {
  return value_case() == kItem;
}
inline bool TestItemBase::_internal_has_item() const {
  return value_case() == kItem;
}
inline void TestItemBase::set_has_item() {
  _impl_._oneof_case_[0] = kItem;
}
inline void TestItemBase::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kItem) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.item_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestItem* TestItemBase::release_item() {
  // @@protoc_insertion_point(field_release:cfg.TestItemBase.Item)
  if (value_case() == kItem) {
    clear_has_value();
    ::cfg::TestItem* temp = _impl_.value_.item_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestItem& TestItemBase::_internal_item() const {
  return value_case() == kItem ? *_impl_.value_.item_ : reinterpret_cast<::cfg::TestItem&>(::cfg::_TestItem_default_instance_);
}
inline const ::cfg::TestItem& TestItemBase::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestItemBase.Item)
  return _internal_item();
}
inline ::cfg::TestItem* TestItemBase::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestItemBase.Item)
  if (value_case() == kItem) {
    clear_has_value();
    ::cfg::TestItem* temp = _impl_.value_.item_;
    _impl_.value_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestItemBase::unsafe_arena_set_allocated_item(::cfg::TestItem* item) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (item) {
    set_has_item();
    _impl_.value_.item_ = item;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestItemBase.Item)
}
inline ::cfg::TestItem* TestItemBase::_internal_mutable_item() {
  if (value_case() != kItem) {
    clear_value();
    set_has_item();
    _impl_.value_.item_ =
        CreateMaybeMessage<::cfg::TestItem>(GetArenaForAllocation());
  }
  return _impl_.value_.item_;
}
inline ::cfg::TestItem* TestItemBase::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:cfg.TestItemBase.Item)
  return _msg;
}

// .cfg.TestEquipment Equipment = 2;
inline bool TestItemBase::has_equipment() const {
  return value_case() == kEquipment;
}
inline bool TestItemBase::_internal_has_equipment() const {
  return value_case() == kEquipment;
}
inline void TestItemBase::set_has_equipment() {
  _impl_._oneof_case_[0] = kEquipment;
}
inline void TestItemBase::clear_equipment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kEquipment) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.equipment_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestEquipment* TestItemBase::release_equipment() {
  // @@protoc_insertion_point(field_release:cfg.TestItemBase.Equipment)
  if (value_case() == kEquipment) {
    clear_has_value();
    ::cfg::TestEquipment* temp = _impl_.value_.equipment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestEquipment& TestItemBase::_internal_equipment() const {
  return value_case() == kEquipment ? *_impl_.value_.equipment_ : reinterpret_cast<::cfg::TestEquipment&>(::cfg::_TestEquipment_default_instance_);
}
inline const ::cfg::TestEquipment& TestItemBase::equipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestItemBase.Equipment)
  return _internal_equipment();
}
inline ::cfg::TestEquipment* TestItemBase::unsafe_arena_release_equipment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestItemBase.Equipment)
  if (value_case() == kEquipment) {
    clear_has_value();
    ::cfg::TestEquipment* temp = _impl_.value_.equipment_;
    _impl_.value_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestItemBase::unsafe_arena_set_allocated_equipment(::cfg::TestEquipment* equipment) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (equipment) {
    set_has_equipment();
    _impl_.value_.equipment_ = equipment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestItemBase.Equipment)
}
inline ::cfg::TestEquipment* TestItemBase::_internal_mutable_equipment() {
  if (value_case() != kEquipment) {
    clear_value();
    set_has_equipment();
    _impl_.value_.equipment_ =
        CreateMaybeMessage<::cfg::TestEquipment>(GetArenaForAllocation());
  }
  return _impl_.value_.equipment_;
}
inline ::cfg::TestEquipment* TestItemBase::mutable_equipment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestEquipment* _msg = _internal_mutable_equipment();
  // @@protoc_insertion_point(field_mutable:cfg.TestItemBase.Equipment)
  return _msg;
}

// .cfg.TestDecorator Decorator = 3;
inline bool TestItemBase::has_decorator() const {
  return value_case() == kDecorator;
}
inline bool TestItemBase::_internal_has_decorator() const {
  return value_case() == kDecorator;
}
inline void TestItemBase::set_has_decorator() {
  _impl_._oneof_case_[0] = kDecorator;
}
inline void TestItemBase::clear_decorator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDecorator) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.decorator_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestDecorator* TestItemBase::release_decorator() {
  // @@protoc_insertion_point(field_release:cfg.TestItemBase.Decorator)
  if (value_case() == kDecorator) {
    clear_has_value();
    ::cfg::TestDecorator* temp = _impl_.value_.decorator_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.decorator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestDecorator& TestItemBase::_internal_decorator() const {
  return value_case() == kDecorator ? *_impl_.value_.decorator_ : reinterpret_cast<::cfg::TestDecorator&>(::cfg::_TestDecorator_default_instance_);
}
inline const ::cfg::TestDecorator& TestItemBase::decorator() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestItemBase.Decorator)
  return _internal_decorator();
}
inline ::cfg::TestDecorator* TestItemBase::unsafe_arena_release_decorator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestItemBase.Decorator)
  if (value_case() == kDecorator) {
    clear_has_value();
    ::cfg::TestDecorator* temp = _impl_.value_.decorator_;
    _impl_.value_.decorator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestItemBase::unsafe_arena_set_allocated_decorator(::cfg::TestDecorator* decorator) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (decorator) {
    set_has_decorator();
    _impl_.value_.decorator_ = decorator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestItemBase.Decorator)
}
inline ::cfg::TestDecorator* TestItemBase::_internal_mutable_decorator() {
  if (value_case() != kDecorator) {
    clear_value();
    set_has_decorator();
    _impl_.value_.decorator_ =
        CreateMaybeMessage<::cfg::TestDecorator>(GetArenaForAllocation());
  }
  return _impl_.value_.decorator_;
}
inline ::cfg::TestDecorator* TestItemBase::mutable_decorator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDecorator* _msg = _internal_mutable_decorator();
  // @@protoc_insertion_point(field_mutable:cfg.TestItemBase.Decorator)
  return _msg;
}

inline bool TestItemBase::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TestItemBase::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline TestItemBase::ValueCase TestItemBase::value_case() const {
  return TestItemBase::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestItem

// int32 id = 1;
inline void TestItem::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestItem::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestItem.id)
  return _internal_id();
}
inline void TestItem::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestItem.id)
}
inline ::int32_t TestItem::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestItem::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void TestItem::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestItem::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestItem.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestItem::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestItem.name)
}
inline std::string* TestItem::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.TestItem.name)
  return _s;
}
inline const std::string& TestItem::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TestItem::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestItem::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestItem::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestItem.name)
  return _impl_.name_.Release();
}
inline void TestItem::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestItem.name)
}

// string desc = 3;
inline void TestItem::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& TestItem::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestItem.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestItem::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestItem.desc)
}
inline std::string* TestItem::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.TestItem.desc)
  return _s;
}
inline const std::string& TestItem::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void TestItem::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* TestItem::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* TestItem::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestItem.desc)
  return _impl_.desc_.Release();
}
inline void TestItem::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestItem.desc)
}

// int32 num = 4;
inline void TestItem::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
}
inline ::int32_t TestItem::num() const {
  // @@protoc_insertion_point(field_get:cfg.TestItem.num)
  return _internal_num();
}
inline void TestItem::set_num(::int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:cfg.TestItem.num)
}
inline ::int32_t TestItem::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void TestItem::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_ = value;
}

// int32 price = 5;
inline void TestItem::clear_price() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.price_ = 0;
}
inline ::int32_t TestItem::price() const {
  // @@protoc_insertion_point(field_get:cfg.TestItem.price)
  return _internal_price();
}
inline void TestItem::set_price(::int32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:cfg.TestItem.price)
}
inline ::int32_t TestItem::_internal_price() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.price_;
}
inline void TestItem::_internal_set_price(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.price_ = value;
}

// -------------------------------------------------------------------

// TestEquipment

// int32 id = 1;
inline void TestEquipment::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestEquipment::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestEquipment.id)
  return _internal_id();
}
inline void TestEquipment::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestEquipment.id)
}
inline ::int32_t TestEquipment::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestEquipment::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void TestEquipment::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestEquipment::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestEquipment.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestEquipment::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestEquipment.name)
}
inline std::string* TestEquipment::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.TestEquipment.name)
  return _s;
}
inline const std::string& TestEquipment::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TestEquipment::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestEquipment::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestEquipment::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestEquipment.name)
  return _impl_.name_.Release();
}
inline void TestEquipment::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestEquipment.name)
}

// string desc = 3;
inline void TestEquipment::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& TestEquipment::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestEquipment.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestEquipment::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestEquipment.desc)
}
inline std::string* TestEquipment::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.TestEquipment.desc)
  return _s;
}
inline const std::string& TestEquipment::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void TestEquipment::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* TestEquipment::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* TestEquipment::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestEquipment.desc)
  return _impl_.desc_.Release();
}
inline void TestEquipment::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestEquipment.desc)
}

// .cfg.TestDemoEnum attr = 4;
inline void TestEquipment::clear_attr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attr_ = 0;
}
inline ::cfg::TestDemoEnum TestEquipment::attr() const {
  // @@protoc_insertion_point(field_get:cfg.TestEquipment.attr)
  return _internal_attr();
}
inline void TestEquipment::set_attr(::cfg::TestDemoEnum value) {
  _internal_set_attr(value);
  // @@protoc_insertion_point(field_set:cfg.TestEquipment.attr)
}
inline ::cfg::TestDemoEnum TestEquipment::_internal_attr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::TestDemoEnum>(_impl_.attr_);
}
inline void TestEquipment::_internal_set_attr(::cfg::TestDemoEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attr_ = value;
}

// int32 value = 5;
inline void TestEquipment::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t TestEquipment::value() const {
  // @@protoc_insertion_point(field_get:cfg.TestEquipment.value)
  return _internal_value();
}
inline void TestEquipment::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cfg.TestEquipment.value)
}
inline ::int32_t TestEquipment::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void TestEquipment::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// TestDecorator

// int32 id = 1;
inline void TestDecorator::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestDecorator::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestDecorator.id)
  return _internal_id();
}
inline void TestDecorator::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestDecorator.id)
}
inline ::int32_t TestDecorator::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestDecorator::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void TestDecorator::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestDecorator::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDecorator.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDecorator::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDecorator.name)
}
inline std::string* TestDecorator::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cfg.TestDecorator.name)
  return _s;
}
inline const std::string& TestDecorator::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TestDecorator::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDecorator::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDecorator::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDecorator.name)
  return _impl_.name_.Release();
}
inline void TestDecorator::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDecorator.name)
}

// string desc = 3;
inline void TestDecorator::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& TestDecorator::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestDecorator.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestDecorator::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestDecorator.desc)
}
inline std::string* TestDecorator::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.TestDecorator.desc)
  return _s;
}
inline const std::string& TestDecorator::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void TestDecorator::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDecorator::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* TestDecorator::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestDecorator.desc)
  return _impl_.desc_.Release();
}
inline void TestDecorator::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestDecorator.desc)
}

// int32 duration = 4;
inline void TestDecorator::clear_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_ = 0;
}
inline ::int32_t TestDecorator::duration() const {
  // @@protoc_insertion_point(field_get:cfg.TestDecorator.duration)
  return _internal_duration();
}
inline void TestDecorator::set_duration(::int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:cfg.TestDecorator.duration)
}
inline ::int32_t TestDecorator::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void TestDecorator::_internal_set_duration(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ = value;
}

// -------------------------------------------------------------------

// TestTestIndex

// int32 id = 1;
inline void TestTestIndex::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestIndex::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestIndex.id)
  return _internal_id();
}
inline void TestTestIndex::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestIndex.id)
}
inline ::int32_t TestTestIndex::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestIndex::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// repeated .cfg.TestDemoType1 eles = 2 [packed = false];
inline int TestTestIndex::_internal_eles_size() const {
  return _internal_eles().size();
}
inline int TestTestIndex::eles_size() const {
  return _internal_eles_size();
}
inline void TestTestIndex::clear_eles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.eles_.Clear();
}
inline ::cfg::TestDemoType1* TestTestIndex::mutable_eles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTestIndex.eles)
  return _internal_mutable_eles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType1>* TestTestIndex::mutable_eles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestIndex.eles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_eles();
}
inline const ::cfg::TestDemoType1& TestTestIndex::eles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestIndex.eles)
  return _internal_eles().Get(index);
}
inline ::cfg::TestDemoType1* TestTestIndex::add_eles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoType1* _add = _internal_mutable_eles()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTestIndex.eles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType1>& TestTestIndex::eles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTestIndex.eles)
  return _internal_eles();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType1>&
TestTestIndex::_internal_eles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.eles_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType1>*
TestTestIndex::_internal_mutable_eles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.eles_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestTestMap

// int32 id = 1;
inline void TestTestMap::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestMap::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestMap.id)
  return _internal_id();
}
inline void TestTestMap::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestMap.id)
}
inline ::int32_t TestTestMap::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestMap::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// map<int32, int32> x1 = 2;
inline int TestTestMap::_internal_x1_size() const {
  return _internal_x1().size();
}
inline int TestTestMap::x1_size() const {
  return _internal_x1_size();
}
inline void TestTestMap::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestMap::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestMap::x1() const {
  // @@protoc_insertion_point(field_map:cfg.TestTestMap.x1)
  return _internal_x1();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestMap::_internal_mutable_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.x1_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestMap::mutable_x1() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestTestMap.x1)
  return _internal_mutable_x1();
}

// map<int64, int32> x2 = 3;
inline int TestTestMap::_internal_x2_size() const {
  return _internal_x2().size();
}
inline int TestTestMap::x2_size() const {
  return _internal_x2_size();
}
inline void TestTestMap::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_.Clear();
}
inline const ::google::protobuf::Map<::int64_t, ::int32_t>& TestTestMap::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x2_.GetMap();
}
inline const ::google::protobuf::Map<::int64_t, ::int32_t>& TestTestMap::x2() const {
  // @@protoc_insertion_point(field_map:cfg.TestTestMap.x2)
  return _internal_x2();
}
inline ::google::protobuf::Map<::int64_t, ::int32_t>* TestTestMap::_internal_mutable_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.x2_.MutableMap();
}
inline ::google::protobuf::Map<::int64_t, ::int32_t>* TestTestMap::mutable_x2() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestTestMap.x2)
  return _internal_mutable_x2();
}

// map<string, int32> x3 = 4;
inline int TestTestMap::_internal_x3_size() const {
  return _internal_x3().size();
}
inline int TestTestMap::x3_size() const {
  return _internal_x3_size();
}
inline void TestTestMap::clear_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x3_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& TestTestMap::_internal_x3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x3_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& TestTestMap::x3() const {
  // @@protoc_insertion_point(field_map:cfg.TestTestMap.x3)
  return _internal_x3();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* TestTestMap::_internal_mutable_x3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.x3_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* TestTestMap::mutable_x3() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestTestMap.x3)
  return _internal_mutable_x3();
}

// map<int32, int32> x4 = 5;
inline int TestTestMap::_internal_x4_size() const {
  return _internal_x4().size();
}
inline int TestTestMap::x4_size() const {
  return _internal_x4_size();
}
inline void TestTestMap::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestMap::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestTestMap::x4() const {
  // @@protoc_insertion_point(field_map:cfg.TestTestMap.x4)
  return _internal_x4();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestMap::_internal_mutable_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.x4_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestTestMap::mutable_x4() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestTestMap.x4)
  return _internal_mutable_x4();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestExcelFromJson

// int32 x4 = 1;
inline void TestExcelFromJson::clear_x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x4_ = 0;
}
inline ::int32_t TestExcelFromJson::x4() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.x4)
  return _internal_x4();
}
inline void TestExcelFromJson::set_x4(::int32_t value) {
  _internal_set_x4(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.x4)
}
inline ::int32_t TestExcelFromJson::_internal_x4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x4_;
}
inline void TestExcelFromJson::_internal_set_x4(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x4_ = value;
}

// bool x1 = 2;
inline void TestExcelFromJson::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = false;
}
inline bool TestExcelFromJson::x1() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.x1)
  return _internal_x1();
}
inline void TestExcelFromJson::set_x1(bool value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.x1)
}
inline bool TestExcelFromJson::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void TestExcelFromJson::_internal_set_x1(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int64 x5 = 3;
inline void TestExcelFromJson::clear_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x5_ = ::int64_t{0};
}
inline ::int64_t TestExcelFromJson::x5() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.x5)
  return _internal_x5();
}
inline void TestExcelFromJson::set_x5(::int64_t value) {
  _internal_set_x5(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.x5)
}
inline ::int64_t TestExcelFromJson::_internal_x5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x5_;
}
inline void TestExcelFromJson::_internal_set_x5(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x5_ = value;
}

// float x6 = 4;
inline void TestExcelFromJson::clear_x6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x6_ = 0;
}
inline float TestExcelFromJson::x6() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.x6)
  return _internal_x6();
}
inline void TestExcelFromJson::set_x6(float value) {
  _internal_set_x6(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.x6)
}
inline float TestExcelFromJson::_internal_x6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x6_;
}
inline void TestExcelFromJson::_internal_set_x6(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x6_ = value;
}

// string s1 = 5;
inline void TestExcelFromJson::clear_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.ClearToEmpty();
}
inline const std::string& TestExcelFromJson::s1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.s1)
  return _internal_s1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestExcelFromJson::set_s1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.s1)
}
inline std::string* TestExcelFromJson::mutable_s1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:cfg.TestExcelFromJson.s1)
  return _s;
}
inline const std::string& TestExcelFromJson::_internal_s1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s1_.Get();
}
inline void TestExcelFromJson::_internal_set_s1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s1_.Set(value, GetArenaForAllocation());
}
inline std::string* TestExcelFromJson::_internal_mutable_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s1_.Mutable( GetArenaForAllocation());
}
inline std::string* TestExcelFromJson::release_s1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestExcelFromJson.s1)
  return _impl_.s1_.Release();
}
inline void TestExcelFromJson::set_allocated_s1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s1_.IsDefault()) {
          _impl_.s1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestExcelFromJson.s1)
}

// string s2 = 6;
inline void TestExcelFromJson::clear_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.ClearToEmpty();
}
inline const std::string& TestExcelFromJson::s2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.s2)
  return _internal_s2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestExcelFromJson::set_s2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.s2)
}
inline std::string* TestExcelFromJson::mutable_s2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:cfg.TestExcelFromJson.s2)
  return _s;
}
inline const std::string& TestExcelFromJson::_internal_s2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s2_.Get();
}
inline void TestExcelFromJson::_internal_set_s2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s2_.Set(value, GetArenaForAllocation());
}
inline std::string* TestExcelFromJson::_internal_mutable_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.s2_.Mutable( GetArenaForAllocation());
}
inline std::string* TestExcelFromJson::release_s2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestExcelFromJson.s2)
  return _impl_.s2_.Release();
}
inline void TestExcelFromJson::set_allocated_s2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s2_.IsDefault()) {
          _impl_.s2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestExcelFromJson.s2)
}

// int64 t1 = 7;
inline void TestExcelFromJson::clear_t1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.t1_ = ::int64_t{0};
}
inline ::int64_t TestExcelFromJson::t1() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.t1)
  return _internal_t1();
}
inline void TestExcelFromJson::set_t1(::int64_t value) {
  _internal_set_t1(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.t1)
}
inline ::int64_t TestExcelFromJson::_internal_t1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.t1_;
}
inline void TestExcelFromJson::_internal_set_t1(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.t1_ = value;
}

// .cfg.TestDemoType1 x12 = 8;
inline bool TestExcelFromJson::has_x12() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x12_ != nullptr);
  return value;
}
inline void TestExcelFromJson::clear_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x12_ != nullptr) _impl_.x12_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestDemoType1& TestExcelFromJson::_internal_x12() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoType1* p = _impl_.x12_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoType1&>(::cfg::_TestDemoType1_default_instance_);
}
inline const ::cfg::TestDemoType1& TestExcelFromJson::x12() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.x12)
  return _internal_x12();
}
inline void TestExcelFromJson::unsafe_arena_set_allocated_x12(::cfg::TestDemoType1* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x12_);
  }
  _impl_.x12_ = reinterpret_cast<::cfg::TestDemoType1*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestExcelFromJson.x12)
}
inline ::cfg::TestDemoType1* TestExcelFromJson::release_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoType1* released = _impl_.x12_;
  _impl_.x12_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoType1* TestExcelFromJson::unsafe_arena_release_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestExcelFromJson.x12)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoType1* temp = _impl_.x12_;
  _impl_.x12_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoType1* TestExcelFromJson::_internal_mutable_x12() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x12_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoType1>(GetArenaForAllocation());
    _impl_.x12_ = reinterpret_cast<::cfg::TestDemoType1*>(p);
  }
  return _impl_.x12_;
}
inline ::cfg::TestDemoType1* TestExcelFromJson::mutable_x12() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoType1* _msg = _internal_mutable_x12();
  // @@protoc_insertion_point(field_mutable:cfg.TestExcelFromJson.x12)
  return _msg;
}
inline void TestExcelFromJson::set_allocated_x12(::cfg::TestDemoType1* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoType1*>(_impl_.x12_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoType1*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x12_ = reinterpret_cast<::cfg::TestDemoType1*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestExcelFromJson.x12)
}

// .cfg.TestDemoEnum x13 = 9;
inline void TestExcelFromJson::clear_x13() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x13_ = 0;
}
inline ::cfg::TestDemoEnum TestExcelFromJson::x13() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.x13)
  return _internal_x13();
}
inline void TestExcelFromJson::set_x13(::cfg::TestDemoEnum value) {
  _internal_set_x13(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.x13)
}
inline ::cfg::TestDemoEnum TestExcelFromJson::_internal_x13() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::TestDemoEnum>(_impl_.x13_);
}
inline void TestExcelFromJson::_internal_set_x13(::cfg::TestDemoEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x13_ = value;
}

// .cfg.TestDemoDynamic x14 = 10;
inline bool TestExcelFromJson::has_x14() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x14_ != nullptr);
  return value;
}
inline void TestExcelFromJson::clear_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x14_ != nullptr) _impl_.x14_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::TestDemoDynamic& TestExcelFromJson::_internal_x14() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoDynamic* p = _impl_.x14_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoDynamic&>(::cfg::_TestDemoDynamic_default_instance_);
}
inline const ::cfg::TestDemoDynamic& TestExcelFromJson::x14() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.x14)
  return _internal_x14();
}
inline void TestExcelFromJson::unsafe_arena_set_allocated_x14(::cfg::TestDemoDynamic* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x14_);
  }
  _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestExcelFromJson.x14)
}
inline ::cfg::TestDemoDynamic* TestExcelFromJson::release_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestDemoDynamic* released = _impl_.x14_;
  _impl_.x14_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoDynamic* TestExcelFromJson::unsafe_arena_release_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestExcelFromJson.x14)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestDemoDynamic* temp = _impl_.x14_;
  _impl_.x14_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoDynamic* TestExcelFromJson::_internal_mutable_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.x14_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoDynamic>(GetArenaForAllocation());
    _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(p);
  }
  return _impl_.x14_;
}
inline ::cfg::TestDemoDynamic* TestExcelFromJson::mutable_x14() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoDynamic* _msg = _internal_mutable_x14();
  // @@protoc_insertion_point(field_mutable:cfg.TestExcelFromJson.x14)
  return _msg;
}
inline void TestExcelFromJson::set_allocated_x14(::cfg::TestDemoDynamic* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoDynamic*>(_impl_.x14_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoDynamic*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestExcelFromJson.x14)
}

// repeated int32 k1 = 11 [packed = true];
inline int TestExcelFromJson::_internal_k1_size() const {
  return _internal_k1().size();
}
inline int TestExcelFromJson::k1_size() const {
  return _internal_k1_size();
}
inline void TestExcelFromJson::clear_k1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k1_.Clear();
}
inline ::int32_t TestExcelFromJson::k1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.k1)
  return _internal_k1().Get(index);
}
inline void TestExcelFromJson::set_k1(int index, ::int32_t value) {
  _internal_mutable_k1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJson.k1)
}
inline void TestExcelFromJson::add_k1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_k1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestExcelFromJson.k1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestExcelFromJson::k1() const {
  // @@protoc_insertion_point(field_list:cfg.TestExcelFromJson.k1)
  return _internal_k1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestExcelFromJson::mutable_k1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestExcelFromJson.k1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestExcelFromJson::_internal_k1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestExcelFromJson::_internal_mutable_k1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k1_;
}

// map<int32, int32> k8 = 12;
inline int TestExcelFromJson::_internal_k8_size() const {
  return _internal_k8().size();
}
inline int TestExcelFromJson::k8_size() const {
  return _internal_k8_size();
}
inline void TestExcelFromJson::clear_k8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k8_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestExcelFromJson::_internal_k8() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k8_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& TestExcelFromJson::k8() const {
  // @@protoc_insertion_point(field_map:cfg.TestExcelFromJson.k8)
  return _internal_k8();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestExcelFromJson::_internal_mutable_k8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.k8_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* TestExcelFromJson::mutable_k8() {
  // @@protoc_insertion_point(field_mutable_map:cfg.TestExcelFromJson.k8)
  return _internal_mutable_k8();
}

// repeated .cfg.TestDemoE2 k9 = 13 [packed = false];
inline int TestExcelFromJson::_internal_k9_size() const {
  return _internal_k9().size();
}
inline int TestExcelFromJson::k9_size() const {
  return _internal_k9_size();
}
inline void TestExcelFromJson::clear_k9() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k9_.Clear();
}
inline ::cfg::TestDemoE2* TestExcelFromJson::mutable_k9(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestExcelFromJson.k9)
  return _internal_mutable_k9()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>* TestExcelFromJson::mutable_k9()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestExcelFromJson.k9)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k9();
}
inline const ::cfg::TestDemoE2& TestExcelFromJson::k9(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.k9)
  return _internal_k9().Get(index);
}
inline ::cfg::TestDemoE2* TestExcelFromJson::add_k9() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoE2* _add = _internal_mutable_k9()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestExcelFromJson.k9)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>& TestExcelFromJson::k9() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestExcelFromJson.k9)
  return _internal_k9();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>&
TestExcelFromJson::_internal_k9() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k9_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>*
TestExcelFromJson::_internal_mutable_k9() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k9_;
}

// repeated .cfg.TestDemoDynamic k15 = 14 [packed = false];
inline int TestExcelFromJson::_internal_k15_size() const {
  return _internal_k15().size();
}
inline int TestExcelFromJson::k15_size() const {
  return _internal_k15_size();
}
inline void TestExcelFromJson::clear_k15() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k15_.Clear();
}
inline ::cfg::TestDemoDynamic* TestExcelFromJson::mutable_k15(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestExcelFromJson.k15)
  return _internal_mutable_k15()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>* TestExcelFromJson::mutable_k15()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestExcelFromJson.k15)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k15();
}
inline const ::cfg::TestDemoDynamic& TestExcelFromJson::k15(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJson.k15)
  return _internal_k15().Get(index);
}
inline ::cfg::TestDemoDynamic* TestExcelFromJson::add_k15() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoDynamic* _add = _internal_mutable_k15()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestExcelFromJson.k15)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>& TestExcelFromJson::k15() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestExcelFromJson.k15)
  return _internal_k15();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>&
TestExcelFromJson::_internal_k15() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k15_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoDynamic>*
TestExcelFromJson::_internal_mutable_k15() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k15_;
}

// -------------------------------------------------------------------

// TestCompositeJsonTable1

// int32 id = 1;
inline void TestCompositeJsonTable1::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestCompositeJsonTable1::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestCompositeJsonTable1.id)
  return _internal_id();
}
inline void TestCompositeJsonTable1::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestCompositeJsonTable1.id)
}
inline ::int32_t TestCompositeJsonTable1::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestCompositeJsonTable1::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string x = 2;
inline void TestCompositeJsonTable1::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_.ClearToEmpty();
}
inline const std::string& TestCompositeJsonTable1::x() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestCompositeJsonTable1.x)
  return _internal_x();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestCompositeJsonTable1::set_x(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestCompositeJsonTable1.x)
}
inline std::string* TestCompositeJsonTable1::mutable_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:cfg.TestCompositeJsonTable1.x)
  return _s;
}
inline const std::string& TestCompositeJsonTable1::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_.Get();
}
inline void TestCompositeJsonTable1::_internal_set_x(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_.Set(value, GetArenaForAllocation());
}
inline std::string* TestCompositeJsonTable1::_internal_mutable_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.x_.Mutable( GetArenaForAllocation());
}
inline std::string* TestCompositeJsonTable1::release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestCompositeJsonTable1.x)
  return _impl_.x_.Release();
}
inline void TestCompositeJsonTable1::set_allocated_x(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.x_.IsDefault()) {
          _impl_.x_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestCompositeJsonTable1.x)
}

// -------------------------------------------------------------------

// TestCompositeJsonTable2

// int32 id = 1;
inline void TestCompositeJsonTable2::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestCompositeJsonTable2::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestCompositeJsonTable2.id)
  return _internal_id();
}
inline void TestCompositeJsonTable2::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestCompositeJsonTable2.id)
}
inline ::int32_t TestCompositeJsonTable2::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestCompositeJsonTable2::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 y = 2;
inline void TestCompositeJsonTable2::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t TestCompositeJsonTable2::y() const {
  // @@protoc_insertion_point(field_get:cfg.TestCompositeJsonTable2.y)
  return _internal_y();
}
inline void TestCompositeJsonTable2::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.TestCompositeJsonTable2.y)
}
inline ::int32_t TestCompositeJsonTable2::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void TestCompositeJsonTable2::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TestCompositeJsonTable3

// int32 a = 1;
inline void TestCompositeJsonTable3::clear_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.a_ = 0;
}
inline ::int32_t TestCompositeJsonTable3::a() const {
  // @@protoc_insertion_point(field_get:cfg.TestCompositeJsonTable3.a)
  return _internal_a();
}
inline void TestCompositeJsonTable3::set_a(::int32_t value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:cfg.TestCompositeJsonTable3.a)
}
inline ::int32_t TestCompositeJsonTable3::_internal_a() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.a_;
}
inline void TestCompositeJsonTable3::_internal_set_a(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.a_ = value;
}

// int32 b = 2;
inline void TestCompositeJsonTable3::clear_b() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.b_ = 0;
}
inline ::int32_t TestCompositeJsonTable3::b() const {
  // @@protoc_insertion_point(field_get:cfg.TestCompositeJsonTable3.b)
  return _internal_b();
}
inline void TestCompositeJsonTable3::set_b(::int32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:cfg.TestCompositeJsonTable3.b)
}
inline ::int32_t TestCompositeJsonTable3::_internal_b() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.b_;
}
inline void TestCompositeJsonTable3::_internal_set_b(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.b_ = value;
}

// -------------------------------------------------------------------

// TestExcelFromJsonMultiRow

// int32 id = 1;
inline void TestExcelFromJsonMultiRow::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestExcelFromJsonMultiRow::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJsonMultiRow.id)
  return _internal_id();
}
inline void TestExcelFromJsonMultiRow::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJsonMultiRow.id)
}
inline ::int32_t TestExcelFromJsonMultiRow::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestExcelFromJsonMultiRow::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 x = 2;
inline void TestExcelFromJsonMultiRow::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t TestExcelFromJsonMultiRow::x() const {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJsonMultiRow.x)
  return _internal_x();
}
inline void TestExcelFromJsonMultiRow::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.TestExcelFromJsonMultiRow.x)
}
inline ::int32_t TestExcelFromJsonMultiRow::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TestExcelFromJsonMultiRow::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// repeated .cfg.TestTestRow items = 3 [packed = false];
inline int TestExcelFromJsonMultiRow::_internal_items_size() const {
  return _internal_items().size();
}
inline int TestExcelFromJsonMultiRow::items_size() const {
  return _internal_items_size();
}
inline void TestExcelFromJsonMultiRow::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::cfg::TestTestRow* TestExcelFromJsonMultiRow::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestExcelFromJsonMultiRow.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestRow>* TestExcelFromJsonMultiRow::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestExcelFromJsonMultiRow.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::cfg::TestTestRow& TestExcelFromJsonMultiRow::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestExcelFromJsonMultiRow.items)
  return _internal_items().Get(index);
}
inline ::cfg::TestTestRow* TestExcelFromJsonMultiRow::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestRow* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestExcelFromJsonMultiRow.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestRow>& TestExcelFromJsonMultiRow::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestExcelFromJsonMultiRow.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestRow>&
TestExcelFromJsonMultiRow::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestRow>*
TestExcelFromJsonMultiRow::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// TestTestRow

// int32 x = 1;
inline void TestTestRow::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t TestTestRow::x() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRow.x)
  return _internal_x();
}
inline void TestTestRow::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRow.x)
}
inline ::int32_t TestTestRow::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TestTestRow::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// bool y = 2;
inline void TestTestRow::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = false;
}
inline bool TestTestRow::y() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRow.y)
  return _internal_y();
}
inline void TestTestRow::set_y(bool value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRow.y)
}
inline bool TestTestRow::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void TestTestRow::_internal_set_y(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// string z = 3;
inline void TestTestRow::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_.ClearToEmpty();
}
inline const std::string& TestTestRow::z() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestRow.z)
  return _internal_z();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestRow::set_z(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestRow.z)
}
inline std::string* TestTestRow::mutable_z() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestRow.z)
  return _s;
}
inline const std::string& TestTestRow::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_.Get();
}
inline void TestTestRow::_internal_set_z(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestRow::_internal_mutable_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.z_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestRow::release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestRow.z)
  return _impl_.z_.Release();
}
inline void TestTestRow::set_allocated_z(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.z_.IsDefault()) {
          _impl_.z_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestRow.z)
}

// .cfg.TestTest3 a = 4;
inline bool TestTestRow::has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.a_ != nullptr);
  return value;
}
inline void TestTestRow::clear_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.a_ != nullptr) _impl_.a_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestTest3& TestTestRow::_internal_a() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestTest3* p = _impl_.a_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestTest3&>(::cfg::_TestTest3_default_instance_);
}
inline const ::cfg::TestTest3& TestTestRow::a() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestRow.a)
  return _internal_a();
}
inline void TestTestRow::unsafe_arena_set_allocated_a(::cfg::TestTest3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.a_);
  }
  _impl_.a_ = reinterpret_cast<::cfg::TestTest3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestRow.a)
}
inline ::cfg::TestTest3* TestTestRow::release_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestTest3* released = _impl_.a_;
  _impl_.a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestTest3* TestTestRow::unsafe_arena_release_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestRow.a)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestTest3* temp = _impl_.a_;
  _impl_.a_ = nullptr;
  return temp;
}
inline ::cfg::TestTest3* TestTestRow::_internal_mutable_a() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.a_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestTest3>(GetArenaForAllocation());
    _impl_.a_ = reinterpret_cast<::cfg::TestTest3*>(p);
  }
  return _impl_.a_;
}
inline ::cfg::TestTest3* TestTestRow::mutable_a() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestTest3* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestRow.a)
  return _msg;
}
inline void TestTestRow::set_allocated_a(::cfg::TestTest3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestTest3*>(_impl_.a_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestTest3*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.a_ = reinterpret_cast<::cfg::TestTest3*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestRow.a)
}

// repeated int32 b = 5 [packed = true];
inline int TestTestRow::_internal_b_size() const {
  return _internal_b().size();
}
inline int TestTestRow::b_size() const {
  return _internal_b_size();
}
inline void TestTestRow::clear_b() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.b_.Clear();
}
inline ::int32_t TestTestRow::b(int index) const {
  // @@protoc_insertion_point(field_get:cfg.TestTestRow.b)
  return _internal_b().Get(index);
}
inline void TestTestRow::set_b(int index, ::int32_t value) {
  _internal_mutable_b()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.TestTestRow.b)
}
inline void TestTestRow::add_b(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_b()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.TestTestRow.b)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRow::b() const {
  // @@protoc_insertion_point(field_list:cfg.TestTestRow.b)
  return _internal_b();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRow::mutable_b() {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTestRow.b)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_b();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TestTestRow::_internal_b()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.b_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TestTestRow::_internal_mutable_b() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.b_;
}

// -------------------------------------------------------------------

// TestTest3

// int32 x = 1;
inline void TestTest3::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t TestTest3::x() const {
  // @@protoc_insertion_point(field_get:cfg.TestTest3.x)
  return _internal_x();
}
inline void TestTest3::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cfg.TestTest3.x)
}
inline ::int32_t TestTest3::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TestTest3::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// int32 y = 2;
inline void TestTest3::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t TestTest3::y() const {
  // @@protoc_insertion_point(field_get:cfg.TestTest3.y)
  return _internal_y();
}
inline void TestTest3::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cfg.TestTest3.y)
}
inline ::int32_t TestTest3::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void TestTest3::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TestTestScriptableObject

// int32 id = 1;
inline void TestTestScriptableObject::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestScriptableObject::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestScriptableObject.id)
  return _internal_id();
}
inline void TestTestScriptableObject::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestScriptableObject.id)
}
inline ::int32_t TestTestScriptableObject::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestScriptableObject::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string desc = 2;
inline void TestTestScriptableObject::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& TestTestScriptableObject::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestScriptableObject.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTestScriptableObject::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.TestTestScriptableObject.desc)
}
inline std::string* TestTestScriptableObject::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestScriptableObject.desc)
  return _s;
}
inline const std::string& TestTestScriptableObject::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void TestTestScriptableObject::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* TestTestScriptableObject::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArenaForAllocation());
}
inline std::string* TestTestScriptableObject::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestScriptableObject.desc)
  return _impl_.desc_.Release();
}
inline void TestTestScriptableObject::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestScriptableObject.desc)
}

// float rate = 3;
inline void TestTestScriptableObject::clear_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rate_ = 0;
}
inline float TestTestScriptableObject::rate() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestScriptableObject.rate)
  return _internal_rate();
}
inline void TestTestScriptableObject::set_rate(float value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestScriptableObject.rate)
}
inline float TestTestScriptableObject::_internal_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rate_;
}
inline void TestTestScriptableObject::_internal_set_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rate_ = value;
}

// int32 num = 4;
inline void TestTestScriptableObject::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
}
inline ::int32_t TestTestScriptableObject::num() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestScriptableObject.num)
  return _internal_num();
}
inline void TestTestScriptableObject::set_num(::int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestScriptableObject.num)
}
inline ::int32_t TestTestScriptableObject::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void TestTestScriptableObject::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_ = value;
}

// .cfg.vec2 v2 = 5;
inline bool TestTestScriptableObject::has_v2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v2_ != nullptr);
  return value;
}
inline void TestTestScriptableObject::clear_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v2_ != nullptr) _impl_.v2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::vec2& TestTestScriptableObject::_internal_v2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec2* p = _impl_.v2_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec2&>(::cfg::_vec2_default_instance_);
}
inline const ::cfg::vec2& TestTestScriptableObject::v2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestScriptableObject.v2)
  return _internal_v2();
}
inline void TestTestScriptableObject::unsafe_arena_set_allocated_v2(::cfg::vec2* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v2_);
  }
  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestScriptableObject.v2)
}
inline ::cfg::vec2* TestTestScriptableObject::release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::vec2* released = _impl_.v2_;
  _impl_.v2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec2* TestTestScriptableObject::unsafe_arena_release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestScriptableObject.v2)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::vec2* temp = _impl_.v2_;
  _impl_.v2_ = nullptr;
  return temp;
}
inline ::cfg::vec2* TestTestScriptableObject::_internal_mutable_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.v2_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec2>(GetArenaForAllocation());
    _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(p);
  }
  return _impl_.v2_;
}
inline ::cfg::vec2* TestTestScriptableObject::mutable_v2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec2* _msg = _internal_mutable_v2();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestScriptableObject.v2)
  return _msg;
}
inline void TestTestScriptableObject::set_allocated_v2(::cfg::vec2* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec2*>(_impl_.v2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec2*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestScriptableObject.v2)
}

// .cfg.vec3 v3 = 6;
inline bool TestTestScriptableObject::has_v3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v3_ != nullptr);
  return value;
}
inline void TestTestScriptableObject::clear_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v3_ != nullptr) _impl_.v3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::vec3& TestTestScriptableObject::_internal_v3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec3* p = _impl_.v3_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec3&>(::cfg::_vec3_default_instance_);
}
inline const ::cfg::vec3& TestTestScriptableObject::v3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestScriptableObject.v3)
  return _internal_v3();
}
inline void TestTestScriptableObject::unsafe_arena_set_allocated_v3(::cfg::vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v3_);
  }
  _impl_.v3_ = reinterpret_cast<::cfg::vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestScriptableObject.v3)
}
inline ::cfg::vec3* TestTestScriptableObject::release_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::vec3* released = _impl_.v3_;
  _impl_.v3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec3* TestTestScriptableObject::unsafe_arena_release_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestScriptableObject.v3)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::vec3* temp = _impl_.v3_;
  _impl_.v3_ = nullptr;
  return temp;
}
inline ::cfg::vec3* TestTestScriptableObject::_internal_mutable_v3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.v3_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec3>(GetArenaForAllocation());
    _impl_.v3_ = reinterpret_cast<::cfg::vec3*>(p);
  }
  return _impl_.v3_;
}
inline ::cfg::vec3* TestTestScriptableObject::mutable_v3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec3* _msg = _internal_mutable_v3();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestScriptableObject.v3)
  return _msg;
}
inline void TestTestScriptableObject::set_allocated_v3(::cfg::vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec3*>(_impl_.v3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec3*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.v3_ = reinterpret_cast<::cfg::vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestScriptableObject.v3)
}

// .cfg.vec4 v4 = 7;
inline bool TestTestScriptableObject::has_v4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v4_ != nullptr);
  return value;
}
inline void TestTestScriptableObject::clear_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v4_ != nullptr) _impl_.v4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cfg::vec4& TestTestScriptableObject::_internal_v4() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec4* p = _impl_.v4_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec4&>(::cfg::_vec4_default_instance_);
}
inline const ::cfg::vec4& TestTestScriptableObject::v4() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestScriptableObject.v4)
  return _internal_v4();
}
inline void TestTestScriptableObject::unsafe_arena_set_allocated_v4(::cfg::vec4* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v4_);
  }
  _impl_.v4_ = reinterpret_cast<::cfg::vec4*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestScriptableObject.v4)
}
inline ::cfg::vec4* TestTestScriptableObject::release_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::vec4* released = _impl_.v4_;
  _impl_.v4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec4* TestTestScriptableObject::unsafe_arena_release_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestScriptableObject.v4)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::vec4* temp = _impl_.v4_;
  _impl_.v4_ = nullptr;
  return temp;
}
inline ::cfg::vec4* TestTestScriptableObject::_internal_mutable_v4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.v4_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec4>(GetArenaForAllocation());
    _impl_.v4_ = reinterpret_cast<::cfg::vec4*>(p);
  }
  return _impl_.v4_;
}
inline ::cfg::vec4* TestTestScriptableObject::mutable_v4() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec4* _msg = _internal_mutable_v4();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestScriptableObject.v4)
  return _msg;
}
inline void TestTestScriptableObject::set_allocated_v4(::cfg::vec4* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec4*>(_impl_.v4_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec4*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.v4_ = reinterpret_cast<::cfg::vec4*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestScriptableObject.v4)
}

// -------------------------------------------------------------------

// TestTestMapper

// int32 id = 1;
inline void TestTestMapper::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t TestTestMapper::id() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestMapper.id)
  return _internal_id();
}
inline void TestTestMapper::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestMapper.id)
}
inline ::int32_t TestTestMapper::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TestTestMapper::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .cfg.AudioType audio_type = 2;
inline void TestTestMapper::clear_audio_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_type_ = 0;
}
inline ::cfg::AudioType TestTestMapper::audio_type() const {
  // @@protoc_insertion_point(field_get:cfg.TestTestMapper.audio_type)
  return _internal_audio_type();
}
inline void TestTestMapper::set_audio_type(::cfg::AudioType value) {
  _internal_set_audio_type(value);
  // @@protoc_insertion_point(field_set:cfg.TestTestMapper.audio_type)
}
inline ::cfg::AudioType TestTestMapper::_internal_audio_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::AudioType>(_impl_.audio_type_);
}
inline void TestTestMapper::_internal_set_audio_type(::cfg::AudioType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_type_ = value;
}

// .cfg.vec2 v2 = 3;
inline bool TestTestMapper::has_v2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v2_ != nullptr);
  return value;
}
inline void TestTestMapper::clear_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v2_ != nullptr) _impl_.v2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::vec2& TestTestMapper::_internal_v2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec2* p = _impl_.v2_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec2&>(::cfg::_vec2_default_instance_);
}
inline const ::cfg::vec2& TestTestMapper::v2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTestMapper.v2)
  return _internal_v2();
}
inline void TestTestMapper::unsafe_arena_set_allocated_v2(::cfg::vec2* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v2_);
  }
  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestTestMapper.v2)
}
inline ::cfg::vec2* TestTestMapper::release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::vec2* released = _impl_.v2_;
  _impl_.v2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec2* TestTestMapper::unsafe_arena_release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.TestTestMapper.v2)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::vec2* temp = _impl_.v2_;
  _impl_.v2_ = nullptr;
  return temp;
}
inline ::cfg::vec2* TestTestMapper::_internal_mutable_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.v2_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec2>(GetArenaForAllocation());
    _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(p);
  }
  return _impl_.v2_;
}
inline ::cfg::vec2* TestTestMapper::mutable_v2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec2* _msg = _internal_mutable_v2();
  // @@protoc_insertion_point(field_mutable:cfg.TestTestMapper.v2)
  return _msg;
}
inline void TestTestMapper::set_allocated_v2(::cfg::vec2* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec2*>(_impl_.v2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec2*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.TestTestMapper.v2)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DefineFromExcel2

// int32 id = 1;
inline void DefineFromExcel2::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t DefineFromExcel2::id() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.id)
  return _internal_id();
}
inline void DefineFromExcel2::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.id)
}
inline ::int32_t DefineFromExcel2::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void DefineFromExcel2::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// bool x1 = 2;
inline void DefineFromExcel2::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = false;
}
inline bool DefineFromExcel2::x1() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x1)
  return _internal_x1();
}
inline void DefineFromExcel2::set_x1(bool value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.x1)
}
inline bool DefineFromExcel2::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x1_;
}
inline void DefineFromExcel2::_internal_set_x1(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// int64 x5 = 3;
inline void DefineFromExcel2::clear_x5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x5_ = ::int64_t{0};
}
inline ::int64_t DefineFromExcel2::x5() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x5)
  return _internal_x5();
}
inline void DefineFromExcel2::set_x5(::int64_t value) {
  _internal_set_x5(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.x5)
}
inline ::int64_t DefineFromExcel2::_internal_x5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x5_;
}
inline void DefineFromExcel2::_internal_set_x5(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x5_ = value;
}

// float x6 = 4;
inline void DefineFromExcel2::clear_x6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x6_ = 0;
}
inline float DefineFromExcel2::x6() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x6)
  return _internal_x6();
}
inline void DefineFromExcel2::set_x6(float value) {
  _internal_set_x6(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.x6)
}
inline float DefineFromExcel2::_internal_x6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x6_;
}
inline void DefineFromExcel2::_internal_set_x6(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x6_ = value;
}

// int32 x8 = 5;
inline void DefineFromExcel2::clear_x8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x8_ = 0;
}
inline ::int32_t DefineFromExcel2::x8() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x8)
  return _internal_x8();
}
inline void DefineFromExcel2::set_x8(::int32_t value) {
  _internal_set_x8(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.x8)
}
inline ::int32_t DefineFromExcel2::_internal_x8() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x8_;
}
inline void DefineFromExcel2::_internal_set_x8(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x8_ = value;
}

// string x10 = 6;
inline void DefineFromExcel2::clear_x10() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x10_.ClearToEmpty();
}
inline const std::string& DefineFromExcel2::x10() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x10)
  return _internal_x10();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DefineFromExcel2::set_x10(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x10_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.x10)
}
inline std::string* DefineFromExcel2::mutable_x10() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_x10();
  // @@protoc_insertion_point(field_mutable:cfg.DefineFromExcel2.x10)
  return _s;
}
inline const std::string& DefineFromExcel2::_internal_x10() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x10_.Get();
}
inline void DefineFromExcel2::_internal_set_x10(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x10_.Set(value, GetArenaForAllocation());
}
inline std::string* DefineFromExcel2::_internal_mutable_x10() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.x10_.Mutable( GetArenaForAllocation());
}
inline std::string* DefineFromExcel2::release_x10() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.DefineFromExcel2.x10)
  return _impl_.x10_.Release();
}
inline void DefineFromExcel2::set_allocated_x10(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x10_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.x10_.IsDefault()) {
          _impl_.x10_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cfg.DefineFromExcel2.x10)
}

// .cfg.TestDemoEnum x13 = 7;
inline void DefineFromExcel2::clear_x13() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x13_ = 0;
}
inline ::cfg::TestDemoEnum DefineFromExcel2::x13() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x13)
  return _internal_x13();
}
inline void DefineFromExcel2::set_x13(::cfg::TestDemoEnum value) {
  _internal_set_x13(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.x13)
}
inline ::cfg::TestDemoEnum DefineFromExcel2::_internal_x13() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::TestDemoEnum>(_impl_.x13_);
}
inline void DefineFromExcel2::_internal_set_x13(::cfg::TestDemoEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x13_ = value;
}

// .cfg.TestDemoFlag x13_2 = 8;
inline void DefineFromExcel2::clear_x13_2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x13_2_ = 0;
}
inline ::cfg::TestDemoFlag DefineFromExcel2::x13_2() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x13_2)
  return _internal_x13_2();
}
inline void DefineFromExcel2::set_x13_2(::cfg::TestDemoFlag value) {
  _internal_set_x13_2(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.x13_2)
}
inline ::cfg::TestDemoFlag DefineFromExcel2::_internal_x13_2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::cfg::TestDemoFlag>(_impl_.x13_2_);
}
inline void DefineFromExcel2::_internal_set_x13_2(::cfg::TestDemoFlag value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x13_2_ = value;
}

// .cfg.TestDemoDynamic x14 = 9;
inline bool DefineFromExcel2::has_x14() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x14_ != nullptr);
  return value;
}
inline void DefineFromExcel2::clear_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x14_ != nullptr) _impl_.x14_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cfg::TestDemoDynamic& DefineFromExcel2::_internal_x14() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestDemoDynamic* p = _impl_.x14_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestDemoDynamic&>(::cfg::_TestDemoDynamic_default_instance_);
}
inline const ::cfg::TestDemoDynamic& DefineFromExcel2::x14() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x14)
  return _internal_x14();
}
inline void DefineFromExcel2::unsafe_arena_set_allocated_x14(::cfg::TestDemoDynamic* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x14_);
  }
  _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.DefineFromExcel2.x14)
}
inline ::cfg::TestDemoDynamic* DefineFromExcel2::release_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoDynamic* released = _impl_.x14_;
  _impl_.x14_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestDemoDynamic* DefineFromExcel2::unsafe_arena_release_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.DefineFromExcel2.x14)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cfg::TestDemoDynamic* temp = _impl_.x14_;
  _impl_.x14_ = nullptr;
  return temp;
}
inline ::cfg::TestDemoDynamic* DefineFromExcel2::_internal_mutable_x14() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x14_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestDemoDynamic>(GetArenaForAllocation());
    _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(p);
  }
  return _impl_.x14_;
}
inline ::cfg::TestDemoDynamic* DefineFromExcel2::mutable_x14() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestDemoDynamic* _msg = _internal_mutable_x14();
  // @@protoc_insertion_point(field_mutable:cfg.DefineFromExcel2.x14)
  return _msg;
}
inline void DefineFromExcel2::set_allocated_x14(::cfg::TestDemoDynamic* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestDemoDynamic*>(_impl_.x14_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestDemoDynamic*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x14_ = reinterpret_cast<::cfg::TestDemoDynamic*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.DefineFromExcel2.x14)
}

// .cfg.TestShape x15 = 10;
inline bool DefineFromExcel2::has_x15() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x15_ != nullptr);
  return value;
}
inline void DefineFromExcel2::clear_x15() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x15_ != nullptr) _impl_.x15_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cfg::TestShape& DefineFromExcel2::_internal_x15() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::TestShape* p = _impl_.x15_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::TestShape&>(::cfg::_TestShape_default_instance_);
}
inline const ::cfg::TestShape& DefineFromExcel2::x15() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.x15)
  return _internal_x15();
}
inline void DefineFromExcel2::unsafe_arena_set_allocated_x15(::cfg::TestShape* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x15_);
  }
  _impl_.x15_ = reinterpret_cast<::cfg::TestShape*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.DefineFromExcel2.x15)
}
inline ::cfg::TestShape* DefineFromExcel2::release_x15() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestShape* released = _impl_.x15_;
  _impl_.x15_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::TestShape* DefineFromExcel2::unsafe_arena_release_x15() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.DefineFromExcel2.x15)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cfg::TestShape* temp = _impl_.x15_;
  _impl_.x15_ = nullptr;
  return temp;
}
inline ::cfg::TestShape* DefineFromExcel2::_internal_mutable_x15() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.x15_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::TestShape>(GetArenaForAllocation());
    _impl_.x15_ = reinterpret_cast<::cfg::TestShape*>(p);
  }
  return _impl_.x15_;
}
inline ::cfg::TestShape* DefineFromExcel2::mutable_x15() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestShape* _msg = _internal_mutable_x15();
  // @@protoc_insertion_point(field_mutable:cfg.DefineFromExcel2.x15)
  return _msg;
}
inline void DefineFromExcel2::set_allocated_x15(::cfg::TestShape* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::TestShape*>(_impl_.x15_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::TestShape*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.x15_ = reinterpret_cast<::cfg::TestShape*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.DefineFromExcel2.x15)
}

// .cfg.vec2 v2 = 11;
inline bool DefineFromExcel2::has_v2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v2_ != nullptr);
  return value;
}
inline void DefineFromExcel2::clear_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.v2_ != nullptr) _impl_.v2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cfg::vec2& DefineFromExcel2::_internal_v2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::cfg::vec2* p = _impl_.v2_;
  return p != nullptr ? *p : reinterpret_cast<const ::cfg::vec2&>(::cfg::_vec2_default_instance_);
}
inline const ::cfg::vec2& DefineFromExcel2::v2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.v2)
  return _internal_v2();
}
inline void DefineFromExcel2::unsafe_arena_set_allocated_v2(::cfg::vec2* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.v2_);
  }
  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.DefineFromExcel2.v2)
}
inline ::cfg::vec2* DefineFromExcel2::release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::vec2* released = _impl_.v2_;
  _impl_.v2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::cfg::vec2* DefineFromExcel2::unsafe_arena_release_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:cfg.DefineFromExcel2.v2)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cfg::vec2* temp = _impl_.v2_;
  _impl_.v2_ = nullptr;
  return temp;
}
inline ::cfg::vec2* DefineFromExcel2::_internal_mutable_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.v2_ == nullptr) {
    auto* p = CreateMaybeMessage<::cfg::vec2>(GetArenaForAllocation());
    _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(p);
  }
  return _impl_.v2_;
}
inline ::cfg::vec2* DefineFromExcel2::mutable_v2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::vec2* _msg = _internal_mutable_v2();
  // @@protoc_insertion_point(field_mutable:cfg.DefineFromExcel2.v2)
  return _msg;
}
inline void DefineFromExcel2::set_allocated_v2(::cfg::vec2* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::cfg::vec2*>(_impl_.v2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::cfg::vec2*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.v2_ = reinterpret_cast<::cfg::vec2*>(value);
  // @@protoc_insertion_point(field_set_allocated:cfg.DefineFromExcel2.v2)
}

// int64 t1 = 12;
inline void DefineFromExcel2::clear_t1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.t1_ = ::int64_t{0};
}
inline ::int64_t DefineFromExcel2::t1() const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.t1)
  return _internal_t1();
}
inline void DefineFromExcel2::set_t1(::int64_t value) {
  _internal_set_t1(value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.t1)
}
inline ::int64_t DefineFromExcel2::_internal_t1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.t1_;
}
inline void DefineFromExcel2::_internal_set_t1(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.t1_ = value;
}

// repeated int32 k1 = 13 [packed = true];
inline int DefineFromExcel2::_internal_k1_size() const {
  return _internal_k1().size();
}
inline int DefineFromExcel2::k1_size() const {
  return _internal_k1_size();
}
inline void DefineFromExcel2::clear_k1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k1_.Clear();
}
inline ::int32_t DefineFromExcel2::k1(int index) const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.k1)
  return _internal_k1().Get(index);
}
inline void DefineFromExcel2::set_k1(int index, ::int32_t value) {
  _internal_mutable_k1()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.k1)
}
inline void DefineFromExcel2::add_k1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_k1()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.DefineFromExcel2.k1)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DefineFromExcel2::k1() const {
  // @@protoc_insertion_point(field_list:cfg.DefineFromExcel2.k1)
  return _internal_k1();
}
inline ::google::protobuf::RepeatedField<::int32_t>* DefineFromExcel2::mutable_k1() {
  // @@protoc_insertion_point(field_mutable_list:cfg.DefineFromExcel2.k1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k1();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DefineFromExcel2::_internal_k1()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k1_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* DefineFromExcel2::_internal_mutable_k1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k1_;
}

// repeated int32 k2 = 14 [packed = true];
inline int DefineFromExcel2::_internal_k2_size() const {
  return _internal_k2().size();
}
inline int DefineFromExcel2::k2_size() const {
  return _internal_k2_size();
}
inline void DefineFromExcel2::clear_k2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k2_.Clear();
}
inline ::int32_t DefineFromExcel2::k2(int index) const {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.k2)
  return _internal_k2().Get(index);
}
inline void DefineFromExcel2::set_k2(int index, ::int32_t value) {
  _internal_mutable_k2()->Set(index, value);
  // @@protoc_insertion_point(field_set:cfg.DefineFromExcel2.k2)
}
inline void DefineFromExcel2::add_k2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_k2()->Add(value);
  // @@protoc_insertion_point(field_add:cfg.DefineFromExcel2.k2)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DefineFromExcel2::k2() const {
  // @@protoc_insertion_point(field_list:cfg.DefineFromExcel2.k2)
  return _internal_k2();
}
inline ::google::protobuf::RepeatedField<::int32_t>* DefineFromExcel2::mutable_k2() {
  // @@protoc_insertion_point(field_mutable_list:cfg.DefineFromExcel2.k2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k2();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DefineFromExcel2::_internal_k2()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k2_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* DefineFromExcel2::_internal_mutable_k2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k2_;
}

// map<int32, int32> k8 = 15;
inline int DefineFromExcel2::_internal_k8_size() const {
  return _internal_k8().size();
}
inline int DefineFromExcel2::k8_size() const {
  return _internal_k8_size();
}
inline void DefineFromExcel2::clear_k8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k8_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& DefineFromExcel2::_internal_k8() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k8_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::int32_t>& DefineFromExcel2::k8() const {
  // @@protoc_insertion_point(field_map:cfg.DefineFromExcel2.k8)
  return _internal_k8();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* DefineFromExcel2::_internal_mutable_k8() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.k8_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::int32_t>* DefineFromExcel2::mutable_k8() {
  // @@protoc_insertion_point(field_mutable_map:cfg.DefineFromExcel2.k8)
  return _internal_mutable_k8();
}

// repeated .cfg.TestDemoE2 k9 = 16 [packed = false];
inline int DefineFromExcel2::_internal_k9_size() const {
  return _internal_k9().size();
}
inline int DefineFromExcel2::k9_size() const {
  return _internal_k9_size();
}
inline void DefineFromExcel2::clear_k9() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k9_.Clear();
}
inline ::cfg::TestDemoE2* DefineFromExcel2::mutable_k9(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.DefineFromExcel2.k9)
  return _internal_mutable_k9()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>* DefineFromExcel2::mutable_k9()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.DefineFromExcel2.k9)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k9();
}
inline const ::cfg::TestDemoE2& DefineFromExcel2::k9(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.k9)
  return _internal_k9().Get(index);
}
inline ::cfg::TestDemoE2* DefineFromExcel2::add_k9() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoE2* _add = _internal_mutable_k9()->Add();
  // @@protoc_insertion_point(field_add:cfg.DefineFromExcel2.k9)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>& DefineFromExcel2::k9() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.DefineFromExcel2.k9)
  return _internal_k9();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>&
DefineFromExcel2::_internal_k9() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k9_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoE2>*
DefineFromExcel2::_internal_mutable_k9() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k9_;
}

// repeated .cfg.vec3 k10 = 17 [packed = false];
inline int DefineFromExcel2::_internal_k10_size() const {
  return _internal_k10().size();
}
inline int DefineFromExcel2::k10_size() const {
  return _internal_k10_size();
}
inline void DefineFromExcel2::clear_k10() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k10_.Clear();
}
inline ::cfg::vec3* DefineFromExcel2::mutable_k10(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.DefineFromExcel2.k10)
  return _internal_mutable_k10()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::vec3>* DefineFromExcel2::mutable_k10()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.DefineFromExcel2.k10)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k10();
}
inline const ::cfg::vec3& DefineFromExcel2::k10(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.k10)
  return _internal_k10().Get(index);
}
inline ::cfg::vec3* DefineFromExcel2::add_k10() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::vec3* _add = _internal_mutable_k10()->Add();
  // @@protoc_insertion_point(field_add:cfg.DefineFromExcel2.k10)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::vec3>& DefineFromExcel2::k10() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.DefineFromExcel2.k10)
  return _internal_k10();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::vec3>&
DefineFromExcel2::_internal_k10() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k10_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::vec3>*
DefineFromExcel2::_internal_mutable_k10() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k10_;
}

// repeated .cfg.vec4 k11 = 18 [packed = false];
inline int DefineFromExcel2::_internal_k11_size() const {
  return _internal_k11().size();
}
inline int DefineFromExcel2::k11_size() const {
  return _internal_k11_size();
}
inline void DefineFromExcel2::clear_k11() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.k11_.Clear();
}
inline ::cfg::vec4* DefineFromExcel2::mutable_k11(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.DefineFromExcel2.k11)
  return _internal_mutable_k11()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::vec4>* DefineFromExcel2::mutable_k11()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.DefineFromExcel2.k11)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_k11();
}
inline const ::cfg::vec4& DefineFromExcel2::k11(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.DefineFromExcel2.k11)
  return _internal_k11().Get(index);
}
inline ::cfg::vec4* DefineFromExcel2::add_k11() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::vec4* _add = _internal_mutable_k11()->Add();
  // @@protoc_insertion_point(field_add:cfg.DefineFromExcel2.k11)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::vec4>& DefineFromExcel2::k11() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.DefineFromExcel2.k11)
  return _internal_k11();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::vec4>&
DefineFromExcel2::_internal_k11() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.k11_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::vec4>*
DefineFromExcel2::_internal_mutable_k11() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.k11_;
}

// -------------------------------------------------------------------

// TestShape

// .cfg.TestCircle Circle = 1;
inline bool TestShape::has_circle() const {
  return value_case() == kCircle;
}
inline bool TestShape::_internal_has_circle() const {
  return value_case() == kCircle;
}
inline void TestShape::set_has_circle() {
  _impl_._oneof_case_[0] = kCircle;
}
inline void TestShape::clear_circle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kCircle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.circle_;
    }
    clear_has_value();
  }
}
inline ::cfg::TestCircle* TestShape::release_circle() {
  // @@protoc_insertion_point(field_release:cfg.TestShape.Circle)
  if (value_case() == kCircle) {
    clear_has_value();
    ::cfg::TestCircle* temp = _impl_.value_.circle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::TestCircle& TestShape::_internal_circle() const {
  return value_case() == kCircle ? *_impl_.value_.circle_ : reinterpret_cast<::cfg::TestCircle&>(::cfg::_TestCircle_default_instance_);
}
inline const ::cfg::TestCircle& TestShape::circle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestShape.Circle)
  return _internal_circle();
}
inline ::cfg::TestCircle* TestShape::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestShape.Circle)
  if (value_case() == kCircle) {
    clear_has_value();
    ::cfg::TestCircle* temp = _impl_.value_.circle_;
    _impl_.value_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestShape::unsafe_arena_set_allocated_circle(::cfg::TestCircle* circle) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (circle) {
    set_has_circle();
    _impl_.value_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestShape.Circle)
}
inline ::cfg::TestCircle* TestShape::_internal_mutable_circle() {
  if (value_case() != kCircle) {
    clear_value();
    set_has_circle();
    _impl_.value_.circle_ =
        CreateMaybeMessage<::cfg::TestCircle>(GetArenaForAllocation());
  }
  return _impl_.value_.circle_;
}
inline ::cfg::TestCircle* TestShape::mutable_circle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::TestCircle* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:cfg.TestShape.Circle)
  return _msg;
}

// .cfg.Test2Rectangle Rectangle = 2;
inline bool TestShape::has_rectangle() const {
  return value_case() == kRectangle;
}
inline bool TestShape::_internal_has_rectangle() const {
  return value_case() == kRectangle;
}
inline void TestShape::set_has_rectangle() {
  _impl_._oneof_case_[0] = kRectangle;
}
inline void TestShape::clear_rectangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kRectangle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.rectangle_;
    }
    clear_has_value();
  }
}
inline ::cfg::Test2Rectangle* TestShape::release_rectangle() {
  // @@protoc_insertion_point(field_release:cfg.TestShape.Rectangle)
  if (value_case() == kRectangle) {
    clear_has_value();
    ::cfg::Test2Rectangle* temp = _impl_.value_.rectangle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cfg::Test2Rectangle& TestShape::_internal_rectangle() const {
  return value_case() == kRectangle ? *_impl_.value_.rectangle_ : reinterpret_cast<::cfg::Test2Rectangle&>(::cfg::_Test2Rectangle_default_instance_);
}
inline const ::cfg::Test2Rectangle& TestShape::rectangle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestShape.Rectangle)
  return _internal_rectangle();
}
inline ::cfg::Test2Rectangle* TestShape::unsafe_arena_release_rectangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cfg.TestShape.Rectangle)
  if (value_case() == kRectangle) {
    clear_has_value();
    ::cfg::Test2Rectangle* temp = _impl_.value_.rectangle_;
    _impl_.value_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestShape::unsafe_arena_set_allocated_rectangle(::cfg::Test2Rectangle* rectangle) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (rectangle) {
    set_has_rectangle();
    _impl_.value_.rectangle_ = rectangle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cfg.TestShape.Rectangle)
}
inline ::cfg::Test2Rectangle* TestShape::_internal_mutable_rectangle() {
  if (value_case() != kRectangle) {
    clear_value();
    set_has_rectangle();
    _impl_.value_.rectangle_ =
        CreateMaybeMessage<::cfg::Test2Rectangle>(GetArenaForAllocation());
  }
  return _impl_.value_.rectangle_;
}
inline ::cfg::Test2Rectangle* TestShape::mutable_rectangle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cfg::Test2Rectangle* _msg = _internal_mutable_rectangle();
  // @@protoc_insertion_point(field_mutable:cfg.TestShape.Rectangle)
  return _msg;
}

inline bool TestShape::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TestShape::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline TestShape::ValueCase TestShape::value_case() const {
  return TestShape::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestCircle

// float radius = 1;
inline void TestCircle::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline float TestCircle::radius() const {
  // @@protoc_insertion_point(field_get:cfg.TestCircle.radius)
  return _internal_radius();
}
inline void TestCircle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:cfg.TestCircle.radius)
}
inline float TestCircle::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void TestCircle::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// Test2Rectangle

// float width = 1;
inline void Test2Rectangle::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline float Test2Rectangle::width() const {
  // @@protoc_insertion_point(field_get:cfg.Test2Rectangle.width)
  return _internal_width();
}
inline void Test2Rectangle::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cfg.Test2Rectangle.width)
}
inline float Test2Rectangle::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Test2Rectangle::_internal_set_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// float height = 2;
inline void Test2Rectangle::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline float Test2Rectangle::height() const {
  // @@protoc_insertion_point(field_get:cfg.Test2Rectangle.height)
  return _internal_height();
}
inline void Test2Rectangle::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cfg.Test2Rectangle.height)
}
inline float Test2Rectangle::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Test2Rectangle::_internal_set_height(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// AiTbBlackboard

// repeated .cfg.AiBlackboard data_list = 1 [packed = false];
inline int AiTbBlackboard::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int AiTbBlackboard::data_list_size() const {
  return _internal_data_list_size();
}
inline void AiTbBlackboard::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::AiBlackboard* AiTbBlackboard::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiTbBlackboard.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboard>* AiTbBlackboard::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiTbBlackboard.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::AiBlackboard& AiTbBlackboard::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTbBlackboard.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::AiBlackboard* AiTbBlackboard::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiBlackboard* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiTbBlackboard.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboard>& AiTbBlackboard::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiTbBlackboard.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboard>&
AiTbBlackboard::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiBlackboard>*
AiTbBlackboard::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// AiTbBehaviorTree

// repeated .cfg.AiBehaviorTree data_list = 1 [packed = false];
inline int AiTbBehaviorTree::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int AiTbBehaviorTree::data_list_size() const {
  return _internal_data_list_size();
}
inline void AiTbBehaviorTree::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::AiBehaviorTree* AiTbBehaviorTree::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.AiTbBehaviorTree.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiBehaviorTree>* AiTbBehaviorTree::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.AiTbBehaviorTree.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::AiBehaviorTree& AiTbBehaviorTree::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.AiTbBehaviorTree.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::AiBehaviorTree* AiTbBehaviorTree::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::AiBehaviorTree* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.AiTbBehaviorTree.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiBehaviorTree>& AiTbBehaviorTree::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.AiTbBehaviorTree.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::AiBehaviorTree>&
AiTbBehaviorTree::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::AiBehaviorTree>*
AiTbBehaviorTree::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// CommonTbGlobalConfig

// repeated .cfg.CommonGlobalConfig data_list = 1 [packed = false];
inline int CommonTbGlobalConfig::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int CommonTbGlobalConfig::data_list_size() const {
  return _internal_data_list_size();
}
inline void CommonTbGlobalConfig::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::CommonGlobalConfig* CommonTbGlobalConfig::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.CommonTbGlobalConfig.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::CommonGlobalConfig>* CommonTbGlobalConfig::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.CommonTbGlobalConfig.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::CommonGlobalConfig& CommonTbGlobalConfig::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.CommonTbGlobalConfig.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::CommonGlobalConfig* CommonTbGlobalConfig::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::CommonGlobalConfig* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.CommonTbGlobalConfig.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::CommonGlobalConfig>& CommonTbGlobalConfig::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.CommonTbGlobalConfig.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::CommonGlobalConfig>&
CommonTbGlobalConfig::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::CommonGlobalConfig>*
CommonTbGlobalConfig::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// ItemTbItem

// repeated .cfg.ItemItem data_list = 1 [packed = false];
inline int ItemTbItem::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int ItemTbItem::data_list_size() const {
  return _internal_data_list_size();
}
inline void ItemTbItem::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::ItemItem* ItemTbItem::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.ItemTbItem.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::ItemItem>* ItemTbItem::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.ItemTbItem.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::ItemItem& ItemTbItem::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.ItemTbItem.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::ItemItem* ItemTbItem::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::ItemItem* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.ItemTbItem.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::ItemItem>& ItemTbItem::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.ItemTbItem.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::ItemItem>&
ItemTbItem::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::ItemItem>*
ItemTbItem::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// L10nTbL10NDemo

// repeated .cfg.L10nL10NDemo data_list = 1 [packed = false];
inline int L10nTbL10NDemo::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int L10nTbL10NDemo::data_list_size() const {
  return _internal_data_list_size();
}
inline void L10nTbL10NDemo::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::L10nL10NDemo* L10nTbL10NDemo::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.L10nTbL10NDemo.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::L10nL10NDemo>* L10nTbL10NDemo::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.L10nTbL10NDemo.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::L10nL10NDemo& L10nTbL10NDemo::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.L10nTbL10NDemo.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::L10nL10NDemo* L10nTbL10NDemo::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::L10nL10NDemo* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.L10nTbL10NDemo.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::L10nL10NDemo>& L10nTbL10NDemo::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.L10nTbL10NDemo.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::L10nL10NDemo>&
L10nTbL10NDemo::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::L10nL10NDemo>*
L10nTbL10NDemo::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// L10nTbPatchDemo

// repeated .cfg.L10nPatchDemo data_list = 1 [packed = false];
inline int L10nTbPatchDemo::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int L10nTbPatchDemo::data_list_size() const {
  return _internal_data_list_size();
}
inline void L10nTbPatchDemo::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::L10nPatchDemo* L10nTbPatchDemo::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.L10nTbPatchDemo.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::L10nPatchDemo>* L10nTbPatchDemo::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.L10nTbPatchDemo.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::L10nPatchDemo& L10nTbPatchDemo::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.L10nTbPatchDemo.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::L10nPatchDemo* L10nTbPatchDemo::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::L10nPatchDemo* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.L10nTbPatchDemo.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::L10nPatchDemo>& L10nTbPatchDemo::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.L10nTbPatchDemo.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::L10nPatchDemo>&
L10nTbPatchDemo::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::L10nPatchDemo>*
L10nTbPatchDemo::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TagTbTestTag

// repeated .cfg.TagTestTag data_list = 1 [packed = false];
inline int TagTbTestTag::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TagTbTestTag::data_list_size() const {
  return _internal_data_list_size();
}
inline void TagTbTestTag::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TagTestTag* TagTbTestTag::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TagTbTestTag.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TagTestTag>* TagTbTestTag::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TagTbTestTag.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TagTestTag& TagTbTestTag::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TagTbTestTag.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TagTestTag* TagTbTestTag::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TagTestTag* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TagTbTestTag.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TagTestTag>& TagTbTestTag::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TagTbTestTag.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TagTestTag>&
TagTbTestTag::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TagTestTag>*
TagTbTestTag::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbFullTypes

// repeated .cfg.TestDemoType2 data_list = 1 [packed = false];
inline int TestTbFullTypes::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbFullTypes::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbFullTypes::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestDemoType2* TestTbFullTypes::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbFullTypes.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>* TestTbFullTypes::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbFullTypes.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestDemoType2& TestTbFullTypes::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbFullTypes.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestDemoType2* TestTbFullTypes::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoType2* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbFullTypes.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>& TestTbFullTypes::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbFullTypes.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>&
TestTbFullTypes::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>*
TestTbFullTypes::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbSingleton

// repeated .cfg.TestDemoSingletonType data_list = 1 [packed = false];
inline int TestTbSingleton::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbSingleton::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbSingleton::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestDemoSingletonType* TestTbSingleton::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbSingleton.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoSingletonType>* TestTbSingleton::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbSingleton.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestDemoSingletonType& TestTbSingleton::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbSingleton.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestDemoSingletonType* TestTbSingleton::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoSingletonType* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbSingleton.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoSingletonType>& TestTbSingleton::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbSingleton.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoSingletonType>&
TestTbSingleton::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoSingletonType>*
TestTbSingleton::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbNotIndexList

// repeated .cfg.TestNotIndexList data_list = 1 [packed = false];
inline int TestTbNotIndexList::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbNotIndexList::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbNotIndexList::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestNotIndexList* TestTbNotIndexList::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbNotIndexList.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestNotIndexList>* TestTbNotIndexList::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbNotIndexList.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestNotIndexList& TestTbNotIndexList::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbNotIndexList.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestNotIndexList* TestTbNotIndexList::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestNotIndexList* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbNotIndexList.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestNotIndexList>& TestTbNotIndexList::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbNotIndexList.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestNotIndexList>&
TestTbNotIndexList::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestNotIndexList>*
TestTbNotIndexList::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbMultiUnionIndexList

// repeated .cfg.TestMultiUnionIndexList data_list = 1 [packed = false];
inline int TestTbMultiUnionIndexList::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbMultiUnionIndexList::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbMultiUnionIndexList::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestMultiUnionIndexList* TestTbMultiUnionIndexList::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbMultiUnionIndexList.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiUnionIndexList>* TestTbMultiUnionIndexList::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbMultiUnionIndexList.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestMultiUnionIndexList& TestTbMultiUnionIndexList::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbMultiUnionIndexList.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestMultiUnionIndexList* TestTbMultiUnionIndexList::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiUnionIndexList* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbMultiUnionIndexList.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiUnionIndexList>& TestTbMultiUnionIndexList::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbMultiUnionIndexList.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiUnionIndexList>&
TestTbMultiUnionIndexList::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiUnionIndexList>*
TestTbMultiUnionIndexList::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbMultiIndexList

// repeated .cfg.TestMultiIndexList data_list = 1 [packed = false];
inline int TestTbMultiIndexList::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbMultiIndexList::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbMultiIndexList::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestMultiIndexList* TestTbMultiIndexList::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbMultiIndexList.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiIndexList>* TestTbMultiIndexList::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbMultiIndexList.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestMultiIndexList& TestTbMultiIndexList::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbMultiIndexList.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestMultiIndexList* TestTbMultiIndexList::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiIndexList* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbMultiIndexList.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiIndexList>& TestTbMultiIndexList::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbMultiIndexList.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiIndexList>&
TestTbMultiIndexList::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiIndexList>*
TestTbMultiIndexList::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbDataFromMisc

// repeated .cfg.TestDemoType2 data_list = 1 [packed = false];
inline int TestTbDataFromMisc::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbDataFromMisc::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbDataFromMisc::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestDemoType2* TestTbDataFromMisc::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbDataFromMisc.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>* TestTbDataFromMisc::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbDataFromMisc.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestDemoType2& TestTbDataFromMisc::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbDataFromMisc.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestDemoType2* TestTbDataFromMisc::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoType2* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbDataFromMisc.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>& TestTbDataFromMisc::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbDataFromMisc.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>&
TestTbDataFromMisc::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoType2>*
TestTbDataFromMisc::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbMultiRowRecord

// repeated .cfg.TestMultiRowRecord data_list = 1 [packed = false];
inline int TestTbMultiRowRecord::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbMultiRowRecord::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbMultiRowRecord::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestMultiRowRecord* TestTbMultiRowRecord::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbMultiRowRecord.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowRecord>* TestTbMultiRowRecord::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbMultiRowRecord.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestMultiRowRecord& TestTbMultiRowRecord::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbMultiRowRecord.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestMultiRowRecord* TestTbMultiRowRecord::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiRowRecord* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbMultiRowRecord.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowRecord>& TestTbMultiRowRecord::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbMultiRowRecord.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowRecord>&
TestTbMultiRowRecord::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowRecord>*
TestTbMultiRowRecord::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestMultiColumn

// repeated .cfg.TestTestMultiColumn data_list = 1 [packed = false];
inline int TestTbTestMultiColumn::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestMultiColumn::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestMultiColumn::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestMultiColumn* TestTbTestMultiColumn::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestMultiColumn.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestMultiColumn>* TestTbTestMultiColumn::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestMultiColumn.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestMultiColumn& TestTbTestMultiColumn::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestMultiColumn.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestMultiColumn* TestTbTestMultiColumn::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestMultiColumn* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestMultiColumn.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMultiColumn>& TestTbTestMultiColumn::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestMultiColumn.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMultiColumn>&
TestTbTestMultiColumn::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestMultiColumn>*
TestTbTestMultiColumn::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbMultiRowTitle

// repeated .cfg.TestMultiRowTitle data_list = 1 [packed = false];
inline int TestTbMultiRowTitle::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbMultiRowTitle::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbMultiRowTitle::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestMultiRowTitle* TestTbMultiRowTitle::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbMultiRowTitle.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowTitle>* TestTbMultiRowTitle::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbMultiRowTitle.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestMultiRowTitle& TestTbMultiRowTitle::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbMultiRowTitle.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestMultiRowTitle* TestTbMultiRowTitle::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestMultiRowTitle* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbMultiRowTitle.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowTitle>& TestTbMultiRowTitle::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbMultiRowTitle.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowTitle>&
TestTbMultiRowTitle::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestMultiRowTitle>*
TestTbMultiRowTitle::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestNull

// repeated .cfg.TestTestNull data_list = 1 [packed = false];
inline int TestTbTestNull::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestNull::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestNull::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestNull* TestTbTestNull::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestNull.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestNull>* TestTbTestNull::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestNull.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestNull& TestTbTestNull::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestNull.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestNull* TestTbTestNull::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestNull* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestNull.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestNull>& TestTbTestNull::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestNull.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestNull>&
TestTbTestNull::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestNull>*
TestTbTestNull::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbDemoPrimitive

// repeated .cfg.TestDemoPrimitiveTypesTable data_list = 1 [packed = false];
inline int TestTbDemoPrimitive::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbDemoPrimitive::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbDemoPrimitive::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestDemoPrimitiveTypesTable* TestTbDemoPrimitive::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbDemoPrimitive.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoPrimitiveTypesTable>* TestTbDemoPrimitive::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbDemoPrimitive.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestDemoPrimitiveTypesTable& TestTbDemoPrimitive::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbDemoPrimitive.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestDemoPrimitiveTypesTable* TestTbDemoPrimitive::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoPrimitiveTypesTable* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbDemoPrimitive.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoPrimitiveTypesTable>& TestTbDemoPrimitive::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbDemoPrimitive.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoPrimitiveTypesTable>&
TestTbDemoPrimitive::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoPrimitiveTypesTable>*
TestTbDemoPrimitive::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestString

// repeated .cfg.TestTestString data_list = 1 [packed = false];
inline int TestTbTestString::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestString::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestString::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestString* TestTbTestString::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestString.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestString>* TestTbTestString::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestString.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestString& TestTbTestString::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestString.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestString* TestTbTestString::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestString* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestString.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestString>& TestTbTestString::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestString.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestString>&
TestTbTestString::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestString>*
TestTbTestString::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbDemoGroup

// repeated .cfg.TestDemoGroup data_list = 1 [packed = false];
inline int TestTbDemoGroup::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbDemoGroup::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbDemoGroup::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestDemoGroup* TestTbDemoGroup::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbDemoGroup.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoGroup>* TestTbDemoGroup::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbDemoGroup.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestDemoGroup& TestTbDemoGroup::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbDemoGroup.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestDemoGroup* TestTbDemoGroup::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDemoGroup* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbDemoGroup.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoGroup>& TestTbDemoGroup::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbDemoGroup.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDemoGroup>&
TestTbDemoGroup::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDemoGroup>*
TestTbDemoGroup::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestGlobal

// repeated .cfg.TestTestGlobal data_list = 1 [packed = false];
inline int TestTbTestGlobal::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestGlobal::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestGlobal::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestGlobal* TestTbTestGlobal::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestGlobal.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestGlobal>* TestTbTestGlobal::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestGlobal.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestGlobal& TestTbTestGlobal::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestGlobal.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestGlobal* TestTbTestGlobal::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestGlobal* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestGlobal.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestGlobal>& TestTbTestGlobal::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestGlobal.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestGlobal>&
TestTbTestGlobal::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestGlobal>*
TestTbTestGlobal::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestBeRef

// repeated .cfg.TestTestBeRef data_list = 1 [packed = false];
inline int TestTbTestBeRef::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestBeRef::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestBeRef::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestBeRef* TestTbTestBeRef::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestBeRef.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>* TestTbTestBeRef::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestBeRef.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestBeRef& TestTbTestBeRef::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestBeRef.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestBeRef* TestTbTestBeRef::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestBeRef* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestBeRef.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>& TestTbTestBeRef::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestBeRef.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>&
TestTbTestBeRef::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>*
TestTbTestBeRef::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestBeRef2

// repeated .cfg.TestTestBeRef data_list = 1 [packed = false];
inline int TestTbTestBeRef2::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestBeRef2::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestBeRef2::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestBeRef* TestTbTestBeRef2::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestBeRef2.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>* TestTbTestBeRef2::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestBeRef2.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestBeRef& TestTbTestBeRef2::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestBeRef2.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestBeRef* TestTbTestBeRef2::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestBeRef* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestBeRef2.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>& TestTbTestBeRef2::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestBeRef2.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>&
TestTbTestBeRef2::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestBeRef>*
TestTbTestBeRef2::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestRef

// repeated .cfg.TestTestRef data_list = 1 [packed = false];
inline int TestTbTestRef::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestRef::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestRef::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestRef* TestTbTestRef::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestRef.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestRef>* TestTbTestRef::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestRef.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestRef& TestTbTestRef::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestRef.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestRef* TestTbTestRef::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestRef* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestRef.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestRef>& TestTbTestRef::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestRef.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestRef>&
TestTbTestRef::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestRef>*
TestTbTestRef::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestSize

// repeated .cfg.TestTestSize data_list = 1 [packed = false];
inline int TestTbTestSize::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestSize::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestSize::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestSize* TestTbTestSize::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestSize.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestSize>* TestTbTestSize::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestSize.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestSize& TestTbTestSize::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestSize.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestSize* TestTbTestSize::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestSize* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestSize.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestSize>& TestTbTestSize::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestSize.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestSize>&
TestTbTestSize::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestSize>*
TestTbTestSize::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestSet

// repeated .cfg.TestTestSet data_list = 1 [packed = false];
inline int TestTbTestSet::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestSet::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestSet::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestSet* TestTbTestSet::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestSet.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestSet>* TestTbTestSet::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestSet.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestSet& TestTbTestSet::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestSet.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestSet* TestTbTestSet::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestSet* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestSet.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestSet>& TestTbTestSet::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestSet.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestSet>&
TestTbTestSet::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestSet>*
TestTbTestSet::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbDetectCsvEncoding

// repeated .cfg.TestDetectEncoding data_list = 1 [packed = false];
inline int TestTbDetectCsvEncoding::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbDetectCsvEncoding::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbDetectCsvEncoding::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestDetectEncoding* TestTbDetectCsvEncoding::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbDetectCsvEncoding.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDetectEncoding>* TestTbDetectCsvEncoding::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbDetectCsvEncoding.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestDetectEncoding& TestTbDetectCsvEncoding::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbDetectCsvEncoding.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestDetectEncoding* TestTbDetectCsvEncoding::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestDetectEncoding* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbDetectCsvEncoding.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDetectEncoding>& TestTbDetectCsvEncoding::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbDetectCsvEncoding.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestDetectEncoding>&
TestTbDetectCsvEncoding::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestDetectEncoding>*
TestTbDetectCsvEncoding::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbItem2

// repeated .cfg.TestItemBase data_list = 1 [packed = false];
inline int TestTbItem2::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbItem2::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbItem2::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestItemBase* TestTbItem2::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbItem2.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestItemBase>* TestTbItem2::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbItem2.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestItemBase& TestTbItem2::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbItem2.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestItemBase* TestTbItem2::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestItemBase* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbItem2.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestItemBase>& TestTbItem2::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbItem2.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestItemBase>&
TestTbItem2::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestItemBase>*
TestTbItem2::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestIndex

// repeated .cfg.TestTestIndex data_list = 1 [packed = false];
inline int TestTbTestIndex::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestIndex::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestIndex::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestIndex* TestTbTestIndex::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestIndex.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestIndex>* TestTbTestIndex::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestIndex.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestIndex& TestTbTestIndex::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestIndex.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestIndex* TestTbTestIndex::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestIndex* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestIndex.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestIndex>& TestTbTestIndex::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestIndex.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestIndex>&
TestTbTestIndex::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestIndex>*
TestTbTestIndex::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestMap

// repeated .cfg.TestTestMap data_list = 1 [packed = false];
inline int TestTbTestMap::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestMap::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestMap::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestMap* TestTbTestMap::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestMap.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestMap>* TestTbTestMap::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestMap.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestMap& TestTbTestMap::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestMap.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestMap* TestTbTestMap::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestMap* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestMap.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMap>& TestTbTestMap::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestMap.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMap>&
TestTbTestMap::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestMap>*
TestTbTestMap::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbExcelFromJson

// repeated .cfg.TestExcelFromJson data_list = 1 [packed = false];
inline int TestTbExcelFromJson::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbExcelFromJson::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbExcelFromJson::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestExcelFromJson* TestTbExcelFromJson::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbExcelFromJson.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJson>* TestTbExcelFromJson::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbExcelFromJson.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestExcelFromJson& TestTbExcelFromJson::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbExcelFromJson.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestExcelFromJson* TestTbExcelFromJson::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestExcelFromJson* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbExcelFromJson.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJson>& TestTbExcelFromJson::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbExcelFromJson.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJson>&
TestTbExcelFromJson::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJson>*
TestTbExcelFromJson::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbCompositeJsonTable1

// repeated .cfg.TestCompositeJsonTable1 data_list = 1 [packed = false];
inline int TestTbCompositeJsonTable1::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbCompositeJsonTable1::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbCompositeJsonTable1::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestCompositeJsonTable1* TestTbCompositeJsonTable1::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbCompositeJsonTable1.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable1>* TestTbCompositeJsonTable1::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbCompositeJsonTable1.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestCompositeJsonTable1& TestTbCompositeJsonTable1::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbCompositeJsonTable1.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestCompositeJsonTable1* TestTbCompositeJsonTable1::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestCompositeJsonTable1* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbCompositeJsonTable1.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable1>& TestTbCompositeJsonTable1::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbCompositeJsonTable1.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable1>&
TestTbCompositeJsonTable1::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable1>*
TestTbCompositeJsonTable1::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbCompositeJsonTable2

// repeated .cfg.TestCompositeJsonTable2 data_list = 1 [packed = false];
inline int TestTbCompositeJsonTable2::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbCompositeJsonTable2::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbCompositeJsonTable2::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestCompositeJsonTable2* TestTbCompositeJsonTable2::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbCompositeJsonTable2.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable2>* TestTbCompositeJsonTable2::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbCompositeJsonTable2.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestCompositeJsonTable2& TestTbCompositeJsonTable2::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbCompositeJsonTable2.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestCompositeJsonTable2* TestTbCompositeJsonTable2::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestCompositeJsonTable2* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbCompositeJsonTable2.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable2>& TestTbCompositeJsonTable2::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbCompositeJsonTable2.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable2>&
TestTbCompositeJsonTable2::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable2>*
TestTbCompositeJsonTable2::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbCompositeJsonTable3

// repeated .cfg.TestCompositeJsonTable3 data_list = 1 [packed = false];
inline int TestTbCompositeJsonTable3::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbCompositeJsonTable3::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbCompositeJsonTable3::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestCompositeJsonTable3* TestTbCompositeJsonTable3::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbCompositeJsonTable3.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable3>* TestTbCompositeJsonTable3::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbCompositeJsonTable3.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestCompositeJsonTable3& TestTbCompositeJsonTable3::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbCompositeJsonTable3.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestCompositeJsonTable3* TestTbCompositeJsonTable3::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestCompositeJsonTable3* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbCompositeJsonTable3.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable3>& TestTbCompositeJsonTable3::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbCompositeJsonTable3.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable3>&
TestTbCompositeJsonTable3::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestCompositeJsonTable3>*
TestTbCompositeJsonTable3::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbExcelFromJsonMultiRow

// repeated .cfg.TestExcelFromJsonMultiRow data_list = 1 [packed = false];
inline int TestTbExcelFromJsonMultiRow::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbExcelFromJsonMultiRow::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbExcelFromJsonMultiRow::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestExcelFromJsonMultiRow* TestTbExcelFromJsonMultiRow::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbExcelFromJsonMultiRow.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJsonMultiRow>* TestTbExcelFromJsonMultiRow::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbExcelFromJsonMultiRow.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestExcelFromJsonMultiRow& TestTbExcelFromJsonMultiRow::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbExcelFromJsonMultiRow.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestExcelFromJsonMultiRow* TestTbExcelFromJsonMultiRow::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestExcelFromJsonMultiRow* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbExcelFromJsonMultiRow.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJsonMultiRow>& TestTbExcelFromJsonMultiRow::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbExcelFromJsonMultiRow.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJsonMultiRow>&
TestTbExcelFromJsonMultiRow::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestExcelFromJsonMultiRow>*
TestTbExcelFromJsonMultiRow::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestScriptableObject

// repeated .cfg.TestTestScriptableObject data_list = 1 [packed = false];
inline int TestTbTestScriptableObject::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestScriptableObject::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestScriptableObject::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestScriptableObject* TestTbTestScriptableObject::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestScriptableObject.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestScriptableObject>* TestTbTestScriptableObject::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestScriptableObject.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestScriptableObject& TestTbTestScriptableObject::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestScriptableObject.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestScriptableObject* TestTbTestScriptableObject::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestScriptableObject* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestScriptableObject.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestScriptableObject>& TestTbTestScriptableObject::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestScriptableObject.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestScriptableObject>&
TestTbTestScriptableObject::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestScriptableObject>*
TestTbTestScriptableObject::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbTestMapper

// repeated .cfg.TestTestMapper data_list = 1 [packed = false];
inline int TestTbTestMapper::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbTestMapper::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbTestMapper::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::TestTestMapper* TestTbTestMapper::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbTestMapper.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestMapper>* TestTbTestMapper::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbTestMapper.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::TestTestMapper& TestTbTestMapper::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbTestMapper.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::TestTestMapper* TestTbTestMapper::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::TestTestMapper* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbTestMapper.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMapper>& TestTbTestMapper::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbTestMapper.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::TestTestMapper>&
TestTbTestMapper::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::TestTestMapper>*
TestTbTestMapper::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

// -------------------------------------------------------------------

// TestTbDefineFromExcel2

// repeated .cfg.DefineFromExcel2 data_list = 1 [packed = false];
inline int TestTbDefineFromExcel2::_internal_data_list_size() const {
  return _internal_data_list().size();
}
inline int TestTbDefineFromExcel2::data_list_size() const {
  return _internal_data_list_size();
}
inline void TestTbDefineFromExcel2::clear_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_list_.Clear();
}
inline ::cfg::DefineFromExcel2* TestTbDefineFromExcel2::mutable_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cfg.TestTbDefineFromExcel2.data_list)
  return _internal_mutable_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cfg::DefineFromExcel2>* TestTbDefineFromExcel2::mutable_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cfg.TestTbDefineFromExcel2.data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_list();
}
inline const ::cfg::DefineFromExcel2& TestTbDefineFromExcel2::data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cfg.TestTbDefineFromExcel2.data_list)
  return _internal_data_list().Get(index);
}
inline ::cfg::DefineFromExcel2* TestTbDefineFromExcel2::add_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::cfg::DefineFromExcel2* _add = _internal_mutable_data_list()->Add();
  // @@protoc_insertion_point(field_add:cfg.TestTbDefineFromExcel2.data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::DefineFromExcel2>& TestTbDefineFromExcel2::data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cfg.TestTbDefineFromExcel2.data_list)
  return _internal_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::cfg::DefineFromExcel2>&
TestTbDefineFromExcel2::_internal_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::cfg::DefineFromExcel2>*
TestTbDefineFromExcel2::_internal_mutable_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_list_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace cfg


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::cfg::AiEExecutor> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::AiEExecutor>() {
  return ::cfg::AiEExecutor_descriptor();
}
template <>
struct is_proto_enum<::cfg::AiEKeyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::AiEKeyType>() {
  return ::cfg::AiEKeyType_descriptor();
}
template <>
struct is_proto_enum<::cfg::AiEFlowAbortMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::AiEFlowAbortMode>() {
  return ::cfg::AiEFlowAbortMode_descriptor();
}
template <>
struct is_proto_enum<::cfg::AiEFinishMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::AiEFinishMode>() {
  return ::cfg::AiEFinishMode_descriptor();
}
template <>
struct is_proto_enum<::cfg::AiENotifyObserverMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::AiENotifyObserverMode>() {
  return ::cfg::AiENotifyObserverMode_descriptor();
}
template <>
struct is_proto_enum<::cfg::AiEOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::AiEOperator>() {
  return ::cfg::AiEOperator_descriptor();
}
template <>
struct is_proto_enum<::cfg::AudioType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::AudioType>() {
  return ::cfg::AudioType_descriptor();
}
template <>
struct is_proto_enum<::cfg::CommonEBoolOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::CommonEBoolOperator>() {
  return ::cfg::CommonEBoolOperator_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEItemQuality> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEItemQuality>() {
  return ::cfg::ItemEItemQuality_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemECurrencyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemECurrencyType>() {
  return ::cfg::ItemECurrencyType_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEMajorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEMajorType>() {
  return ::cfg::ItemEMajorType_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEMinorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEMinorType>() {
  return ::cfg::ItemEMinorType_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEClothersStarQualityType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEClothersStarQualityType>() {
  return ::cfg::ItemEClothersStarQualityType_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEClothersTag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEClothersTag>() {
  return ::cfg::ItemEClothersTag_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEUseType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEUseType>() {
  return ::cfg::ItemEUseType_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEClothesHidePartType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEClothesHidePartType>() {
  return ::cfg::ItemEClothesHidePartType_descriptor();
}
template <>
struct is_proto_enum<::cfg::ItemEClothesPropertyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::ItemEClothesPropertyType>() {
  return ::cfg::ItemEClothesPropertyType_descriptor();
}
template <>
struct is_proto_enum<::cfg::TestDemoEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::TestDemoEnum>() {
  return ::cfg::TestDemoEnum_descriptor();
}
template <>
struct is_proto_enum<::cfg::TestDemoFlag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::TestDemoFlag>() {
  return ::cfg::TestDemoFlag_descriptor();
}
template <>
struct is_proto_enum<::cfg::TestETestUeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::TestETestUeType>() {
  return ::cfg::TestETestUeType_descriptor();
}
template <>
struct is_proto_enum<::cfg::TestETestEmptyEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::TestETestEmptyEnum>() {
  return ::cfg::TestETestEmptyEnum_descriptor();
}
template <>
struct is_proto_enum<::cfg::TestETestEmptyEnum2> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::TestETestEmptyEnum2>() {
  return ::cfg::TestETestEmptyEnum2_descriptor();
}
template <>
struct is_proto_enum<::cfg::TestETestQuality> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::TestETestQuality>() {
  return ::cfg::TestETestQuality_descriptor();
}
template <>
struct is_proto_enum<::cfg::TestAccessFlag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cfg::TestAccessFlag>() {
  return ::cfg::TestAccessFlag_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_schema_2eproto_2epb_2eh
