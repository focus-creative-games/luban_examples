//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include <algorithm>
#include "gen_types.h"

using ByteBuf = bright::serialization::ByteBuf;

namespace cfg
{

    bool ai::Blackboard::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if(!_buf.readString(parentName)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); keys.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<ai::BlackboardKey> _e;  if(!ai::BlackboardKey::deserializeBlackboardKey(_buf, _e)) return false; keys.push_back(_e);}}

        return true;
    }

    bool ai::Blackboard::deserializeBlackboard(ByteBuf& _buf, ::bright::SharedPtr<ai::Blackboard>& _out)
    {
        _out.reset(new ai::Blackboard());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::Blackboard::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->parentName_Ref = ((ai::TbBlackboard*)(_tables["ai.TbBlackboard"]))->get(parentName);
        for(auto _e : keys) { _e->resolve(_tables); }
    }

    bool ai::BlackboardKey::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if (!_buf.readBool(isStatic)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; type = ai::EKeyType(__enum_temp__); }
        if(!_buf.readString(typeClassName)) return false;

        return true;
    }

    bool ai::BlackboardKey::deserializeBlackboardKey(ByteBuf& _buf, ::bright::SharedPtr<ai::BlackboardKey>& _out)
    {
        _out.reset(new ai::BlackboardKey());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BlackboardKey::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool ai::BehaviorTree::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if(!_buf.readString(blackboardId)) return false;
        if(!ai::ComposeNode::deserializeComposeNode(_buf, root)) return false;

        return true;
    }

    bool ai::BehaviorTree::deserializeBehaviorTree(ByteBuf& _buf, ::bright::SharedPtr<ai::BehaviorTree>& _out)
    {
        _out.reset(new ai::BehaviorTree());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BehaviorTree::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->blackboardId_Ref = ((ai::TbBlackboard*)(_tables["ai.TbBlackboard"]))->get(blackboardId);
        root->resolve(_tables);
    }

    bool ai::Node::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(nodeName)) return false;

        return true;
    }

    bool ai::Node::deserializeNode(ByteBuf& _buf, ::bright::SharedPtr<ai::Node>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeSetDefaultFocus::__ID__: { _out.reset(new ai::UeSetDefaultFocus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ExecuteTimeStatistic::__ID__: { _out.reset(new ai::ExecuteTimeStatistic()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseTarget::__ID__: { _out.reset(new ai::ChooseTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::KeepFaceTarget::__ID__: { _out.reset(new ai::KeepFaceTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::GetOwnerPlayer::__ID__: { _out.reset(new ai::GetOwnerPlayer()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UpdateDailyBehaviorProps::__ID__: { _out.reset(new ai::UpdateDailyBehaviorProps()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeLoop::__ID__: { _out.reset(new ai::UeLoop()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeCooldown::__ID__: { _out.reset(new ai::UeCooldown()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeTimeLimit::__ID__: { _out.reset(new ai::UeTimeLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeBlackboard::__ID__: { _out.reset(new ai::UeBlackboard()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeForceSuccess::__ID__: { _out.reset(new ai::UeForceSuccess()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IsAtLocation::__ID__: { _out.reset(new ai::IsAtLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DistanceLessThan::__ID__: { _out.reset(new ai::DistanceLessThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Sequence::__ID__: { _out.reset(new ai::Sequence()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Selector::__ID__: { _out.reset(new ai::Selector()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::SimpleParallel::__ID__: { _out.reset(new ai::SimpleParallel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWait::__ID__: { _out.reset(new ai::UeWait()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWaitBlackboardTime::__ID__: { _out.reset(new ai::UeWaitBlackboardTime()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToTarget::__ID__: { _out.reset(new ai::MoveToTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseSkill::__ID__: { _out.reset(new ai::ChooseSkill()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToRandomLocation::__ID__: { _out.reset(new ai::MoveToRandomLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToLocation::__ID__: { _out.reset(new ai::MoveToLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DebugPrint::__ID__: { _out.reset(new ai::DebugPrint()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Node::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool ai::Service::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::Service::deserializeService(ByteBuf& _buf, ::bright::SharedPtr<ai::Service>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeSetDefaultFocus::__ID__: { _out.reset(new ai::UeSetDefaultFocus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ExecuteTimeStatistic::__ID__: { _out.reset(new ai::ExecuteTimeStatistic()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseTarget::__ID__: { _out.reset(new ai::ChooseTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::KeepFaceTarget::__ID__: { _out.reset(new ai::KeepFaceTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::GetOwnerPlayer::__ID__: { _out.reset(new ai::GetOwnerPlayer()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UpdateDailyBehaviorProps::__ID__: { _out.reset(new ai::UpdateDailyBehaviorProps()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Service::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Node::resolve(_tables);
    }

    bool ai::UeSetDefaultFocus::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(keyboardKey)) return false;

        return true;
    }

    bool ai::UeSetDefaultFocus::deserializeUeSetDefaultFocus(ByteBuf& _buf, ::bright::SharedPtr<ai::UeSetDefaultFocus>& _out)
    {
        _out.reset(new ai::UeSetDefaultFocus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeSetDefaultFocus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::ExecuteTimeStatistic::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::ExecuteTimeStatistic::deserializeExecuteTimeStatistic(ByteBuf& _buf, ::bright::SharedPtr<ai::ExecuteTimeStatistic>& _out)
    {
        _out.reset(new ai::ExecuteTimeStatistic());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::ExecuteTimeStatistic::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::ChooseTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(resultTargetKey)) return false;

        return true;
    }

    bool ai::ChooseTarget::deserializeChooseTarget(ByteBuf& _buf, ::bright::SharedPtr<ai::ChooseTarget>& _out)
    {
        _out.reset(new ai::ChooseTarget());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::ChooseTarget::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::KeepFaceTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(targetActorKey)) return false;

        return true;
    }

    bool ai::KeepFaceTarget::deserializeKeepFaceTarget(ByteBuf& _buf, ::bright::SharedPtr<ai::KeepFaceTarget>& _out)
    {
        _out.reset(new ai::KeepFaceTarget());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::KeepFaceTarget::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::GetOwnerPlayer::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(playerActorKey)) return false;

        return true;
    }

    bool ai::GetOwnerPlayer::deserializeGetOwnerPlayer(ByteBuf& _buf, ::bright::SharedPtr<ai::GetOwnerPlayer>& _out)
    {
        _out.reset(new ai::GetOwnerPlayer());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::GetOwnerPlayer::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::UpdateDailyBehaviorProps::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(satietyKey)) return false;
        if(!_buf.readString(energyKey)) return false;
        if(!_buf.readString(moodKey)) return false;
        if(!_buf.readString(satietyLowerThresholdKey)) return false;
        if(!_buf.readString(satietyUpperThresholdKey)) return false;
        if(!_buf.readString(energyLowerThresholdKey)) return false;
        if(!_buf.readString(energyUpperThresholdKey)) return false;
        if(!_buf.readString(moodLowerThresholdKey)) return false;
        if(!_buf.readString(moodUpperThresholdKey)) return false;

        return true;
    }

    bool ai::UpdateDailyBehaviorProps::deserializeUpdateDailyBehaviorProps(ByteBuf& _buf, ::bright::SharedPtr<ai::UpdateDailyBehaviorProps>& _out)
    {
        _out.reset(new ai::UpdateDailyBehaviorProps());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UpdateDailyBehaviorProps::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::Decorator::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; flowAbortMode = ai::EFlowAbortMode(__enum_temp__); }

        return true;
    }

    bool ai::Decorator::deserializeDecorator(ByteBuf& _buf, ::bright::SharedPtr<ai::Decorator>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeLoop::__ID__: { _out.reset(new ai::UeLoop()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeCooldown::__ID__: { _out.reset(new ai::UeCooldown()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeTimeLimit::__ID__: { _out.reset(new ai::UeTimeLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeBlackboard::__ID__: { _out.reset(new ai::UeBlackboard()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeForceSuccess::__ID__: { _out.reset(new ai::UeForceSuccess()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IsAtLocation::__ID__: { _out.reset(new ai::IsAtLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DistanceLessThan::__ID__: { _out.reset(new ai::DistanceLessThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Decorator::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Node::resolve(_tables);
    }

    bool ai::UeLoop::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(numLoops)) return false;
        if (!_buf.readBool(infiniteLoop)) return false;
        if(!_buf.readFloat(infiniteLoopTimeoutTime)) return false;

        return true;
    }

    bool ai::UeLoop::deserializeUeLoop(ByteBuf& _buf, ::bright::SharedPtr<ai::UeLoop>& _out)
    {
        _out.reset(new ai::UeLoop());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeLoop::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::UeCooldown::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(cooldownTime)) return false;

        return true;
    }

    bool ai::UeCooldown::deserializeUeCooldown(ByteBuf& _buf, ::bright::SharedPtr<ai::UeCooldown>& _out)
    {
        _out.reset(new ai::UeCooldown());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeCooldown::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::UeTimeLimit::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(limitTime)) return false;

        return true;
    }

    bool ai::UeTimeLimit::deserializeUeTimeLimit(ByteBuf& _buf, ::bright::SharedPtr<ai::UeTimeLimit>& _out)
    {
        _out.reset(new ai::UeTimeLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeTimeLimit::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::UeBlackboard::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; notifyObserver = ai::ENotifyObserverMode(__enum_temp__); }
        if(!_buf.readString(blackboardKey)) return false;
        if(!ai::KeyQueryOperator::deserializeKeyQueryOperator(_buf, keyQuery)) return false;

        return true;
    }

    bool ai::UeBlackboard::deserializeUeBlackboard(ByteBuf& _buf, ::bright::SharedPtr<ai::UeBlackboard>& _out)
    {
        _out.reset(new ai::UeBlackboard());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeBlackboard::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Decorator::resolve(_tables);
        keyQuery->resolve(_tables);
    }

    bool ai::KeyQueryOperator::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool ai::KeyQueryOperator::deserializeKeyQueryOperator(ByteBuf& _buf, ::bright::SharedPtr<ai::KeyQueryOperator>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::IsSet::__ID__: { _out.reset(new ai::IsSet()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IsNotSet::__ID__: { _out.reset(new ai::IsNotSet()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::BinaryOperator::__ID__: { _out.reset(new ai::BinaryOperator()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::KeyQueryOperator::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool ai::IsSet::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::IsSet::deserializeIsSet(ByteBuf& _buf, ::bright::SharedPtr<ai::IsSet>& _out)
    {
        _out.reset(new ai::IsSet());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IsSet::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        KeyQueryOperator::resolve(_tables);
    }

    bool ai::IsNotSet::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::IsNotSet::deserializeIsNotSet(ByteBuf& _buf, ::bright::SharedPtr<ai::IsNotSet>& _out)
    {
        _out.reset(new ai::IsNotSet());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IsNotSet::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        KeyQueryOperator::resolve(_tables);
    }

    bool ai::BinaryOperator::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; oper = ai::EOperator(__enum_temp__); }
        if(!ai::KeyData::deserializeKeyData(_buf, data)) return false;

        return true;
    }

    bool ai::BinaryOperator::deserializeBinaryOperator(ByteBuf& _buf, ::bright::SharedPtr<ai::BinaryOperator>& _out)
    {
        _out.reset(new ai::BinaryOperator());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BinaryOperator::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        KeyQueryOperator::resolve(_tables);
        data->resolve(_tables);
    }

    bool ai::KeyData::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool ai::KeyData::deserializeKeyData(ByteBuf& _buf, ::bright::SharedPtr<ai::KeyData>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::FloatKeyData::__ID__: { _out.reset(new ai::FloatKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IntKeyData::__ID__: { _out.reset(new ai::IntKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::StringKeyData::__ID__: { _out.reset(new ai::StringKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::BlackboardKeyData::__ID__: { _out.reset(new ai::BlackboardKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::KeyData::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool ai::FloatKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(value)) return false;

        return true;
    }

    bool ai::FloatKeyData::deserializeFloatKeyData(ByteBuf& _buf, ::bright::SharedPtr<ai::FloatKeyData>& _out)
    {
        _out.reset(new ai::FloatKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::FloatKeyData::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::IntKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool ai::IntKeyData::deserializeIntKeyData(ByteBuf& _buf, ::bright::SharedPtr<ai::IntKeyData>& _out)
    {
        _out.reset(new ai::IntKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IntKeyData::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::StringKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(value)) return false;

        return true;
    }

    bool ai::StringKeyData::deserializeStringKeyData(ByteBuf& _buf, ::bright::SharedPtr<ai::StringKeyData>& _out)
    {
        _out.reset(new ai::StringKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::StringKeyData::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::BlackboardKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(value)) return false;

        return true;
    }

    bool ai::BlackboardKeyData::deserializeBlackboardKeyData(ByteBuf& _buf, ::bright::SharedPtr<ai::BlackboardKeyData>& _out)
    {
        _out.reset(new ai::BlackboardKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BlackboardKeyData::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::UeForceSuccess::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::UeForceSuccess::deserializeUeForceSuccess(ByteBuf& _buf, ::bright::SharedPtr<ai::UeForceSuccess>& _out)
    {
        _out.reset(new ai::UeForceSuccess());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeForceSuccess::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::IsAtLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(acceptableRadius)) return false;
        if(!_buf.readString(keyboardKey)) return false;
        if (!_buf.readBool(inverseCondition)) return false;

        return true;
    }

    bool ai::IsAtLocation::deserializeIsAtLocation(ByteBuf& _buf, ::bright::SharedPtr<ai::IsAtLocation>& _out)
    {
        _out.reset(new ai::IsAtLocation());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IsAtLocation::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::DistanceLessThan::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(actor1Key)) return false;
        if(!_buf.readString(actor2Key)) return false;
        if(!_buf.readFloat(distance)) return false;
        if (!_buf.readBool(reverseResult)) return false;

        return true;
    }

    bool ai::DistanceLessThan::deserializeDistanceLessThan(ByteBuf& _buf, ::bright::SharedPtr<ai::DistanceLessThan>& _out)
    {
        _out.reset(new ai::DistanceLessThan());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::DistanceLessThan::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::FlowNode::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); decorators.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<ai::Decorator> _e;  if(!ai::Decorator::deserializeDecorator(_buf, _e)) return false; decorators.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); services.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<ai::Service> _e;  if(!ai::Service::deserializeService(_buf, _e)) return false; services.push_back(_e);}}

        return true;
    }

    bool ai::FlowNode::deserializeFlowNode(ByteBuf& _buf, ::bright::SharedPtr<ai::FlowNode>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::Sequence::__ID__: { _out.reset(new ai::Sequence()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Selector::__ID__: { _out.reset(new ai::Selector()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::SimpleParallel::__ID__: { _out.reset(new ai::SimpleParallel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWait::__ID__: { _out.reset(new ai::UeWait()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWaitBlackboardTime::__ID__: { _out.reset(new ai::UeWaitBlackboardTime()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToTarget::__ID__: { _out.reset(new ai::MoveToTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseSkill::__ID__: { _out.reset(new ai::ChooseSkill()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToRandomLocation::__ID__: { _out.reset(new ai::MoveToRandomLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToLocation::__ID__: { _out.reset(new ai::MoveToLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DebugPrint::__ID__: { _out.reset(new ai::DebugPrint()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::FlowNode::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Node::resolve(_tables);
        for(auto _e : decorators) { _e->resolve(_tables); }
        for(auto _e : services) { _e->resolve(_tables); }
    }

    bool ai::ComposeNode::deserialize(ByteBuf& _buf)
    {
        if (!ai::FlowNode::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::ComposeNode::deserializeComposeNode(ByteBuf& _buf, ::bright::SharedPtr<ai::ComposeNode>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::Sequence::__ID__: { _out.reset(new ai::Sequence()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Selector::__ID__: { _out.reset(new ai::Selector()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::SimpleParallel::__ID__: { _out.reset(new ai::SimpleParallel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::ComposeNode::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        FlowNode::resolve(_tables);
    }

    bool ai::Sequence::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); children.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<ai::FlowNode> _e;  if(!ai::FlowNode::deserializeFlowNode(_buf, _e)) return false; children.push_back(_e);}}

        return true;
    }

    bool ai::Sequence::deserializeSequence(ByteBuf& _buf, ::bright::SharedPtr<ai::Sequence>& _out)
    {
        _out.reset(new ai::Sequence());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::Sequence::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ComposeNode::resolve(_tables);
        for(auto _e : children) { _e->resolve(_tables); }
    }

    bool ai::Selector::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); children.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<ai::FlowNode> _e;  if(!ai::FlowNode::deserializeFlowNode(_buf, _e)) return false; children.push_back(_e);}}

        return true;
    }

    bool ai::Selector::deserializeSelector(ByteBuf& _buf, ::bright::SharedPtr<ai::Selector>& _out)
    {
        _out.reset(new ai::Selector());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::Selector::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ComposeNode::resolve(_tables);
        for(auto _e : children) { _e->resolve(_tables); }
    }

    bool ai::SimpleParallel::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; finishMode = ai::EFinishMode(__enum_temp__); }
        if(!ai::Task::deserializeTask(_buf, mainTask)) return false;
        if(!ai::FlowNode::deserializeFlowNode(_buf, backgroundNode)) return false;

        return true;
    }

    bool ai::SimpleParallel::deserializeSimpleParallel(ByteBuf& _buf, ::bright::SharedPtr<ai::SimpleParallel>& _out)
    {
        _out.reset(new ai::SimpleParallel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::SimpleParallel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ComposeNode::resolve(_tables);
        mainTask->resolve(_tables);
        backgroundNode->resolve(_tables);
    }

    bool ai::Task::deserialize(ByteBuf& _buf)
    {
        if (!ai::FlowNode::deserialize(_buf))
        {
            return false;
        }

        if (!_buf.readBool(ignoreRestartSelf)) return false;

        return true;
    }

    bool ai::Task::deserializeTask(ByteBuf& _buf, ::bright::SharedPtr<ai::Task>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeWait::__ID__: { _out.reset(new ai::UeWait()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWaitBlackboardTime::__ID__: { _out.reset(new ai::UeWaitBlackboardTime()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToTarget::__ID__: { _out.reset(new ai::MoveToTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseSkill::__ID__: { _out.reset(new ai::ChooseSkill()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToRandomLocation::__ID__: { _out.reset(new ai::MoveToRandomLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToLocation::__ID__: { _out.reset(new ai::MoveToLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DebugPrint::__ID__: { _out.reset(new ai::DebugPrint()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Task::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        FlowNode::resolve(_tables);
    }

    bool ai::UeWait::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(waitTime)) return false;
        if(!_buf.readFloat(randomDeviation)) return false;

        return true;
    }

    bool ai::UeWait::deserializeUeWait(ByteBuf& _buf, ::bright::SharedPtr<ai::UeWait>& _out)
    {
        _out.reset(new ai::UeWait());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeWait::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::UeWaitBlackboardTime::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(blackboardKey)) return false;

        return true;
    }

    bool ai::UeWaitBlackboardTime::deserializeUeWaitBlackboardTime(ByteBuf& _buf, ::bright::SharedPtr<ai::UeWaitBlackboardTime>& _out)
    {
        _out.reset(new ai::UeWaitBlackboardTime());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeWaitBlackboardTime::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::MoveToTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(targetActorKey)) return false;
        if(!_buf.readFloat(acceptableRadius)) return false;

        return true;
    }

    bool ai::MoveToTarget::deserializeMoveToTarget(ByteBuf& _buf, ::bright::SharedPtr<ai::MoveToTarget>& _out)
    {
        _out.reset(new ai::MoveToTarget());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::MoveToTarget::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::ChooseSkill::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(targetActorKey)) return false;
        if(!_buf.readString(resultSkillIdKey)) return false;

        return true;
    }

    bool ai::ChooseSkill::deserializeChooseSkill(ByteBuf& _buf, ::bright::SharedPtr<ai::ChooseSkill>& _out)
    {
        _out.reset(new ai::ChooseSkill());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::ChooseSkill::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::MoveToRandomLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(originPositionKey)) return false;
        if(!_buf.readFloat(radius)) return false;

        return true;
    }

    bool ai::MoveToRandomLocation::deserializeMoveToRandomLocation(ByteBuf& _buf, ::bright::SharedPtr<ai::MoveToRandomLocation>& _out)
    {
        _out.reset(new ai::MoveToRandomLocation());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::MoveToRandomLocation::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::MoveToLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readVector3(location)) return false;
        if(!_buf.readFloat(acceptableRadius)) return false;

        return true;
    }

    bool ai::MoveToLocation::deserializeMoveToLocation(ByteBuf& _buf, ::bright::SharedPtr<ai::MoveToLocation>& _out)
    {
        _out.reset(new ai::MoveToLocation());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::MoveToLocation::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::DebugPrint::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(text)) return false;

        return true;
    }

    bool ai::DebugPrint::deserializeDebugPrint(ByteBuf& _buf, ::bright::SharedPtr<ai::DebugPrint>& _out)
    {
        _out.reset(new ai::DebugPrint());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::DebugPrint::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool blueprint::Clazz::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); parents.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<blueprint::Clazz> _e;  if(!blueprint::Clazz::deserializeClazz(_buf, _e)) return false; parents.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); methods.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<blueprint::Method> _e;  if(!blueprint::Method::deserializeMethod(_buf, _e)) return false; methods.push_back(_e);}}

        return true;
    }

    bool blueprint::Clazz::deserializeClazz(ByteBuf& _buf, ::bright::SharedPtr<blueprint::Clazz>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case blueprint::Interface::__ID__: { _out.reset(new blueprint::Interface()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::NormalClazz::__ID__: { _out.reset(new blueprint::NormalClazz()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::EnumClazz::__ID__: { _out.reset(new blueprint::EnumClazz()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void blueprint::Clazz::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : parents) { _e->resolve(_tables); }
        for(auto _e : methods) { _e->resolve(_tables); }
    }

    bool blueprint::Method::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if (!_buf.readBool(isStatic)) return false;
        if(!_buf.readString(returnType)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); parameters.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<blueprint::ParamInfo> _e;  if(!blueprint::ParamInfo::deserializeParamInfo(_buf, _e)) return false; parameters.push_back(_e);}}

        return true;
    }

    bool blueprint::Method::deserializeMethod(ByteBuf& _buf, ::bright::SharedPtr<blueprint::Method>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case blueprint::AbstraceMethod::__ID__: { _out.reset(new blueprint::AbstraceMethod()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::ExternalMethod::__ID__: { _out.reset(new blueprint::ExternalMethod()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::BlueprintMethod::__ID__: { _out.reset(new blueprint::BlueprintMethod()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void blueprint::Method::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : parameters) { _e->resolve(_tables); }
    }

    bool blueprint::ParamInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(type)) return false;
        if (!_buf.readBool(isRef)) return false;

        return true;
    }

    bool blueprint::ParamInfo::deserializeParamInfo(ByteBuf& _buf, ::bright::SharedPtr<blueprint::ParamInfo>& _out)
    {
        _out.reset(new blueprint::ParamInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::ParamInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool blueprint::AbstraceMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::AbstraceMethod::deserializeAbstraceMethod(ByteBuf& _buf, ::bright::SharedPtr<blueprint::AbstraceMethod>& _out)
    {
        _out.reset(new blueprint::AbstraceMethod());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::AbstraceMethod::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Method::resolve(_tables);
    }

    bool blueprint::ExternalMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::ExternalMethod::deserializeExternalMethod(ByteBuf& _buf, ::bright::SharedPtr<blueprint::ExternalMethod>& _out)
    {
        _out.reset(new blueprint::ExternalMethod());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::ExternalMethod::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Method::resolve(_tables);
    }

    bool blueprint::BlueprintMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::BlueprintMethod::deserializeBlueprintMethod(ByteBuf& _buf, ::bright::SharedPtr<blueprint::BlueprintMethod>& _out)
    {
        _out.reset(new blueprint::BlueprintMethod());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::BlueprintMethod::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Method::resolve(_tables);
    }

    bool blueprint::Interface::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::Interface::deserializeInterface(ByteBuf& _buf, ::bright::SharedPtr<blueprint::Interface>& _out)
    {
        _out.reset(new blueprint::Interface());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::Interface::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Clazz::resolve(_tables);
    }

    bool blueprint::NormalClazz::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }

        if (!_buf.readBool(isAbstract)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); fields.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<blueprint::Field> _e;  if(!blueprint::Field::deserializeField(_buf, _e)) return false; fields.push_back(_e);}}

        return true;
    }

    bool blueprint::NormalClazz::deserializeNormalClazz(ByteBuf& _buf, ::bright::SharedPtr<blueprint::NormalClazz>& _out)
    {
        _out.reset(new blueprint::NormalClazz());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::NormalClazz::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Clazz::resolve(_tables);
        for(auto _e : fields) { _e->resolve(_tables); }
    }

    bool blueprint::Field::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(type)) return false;
        if(!_buf.readString(desc)) return false;

        return true;
    }

    bool blueprint::Field::deserializeField(ByteBuf& _buf, ::bright::SharedPtr<blueprint::Field>& _out)
    {
        _out.reset(new blueprint::Field());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::Field::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool blueprint::EnumClazz::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); enums.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<blueprint::EnumField> _e;  if(!blueprint::EnumField::deserializeEnumField(_buf, _e)) return false; enums.push_back(_e);}}

        return true;
    }

    bool blueprint::EnumClazz::deserializeEnumClazz(ByteBuf& _buf, ::bright::SharedPtr<blueprint::EnumClazz>& _out)
    {
        _out.reset(new blueprint::EnumClazz());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::EnumClazz::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Clazz::resolve(_tables);
        for(auto _e : enums) { _e->resolve(_tables); }
    }

    bool blueprint::EnumField::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool blueprint::EnumField::deserializeEnumField(ByteBuf& _buf, ::bright::SharedPtr<blueprint::EnumField>& _out)
    {
        _out.reset(new blueprint::EnumField());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::EnumField::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool bonus::DropInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(desc)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); clientShowItems.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<bonus::ShowItemInfo> _e;  if(!bonus::ShowItemInfo::deserializeShowItemInfo(_buf, _e)) return false; clientShowItems.push_back(_e);}}
        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;

        return true;
    }

    bool bonus::DropInfo::deserializeDropInfo(ByteBuf& _buf, ::bright::SharedPtr<bonus::DropInfo>& _out)
    {
        _out.reset(new bonus::DropInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::DropInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : clientShowItems) { _e->resolve(_tables); }
        bonus->resolve(_tables);
    }

    bool bonus::ShowItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readLong(itemNum)) return false;

        return true;
    }

    bool bonus::ShowItemInfo::deserializeShowItemInfo(ByteBuf& _buf, ::bright::SharedPtr<bonus::ShowItemInfo>& _out)
    {
        _out.reset(new bonus::ShowItemInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ShowItemInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::Bonus::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool bonus::Bonus::deserializeBonus(ByteBuf& _buf, ::bright::SharedPtr<bonus::Bonus>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case bonus::OneItem::__ID__: { _out.reset(new bonus::OneItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::OneItems::__ID__: { _out.reset(new bonus::OneItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::Item::__ID__: { _out.reset(new bonus::Item()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::Items::__ID__: { _out.reset(new bonus::Items()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::CoefficientItem::__ID__: { _out.reset(new bonus::CoefficientItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::WeightItems::__ID__: { _out.reset(new bonus::WeightItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::ProbabilityItems::__ID__: { _out.reset(new bonus::ProbabilityItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::MultiBonus::__ID__: { _out.reset(new bonus::MultiBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::ProbabilityBonus::__ID__: { _out.reset(new bonus::ProbabilityBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::WeightBonus::__ID__: { _out.reset(new bonus::WeightBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::DropBonus::__ID__: { _out.reset(new bonus::DropBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void bonus::Bonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool bonus::OneItem::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;

        return true;
    }

    bool bonus::OneItem::deserializeOneItem(ByteBuf& _buf, ::bright::SharedPtr<bonus::OneItem>& _out)
    {
        _out.reset(new bonus::OneItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::OneItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::OneItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));items.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; items.push_back(_e);}}

        return true;
    }

    bool bonus::OneItems::deserializeOneItems(ByteBuf& _buf, ::bright::SharedPtr<bonus::OneItems>& _out)
    {
        _out.reset(new bonus::OneItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::OneItems::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
    }

    bool bonus::Item::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(amount)) return false;

        return true;
    }

    bool bonus::Item::deserializeItem(ByteBuf& _buf, ::bright::SharedPtr<bonus::Item>& _out)
    {
        _out.reset(new bonus::Item());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::Item::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::Items::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));itemList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<bonus::Item> _e;if(!bonus::Item::deserializeItem(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::Items::deserializeItems(ByteBuf& _buf, ::bright::SharedPtr<bonus::Items>& _out)
    {
        _out.reset(new bonus::Items());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::Items::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool bonus::CoefficientItem::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(bonusId)) return false;
        if(!bonus::Items::deserializeItems(_buf, bonusList)) return false;

        return true;
    }

    bool bonus::CoefficientItem::deserializeCoefficientItem(ByteBuf& _buf, ::bright::SharedPtr<bonus::CoefficientItem>& _out)
    {
        _out.reset(new bonus::CoefficientItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::CoefficientItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        bonusList->resolve(_tables);
    }

    bool bonus::WeightItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));itemList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<bonus::WeightItemInfo> _e;if(!bonus::WeightItemInfo::deserializeWeightItemInfo(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::WeightItems::deserializeWeightItems(ByteBuf& _buf, ::bright::SharedPtr<bonus::WeightItems>& _out)
    {
        _out.reset(new bonus::WeightItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightItems::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool bonus::WeightItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readInt(weight)) return false;

        return true;
    }

    bool bonus::WeightItemInfo::deserializeWeightItemInfo(ByteBuf& _buf, ::bright::SharedPtr<bonus::WeightItemInfo>& _out)
    {
        _out.reset(new bonus::WeightItemInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightItemInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::ProbabilityItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));itemList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<bonus::ProbabilityItemInfo> _e;if(!bonus::ProbabilityItemInfo::deserializeProbabilityItemInfo(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::ProbabilityItems::deserializeProbabilityItems(ByteBuf& _buf, ::bright::SharedPtr<bonus::ProbabilityItems>& _out)
    {
        _out.reset(new bonus::ProbabilityItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityItems::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool bonus::ProbabilityItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readFloat(probability)) return false;

        return true;
    }

    bool bonus::ProbabilityItemInfo::deserializeProbabilityItemInfo(ByteBuf& _buf, ::bright::SharedPtr<bonus::ProbabilityItemInfo>& _out)
    {
        _out.reset(new bonus::ProbabilityItemInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityItemInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::MultiBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<bonus::Bonus> _e;if(!bonus::Bonus::deserializeBonus(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::MultiBonus::deserializeMultiBonus(ByteBuf& _buf, ::bright::SharedPtr<bonus::MultiBonus>& _out)
    {
        _out.reset(new bonus::MultiBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::MultiBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : bonuses) { _e->resolve(_tables); }
    }

    bool bonus::ProbabilityBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<bonus::ProbabilityBonusInfo> _e;if(!bonus::ProbabilityBonusInfo::deserializeProbabilityBonusInfo(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::ProbabilityBonus::deserializeProbabilityBonus(ByteBuf& _buf, ::bright::SharedPtr<bonus::ProbabilityBonus>& _out)
    {
        _out.reset(new bonus::ProbabilityBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : bonuses) { _e->resolve(_tables); }
    }

    bool bonus::ProbabilityBonusInfo::deserialize(ByteBuf& _buf)
    {

        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;
        if(!_buf.readFloat(probability)) return false;

        return true;
    }

    bool bonus::ProbabilityBonusInfo::deserializeProbabilityBonusInfo(ByteBuf& _buf, ::bright::SharedPtr<bonus::ProbabilityBonusInfo>& _out)
    {
        _out.reset(new bonus::ProbabilityBonusInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityBonusInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        bonus->resolve(_tables);
    }

    bool bonus::WeightBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<bonus::WeightBonusInfo> _e;if(!bonus::WeightBonusInfo::deserializeWeightBonusInfo(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::WeightBonus::deserializeWeightBonus(ByteBuf& _buf, ::bright::SharedPtr<bonus::WeightBonus>& _out)
    {
        _out.reset(new bonus::WeightBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : bonuses) { _e->resolve(_tables); }
    }

    bool bonus::WeightBonusInfo::deserialize(ByteBuf& _buf)
    {

        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;
        if(!_buf.readInt(weight)) return false;

        return true;
    }

    bool bonus::WeightBonusInfo::deserializeWeightBonusInfo(ByteBuf& _buf, ::bright::SharedPtr<bonus::WeightBonusInfo>& _out)
    {
        _out.reset(new bonus::WeightBonusInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightBonusInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        bonus->resolve(_tables);
    }

    bool bonus::DropBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(id)) return false;

        return true;
    }

    bool bonus::DropBonus::deserializeDropBonus(ByteBuf& _buf, ::bright::SharedPtr<bonus::DropBonus>& _out)
    {
        _out.reset(new bonus::DropBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::DropBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Bonus::resolve(_tables);
        this->id_Ref = ((bonus::TbDrop*)(_tables["bonus.TbDrop"]))->get(id);
    }

    bool common::GlobalConfig::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(bagCapacity)) return false;
        if(!_buf.readInt(bagCapacitySpecial)) return false;
        if(!_buf.readInt(bagTempExpendableCapacity)) return false;
        if(!_buf.readInt(bagTempToolCapacity)) return false;
        if(!_buf.readInt(bagInitCapacity)) return false;
        if(!_buf.readInt(quickBagCapacity)) return false;
        if(!_buf.readInt(clothBagCapacity)) return false;
        if(!_buf.readInt(clothBagInitCapacity)) return false;
        if(!_buf.readInt(clothBagCapacitySpecial)) return false;
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { bagInitItemsDropId.reset(new ::bright::int32()); if(!_buf.readInt(*bagInitItemsDropId)) return false; } else { bagInitItemsDropId.reset(); } }
        if(!_buf.readInt(mailBoxCapacity)) return false;
        if(!_buf.readFloat(damageParamC)) return false;
        if(!_buf.readFloat(damageParamE)) return false;
        if(!_buf.readFloat(damageParamF)) return false;
        if(!_buf.readFloat(damageParamD)) return false;
        if(!_buf.readFloat(roleSpeed)) return false;
        if(!_buf.readFloat(monsterSpeed)) return false;
        if(!_buf.readInt(initEnergy)) return false;
        if(!_buf.readInt(initViality)) return false;
        if(!_buf.readInt(maxViality)) return false;
        if(!_buf.readInt(perVialityRecoveryTime)) return false;

        return true;
    }

    bool common::GlobalConfig::deserializeGlobalConfig(ByteBuf& _buf, ::bright::SharedPtr<common::GlobalConfig>& _out)
    {
        _out.reset(new common::GlobalConfig());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void common::GlobalConfig::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->bagInitItemsDropId_Ref = this->bagInitItemsDropId != nullptr ? ((bonus::TbDrop*)(_tables["bonus.TbDrop"]))->get(*(this->bagInitItemsDropId)) : nullptr;
    }

    bool error::ErrorInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(code)) return false;
        if(!_buf.readString(desc)) return false;
        if(!error::ErrorStyle::deserializeErrorStyle(_buf, style)) return false;

        return true;
    }

    bool error::ErrorInfo::deserializeErrorInfo(ByteBuf& _buf, ::bright::SharedPtr<error::ErrorInfo>& _out)
    {
        _out.reset(new error::ErrorInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        style->resolve(_tables);
    }

    bool error::ErrorStyle::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool error::ErrorStyle::deserializeErrorStyle(ByteBuf& _buf, ::bright::SharedPtr<error::ErrorStyle>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case error::ErrorStyleTip::__ID__: { _out.reset(new error::ErrorStyleTip()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case error::ErrorStyleMsgbox::__ID__: { _out.reset(new error::ErrorStyleMsgbox()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case error::ErrorStyleDlgOk::__ID__: { _out.reset(new error::ErrorStyleDlgOk()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case error::ErrorStyleDlgOkCancel::__ID__: { _out.reset(new error::ErrorStyleDlgOkCancel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void error::ErrorStyle::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool error::ErrorStyleTip::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool error::ErrorStyleTip::deserializeErrorStyleTip(ByteBuf& _buf, ::bright::SharedPtr<error::ErrorStyleTip>& _out)
    {
        _out.reset(new error::ErrorStyleTip());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleTip::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::ErrorStyleMsgbox::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(btnName)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; operation = error::EOperation(__enum_temp__); }

        return true;
    }

    bool error::ErrorStyleMsgbox::deserializeErrorStyleMsgbox(ByteBuf& _buf, ::bright::SharedPtr<error::ErrorStyleMsgbox>& _out)
    {
        _out.reset(new error::ErrorStyleMsgbox());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleMsgbox::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::ErrorStyleDlgOk::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(btnName)) return false;

        return true;
    }

    bool error::ErrorStyleDlgOk::deserializeErrorStyleDlgOk(ByteBuf& _buf, ::bright::SharedPtr<error::ErrorStyleDlgOk>& _out)
    {
        _out.reset(new error::ErrorStyleDlgOk());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleDlgOk::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::ErrorStyleDlgOkCancel::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(btn1Name)) return false;
        if(!_buf.readString(btn2Name)) return false;

        return true;
    }

    bool error::ErrorStyleDlgOkCancel::deserializeErrorStyleDlgOkCancel(ByteBuf& _buf, ::bright::SharedPtr<error::ErrorStyleDlgOkCancel>& _out)
    {
        _out.reset(new error::ErrorStyleDlgOkCancel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleDlgOkCancel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::CodeInfo::deserialize(ByteBuf& _buf)
    {

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; code = error::EErrorCode(__enum_temp__); }
        if(!_buf.readString(key)) return false;

        return true;
    }

    bool error::CodeInfo::deserializeCodeInfo(ByteBuf& _buf, ::bright::SharedPtr<error::CodeInfo>& _out)
    {
        _out.reset(new error::CodeInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::CodeInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool item::Item::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; majorType = item::EMajorType(__enum_temp__); }
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; minorType = item::EMinorType(__enum_temp__); }
        if(!_buf.readInt(maxPileNum)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; quality = item::EItemQuality(__enum_temp__); }
        if(!_buf.readString(icon)) return false;
        if(!_buf.readString(iconBackgroud)) return false;
        if(!_buf.readString(iconMask)) return false;
        if(!_buf.readString(desc)) return false;
        if(!_buf.readInt(showOrder)) return false;
        if(!_buf.readString(quantifier)) return false;
        if (!_buf.readBool(showInBag)) return false;
        if(!_buf.readInt(minShowLevel)) return false;
        if (!_buf.readBool(batchUsable)) return false;
        if(!_buf.readFloat(progressTimeWhenUse)) return false;
        if (!_buf.readBool(showHintWhenUse)) return false;
        if (!_buf.readBool(droppable)) return false;
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { price.reset(new ::bright::int32()); if(!_buf.readInt(*price)) return false; } else { price.reset(); } }
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; useType = item::EUseType(__enum_temp__); }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { levelUpId.reset(new ::bright::int32()); if(!_buf.readInt(*levelUpId)) return false; } else { levelUpId.reset(); } }

        return true;
    }

    bool item::Item::deserializeItem(ByteBuf& _buf, ::bright::SharedPtr<item::Item>& _out)
    {
        _out.reset(new item::Item());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::Item::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool item::ItemFunction::deserialize(ByteBuf& _buf)
    {

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; minorType = item::EMinorType(__enum_temp__); }
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; funcType = item::EItemFunctionType(__enum_temp__); }
        if(!_buf.readString(method)) return false;
        if (!_buf.readBool(closeBagUi)) return false;

        return true;
    }

    bool item::ItemFunction::deserializeItemFunction(ByteBuf& _buf, ::bright::SharedPtr<item::ItemFunction>& _out)
    {
        _out.reset(new item::ItemFunction());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::ItemFunction::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool item::ItemExtra::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;

        return true;
    }

    bool item::ItemExtra::deserializeItemExtra(ByteBuf& _buf, ::bright::SharedPtr<item::ItemExtra>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case item::TreasureBox::__ID__: { _out.reset(new item::TreasureBox()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::InteractionItem::__ID__: { _out.reset(new item::InteractionItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::Clothes::__ID__: { _out.reset(new item::Clothes()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::DesignDrawing::__ID__: { _out.reset(new item::DesignDrawing()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::Dymmy::__ID__: { _out.reset(new item::Dymmy()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void item::ItemExtra::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool item::TreasureBox::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { keyItemId.reset(new ::bright::int32()); if(!_buf.readInt(*keyItemId)) return false; } else { keyItemId.reset(); } }
        if(!condition::MinLevel::deserializeMinLevel(_buf, openLevel)) return false;
        if (!_buf.readBool(useOnObtain)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); dropIds.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; dropIds.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); chooseList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<item::ChooseOneBonus> _e;  if(!item::ChooseOneBonus::deserializeChooseOneBonus(_buf, _e)) return false; chooseList.push_back(_e);}}

        return true;
    }

    bool item::TreasureBox::deserializeTreasureBox(ByteBuf& _buf, ::bright::SharedPtr<item::TreasureBox>& _out)
    {
        _out.reset(new item::TreasureBox());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::TreasureBox::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
        openLevel->resolve(_tables);
        for(auto _e : chooseList) { _e->resolve(_tables); }
    }

    bool condition::Condition::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool condition::Condition::deserializeCondition(ByteBuf& _buf, ::bright::SharedPtr<condition::Condition>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::TimeRange::__ID__: { _out.reset(new condition::TimeRange()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MultiRoleCondition::__ID__: { _out.reset(new condition::MultiRoleCondition()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::GenderLimit::__ID__: { _out.reset(new condition::GenderLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinLevel::__ID__: { _out.reset(new condition::MinLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MaxLevel::__ID__: { _out.reset(new condition::MaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinMaxLevel::__ID__: { _out.reset(new condition::MinMaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ClothesPropertyScoreGreaterThan::__ID__: { _out.reset(new condition::ClothesPropertyScoreGreaterThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ContainsItem::__ID__: { _out.reset(new condition::ContainsItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void condition::Condition::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool condition::TimeRange::deserialize(ByteBuf& _buf)
    {
        if (!condition::Condition::deserialize(_buf))
        {
            return false;
        }

        if(!common::DateTimeRange::deserializeDateTimeRange(_buf, dateTimeRange)) return false;

        return true;
    }

    bool condition::TimeRange::deserializeTimeRange(ByteBuf& _buf, ::bright::SharedPtr<condition::TimeRange>& _out)
    {
        _out.reset(new condition::TimeRange());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::TimeRange::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Condition::resolve(_tables);
        dateTimeRange->resolve(_tables);
    }

    bool common::DateTimeRange::deserialize(ByteBuf& _buf)
    {

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { startTime.reset(new ::bright::datetime()); if(!_buf.readInt(*startTime)) return false; } else { startTime.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { endTime.reset(new ::bright::datetime()); if(!_buf.readInt(*endTime)) return false; } else { endTime.reset(); } }

        return true;
    }

    bool common::DateTimeRange::deserializeDateTimeRange(ByteBuf& _buf, ::bright::SharedPtr<common::DateTimeRange>& _out)
    {
        _out.reset(new common::DateTimeRange());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void common::DateTimeRange::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool condition::RoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::Condition::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool condition::RoleCondition::deserializeRoleCondition(ByteBuf& _buf, ::bright::SharedPtr<condition::RoleCondition>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::MultiRoleCondition::__ID__: { _out.reset(new condition::MultiRoleCondition()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::GenderLimit::__ID__: { _out.reset(new condition::GenderLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinLevel::__ID__: { _out.reset(new condition::MinLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MaxLevel::__ID__: { _out.reset(new condition::MaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinMaxLevel::__ID__: { _out.reset(new condition::MinMaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ClothesPropertyScoreGreaterThan::__ID__: { _out.reset(new condition::ClothesPropertyScoreGreaterThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ContainsItem::__ID__: { _out.reset(new condition::ContainsItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void condition::RoleCondition::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Condition::resolve(_tables);
    }

    bool condition::MultiRoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));conditions.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<condition::RoleCondition> _e;if(!condition::RoleCondition::deserializeRoleCondition(_buf, _e)) return false; conditions.push_back(_e);}}

        return true;
    }

    bool condition::MultiRoleCondition::deserializeMultiRoleCondition(ByteBuf& _buf, ::bright::SharedPtr<condition::MultiRoleCondition>& _out)
    {
        _out.reset(new condition::MultiRoleCondition());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MultiRoleCondition::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        RoleCondition::resolve(_tables);
        for(auto _e : conditions) { _e->resolve(_tables); }
    }

    bool condition::BoolRoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool condition::BoolRoleCondition::deserializeBoolRoleCondition(ByteBuf& _buf, ::bright::SharedPtr<condition::BoolRoleCondition>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::GenderLimit::__ID__: { _out.reset(new condition::GenderLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinLevel::__ID__: { _out.reset(new condition::MinLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MaxLevel::__ID__: { _out.reset(new condition::MaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinMaxLevel::__ID__: { _out.reset(new condition::MinMaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ClothesPropertyScoreGreaterThan::__ID__: { _out.reset(new condition::ClothesPropertyScoreGreaterThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void condition::BoolRoleCondition::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        RoleCondition::resolve(_tables);
    }

    bool condition::GenderLimit::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; gender = role::EGenderType(__enum_temp__); }

        return true;
    }

    bool condition::GenderLimit::deserializeGenderLimit(ByteBuf& _buf, ::bright::SharedPtr<condition::GenderLimit>& _out)
    {
        _out.reset(new condition::GenderLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::GenderLimit::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::MinLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(level)) return false;

        return true;
    }

    bool condition::MinLevel::deserializeMinLevel(ByteBuf& _buf, ::bright::SharedPtr<condition::MinLevel>& _out)
    {
        _out.reset(new condition::MinLevel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MinLevel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::MaxLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(level)) return false;

        return true;
    }

    bool condition::MaxLevel::deserializeMaxLevel(ByteBuf& _buf, ::bright::SharedPtr<condition::MaxLevel>& _out)
    {
        _out.reset(new condition::MaxLevel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MaxLevel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::MinMaxLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(min)) return false;
        if(!_buf.readInt(max)) return false;

        return true;
    }

    bool condition::MinMaxLevel::deserializeMinMaxLevel(ByteBuf& _buf, ::bright::SharedPtr<condition::MinMaxLevel>& _out)
    {
        _out.reset(new condition::MinMaxLevel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MinMaxLevel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::ClothesPropertyScoreGreaterThan::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; prop = item::EClothesPropertyType(__enum_temp__); }
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool condition::ClothesPropertyScoreGreaterThan::deserializeClothesPropertyScoreGreaterThan(ByteBuf& _buf, ::bright::SharedPtr<condition::ClothesPropertyScoreGreaterThan>& _out)
    {
        _out.reset(new condition::ClothesPropertyScoreGreaterThan());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::ClothesPropertyScoreGreaterThan::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::ContainsItem::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if (!_buf.readBool(reverse)) return false;

        return true;
    }

    bool condition::ContainsItem::deserializeContainsItem(ByteBuf& _buf, ::bright::SharedPtr<condition::ContainsItem>& _out)
    {
        _out.reset(new condition::ContainsItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::ContainsItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        RoleCondition::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool item::ChooseOneBonus::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(dropId)) return false;
        if (!_buf.readBool(isUnique)) return false;

        return true;
    }

    bool item::ChooseOneBonus::deserializeChooseOneBonus(ByteBuf& _buf, ::bright::SharedPtr<item::ChooseOneBonus>& _out)
    {
        _out.reset(new item::ChooseOneBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::ChooseOneBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->dropId_Ref = ((bonus::TbDrop*)(_tables["bonus.TbDrop"]))->get(dropId);
    }

    bool item::InteractionItem::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { attackNum.reset(new ::bright::int32()); if(!_buf.readInt(*attackNum)) return false; } else { attackNum.reset(); } }
        if(!_buf.readString(holdingStaticMesh)) return false;
        if(!_buf.readString(holdingStaticMeshMat)) return false;

        return true;
    }

    bool item::InteractionItem::deserializeInteractionItem(ByteBuf& _buf, ::bright::SharedPtr<item::InteractionItem>& _out)
    {
        _out.reset(new item::InteractionItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::InteractionItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
    }

    bool item::Clothes::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(attack)) return false;
        if(!_buf.readLong(hp)) return false;
        if(!_buf.readInt(energyLimit)) return false;
        if(!_buf.readInt(energyResume)) return false;

        return true;
    }

    bool item::Clothes::deserializeClothes(ByteBuf& _buf, ::bright::SharedPtr<item::Clothes>& _out)
    {
        _out.reset(new item::Clothes());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::Clothes::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
    }

    bool item::DesignDrawing::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); learnComponentId.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; learnComponentId.push_back(_e);}}

        return true;
    }

    bool item::DesignDrawing::deserializeDesignDrawing(ByteBuf& _buf, ::bright::SharedPtr<item::DesignDrawing>& _out)
    {
        _out.reset(new item::DesignDrawing());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::DesignDrawing::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
    }

    bool item::Dymmy::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        if(!cost::Cost::deserializeCost(_buf, cost)) return false;

        return true;
    }

    bool item::Dymmy::deserializeDymmy(ByteBuf& _buf, ::bright::SharedPtr<item::Dymmy>& _out)
    {
        _out.reset(new item::Dymmy());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::Dymmy::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
        cost->resolve(_tables);
    }

    bool cost::Cost::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool cost::Cost::deserializeCost(ByteBuf& _buf, ::bright::SharedPtr<cost::Cost>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case cost::CostCurrency::__ID__: { _out.reset(new cost::CostCurrency()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostCurrencies::__ID__: { _out.reset(new cost::CostCurrencies()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostOneItem::__ID__: { _out.reset(new cost::CostOneItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostItem::__ID__: { _out.reset(new cost::CostItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostItems::__ID__: { _out.reset(new cost::CostItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void cost::Cost::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }
}