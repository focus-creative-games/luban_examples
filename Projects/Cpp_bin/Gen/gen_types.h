//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma once
#include <functional>

#include "bright/serialization/ByteBuf.h"
#include "bright/CfgBean.hpp"

using ByteBuf = ::bright::serialization::ByteBuf;

namespace cfg
{


namespace ai {
enum class EExecutor
{
    CLIENT = 0,
    SERVER = 1,
};
}

namespace ai {
enum class EKeyType
{
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS = 8,
    ENUM = 9,
    OBJECT = 10,
};
}

namespace ai {
enum class EFlowAbortMode
{
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
};
}

namespace ai {
enum class EFinishMode
{
    IMMEDIATE = 0,
    DELAYED = 1,
};
}

namespace ai {
enum class ENotifyObserverMode
{
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
};
}

namespace ai {
enum class EOperator
{
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
};
}

namespace common {
enum class EBoolOperator
{
    AND = 0,
    OR = 1,
};
}

namespace error {
enum class EOperation
{
    /**
     * 登出
     */
    LOGOUT = 0,
    /**
     * 重启
     */
    RESTART = 1,
};
}

namespace error {
enum class EErrorCode
{
    OK = 0,
    SERVER_NOT_EXISTS = 1,
    HAS_BIND_SERVER = 2,
    AUTH_FAIL = 3,
    NOT_BIND_SERVER = 4,
    SERVER_ACCESS_FAIL = 5,
    EXAMPLE_FLASH = 6,
    EXAMPLE_MSGBOX = 7,
    EXAMPLE_DLG_OK = 8,
    EXAMPLE_DLG_OK_CANCEL = 9,
    ROLE_CREATE_NAME_INVALID_CHAR = 100,
    ROLE_CREATE_NAME_EMPTY = 101,
    ROLE_CREATE_NAME_EXCEED_MAX_LENGTH = 102,
    ROLE_CREATE_ROLE_LIST_FULL = 103,
    ROLE_CREATE_INVALID_PROFESSION = 104,
    ROLE_CREATE_INVALID_GENDER = 105,
    ROLE_NOT_OWNED_BY_USER = 106,
    ROLE_LEVEL_NOT_ARRIVE = 107,
    PARAM_ILLEGAL = 200,
    TEMP_BAG_NOT_EMPTY = 201,
    ITEM_CAN_NOT_USE = 202,
    CURRENCY_NOT_ENOUGH = 203,
    BAG_IS_FULL = 204,
    ITEM_NOT_ENOUGH = 205,
    ITEM_IN_BAG = 206,
    GENDER_NOT_MATCH = 300,
    LEVEL_TOO_LOW = 301,
    LEVEL_TOO_HIGH = 302,
    EXCEED_LIMIT = 303,
    OVER_TIME = 304,
    SERVER_ERROR = 305,
    SKILL_NOT_IN_LIST = 400,
    SKILL_NOT_COOLDOWN = 401,
    SKILL_TARGET_NOT_EXIST = 402,
    SKILL_ANOTHER_CASTING = 403,
    SKILL_OUT_OF_DISTANCE = 404,
    SKILL_TARGET_CAMP_NOT_MATCH = 405,
    SKILL_INVALID_DIRECTION = 406,
    SKILL_NOT_IN_SELECT_SHAPE = 407,
    SKILL_ENERGY_NOT_ENOUGH = 408,
    DIALOG_NODE_NOT_CHOOSEN = 500,
    DIALOG_NOT_FINISH = 501,
    DIALOG_HAS_FINISH = 502,
    QUEST_STAGE_NOT_FINISHED = 503,
    QUEST_NOT_DOING = 504,
    QUEST_STAGE_NOT_DOING = 505,
    QUEST_HAS_ACCEPTED = 506,
    MAP_OBJECT_NOT_EXIST = 600,
    INTERACTION_OBJECT_NOT_SUPPORT_OPERATION = 601,
    HAS_NOT_EQUIP = 602,
    HANDHELD_EQUIP_ID_NOT_MATCH = 603,
    NOT_AVAILABLE_SUIT_ID = 604,
    NO_INTERACTION_COMPONENT = 605,
    HAS_INTERACTED = 606,
    VIALITY_NOT_ENOUGH = 607,
    PLAYER_SESSION_NOT_EXIST = 608,
    PLAYER_SESSION_WORLD_PLAYER_NOT_INIT = 609,
    MAP_NOT_EXIST = 610,
    MAIL_TYPE_ERROR = 700,
    MAIL_NOT_EXITST = 701,
    MAIL_HAVE_DELETED = 702,
    MAIL_AWARD_HAVE_RECEIVED = 703,
    MAIL_OPERATE_TYPE_ERROR = 704,
    MAIL_CONDITION_NOT_MEET = 705,
    MAIL_STATE_ERROR = 706,
    MAIL_NO_AWARD = 707,
    MAIL_BOX_IS_FULL = 708,
    PROP_SCORE_NOT_BIGGER_THAN = 800,
    NOT_WEAR_CLOTHES = 801,
    NOT_WEAR_SUIT = 802,
    SUIT_NOT_UNLOCK = 900,
    SUIT_COMPONENT_NOT_UNLOCK = 901,
    SUIT_STATE_ERROR = 902,
    SUIT_COMPONENT_STATE_ERROR = 903,
    SUIT_COMPONENT_NO_NEED_LEARN = 904,
    STORE_NOT_ENABLED = 1000,
    SHELF_NOT_ENABLED = 1001,
    GOODS_NOT_ENABLED = 1002,
    GOODS_NOT_IN_CUR_REFRESH = 1003,
    RETRY = 1100,
    NOT_COOLDOWN = 1101,
    SELFIE_UNLOCK = 1200,
    SELFIE_ALREADY_UNLOCK = 1201,
    SELFIE_LACK_STARTS = 1202,
    SELFIE_HAD_REWARD = 1203,
};
}

namespace item {
/**
 * 道具品质
 */
enum class EItemQuality
{
    /**
     * 白
     */
    WHITE = 0,
    /**
     * 绿
     */
    GREEN = 1,
    /**
     * 蓝
     */
    BLUE = 2,
    /**
     * 紫
     */
    PURPLE = 3,
    /**
     * 金
     */
    GOLDEN = 4,
};
}

namespace item {
enum class ECurrencyType
{
    /**
     * 钻石
     */
    DIAMOND = 1,
    /**
     * 金币
     */
    GOLD = 2,
    /**
     * 银币
     */
    SILVER = 3,
    /**
     * 经验
     */
    EXP = 4,
    /**
     * 能量点
     */
    POWER_POINT = 5,
};
}

namespace item {
enum class EMajorType
{
    /**
     * 货币
     */
    CURRENCY = 1,
    /**
     * 服装
     */
    CLOTH = 2,
    /**
     * 任务
     */
    QUEST = 3,
    /**
     * 消耗品
     */
    CONSUMABLES = 4,
    /**
     * 宝箱
     */
    TREASURE_BOX = 5,
    /**
     * 成就和称谓
     */
    ACHIEVEMENT_AND_TITLE = 6,
    /**
     * 头像框
     */
    HEAD_FRAME = 7,
    /**
     * 语音
     */
    VOICE = 8,
    /**
     * 动作
     */
    ACTION = 9,
    /**
     * 扩容道具
     */
    EXPANSION = 10,
    /**
     * 制作材料
     */
    MATERIAL = 11,
};
}

namespace item {
enum class EMinorType
{
    /**
     * 钻石
     */
    DIAMOND = 101,
    /**
     * 金币
     */
    GOLD = 102,
    /**
     * 银币
     */
    SILVER = 103,
    /**
     * 经验
     */
    EXP = 104,
    /**
     * 能量点
     */
    POWER_POINT = 105,
    /**
     * 发型
     */
    HAIR_STYLE = 210,
    /**
     * 外套
     */
    COAT = 220,
    /**
     * 上衣
     */
    UPPER_JACKET = 230,
    /**
     * 裤子
     */
    TROUSERS = 241,
    /**
     * 裙子
     */
    SKIRT = 242,
    /**
     * 袜子
     */
    SOCKS = 250,
    /**
     * 鞋子
     */
    SHOES = 260,
    /**
     * 发饰
     */
    HAIR_ACCESSORY = 271,
    /**
     * 帽子
     */
    HAT = 272,
    /**
     * 耳饰
     */
    EARRING = 273,
    /**
     * 颈饰
     */
    NECKLACE = 274,
    /**
     * 腕饰
     */
    BRACELET = 275,
    /**
     * 发箍
     */
    HAIR_CLASP = 276,
    /**
     * 手套
     */
    GLOVE = 277,
    /**
     * 手持物
     */
    HANDHELD_OBJECT = 278,
    /**
     * 特殊
     */
    SPECIAL = 279,
    /**
     * 底妆
     */
    BASE_COSMETIC = 281,
    /**
     * 眉妆
     */
    EYEBROW_COSMETIC = 282,
    /**
     * 睫毛
     */
    EYELASH = 283,
    /**
     * 美瞳
     */
    COSMETIC_CONTACT_LENSES = 284,
    /**
     * 唇妆
     */
    LIP_COSMETIC = 285,
    /**
     * 肤色
     */
    SKIN_COLOR = 286,
    /**
     * 连衣裙
     */
    ONE_PIECE_DRESS = 290,
    /**
     * 换装场景
     */
    SWITCH_CLOTHES_SCENE = 291,
    /**
     * 任务道具
     */
    QUEST = 301,
    /**
     * 投掷物
     */
    CAST = 401,
    /**
     * 刀剑
     */
    SWORD = 421,
    /**
     * 弓箭
     */
    BOW_ARROW = 422,
    /**
     * 法杖
     */
    WANDS = 423,
    /**
     * 特殊工具
     */
    SPECIAL_TOOL = 424,
    /**
     * 食物
     */
    FOOD = 403,
    /**
     * 宝箱
     */
    TREASURE_BOX = 501,
    /**
     * 钥匙
     */
    KEY = 502,
    /**
     * 多选一宝箱
     */
    MULTI_CHOOSE_TREASURE_BOX = 503,
    /**
     * 成就相关
     */
    ACHIEVEMENT = 601,
    /**
     * 称谓相关
     */
    TITLE = 602,
    /**
     * 头像框
     */
    AVATAR_FRAME = 701,
    /**
     * 语音
     */
    VOICE = 801,
    /**
     * 特殊待机动作
     */
    IDLE_POSE = 901,
    /**
     * 拍照动作
     */
    PHOTO_POSE = 902,
    /**
     * 背包
     */
    BAG = 1001,
    /**
     * 好友数量
     */
    FRIEND_CAPACITY = 1002,
    /**
     * 制作材料
     */
    CONSTRUCTION_MATERIAL = 1101,
    /**
     * 设计图纸
     */
    DESIGN_DRAWING = 1102,
};
}

namespace item {
enum class EClothersStarQualityType
{
    /**
     * 一星
     */
    ONE = 1,
    /**
     * 二星
     */
    TWO = 2,
    /**
     * 三星
     */
    THREE = 3,
    /**
     * 四星
     */
    FOUR = 4,
    /**
     * 五星
     */
    FIVE = 5,
    /**
     * 六星
     */
    SIX = 6,
    /**
     * 七星
     */
    SEVEN = 7,
    /**
     * 八星
     */
    EIGHT = 8,
    /**
     * 九星
     */
    NINE = 9,
    /**
     * 十星
     */
    TEN = 10,
};
}

namespace item {
enum class EClothersTag
{
    /**
     * 防晒
     */
    FANG_SHAI = 1,
    /**
     * 舞者
     */
    WU_ZHE = 2,
};
}

namespace item {
enum class EUseType
{
    /**
     * 手动
     */
    MANUAL = 0,
    /**
     * 自动
     */
    AUTO = 1,
};
}

namespace item {
enum class EClothesHidePartType
{
    /**
     * 胸部
     */
    CHEST = 0,
    /**
     * 手
     */
    HEAD = 1,
    /**
     * 脊柱上
     */
    SPINE_UPPER = 2,
    /**
     * 脊柱下
     */
    SPINE_LOWER = 3,
    /**
     * 臀部
     */
    HIP = 4,
    /**
     * 腿上
     */
    LEG_UPPER = 5,
    /**
     * 腿中
     */
    LEG_MIDDLE = 6,
    /**
     * 腿下
     */
    LEG_LOWER = 7,
};
}

namespace item {
enum class EClothesPropertyType
{
    /**
     * 简约
     */
    JIAN_YUE = 1,
    /**
     * 华丽
     */
    HUA_LI = 2,
    /**
     * 可爱
     */
    KE_AI = 3,
    /**
     * 成熟
     */
    CHENG_SHU = 4,
    /**
     * 活泼
     */
    HUO_PO = 5,
    /**
     * 优雅
     */
    YOU_YA = 6,
    /**
     * 清纯
     */
    QING_CHUN = 7,
    /**
     * 性感
     */
    XING_GAN = 8,
    /**
     * 清凉
     */
    QING_LIANG = 9,
    /**
     * 保暖
     */
    BAO_NUAN = 10,
};
}

namespace item {
enum class EItemFunctionType
{
    /**
     * 更换手持物
     */
    REPLACE_HANDHELD = 0,
    /**
     * 使用设计图纸
     */
    USE_DESIGN_DRAWING = 1,
};
}

namespace limit {
enum class ENamespace
{
    ITEM_DAILY_OBTAIN = 1,
    TREASURE_DAILY_USE = 2,
    STORE_GOODS_LIMIT_BUY = 3,
};
}

namespace mail {
enum class EMailType
{
    /**
     * 全局邮件
     */
    GLOBAL = 0,
    /**
     * 系统邮件
     */
    SYSTEM = 1,
};
}

namespace role {
enum class EGenderType
{
    /**
     * 男
     */
    MALE = 1,
    /**
     * 女
     */
    FEMALE = 2,
};
}

namespace role {
enum class EProfession
{
    TEST_PROFESSION = 1,
};
}

namespace test {
enum class DemoEnum
{
    NONE = 0,
    /**
     * aa
     */
    A = 1,
    /**
     * bb
     */
    B = 2,
    /**
     * cc
     */
    C = 4,
    /**
     * dd
     */
    D = 5,
};
}

namespace test {
enum class DemoFlag
{
    A = 1,
    B = 2,
    D = A|B,
};
}

namespace test {
enum class ETestUeType
{
    /**
     * 白
     */
    WHITE = 0,
    BLACK = 1,
};
}

namespace test {
enum class ETestEmptyEnum
{
};
}

namespace test {
enum class ETestEmptyEnum2
{
    SMALL_THAN_256 = 255,
    X_256 = 256,
    X_257 = 257,
};
}

namespace test {
enum class AudioType
{
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
};
}

namespace test {
enum class ETestQuality
{
    /**
     * 最高品质
     */
    A = 1,
    /**
     * 黑色的
     */
    B = 2,
    /**
     * 蓝色的
     */
    C = 3,
    /**
     * 最差品质
     */
    D = 4,
};
}

namespace test {
enum class AccessFlag
{
    WRITE = 1,
    READ = 2,
    TRUNCATE = 4,
    NEW = 8,
    READ_WRITE = WRITE|READ,
};
}

namespace ai { class Blackboard; }
namespace ai { class BlackboardKey; }
namespace ai { class BehaviorTree; }
namespace ai { class Node; }
namespace ai { class Service; }
namespace ai { class UeSetDefaultFocus; }
namespace ai { class ExecuteTimeStatistic; }
namespace ai { class ChooseTarget; }
namespace ai { class KeepFaceTarget; }
namespace ai { class GetOwnerPlayer; }
namespace ai { class UpdateDailyBehaviorProps; }
namespace ai { class Decorator; }
namespace ai { class UeLoop; }
namespace ai { class UeCooldown; }
namespace ai { class UeTimeLimit; }
namespace ai { class UeBlackboard; }
namespace ai { class KeyQueryOperator; }
namespace ai { class IsSet; }
namespace ai { class IsNotSet; }
namespace ai { class BinaryOperator; }
namespace ai { class KeyData; }
namespace ai { class FloatKeyData; }
namespace ai { class IntKeyData; }
namespace ai { class StringKeyData; }
namespace ai { class BlackboardKeyData; }
namespace ai { class UeForceSuccess; }
namespace ai { class IsAtLocation; }
namespace ai { class DistanceLessThan; }
namespace ai { class FlowNode; }
namespace ai { class ComposeNode; }
namespace ai { class Sequence; }
namespace ai { class Selector; }
namespace ai { class SimpleParallel; }
namespace ai { class Task; }
namespace ai { class UeWait; }
namespace ai { class UeWaitBlackboardTime; }
namespace ai { class MoveToTarget; }
namespace ai { class ChooseSkill; }
namespace ai { class MoveToRandomLocation; }
namespace ai { class MoveToLocation; }
namespace ai { class DebugPrint; }
namespace blueprint { class Clazz; }
namespace blueprint { class Method; }
namespace blueprint { class ParamInfo; }
namespace blueprint { class AbstraceMethod; }
namespace blueprint { class ExternalMethod; }
namespace blueprint { class BlueprintMethod; }
namespace blueprint { class Interface; }
namespace blueprint { class NormalClazz; }
namespace blueprint { class Field; }
namespace blueprint { class EnumClazz; }
namespace blueprint { class EnumField; }
namespace bonus { class DropInfo; }
namespace bonus { class ShowItemInfo; }
namespace bonus { class Bonus; }
namespace bonus { class OneItem; }
namespace bonus { class OneItems; }
namespace bonus { class Item; }
namespace bonus { class Items; }
namespace bonus { class CoefficientItem; }
namespace bonus { class WeightItems; }
namespace bonus { class WeightItemInfo; }
namespace bonus { class ProbabilityItems; }
namespace bonus { class ProbabilityItemInfo; }
namespace bonus { class MultiBonus; }
namespace bonus { class ProbabilityBonus; }
namespace bonus { class ProbabilityBonusInfo; }
namespace bonus { class WeightBonus; }
namespace bonus { class WeightBonusInfo; }
namespace bonus { class DropBonus; }
namespace common { class GlobalConfig; }
namespace error { class ErrorInfo; }
namespace error { class ErrorStyle; }
namespace error { class ErrorStyleTip; }
namespace error { class ErrorStyleMsgbox; }
namespace error { class ErrorStyleDlgOk; }
namespace error { class ErrorStyleDlgOkCancel; }
namespace error { class CodeInfo; }
namespace item { class Item; }
namespace item { class ItemFunction; }
namespace item { class ItemExtra; }
namespace item { class TreasureBox; }
namespace condition { class Condition; }
namespace condition { class TimeRange; }
namespace common { class DateTimeRange; }
namespace condition { class RoleCondition; }
namespace condition { class MultiRoleCondition; }
namespace condition { class BoolRoleCondition; }
namespace condition { class GenderLimit; }
namespace condition { class MinLevel; }
namespace condition { class MaxLevel; }
namespace condition { class MinMaxLevel; }
namespace condition { class ClothesPropertyScoreGreaterThan; }
namespace condition { class ContainsItem; }
namespace item { class ChooseOneBonus; }
namespace item { class InteractionItem; }
namespace item { class Clothes; }
namespace item { class DesignDrawing; }
namespace item { class Dymmy; }
namespace cost { class Cost; }
namespace cost { class CostCurrency; }
namespace cost { class CostCurrencies; }
namespace cost { class CostOneItem; }
namespace cost { class CostItem; }
namespace cost { class CostItems; }
namespace l10n { class L10NDemo; }
namespace l10n { class PatchDemo; }
namespace mail { class SystemMail; }
namespace mail { class GlobalMail; }
namespace role { class LevelExpAttr; }
namespace role { class LevelBonus; }
namespace role { class DistinctBonusInfos; }
namespace role { class BonusInfo; }
namespace tag { class TestTag; }
namespace test { class DemoType2; }
namespace test { class DemoType1; }
namespace test { class DemoDynamic; }
namespace test { class DemoD2; }
namespace test { class DemoD3; }
namespace test { class DemoE1; }
namespace test {namespace login { class RoleInfo; }}
namespace test { class DemoD5; }
namespace test { class DateTimeRange; }
namespace test { class DemoE2; }
namespace test { class DemoSingletonType; }
namespace test { class NotIndexList; }
namespace test { class MultiUnionIndexList; }
namespace test { class MultiIndexList; }
namespace test { class MultiRowRecord; }
namespace test { class MultiRowType1; }
namespace test { class MultiRowType2; }
namespace test { class MultiRowType3; }
namespace test { class TestMultiColumn; }
namespace test { class Foo; }
namespace test { class MultiRowTitle; }
namespace test { class H1; }
namespace test { class H2; }
namespace test { class TestNull; }
namespace test { class DemoPrimitiveTypesTable; }
namespace test { class TestString; }
namespace test { class CompactString; }
namespace test { class DemoGroup; }
namespace test { class InnerGroup; }
namespace test { class TestGlobal; }
namespace test { class TestBeRef; }
namespace test { class TestRef; }
namespace test { class TestSize; }
namespace test { class TestSet; }
namespace test { class DetectEncoding; }
namespace test { class ItemBase; }
namespace test { class Item; }
namespace test { class Equipment; }
namespace test { class Decorator; }
namespace test { class DefineFromExcel; }
namespace test { class Shape; }
namespace test { class Circle; }
namespace test2 { class Rectangle; }
namespace test { class DefineFromExcelOne; }
namespace test { class TestIndex; }
namespace test { class TestMap; }
namespace test { class ExcelFromJson; }
namespace test { class CompositeJsonTable1; }
namespace test { class CompositeJsonTable2; }
namespace test { class CompositeJsonTable3; }
namespace test { class ExcelFromJsonMultiRow; }
namespace test { class TestRow; }
namespace test { class Test3; }
namespace test { class TestSep; }
namespace test { class SepBean1; }
namespace test { class SepVector; }
namespace test { class TestScriptableObject; }
namespace test { class TestExternalType; }
namespace test { class Color; }
namespace test { class DefineFromExcel2; }
namespace test { class TestExcelBean1; }
namespace test { class TestDesc; }

namespace ai {



class Blackboard : public  bright::CfgBean 
{
    public:

    static bool deserializeBlackboard(ByteBuf& _buf, ::bright::SharedPtr<Blackboard>& _out);

    Blackboard()
    { 

    }

    Blackboard(::bright::String name, ::bright::String desc, ::bright::String parent_name, ::bright::Vector<::bright::SharedPtr<ai::BlackboardKey>> keys ) 
    {

        this->name = name;
        this->desc = desc;
        this->parentName = parent_name;
        this->keys = keys;
    }
    virtual ~Blackboard() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String name;
    ::bright::String desc;
    ::bright::String parentName;
    ::bright::SharedPtr<ai::Blackboard> parentName_Ref;
    ::bright::Vector<::bright::SharedPtr<ai::BlackboardKey>> keys;

    static constexpr int __ID__ = 1576193005;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class BlackboardKey : public  bright::CfgBean 
{
    public:

    static bool deserializeBlackboardKey(ByteBuf& _buf, ::bright::SharedPtr<BlackboardKey>& _out);

    BlackboardKey()
    { 

    }

    BlackboardKey(::bright::String name, ::bright::String desc, bool is_static, ai::EKeyType type, ::bright::String type_class_name ) 
    {

        this->name = name;
        this->desc = desc;
        this->isStatic = is_static;
        this->type = type;
        this->typeClassName = type_class_name;
    }
    virtual ~BlackboardKey() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String name;
    ::bright::String desc;
    bool isStatic;
    ai::EKeyType type;
    ::bright::String typeClassName;

    static constexpr int __ID__ = -511559886;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class BehaviorTree : public  bright::CfgBean 
{
    public:

    static bool deserializeBehaviorTree(ByteBuf& _buf, ::bright::SharedPtr<BehaviorTree>& _out);

    BehaviorTree()
    { 

    }

    BehaviorTree(::bright::int32 id, ::bright::String name, ::bright::String desc, ::bright::String blackboard_id, ::bright::SharedPtr<ai::ComposeNode> root ) 
    {

        this->id = id;
        this->name = name;
        this->desc = desc;
        this->blackboardId = blackboard_id;
        this->root = root;
    }
    virtual ~BehaviorTree() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String name;
    ::bright::String desc;
    ::bright::String blackboardId;
    ::bright::SharedPtr<ai::Blackboard> blackboardId_Ref;
    ::bright::SharedPtr<ai::ComposeNode> root;

    static constexpr int __ID__ = 159552822;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class Node : public  bright::CfgBean 
{
    public:

    static bool deserializeNode(ByteBuf& _buf, ::bright::SharedPtr<Node>& _out);

    Node()
    { 

    }

    Node(::bright::int32 id, ::bright::String node_name ) 
    {

        this->id = id;
        this->nodeName = node_name;
    }
    virtual ~Node() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String nodeName;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class Service : public  ai::Node 
{
    public:

    static bool deserializeService(ByteBuf& _buf, ::bright::SharedPtr<Service>& _out);

    Service()
    { 

    }

    Service(::bright::int32 id, ::bright::String node_name ) 
            : ai::Node(id, node_name)
    {

    }
    virtual ~Service() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeSetDefaultFocus : public  ai::Service 
{
    public:

    static bool deserializeUeSetDefaultFocus(ByteBuf& _buf, ::bright::SharedPtr<UeSetDefaultFocus>& _out);

    UeSetDefaultFocus()
    { 

    }

    UeSetDefaultFocus(::bright::int32 id, ::bright::String node_name, ::bright::String keyboard_key ) 
            : ai::Service(id, node_name)
    {

        this->keyboardKey = keyboard_key;
    }
    virtual ~UeSetDefaultFocus() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String keyboardKey;

    static constexpr int __ID__ = 1812449155;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class ExecuteTimeStatistic : public  ai::Service 
{
    public:

    static bool deserializeExecuteTimeStatistic(ByteBuf& _buf, ::bright::SharedPtr<ExecuteTimeStatistic>& _out);

    ExecuteTimeStatistic()
    { 

    }

    ExecuteTimeStatistic(::bright::int32 id, ::bright::String node_name ) 
            : ai::Service(id, node_name)
    {

    }
    virtual ~ExecuteTimeStatistic() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = 990693812;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class ChooseTarget : public  ai::Service 
{
    public:

    static bool deserializeChooseTarget(ByteBuf& _buf, ::bright::SharedPtr<ChooseTarget>& _out);

    ChooseTarget()
    { 

    }

    ChooseTarget(::bright::int32 id, ::bright::String node_name, ::bright::String result_target_key ) 
            : ai::Service(id, node_name)
    {

        this->resultTargetKey = result_target_key;
    }
    virtual ~ChooseTarget() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String resultTargetKey;

    static constexpr int __ID__ = 1601247918;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class KeepFaceTarget : public  ai::Service 
{
    public:

    static bool deserializeKeepFaceTarget(ByteBuf& _buf, ::bright::SharedPtr<KeepFaceTarget>& _out);

    KeepFaceTarget()
    { 

    }

    KeepFaceTarget(::bright::int32 id, ::bright::String node_name, ::bright::String target_actor_key ) 
            : ai::Service(id, node_name)
    {

        this->targetActorKey = target_actor_key;
    }
    virtual ~KeepFaceTarget() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String targetActorKey;

    static constexpr int __ID__ = 1195270745;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class GetOwnerPlayer : public  ai::Service 
{
    public:

    static bool deserializeGetOwnerPlayer(ByteBuf& _buf, ::bright::SharedPtr<GetOwnerPlayer>& _out);

    GetOwnerPlayer()
    { 

    }

    GetOwnerPlayer(::bright::int32 id, ::bright::String node_name, ::bright::String player_actor_key ) 
            : ai::Service(id, node_name)
    {

        this->playerActorKey = player_actor_key;
    }
    virtual ~GetOwnerPlayer() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String playerActorKey;

    static constexpr int __ID__ = -999247644;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UpdateDailyBehaviorProps : public  ai::Service 
{
    public:

    static bool deserializeUpdateDailyBehaviorProps(ByteBuf& _buf, ::bright::SharedPtr<UpdateDailyBehaviorProps>& _out);

    UpdateDailyBehaviorProps()
    { 

    }

    UpdateDailyBehaviorProps(::bright::int32 id, ::bright::String node_name, ::bright::String satiety_key, ::bright::String energy_key, ::bright::String mood_key, ::bright::String satiety_lower_threshold_key, ::bright::String satiety_upper_threshold_key, ::bright::String energy_lower_threshold_key, ::bright::String energy_upper_threshold_key, ::bright::String mood_lower_threshold_key, ::bright::String mood_upper_threshold_key ) 
            : ai::Service(id, node_name)
    {

        this->satietyKey = satiety_key;
        this->energyKey = energy_key;
        this->moodKey = mood_key;
        this->satietyLowerThresholdKey = satiety_lower_threshold_key;
        this->satietyUpperThresholdKey = satiety_upper_threshold_key;
        this->energyLowerThresholdKey = energy_lower_threshold_key;
        this->energyUpperThresholdKey = energy_upper_threshold_key;
        this->moodLowerThresholdKey = mood_lower_threshold_key;
        this->moodUpperThresholdKey = mood_upper_threshold_key;
    }
    virtual ~UpdateDailyBehaviorProps() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String satietyKey;
    ::bright::String energyKey;
    ::bright::String moodKey;
    ::bright::String satietyLowerThresholdKey;
    ::bright::String satietyUpperThresholdKey;
    ::bright::String energyLowerThresholdKey;
    ::bright::String energyUpperThresholdKey;
    ::bright::String moodLowerThresholdKey;
    ::bright::String moodUpperThresholdKey;

    static constexpr int __ID__ = -61887372;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class Decorator : public  ai::Node 
{
    public:

    static bool deserializeDecorator(ByteBuf& _buf, ::bright::SharedPtr<Decorator>& _out);

    Decorator()
    { 

    }

    Decorator(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode ) 
            : ai::Node(id, node_name)
    {

        this->flowAbortMode = flow_abort_mode;
    }
    virtual ~Decorator() {}

    bool deserialize(ByteBuf& _buf);

    ai::EFlowAbortMode flowAbortMode;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeLoop : public  ai::Decorator 
{
    public:

    static bool deserializeUeLoop(ByteBuf& _buf, ::bright::SharedPtr<UeLoop>& _out);

    UeLoop()
    { 

    }

    UeLoop(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode, ::bright::int32 num_loops, bool infinite_loop, ::bright::float32 infinite_loop_timeout_time ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->numLoops = num_loops;
        this->infiniteLoop = infinite_loop;
        this->infiniteLoopTimeoutTime = infinite_loop_timeout_time;
    }
    virtual ~UeLoop() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 numLoops;
    bool infiniteLoop;
    ::bright::float32 infiniteLoopTimeoutTime;

    static constexpr int __ID__ = -513308166;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeCooldown : public  ai::Decorator 
{
    public:

    static bool deserializeUeCooldown(ByteBuf& _buf, ::bright::SharedPtr<UeCooldown>& _out);

    UeCooldown()
    { 

    }

    UeCooldown(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode, ::bright::float32 cooldown_time ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->cooldownTime = cooldown_time;
    }
    virtual ~UeCooldown() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::float32 cooldownTime;

    static constexpr int __ID__ = -951439423;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeTimeLimit : public  ai::Decorator 
{
    public:

    static bool deserializeUeTimeLimit(ByteBuf& _buf, ::bright::SharedPtr<UeTimeLimit>& _out);

    UeTimeLimit()
    { 

    }

    UeTimeLimit(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode, ::bright::float32 limit_time ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->limitTime = limit_time;
    }
    virtual ~UeTimeLimit() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::float32 limitTime;

    static constexpr int __ID__ = 338469720;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeBlackboard : public  ai::Decorator 
{
    public:

    static bool deserializeUeBlackboard(ByteBuf& _buf, ::bright::SharedPtr<UeBlackboard>& _out);

    UeBlackboard()
    { 

    }

    UeBlackboard(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode, ai::ENotifyObserverMode notify_observer, ::bright::String blackboard_key, ::bright::SharedPtr<ai::KeyQueryOperator> key_query ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->notifyObserver = notify_observer;
        this->blackboardKey = blackboard_key;
        this->keyQuery = key_query;
    }
    virtual ~UeBlackboard() {}

    bool deserialize(ByteBuf& _buf);

    ai::ENotifyObserverMode notifyObserver;
    ::bright::String blackboardKey;
    ::bright::SharedPtr<ai::KeyQueryOperator> keyQuery;

    static constexpr int __ID__ = -315297507;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class KeyQueryOperator : public  bright::CfgBean 
{
    public:

    static bool deserializeKeyQueryOperator(ByteBuf& _buf, ::bright::SharedPtr<KeyQueryOperator>& _out);

    KeyQueryOperator()
    { 

    }

    virtual ~KeyQueryOperator() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class IsSet : public  ai::KeyQueryOperator 
{
    public:

    static bool deserializeIsSet(ByteBuf& _buf, ::bright::SharedPtr<IsSet>& _out);

    IsSet()
    { 

    }

    virtual ~IsSet() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = 1635350898;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class IsNotSet : public  ai::KeyQueryOperator 
{
    public:

    static bool deserializeIsNotSet(ByteBuf& _buf, ::bright::SharedPtr<IsNotSet>& _out);

    IsNotSet()
    { 

    }

    virtual ~IsNotSet() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = 790736255;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class BinaryOperator : public  ai::KeyQueryOperator 
{
    public:

    static bool deserializeBinaryOperator(ByteBuf& _buf, ::bright::SharedPtr<BinaryOperator>& _out);

    BinaryOperator()
    { 

    }

    BinaryOperator(ai::EOperator oper, ::bright::SharedPtr<ai::KeyData> data ) 
            : ai::KeyQueryOperator()
    {

        this->oper = oper;
        this->data = data;
    }
    virtual ~BinaryOperator() {}

    bool deserialize(ByteBuf& _buf);

    ai::EOperator oper;
    ::bright::SharedPtr<ai::KeyData> data;

    static constexpr int __ID__ = -979891605;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class KeyData : public  bright::CfgBean 
{
    public:

    static bool deserializeKeyData(ByteBuf& _buf, ::bright::SharedPtr<KeyData>& _out);

    KeyData()
    { 

    }

    virtual ~KeyData() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class FloatKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeFloatKeyData(ByteBuf& _buf, ::bright::SharedPtr<FloatKeyData>& _out);

    FloatKeyData()
    { 

    }

    FloatKeyData(::bright::float32 value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~FloatKeyData() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::float32 value;

    static constexpr int __ID__ = -719747885;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class IntKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeIntKeyData(ByteBuf& _buf, ::bright::SharedPtr<IntKeyData>& _out);

    IntKeyData()
    { 

    }

    IntKeyData(::bright::int32 value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~IntKeyData() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 value;

    static constexpr int __ID__ = -342751904;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class StringKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeStringKeyData(ByteBuf& _buf, ::bright::SharedPtr<StringKeyData>& _out);

    StringKeyData()
    { 

    }

    StringKeyData(::bright::String value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~StringKeyData() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String value;

    static constexpr int __ID__ = -307888654;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class BlackboardKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeBlackboardKeyData(ByteBuf& _buf, ::bright::SharedPtr<BlackboardKeyData>& _out);

    BlackboardKeyData()
    { 

    }

    BlackboardKeyData(::bright::String value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~BlackboardKeyData() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String value;

    static constexpr int __ID__ = 1517269500;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeForceSuccess : public  ai::Decorator 
{
    public:

    static bool deserializeUeForceSuccess(ByteBuf& _buf, ::bright::SharedPtr<UeForceSuccess>& _out);

    UeForceSuccess()
    { 

    }

    UeForceSuccess(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

    }
    virtual ~UeForceSuccess() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = 195054574;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class IsAtLocation : public  ai::Decorator 
{
    public:

    static bool deserializeIsAtLocation(ByteBuf& _buf, ::bright::SharedPtr<IsAtLocation>& _out);

    IsAtLocation()
    { 

    }

    IsAtLocation(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode, ::bright::float32 acceptable_radius, ::bright::String keyboard_key, bool inverse_condition ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->acceptableRadius = acceptable_radius;
        this->keyboardKey = keyboard_key;
        this->inverseCondition = inverse_condition;
    }
    virtual ~IsAtLocation() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::float32 acceptableRadius;
    ::bright::String keyboardKey;
    bool inverseCondition;

    static constexpr int __ID__ = 1255972344;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class DistanceLessThan : public  ai::Decorator 
{
    public:

    static bool deserializeDistanceLessThan(ByteBuf& _buf, ::bright::SharedPtr<DistanceLessThan>& _out);

    DistanceLessThan()
    { 

    }

    DistanceLessThan(::bright::int32 id, ::bright::String node_name, ai::EFlowAbortMode flow_abort_mode, ::bright::String actor1_key, ::bright::String actor2_key, ::bright::float32 distance, bool reverse_result ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->actor1Key = actor1_key;
        this->actor2Key = actor2_key;
        this->distance = distance;
        this->reverseResult = reverse_result;
    }
    virtual ~DistanceLessThan() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String actor1Key;
    ::bright::String actor2Key;
    ::bright::float32 distance;
    bool reverseResult;

    static constexpr int __ID__ = -1207170283;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class FlowNode : public  ai::Node 
{
    public:

    static bool deserializeFlowNode(ByteBuf& _buf, ::bright::SharedPtr<FlowNode>& _out);

    FlowNode()
    { 

    }

    FlowNode(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services ) 
            : ai::Node(id, node_name)
    {

        this->decorators = decorators;
        this->services = services;
    }
    virtual ~FlowNode() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators;
    ::bright::Vector<::bright::SharedPtr<ai::Service>> services;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class ComposeNode : public  ai::FlowNode 
{
    public:

    static bool deserializeComposeNode(ByteBuf& _buf, ::bright::SharedPtr<ComposeNode>& _out);

    ComposeNode()
    { 

    }

    ComposeNode(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services ) 
            : ai::FlowNode(id, node_name, decorators, services)
    {

    }
    virtual ~ComposeNode() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class Sequence : public  ai::ComposeNode 
{
    public:

    static bool deserializeSequence(ByteBuf& _buf, ::bright::SharedPtr<Sequence>& _out);

    Sequence()
    { 

    }

    Sequence(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, ::bright::Vector<::bright::SharedPtr<ai::FlowNode>> children ) 
            : ai::ComposeNode(id, node_name, decorators, services)
    {

        this->children = children;
    }
    virtual ~Sequence() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<ai::FlowNode>> children;

    static constexpr int __ID__ = -1789006105;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class Selector : public  ai::ComposeNode 
{
    public:

    static bool deserializeSelector(ByteBuf& _buf, ::bright::SharedPtr<Selector>& _out);

    Selector()
    { 

    }

    Selector(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, ::bright::Vector<::bright::SharedPtr<ai::FlowNode>> children ) 
            : ai::ComposeNode(id, node_name, decorators, services)
    {

        this->children = children;
    }
    virtual ~Selector() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<ai::FlowNode>> children;

    static constexpr int __ID__ = -1946981627;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class SimpleParallel : public  ai::ComposeNode 
{
    public:

    static bool deserializeSimpleParallel(ByteBuf& _buf, ::bright::SharedPtr<SimpleParallel>& _out);

    SimpleParallel()
    { 

    }

    SimpleParallel(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, ai::EFinishMode finish_mode, ::bright::SharedPtr<ai::Task> main_task, ::bright::SharedPtr<ai::FlowNode> background_node ) 
            : ai::ComposeNode(id, node_name, decorators, services)
    {

        this->finishMode = finish_mode;
        this->mainTask = main_task;
        this->backgroundNode = background_node;
    }
    virtual ~SimpleParallel() {}

    bool deserialize(ByteBuf& _buf);

    ai::EFinishMode finishMode;
    ::bright::SharedPtr<ai::Task> mainTask;
    ::bright::SharedPtr<ai::FlowNode> backgroundNode;

    static constexpr int __ID__ = -1952582529;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class Task : public  ai::FlowNode 
{
    public:

    static bool deserializeTask(ByteBuf& _buf, ::bright::SharedPtr<Task>& _out);

    Task()
    { 

    }

    Task(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self ) 
            : ai::FlowNode(id, node_name, decorators, services)
    {

        this->ignoreRestartSelf = ignore_restart_self;
    }
    virtual ~Task() {}

    bool deserialize(ByteBuf& _buf);

    bool ignoreRestartSelf;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeWait : public  ai::Task 
{
    public:

    static bool deserializeUeWait(ByteBuf& _buf, ::bright::SharedPtr<UeWait>& _out);

    UeWait()
    { 

    }

    UeWait(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self, ::bright::float32 wait_time, ::bright::float32 random_deviation ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->waitTime = wait_time;
        this->randomDeviation = random_deviation;
    }
    virtual ~UeWait() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::float32 waitTime;
    ::bright::float32 randomDeviation;

    static constexpr int __ID__ = -512994101;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class UeWaitBlackboardTime : public  ai::Task 
{
    public:

    static bool deserializeUeWaitBlackboardTime(ByteBuf& _buf, ::bright::SharedPtr<UeWaitBlackboardTime>& _out);

    UeWaitBlackboardTime()
    { 

    }

    UeWaitBlackboardTime(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self, ::bright::String blackboard_key ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->blackboardKey = blackboard_key;
    }
    virtual ~UeWaitBlackboardTime() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String blackboardKey;

    static constexpr int __ID__ = 1215378271;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class MoveToTarget : public  ai::Task 
{
    public:

    static bool deserializeMoveToTarget(ByteBuf& _buf, ::bright::SharedPtr<MoveToTarget>& _out);

    MoveToTarget()
    { 

    }

    MoveToTarget(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self, ::bright::String target_actor_key, ::bright::float32 acceptable_radius ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->targetActorKey = target_actor_key;
        this->acceptableRadius = acceptable_radius;
    }
    virtual ~MoveToTarget() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String targetActorKey;
    ::bright::float32 acceptableRadius;

    static constexpr int __ID__ = 514987779;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class ChooseSkill : public  ai::Task 
{
    public:

    static bool deserializeChooseSkill(ByteBuf& _buf, ::bright::SharedPtr<ChooseSkill>& _out);

    ChooseSkill()
    { 

    }

    ChooseSkill(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self, ::bright::String target_actor_key, ::bright::String result_skill_id_key ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->targetActorKey = target_actor_key;
        this->resultSkillIdKey = result_skill_id_key;
    }
    virtual ~ChooseSkill() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String targetActorKey;
    ::bright::String resultSkillIdKey;

    static constexpr int __ID__ = -918812268;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class MoveToRandomLocation : public  ai::Task 
{
    public:

    static bool deserializeMoveToRandomLocation(ByteBuf& _buf, ::bright::SharedPtr<MoveToRandomLocation>& _out);

    MoveToRandomLocation()
    { 

    }

    MoveToRandomLocation(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self, ::bright::String origin_position_key, ::bright::float32 radius ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->originPositionKey = origin_position_key;
        this->radius = radius;
    }
    virtual ~MoveToRandomLocation() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String originPositionKey;
    ::bright::float32 radius;

    static constexpr int __ID__ = -2140042998;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class MoveToLocation : public  ai::Task 
{
    public:

    static bool deserializeMoveToLocation(ByteBuf& _buf, ::bright::SharedPtr<MoveToLocation>& _out);

    MoveToLocation()
    { 

    }

    MoveToLocation(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self, ::bright::Vector3 location, ::bright::float32 acceptable_radius ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->location = location;
        this->acceptableRadius = acceptable_radius;
    }
    virtual ~MoveToLocation() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector3 location;
    ::bright::float32 acceptableRadius;

    static constexpr int __ID__ = -969953113;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace ai {



class DebugPrint : public  ai::Task 
{
    public:

    static bool deserializeDebugPrint(ByteBuf& _buf, ::bright::SharedPtr<DebugPrint>& _out);

    DebugPrint()
    { 

    }

    DebugPrint(::bright::int32 id, ::bright::String node_name, ::bright::Vector<::bright::SharedPtr<ai::Decorator>> decorators, ::bright::Vector<::bright::SharedPtr<ai::Service>> services, bool ignore_restart_self, ::bright::String text ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->text = text;
    }
    virtual ~DebugPrint() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String text;

    static constexpr int __ID__ = 1357409728;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class Clazz : public  bright::CfgBean 
{
    public:

    static bool deserializeClazz(ByteBuf& _buf, ::bright::SharedPtr<Clazz>& _out);

    Clazz()
    { 

    }

    Clazz(::bright::String name, ::bright::String desc, ::bright::Vector<::bright::SharedPtr<blueprint::Clazz>> parents, ::bright::Vector<::bright::SharedPtr<blueprint::Method>> methods ) 
    {

        this->name = name;
        this->desc = desc;
        this->parents = parents;
        this->methods = methods;
    }
    virtual ~Clazz() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String name;
    ::bright::String desc;
    ::bright::Vector<::bright::SharedPtr<blueprint::Clazz>> parents;
    ::bright::Vector<::bright::SharedPtr<blueprint::Method>> methods;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class Method : public  bright::CfgBean 
{
    public:

    static bool deserializeMethod(ByteBuf& _buf, ::bright::SharedPtr<Method>& _out);

    Method()
    { 

    }

    Method(::bright::String name, ::bright::String desc, bool is_static, ::bright::String return_type, ::bright::Vector<::bright::SharedPtr<blueprint::ParamInfo>> parameters ) 
    {

        this->name = name;
        this->desc = desc;
        this->isStatic = is_static;
        this->returnType = return_type;
        this->parameters = parameters;
    }
    virtual ~Method() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String name;
    ::bright::String desc;
    bool isStatic;
    ::bright::String returnType;
    ::bright::Vector<::bright::SharedPtr<blueprint::ParamInfo>> parameters;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class ParamInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeParamInfo(ByteBuf& _buf, ::bright::SharedPtr<ParamInfo>& _out);

    ParamInfo()
    { 

    }

    ParamInfo(::bright::String name, ::bright::String type, bool is_ref ) 
    {

        this->name = name;
        this->type = type;
        this->isRef = is_ref;
    }
    virtual ~ParamInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String name;
    ::bright::String type;
    bool isRef;

    static constexpr int __ID__ = -729799392;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class AbstraceMethod : public  blueprint::Method 
{
    public:

    static bool deserializeAbstraceMethod(ByteBuf& _buf, ::bright::SharedPtr<AbstraceMethod>& _out);

    AbstraceMethod()
    { 

    }

    AbstraceMethod(::bright::String name, ::bright::String desc, bool is_static, ::bright::String return_type, ::bright::Vector<::bright::SharedPtr<blueprint::ParamInfo>> parameters ) 
            : blueprint::Method(name, desc, is_static, return_type, parameters)
    {

    }
    virtual ~AbstraceMethod() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = -392137809;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class ExternalMethod : public  blueprint::Method 
{
    public:

    static bool deserializeExternalMethod(ByteBuf& _buf, ::bright::SharedPtr<ExternalMethod>& _out);

    ExternalMethod()
    { 

    }

    ExternalMethod(::bright::String name, ::bright::String desc, bool is_static, ::bright::String return_type, ::bright::Vector<::bright::SharedPtr<blueprint::ParamInfo>> parameters ) 
            : blueprint::Method(name, desc, is_static, return_type, parameters)
    {

    }
    virtual ~ExternalMethod() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = 1739079015;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class BlueprintMethod : public  blueprint::Method 
{
    public:

    static bool deserializeBlueprintMethod(ByteBuf& _buf, ::bright::SharedPtr<BlueprintMethod>& _out);

    BlueprintMethod()
    { 

    }

    BlueprintMethod(::bright::String name, ::bright::String desc, bool is_static, ::bright::String return_type, ::bright::Vector<::bright::SharedPtr<blueprint::ParamInfo>> parameters ) 
            : blueprint::Method(name, desc, is_static, return_type, parameters)
    {

    }
    virtual ~BlueprintMethod() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = -696408103;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class Interface : public  blueprint::Clazz 
{
    public:

    static bool deserializeInterface(ByteBuf& _buf, ::bright::SharedPtr<Interface>& _out);

    Interface()
    { 

    }

    Interface(::bright::String name, ::bright::String desc, ::bright::Vector<::bright::SharedPtr<blueprint::Clazz>> parents, ::bright::Vector<::bright::SharedPtr<blueprint::Method>> methods ) 
            : blueprint::Clazz(name, desc, parents, methods)
    {

    }
    virtual ~Interface() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = 2114170750;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class NormalClazz : public  blueprint::Clazz 
{
    public:

    static bool deserializeNormalClazz(ByteBuf& _buf, ::bright::SharedPtr<NormalClazz>& _out);

    NormalClazz()
    { 

    }

    NormalClazz(::bright::String name, ::bright::String desc, ::bright::Vector<::bright::SharedPtr<blueprint::Clazz>> parents, ::bright::Vector<::bright::SharedPtr<blueprint::Method>> methods, bool is_abstract, ::bright::Vector<::bright::SharedPtr<blueprint::Field>> fields ) 
            : blueprint::Clazz(name, desc, parents, methods)
    {

        this->isAbstract = is_abstract;
        this->fields = fields;
    }
    virtual ~NormalClazz() {}

    bool deserialize(ByteBuf& _buf);

    bool isAbstract;
    ::bright::Vector<::bright::SharedPtr<blueprint::Field>> fields;

    static constexpr int __ID__ = -2073576778;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class Field : public  bright::CfgBean 
{
    public:

    static bool deserializeField(ByteBuf& _buf, ::bright::SharedPtr<Field>& _out);

    Field()
    { 

    }

    Field(::bright::String name, ::bright::String type, ::bright::String desc ) 
    {

        this->name = name;
        this->type = type;
        this->desc = desc;
    }
    virtual ~Field() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String name;
    ::bright::String type;
    ::bright::String desc;

    static constexpr int __ID__ = 1694158271;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class EnumClazz : public  blueprint::Clazz 
{
    public:

    static bool deserializeEnumClazz(ByteBuf& _buf, ::bright::SharedPtr<EnumClazz>& _out);

    EnumClazz()
    { 

    }

    EnumClazz(::bright::String name, ::bright::String desc, ::bright::Vector<::bright::SharedPtr<blueprint::Clazz>> parents, ::bright::Vector<::bright::SharedPtr<blueprint::Method>> methods, ::bright::Vector<::bright::SharedPtr<blueprint::EnumField>> enums ) 
            : blueprint::Clazz(name, desc, parents, methods)
    {

        this->enums = enums;
    }
    virtual ~EnumClazz() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<blueprint::EnumField>> enums;

    static constexpr int __ID__ = 1827364892;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace blueprint {



class EnumField : public  bright::CfgBean 
{
    public:

    static bool deserializeEnumField(ByteBuf& _buf, ::bright::SharedPtr<EnumField>& _out);

    EnumField()
    { 

    }

    EnumField(::bright::String name, ::bright::int32 value ) 
    {

        this->name = name;
        this->value = value;
    }
    virtual ~EnumField() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String name;
    ::bright::int32 value;

    static constexpr int __ID__ = 1830049470;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class DropInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeDropInfo(ByteBuf& _buf, ::bright::SharedPtr<DropInfo>& _out);

    DropInfo()
    { 

    }

    DropInfo(::bright::int32 id, ::bright::String desc, ::bright::Vector<::bright::SharedPtr<bonus::ShowItemInfo>> client_show_items, ::bright::SharedPtr<bonus::Bonus> bonus ) 
    {

        this->id = id;
        this->desc = desc;
        this->clientShowItems = client_show_items;
        this->bonus = bonus;
    }
    virtual ~DropInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String desc;
    ::bright::Vector<::bright::SharedPtr<bonus::ShowItemInfo>> clientShowItems;
    ::bright::SharedPtr<bonus::Bonus> bonus;

    static constexpr int __ID__ = -2014781108;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class ShowItemInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeShowItemInfo(ByteBuf& _buf, ::bright::SharedPtr<ShowItemInfo>& _out);

    ShowItemInfo()
    { 

    }

    ShowItemInfo(::bright::int32 item_id, ::bright::int64 item_num ) 
    {

        this->itemId = item_id;
        this->itemNum = item_num;
    }
    virtual ~ShowItemInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;
    ::bright::int64 itemNum;

    static constexpr int __ID__ = -1496363507;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class Bonus : public  bright::CfgBean 
{
    public:

    static bool deserializeBonus(ByteBuf& _buf, ::bright::SharedPtr<Bonus>& _out);

    Bonus()
    { 

    }

    virtual ~Bonus() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class OneItem : public  bonus::Bonus 
{
    public:

    static bool deserializeOneItem(ByteBuf& _buf, ::bright::SharedPtr<OneItem>& _out);

    OneItem()
    { 

    }

    OneItem(::bright::int32 item_id ) 
            : bonus::Bonus()
    {

        this->itemId = item_id;
    }
    virtual ~OneItem() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;

    static constexpr int __ID__ = -1649658966;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class OneItems : public  bonus::Bonus 
{
    public:

    static bool deserializeOneItems(ByteBuf& _buf, ::bright::SharedPtr<OneItems>& _out);

    OneItems()
    { 

    }

    OneItems(::bright::Vector<::bright::int32> items ) 
            : bonus::Bonus()
    {

        this->items = items;
    }
    virtual ~OneItems() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::int32> items;

    static constexpr int __ID__ = 400179721;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class Item : public  bonus::Bonus 
{
    public:

    static bool deserializeItem(ByteBuf& _buf, ::bright::SharedPtr<Item>& _out);

    Item()
    { 

    }

    Item(::bright::int32 item_id, ::bright::int32 amount ) 
            : bonus::Bonus()
    {

        this->itemId = item_id;
        this->amount = amount;
    }
    virtual ~Item() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;
    ::bright::int32 amount;

    static constexpr int __ID__ = 1689011106;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class Items : public  bonus::Bonus 
{
    public:

    static bool deserializeItems(ByteBuf& _buf, ::bright::SharedPtr<Items>& _out);

    Items()
    { 

    }

    Items(::bright::Vector<::bright::SharedPtr<bonus::Item>> item_list ) 
            : bonus::Bonus()
    {

        this->itemList = item_list;
    }
    virtual ~Items() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<bonus::Item>> itemList;

    static constexpr int __ID__ = 819736849;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class CoefficientItem : public  bonus::Bonus 
{
    public:

    static bool deserializeCoefficientItem(ByteBuf& _buf, ::bright::SharedPtr<CoefficientItem>& _out);

    CoefficientItem()
    { 

    }

    CoefficientItem(::bright::int32 bonus_id, ::bright::SharedPtr<bonus::Items> bonus_list ) 
            : bonus::Bonus()
    {

        this->bonusId = bonus_id;
        this->bonusList = bonus_list;
    }
    virtual ~CoefficientItem() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 bonusId;
    ::bright::SharedPtr<bonus::Items> bonusList;

    static constexpr int __ID__ = -229470727;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class WeightItems : public  bonus::Bonus 
{
    public:

    static bool deserializeWeightItems(ByteBuf& _buf, ::bright::SharedPtr<WeightItems>& _out);

    WeightItems()
    { 

    }

    WeightItems(::bright::Vector<::bright::SharedPtr<bonus::WeightItemInfo>> item_list ) 
            : bonus::Bonus()
    {

        this->itemList = item_list;
    }
    virtual ~WeightItems() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<bonus::WeightItemInfo>> itemList;

    static constexpr int __ID__ = -356202311;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class WeightItemInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeWeightItemInfo(ByteBuf& _buf, ::bright::SharedPtr<WeightItemInfo>& _out);

    WeightItemInfo()
    { 

    }

    WeightItemInfo(::bright::int32 item_id, ::bright::int32 num, ::bright::int32 weight ) 
    {

        this->itemId = item_id;
        this->num = num;
        this->weight = weight;
    }
    virtual ~WeightItemInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;
    ::bright::int32 num;
    ::bright::int32 weight;

    static constexpr int __ID__ = 1239999176;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class ProbabilityItems : public  bonus::Bonus 
{
    public:

    static bool deserializeProbabilityItems(ByteBuf& _buf, ::bright::SharedPtr<ProbabilityItems>& _out);

    ProbabilityItems()
    { 

    }

    ProbabilityItems(::bright::Vector<::bright::SharedPtr<bonus::ProbabilityItemInfo>> item_list ) 
            : bonus::Bonus()
    {

        this->itemList = item_list;
    }
    virtual ~ProbabilityItems() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<bonus::ProbabilityItemInfo>> itemList;

    static constexpr int __ID__ = 366387866;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class ProbabilityItemInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeProbabilityItemInfo(ByteBuf& _buf, ::bright::SharedPtr<ProbabilityItemInfo>& _out);

    ProbabilityItemInfo()
    { 

    }

    ProbabilityItemInfo(::bright::int32 item_id, ::bright::int32 num, ::bright::float32 probability ) 
    {

        this->itemId = item_id;
        this->num = num;
        this->probability = probability;
    }
    virtual ~ProbabilityItemInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;
    ::bright::int32 num;
    ::bright::float32 probability;

    static constexpr int __ID__ = 1547874631;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class MultiBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeMultiBonus(ByteBuf& _buf, ::bright::SharedPtr<MultiBonus>& _out);

    MultiBonus()
    { 

    }

    MultiBonus(::bright::Vector<::bright::SharedPtr<bonus::Bonus>> bonuses ) 
            : bonus::Bonus()
    {

        this->bonuses = bonuses;
    }
    virtual ~MultiBonus() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<bonus::Bonus>> bonuses;

    static constexpr int __ID__ = 1421907893;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class ProbabilityBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeProbabilityBonus(ByteBuf& _buf, ::bright::SharedPtr<ProbabilityBonus>& _out);

    ProbabilityBonus()
    { 

    }

    ProbabilityBonus(::bright::Vector<::bright::SharedPtr<bonus::ProbabilityBonusInfo>> bonuses ) 
            : bonus::Bonus()
    {

        this->bonuses = bonuses;
    }
    virtual ~ProbabilityBonus() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<bonus::ProbabilityBonusInfo>> bonuses;

    static constexpr int __ID__ = 359783161;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class ProbabilityBonusInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeProbabilityBonusInfo(ByteBuf& _buf, ::bright::SharedPtr<ProbabilityBonusInfo>& _out);

    ProbabilityBonusInfo()
    { 

    }

    ProbabilityBonusInfo(::bright::SharedPtr<bonus::Bonus> bonus, ::bright::float32 probability ) 
    {

        this->bonus = bonus;
        this->probability = probability;
    }
    virtual ~ProbabilityBonusInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<bonus::Bonus> bonus;
    ::bright::float32 probability;

    static constexpr int __ID__ = 46960455;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class WeightBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeWeightBonus(ByteBuf& _buf, ::bright::SharedPtr<WeightBonus>& _out);

    WeightBonus()
    { 

    }

    WeightBonus(::bright::Vector<::bright::SharedPtr<bonus::WeightBonusInfo>> bonuses ) 
            : bonus::Bonus()
    {

        this->bonuses = bonuses;
    }
    virtual ~WeightBonus() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<bonus::WeightBonusInfo>> bonuses;

    static constexpr int __ID__ = -362807016;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class WeightBonusInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeWeightBonusInfo(ByteBuf& _buf, ::bright::SharedPtr<WeightBonusInfo>& _out);

    WeightBonusInfo()
    { 

    }

    WeightBonusInfo(::bright::SharedPtr<bonus::Bonus> bonus, ::bright::int32 weight ) 
    {

        this->bonus = bonus;
        this->weight = weight;
    }
    virtual ~WeightBonusInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<bonus::Bonus> bonus;
    ::bright::int32 weight;

    static constexpr int __ID__ = -907244058;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace bonus {



class DropBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeDropBonus(ByteBuf& _buf, ::bright::SharedPtr<DropBonus>& _out);

    DropBonus()
    { 

    }

    DropBonus(::bright::int32 id ) 
            : bonus::Bonus()
    {

        this->id = id;
    }
    virtual ~DropBonus() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::SharedPtr<bonus::DropInfo> id_Ref;

    static constexpr int __ID__ = 1959868225;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace common {



class GlobalConfig : public  bright::CfgBean 
{
    public:

    static bool deserializeGlobalConfig(ByteBuf& _buf, ::bright::SharedPtr<GlobalConfig>& _out);

    GlobalConfig()
    { 

    }

    GlobalConfig(::bright::int32 bag_capacity, ::bright::int32 bag_capacity_special, ::bright::int32 bag_temp_expendable_capacity, ::bright::int32 bag_temp_tool_capacity, ::bright::int32 bag_init_capacity, ::bright::int32 quick_bag_capacity, ::bright::int32 cloth_bag_capacity, ::bright::int32 cloth_bag_init_capacity, ::bright::int32 cloth_bag_capacity_special, ::bright::SharedPtr<::bright::int32> bag_init_items_drop_id, ::bright::int32 mail_box_capacity, ::bright::float32 damage_param_c, ::bright::float32 damage_param_e, ::bright::float32 damage_param_f, ::bright::float32 damage_param_d, ::bright::float32 role_speed, ::bright::float32 monster_speed, ::bright::int32 init_energy, ::bright::int32 init_viality, ::bright::int32 max_viality, ::bright::int32 per_viality_recovery_time ) 
    {

        this->bagCapacity = bag_capacity;
        this->bagCapacitySpecial = bag_capacity_special;
        this->bagTempExpendableCapacity = bag_temp_expendable_capacity;
        this->bagTempToolCapacity = bag_temp_tool_capacity;
        this->bagInitCapacity = bag_init_capacity;
        this->quickBagCapacity = quick_bag_capacity;
        this->clothBagCapacity = cloth_bag_capacity;
        this->clothBagInitCapacity = cloth_bag_init_capacity;
        this->clothBagCapacitySpecial = cloth_bag_capacity_special;
        this->bagInitItemsDropId = bag_init_items_drop_id;
        this->mailBoxCapacity = mail_box_capacity;
        this->damageParamC = damage_param_c;
        this->damageParamE = damage_param_e;
        this->damageParamF = damage_param_f;
        this->damageParamD = damage_param_d;
        this->roleSpeed = role_speed;
        this->monsterSpeed = monster_speed;
        this->initEnergy = init_energy;
        this->initViality = init_viality;
        this->maxViality = max_viality;
        this->perVialityRecoveryTime = per_viality_recovery_time;
    }
    virtual ~GlobalConfig() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 背包容量
     */
    ::bright::int32 bagCapacity;
    ::bright::int32 bagCapacitySpecial;
    ::bright::int32 bagTempExpendableCapacity;
    ::bright::int32 bagTempToolCapacity;
    ::bright::int32 bagInitCapacity;
    ::bright::int32 quickBagCapacity;
    ::bright::int32 clothBagCapacity;
    ::bright::int32 clothBagInitCapacity;
    ::bright::int32 clothBagCapacitySpecial;
    ::bright::SharedPtr<::bright::int32> bagInitItemsDropId;
    ::bright::SharedPtr<bonus::DropInfo> bagInitItemsDropId_Ref;
    ::bright::int32 mailBoxCapacity;
    ::bright::float32 damageParamC;
    ::bright::float32 damageParamE;
    ::bright::float32 damageParamF;
    ::bright::float32 damageParamD;
    ::bright::float32 roleSpeed;
    ::bright::float32 monsterSpeed;
    ::bright::int32 initEnergy;
    ::bright::int32 initViality;
    ::bright::int32 maxViality;
    ::bright::int32 perVialityRecoveryTime;

    static constexpr int __ID__ = -848234488;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace error {



class ErrorInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeErrorInfo(ByteBuf& _buf, ::bright::SharedPtr<ErrorInfo>& _out);

    ErrorInfo()
    { 

    }

    ErrorInfo(::bright::String code, ::bright::String desc, ::bright::SharedPtr<error::ErrorStyle> style ) 
    {

        this->code = code;
        this->desc = desc;
        this->style = style;
    }
    virtual ~ErrorInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String code;
    ::bright::String desc;
    ::bright::SharedPtr<error::ErrorStyle> style;

    static constexpr int __ID__ = 1389347408;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace error {



class ErrorStyle : public  bright::CfgBean 
{
    public:

    static bool deserializeErrorStyle(ByteBuf& _buf, ::bright::SharedPtr<ErrorStyle>& _out);

    ErrorStyle()
    { 

    }

    virtual ~ErrorStyle() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace error {



class ErrorStyleTip : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleTip(ByteBuf& _buf, ::bright::SharedPtr<ErrorStyleTip>& _out);

    ErrorStyleTip()
    { 

    }

    virtual ~ErrorStyleTip() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int __ID__ = 1915239884;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace error {



class ErrorStyleMsgbox : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleMsgbox(ByteBuf& _buf, ::bright::SharedPtr<ErrorStyleMsgbox>& _out);

    ErrorStyleMsgbox()
    { 

    }

    ErrorStyleMsgbox(::bright::String btn_name, error::EOperation operation ) 
            : error::ErrorStyle()
    {

        this->btnName = btn_name;
        this->operation = operation;
    }
    virtual ~ErrorStyleMsgbox() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String btnName;
    error::EOperation operation;

    static constexpr int __ID__ = -1920482343;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace error {



class ErrorStyleDlgOk : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleDlgOk(ByteBuf& _buf, ::bright::SharedPtr<ErrorStyleDlgOk>& _out);

    ErrorStyleDlgOk()
    { 

    }

    ErrorStyleDlgOk(::bright::String btn_name ) 
            : error::ErrorStyle()
    {

        this->btnName = btn_name;
    }
    virtual ~ErrorStyleDlgOk() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String btnName;

    static constexpr int __ID__ = -2010134516;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace error {



class ErrorStyleDlgOkCancel : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleDlgOkCancel(ByteBuf& _buf, ::bright::SharedPtr<ErrorStyleDlgOkCancel>& _out);

    ErrorStyleDlgOkCancel()
    { 

    }

    ErrorStyleDlgOkCancel(::bright::String btn1_name, ::bright::String btn2_name ) 
            : error::ErrorStyle()
    {

        this->btn1Name = btn1_name;
        this->btn2Name = btn2_name;
    }
    virtual ~ErrorStyleDlgOkCancel() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::String btn1Name;
    ::bright::String btn2Name;

    static constexpr int __ID__ = 971221414;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace error {



class CodeInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeCodeInfo(ByteBuf& _buf, ::bright::SharedPtr<CodeInfo>& _out);

    CodeInfo()
    { 

    }

    CodeInfo(error::EErrorCode code, ::bright::String key ) 
    {

        this->code = code;
        this->key = key;
    }
    virtual ~CodeInfo() {}

    bool deserialize(ByteBuf& _buf);

    error::EErrorCode code;
    ::bright::String key;

    static constexpr int __ID__ = -1942481535;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



/**
 * 道具
 */
class Item : public  bright::CfgBean 
{
    public:

    static bool deserializeItem(ByteBuf& _buf, ::bright::SharedPtr<Item>& _out);

    Item()
    { 

    }

    Item(::bright::int32 id, ::bright::String name, item::EMajorType major_type, item::EMinorType minor_type, ::bright::int32 max_pile_num, item::EItemQuality quality, ::bright::String icon, ::bright::String icon_backgroud, ::bright::String icon_mask, ::bright::String desc, ::bright::int32 show_order, ::bright::String quantifier, bool show_in_bag, ::bright::int32 min_show_level, bool batch_usable, ::bright::float32 progress_time_when_use, bool show_hint_when_use, bool droppable, ::bright::SharedPtr<::bright::int32> price, item::EUseType use_type, ::bright::SharedPtr<::bright::int32> level_up_id ) 
    {

        this->id = id;
        this->name = name;
        this->majorType = major_type;
        this->minorType = minor_type;
        this->maxPileNum = max_pile_num;
        this->quality = quality;
        this->icon = icon;
        this->iconBackgroud = icon_backgroud;
        this->iconMask = icon_mask;
        this->desc = desc;
        this->showOrder = show_order;
        this->quantifier = quantifier;
        this->showInBag = show_in_bag;
        this->minShowLevel = min_show_level;
        this->batchUsable = batch_usable;
        this->progressTimeWhenUse = progress_time_when_use;
        this->showHintWhenUse = show_hint_when_use;
        this->droppable = droppable;
        this->price = price;
        this->useType = use_type;
        this->levelUpId = level_up_id;
    }
    virtual ~Item() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 道具id
     */
    ::bright::int32 id;
    ::bright::String name;
    item::EMajorType majorType;
    item::EMinorType minorType;
    ::bright::int32 maxPileNum;
    item::EItemQuality quality;
    ::bright::String icon;
    ::bright::String iconBackgroud;
    ::bright::String iconMask;
    ::bright::String desc;
    ::bright::int32 showOrder;
    ::bright::String quantifier;
    bool showInBag;
    ::bright::int32 minShowLevel;
    bool batchUsable;
    ::bright::float32 progressTimeWhenUse;
    bool showHintWhenUse;
    bool droppable;
    ::bright::SharedPtr<::bright::int32> price;
    item::EUseType useType;
    ::bright::SharedPtr<::bright::int32> levelUpId;

    static constexpr int __ID__ = 2107285806;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class ItemFunction : public  bright::CfgBean 
{
    public:

    static bool deserializeItemFunction(ByteBuf& _buf, ::bright::SharedPtr<ItemFunction>& _out);

    ItemFunction()
    { 

    }

    ItemFunction(item::EMinorType minor_type, item::EItemFunctionType func_type, ::bright::String method, bool close_bag_ui ) 
    {

        this->minorType = minor_type;
        this->funcType = func_type;
        this->method = method;
        this->closeBagUi = close_bag_ui;
    }
    virtual ~ItemFunction() {}

    bool deserialize(ByteBuf& _buf);

    item::EMinorType minorType;
    item::EItemFunctionType funcType;
    ::bright::String method;
    bool closeBagUi;

    static constexpr int __ID__ = 1205824294;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class ItemExtra : public  bright::CfgBean 
{
    public:

    static bool deserializeItemExtra(ByteBuf& _buf, ::bright::SharedPtr<ItemExtra>& _out);

    ItemExtra()
    { 

    }

    ItemExtra(::bright::int32 id ) 
    {

        this->id = id;
    }
    virtual ~ItemExtra() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class TreasureBox : public  item::ItemExtra 
{
    public:

    static bool deserializeTreasureBox(ByteBuf& _buf, ::bright::SharedPtr<TreasureBox>& _out);

    TreasureBox()
    { 

    }

    TreasureBox(::bright::int32 id, ::bright::SharedPtr<::bright::int32> key_item_id, ::bright::SharedPtr<condition::MinLevel> open_level, bool use_on_obtain, ::bright::Vector<::bright::int32> drop_ids, ::bright::Vector<::bright::SharedPtr<item::ChooseOneBonus>> choose_list ) 
            : item::ItemExtra(id)
    {

        this->keyItemId = key_item_id;
        this->openLevel = open_level;
        this->useOnObtain = use_on_obtain;
        this->dropIds = drop_ids;
        this->chooseList = choose_list;
    }
    virtual ~TreasureBox() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<::bright::int32> keyItemId;
    ::bright::SharedPtr<condition::MinLevel> openLevel;
    bool useOnObtain;
    ::bright::Vector<::bright::int32> dropIds;
    ::bright::Vector<::bright::SharedPtr<item::ChooseOneBonus>> chooseList;

    static constexpr int __ID__ = 1494222369;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class Condition : public  bright::CfgBean 
{
    public:

    static bool deserializeCondition(ByteBuf& _buf, ::bright::SharedPtr<Condition>& _out);

    Condition()
    { 

    }

    virtual ~Condition() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class TimeRange : public  condition::Condition 
{
    public:

    static bool deserializeTimeRange(ByteBuf& _buf, ::bright::SharedPtr<TimeRange>& _out);

    TimeRange()
    { 

    }

    TimeRange(::bright::SharedPtr<common::DateTimeRange> date_time_range ) 
            : condition::Condition()
    {

        this->dateTimeRange = date_time_range;
    }
    virtual ~TimeRange() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<common::DateTimeRange> dateTimeRange;

    static constexpr int __ID__ = 1069033789;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace common {



class DateTimeRange : public  bright::CfgBean 
{
    public:

    static bool deserializeDateTimeRange(ByteBuf& _buf, ::bright::SharedPtr<DateTimeRange>& _out);

    DateTimeRange()
    { 

    }

    DateTimeRange(::bright::SharedPtr<::bright::datetime> start_time, ::bright::SharedPtr<::bright::datetime> end_time ) 
    {

        this->startTime = start_time;
        this->endTime = end_time;
    }
    virtual ~DateTimeRange() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<::bright::datetime> startTime;
    ::bright::SharedPtr<::bright::datetime> endTime;

    static constexpr int __ID__ = 1642200959;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class RoleCondition : public  condition::Condition 
{
    public:

    static bool deserializeRoleCondition(ByteBuf& _buf, ::bright::SharedPtr<RoleCondition>& _out);

    RoleCondition()
    { 

    }

    virtual ~RoleCondition() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class MultiRoleCondition : public  condition::RoleCondition 
{
    public:

    static bool deserializeMultiRoleCondition(ByteBuf& _buf, ::bright::SharedPtr<MultiRoleCondition>& _out);

    MultiRoleCondition()
    { 

    }

    MultiRoleCondition(::bright::Vector<::bright::SharedPtr<condition::RoleCondition>> conditions ) 
            : condition::RoleCondition()
    {

        this->conditions = conditions;
    }
    virtual ~MultiRoleCondition() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<condition::RoleCondition>> conditions;

    static constexpr int __ID__ = 934079583;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class BoolRoleCondition : public  condition::RoleCondition 
{
    public:

    static bool deserializeBoolRoleCondition(ByteBuf& _buf, ::bright::SharedPtr<BoolRoleCondition>& _out);

    BoolRoleCondition()
    { 

    }

    virtual ~BoolRoleCondition() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class GenderLimit : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeGenderLimit(ByteBuf& _buf, ::bright::SharedPtr<GenderLimit>& _out);

    GenderLimit()
    { 

    }

    GenderLimit(role::EGenderType gender ) 
            : condition::BoolRoleCondition()
    {

        this->gender = gender;
    }
    virtual ~GenderLimit() {}

    bool deserialize(ByteBuf& _buf);

    role::EGenderType gender;

    static constexpr int __ID__ = 103675143;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class MinLevel : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeMinLevel(ByteBuf& _buf, ::bright::SharedPtr<MinLevel>& _out);

    MinLevel()
    { 

    }

    MinLevel(::bright::int32 level ) 
            : condition::BoolRoleCondition()
    {

        this->level = level;
    }
    virtual ~MinLevel() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 level;

    static constexpr int __ID__ = -1075273755;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class MaxLevel : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeMaxLevel(ByteBuf& _buf, ::bright::SharedPtr<MaxLevel>& _out);

    MaxLevel()
    { 

    }

    MaxLevel(::bright::int32 level ) 
            : condition::BoolRoleCondition()
    {

        this->level = level;
    }
    virtual ~MaxLevel() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 level;

    static constexpr int __ID__ = 700922899;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class MinMaxLevel : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeMinMaxLevel(ByteBuf& _buf, ::bright::SharedPtr<MinMaxLevel>& _out);

    MinMaxLevel()
    { 

    }

    MinMaxLevel(::bright::int32 min, ::bright::int32 max ) 
            : condition::BoolRoleCondition()
    {

        this->min = min;
        this->max = max;
    }
    virtual ~MinMaxLevel() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 min;
    ::bright::int32 max;

    static constexpr int __ID__ = 907499647;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class ClothesPropertyScoreGreaterThan : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeClothesPropertyScoreGreaterThan(ByteBuf& _buf, ::bright::SharedPtr<ClothesPropertyScoreGreaterThan>& _out);

    ClothesPropertyScoreGreaterThan()
    { 

    }

    ClothesPropertyScoreGreaterThan(item::EClothesPropertyType prop, ::bright::int32 value ) 
            : condition::BoolRoleCondition()
    {

        this->prop = prop;
        this->value = value;
    }
    virtual ~ClothesPropertyScoreGreaterThan() {}

    bool deserialize(ByteBuf& _buf);

    item::EClothesPropertyType prop;
    ::bright::int32 value;

    static constexpr int __ID__ = 696630835;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace condition {



class ContainsItem : public  condition::RoleCondition 
{
    public:

    static bool deserializeContainsItem(ByteBuf& _buf, ::bright::SharedPtr<ContainsItem>& _out);

    ContainsItem()
    { 

    }

    ContainsItem(::bright::int32 item_id, ::bright::int32 num, bool reverse ) 
            : condition::RoleCondition()
    {

        this->itemId = item_id;
        this->num = num;
        this->reverse = reverse;
    }
    virtual ~ContainsItem() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;
    ::bright::int32 num;
    bool reverse;

    static constexpr int __ID__ = 1961145317;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class ChooseOneBonus : public  bright::CfgBean 
{
    public:

    static bool deserializeChooseOneBonus(ByteBuf& _buf, ::bright::SharedPtr<ChooseOneBonus>& _out);

    ChooseOneBonus()
    { 

    }

    ChooseOneBonus(::bright::int32 drop_id, bool is_unique ) 
    {

        this->dropId = drop_id;
        this->isUnique = is_unique;
    }
    virtual ~ChooseOneBonus() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 dropId;
    ::bright::SharedPtr<bonus::DropInfo> dropId_Ref;
    bool isUnique;

    static constexpr int __ID__ = 228058347;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class InteractionItem : public  item::ItemExtra 
{
    public:

    static bool deserializeInteractionItem(ByteBuf& _buf, ::bright::SharedPtr<InteractionItem>& _out);

    InteractionItem()
    { 

    }

    InteractionItem(::bright::int32 id, ::bright::SharedPtr<::bright::int32> attack_num, ::bright::String holding_static_mesh, ::bright::String holding_static_mesh_mat ) 
            : item::ItemExtra(id)
    {

        this->attackNum = attack_num;
        this->holdingStaticMesh = holding_static_mesh;
        this->holdingStaticMeshMat = holding_static_mesh_mat;
    }
    virtual ~InteractionItem() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<::bright::int32> attackNum;
    ::bright::String holdingStaticMesh;
    ::bright::String holdingStaticMeshMat;

    static constexpr int __ID__ = 640937802;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class Clothes : public  item::ItemExtra 
{
    public:

    static bool deserializeClothes(ByteBuf& _buf, ::bright::SharedPtr<Clothes>& _out);

    Clothes()
    { 

    }

    Clothes(::bright::int32 id, ::bright::int32 attack, ::bright::int64 hp, ::bright::int32 energy_limit, ::bright::int32 energy_resume ) 
            : item::ItemExtra(id)
    {

        this->attack = attack;
        this->hp = hp;
        this->energyLimit = energy_limit;
        this->energyResume = energy_resume;
    }
    virtual ~Clothes() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 attack;
    ::bright::int64 hp;
    ::bright::int32 energyLimit;
    ::bright::int32 energyResume;

    static constexpr int __ID__ = 1659907149;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class DesignDrawing : public  item::ItemExtra 
{
    public:

    static bool deserializeDesignDrawing(ByteBuf& _buf, ::bright::SharedPtr<DesignDrawing>& _out);

    DesignDrawing()
    { 

    }

    DesignDrawing(::bright::int32 id, ::bright::Vector<::bright::int32> learn_component_id ) 
            : item::ItemExtra(id)
    {

        this->learnComponentId = learn_component_id;
    }
    virtual ~DesignDrawing() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::int32> learnComponentId;

    static constexpr int __ID__ = -1679179579;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace item {



class Dymmy : public  item::ItemExtra 
{
    public:

    static bool deserializeDymmy(ByteBuf& _buf, ::bright::SharedPtr<Dymmy>& _out);

    Dymmy()
    { 

    }

    Dymmy(::bright::int32 id, ::bright::SharedPtr<cost::Cost> cost ) 
            : item::ItemExtra(id)
    {

        this->cost = cost;
    }
    virtual ~Dymmy() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<cost::Cost> cost;

    static constexpr int __ID__ = 896889705;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace cost {



class Cost : public  bright::CfgBean 
{
    public:

    static bool deserializeCost(ByteBuf& _buf, ::bright::SharedPtr<Cost>& _out);

    Cost()
    { 

    }

    virtual ~Cost() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace cost {



class CostCurrency : public  cost::Cost 
{
    public:

    static bool deserializeCostCurrency(ByteBuf& _buf, ::bright::SharedPtr<CostCurrency>& _out);

    CostCurrency()
    { 

    }

    CostCurrency(item::ECurrencyType type, ::bright::int32 num ) 
            : cost::Cost()
    {

        this->type = type;
        this->num = num;
    }
    virtual ~CostCurrency() {}

    bool deserialize(ByteBuf& _buf);

    item::ECurrencyType type;
    ::bright::int32 num;

    static constexpr int __ID__ = 911838111;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace cost {



class CostCurrencies : public  cost::Cost 
{
    public:

    static bool deserializeCostCurrencies(ByteBuf& _buf, ::bright::SharedPtr<CostCurrencies>& _out);

    CostCurrencies()
    { 

    }

    CostCurrencies(::bright::Vector<::bright::SharedPtr<cost::CostCurrency>> currencies ) 
            : cost::Cost()
    {

        this->currencies = currencies;
    }
    virtual ~CostCurrencies() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<cost::CostCurrency>> currencies;

    static constexpr int __ID__ = 103084157;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace cost {



class CostOneItem : public  cost::Cost 
{
    public:

    static bool deserializeCostOneItem(ByteBuf& _buf, ::bright::SharedPtr<CostOneItem>& _out);

    CostOneItem()
    { 

    }

    CostOneItem(::bright::int32 item_id ) 
            : cost::Cost()
    {

        this->itemId = item_id;
    }
    virtual ~CostOneItem() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;

    static constexpr int __ID__ = -1033587381;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace cost {



class CostItem : public  cost::Cost 
{
    public:

    static bool deserializeCostItem(ByteBuf& _buf, ::bright::SharedPtr<CostItem>& _out);

    CostItem()
    { 

    }

    CostItem(::bright::int32 item_id, ::bright::int32 amount ) 
            : cost::Cost()
    {

        this->itemId = item_id;
        this->amount = amount;
    }
    virtual ~CostItem() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 itemId;
    ::bright::SharedPtr<item::Item> itemId_Ref;
    ::bright::int32 amount;

    static constexpr int __ID__ = -1249440351;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace cost {



class CostItems : public  cost::Cost 
{
    public:

    static bool deserializeCostItems(ByteBuf& _buf, ::bright::SharedPtr<CostItems>& _out);

    CostItems()
    { 

    }

    CostItems(::bright::Vector<::bright::SharedPtr<cost::CostItem>> item_list ) 
            : cost::Cost()
    {

        this->itemList = item_list;
    }
    virtual ~CostItems() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::Vector<::bright::SharedPtr<cost::CostItem>> itemList;

    static constexpr int __ID__ = -77945102;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace l10n {



class L10NDemo : public  bright::CfgBean 
{
    public:

    static bool deserializeL10NDemo(ByteBuf& _buf, ::bright::SharedPtr<L10NDemo>& _out);

    L10NDemo()
    { 

    }

    L10NDemo(::bright::int32 id, ::bright::String text ) 
    {

        this->id = id;
        this->text = text;
    }
    virtual ~L10NDemo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String text;

    static constexpr int __ID__ = -331195887;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace l10n {



class PatchDemo : public  bright::CfgBean 
{
    public:

    static bool deserializePatchDemo(ByteBuf& _buf, ::bright::SharedPtr<PatchDemo>& _out);

    PatchDemo()
    { 

    }

    PatchDemo(::bright::int32 id, ::bright::int32 value ) 
    {

        this->id = id;
        this->value = value;
    }
    virtual ~PatchDemo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 value;

    static constexpr int __ID__ = -1707294656;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace mail {



class SystemMail : public  bright::CfgBean 
{
    public:

    static bool deserializeSystemMail(ByteBuf& _buf, ::bright::SharedPtr<SystemMail>& _out);

    SystemMail()
    { 

    }

    SystemMail(::bright::int32 id, ::bright::String title, ::bright::String sender, ::bright::String content, ::bright::Vector<::bright::int32> award ) 
    {

        this->id = id;
        this->title = title;
        this->sender = sender;
        this->content = content;
        this->award = award;
    }
    virtual ~SystemMail() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String title;
    ::bright::String sender;
    ::bright::String content;
    ::bright::Vector<::bright::int32> award;

    static constexpr int __ID__ = 1214073149;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace mail {



class GlobalMail : public  bright::CfgBean 
{
    public:

    static bool deserializeGlobalMail(ByteBuf& _buf, ::bright::SharedPtr<GlobalMail>& _out);

    GlobalMail()
    { 

    }

    GlobalMail(::bright::int32 id, ::bright::String title, ::bright::String sender, ::bright::String content, ::bright::Vector<::bright::int32> award, bool all_server, ::bright::Vector<::bright::int32> server_list, ::bright::String platform, ::bright::String channel, ::bright::SharedPtr<condition::MinMaxLevel> min_max_level, ::bright::SharedPtr<condition::TimeRange> register_time, ::bright::SharedPtr<condition::TimeRange> mail_time ) 
    {

        this->id = id;
        this->title = title;
        this->sender = sender;
        this->content = content;
        this->award = award;
        this->allServer = all_server;
        this->serverList = server_list;
        this->platform = platform;
        this->channel = channel;
        this->minMaxLevel = min_max_level;
        this->registerTime = register_time;
        this->mailTime = mail_time;
    }
    virtual ~GlobalMail() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String title;
    ::bright::String sender;
    ::bright::String content;
    ::bright::Vector<::bright::int32> award;
    bool allServer;
    ::bright::Vector<::bright::int32> serverList;
    ::bright::String platform;
    ::bright::String channel;
    ::bright::SharedPtr<condition::MinMaxLevel> minMaxLevel;
    ::bright::SharedPtr<condition::TimeRange> registerTime;
    ::bright::SharedPtr<condition::TimeRange> mailTime;

    static constexpr int __ID__ = -287571791;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace role {



class LevelExpAttr : public  bright::CfgBean 
{
    public:

    static bool deserializeLevelExpAttr(ByteBuf& _buf, ::bright::SharedPtr<LevelExpAttr>& _out);

    LevelExpAttr()
    { 

    }

    LevelExpAttr(::bright::int32 level, ::bright::int64 need_exp, ::bright::Vector<::bright::int32> clothes_attrs ) 
    {

        this->level = level;
        this->needExp = need_exp;
        this->clothesAttrs = clothes_attrs;
    }
    virtual ~LevelExpAttr() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 level;
    ::bright::int64 needExp;
    ::bright::Vector<::bright::int32> clothesAttrs;

    static constexpr int __ID__ = -1569837022;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace role {



class LevelBonus : public  bright::CfgBean 
{
    public:

    static bool deserializeLevelBonus(ByteBuf& _buf, ::bright::SharedPtr<LevelBonus>& _out);

    LevelBonus()
    { 

    }

    LevelBonus(::bright::int32 id, ::bright::Vector<::bright::SharedPtr<role::DistinctBonusInfos>> distinct_bonus_infos ) 
    {

        this->id = id;
        this->distinctBonusInfos = distinct_bonus_infos;
    }
    virtual ~LevelBonus() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::Vector<::bright::SharedPtr<role::DistinctBonusInfos>> distinctBonusInfos;

    static constexpr int __ID__ = -572269677;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace role {



class DistinctBonusInfos : public  bright::CfgBean 
{
    public:

    static bool deserializeDistinctBonusInfos(ByteBuf& _buf, ::bright::SharedPtr<DistinctBonusInfos>& _out);

    DistinctBonusInfos()
    { 

    }

    DistinctBonusInfos(::bright::int32 effective_level, ::bright::Vector<::bright::SharedPtr<role::BonusInfo>> bonus_info ) 
    {

        this->effectiveLevel = effective_level;
        this->bonusInfo = bonus_info;
    }
    virtual ~DistinctBonusInfos() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 effectiveLevel;
    ::bright::Vector<::bright::SharedPtr<role::BonusInfo>> bonusInfo;

    static constexpr int __ID__ = -854361766;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace role {



class BonusInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeBonusInfo(ByteBuf& _buf, ::bright::SharedPtr<BonusInfo>& _out);

    BonusInfo()
    { 

    }

    BonusInfo(item::ECurrencyType type, ::bright::float32 coefficient ) 
    {

        this->type = type;
        this->coefficient = coefficient;
    }
    virtual ~BonusInfo() {}

    bool deserialize(ByteBuf& _buf);

    item::ECurrencyType type;
    ::bright::float32 coefficient;

    static constexpr int __ID__ = -1354421803;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace tag {



class TestTag : public  bright::CfgBean 
{
    public:

    static bool deserializeTestTag(ByteBuf& _buf, ::bright::SharedPtr<TestTag>& _out);

    TestTag()
    { 

    }

    TestTag(::bright::int32 id, ::bright::String value ) 
    {

        this->id = id;
        this->value = value;
    }
    virtual ~TestTag() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String value;

    static constexpr int __ID__ = 1742933812;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoType2 : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoType2(ByteBuf& _buf, ::bright::SharedPtr<DemoType2>& _out);

    DemoType2()
    { 

    }

    DemoType2(::bright::int32 x4, bool x1, ::bright::byte x2, ::bright::int16 x3, ::bright::int64 x5, ::bright::float32 x6, ::bright::float64 x7, ::bright::int16 x8_0, ::bright::int32 x8, ::bright::int64 x9, ::bright::String x10, ::bright::SharedPtr<test::DemoType1> x12, test::DemoEnum x13, ::bright::SharedPtr<test::DemoDynamic> x14, ::bright::String s1, ::bright::Vector2 v2, ::bright::Vector3 v3, ::bright::Vector4 v4, ::bright::datetime t1, ::bright::Vector<::bright::int32> k1, ::bright::Vector<::bright::int32> k2, ::bright::HashSet<::bright::int32> k5, ::bright::HashMap<::bright::int32, ::bright::int32> k8, ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9, ::bright::Vector<::bright::SharedPtr<test::DemoDynamic>> k15 ) 
    {

        this->x4 = x4;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x5 = x5;
        this->x6 = x6;
        this->x7 = x7;
        this->x80 = x8_0;
        this->x8 = x8;
        this->x9 = x9;
        this->x10 = x10;
        this->x12 = x12;
        this->x13 = x13;
        this->x14 = x14;
        this->s1 = s1;
        this->v2 = v2;
        this->v3 = v3;
        this->v4 = v4;
        this->t1 = t1;
        this->k1 = k1;
        this->k2 = k2;
        this->k5 = k5;
        this->k8 = k8;
        this->k9 = k9;
        this->k15 = k15;
    }
    virtual ~DemoType2() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x4;
    bool x1;
    ::bright::byte x2;
    ::bright::int16 x3;
    ::bright::int64 x5;
    ::bright::float32 x6;
    ::bright::float64 x7;
    ::bright::int16 x80;
    ::bright::int32 x8;
    ::bright::int64 x9;
    ::bright::String x10;
    ::bright::SharedPtr<test::DemoType1> x12;
    test::DemoEnum x13;
    ::bright::SharedPtr<test::DemoDynamic> x14;
    ::bright::String s1;
    ::bright::Vector2 v2;
    ::bright::Vector3 v3;
    ::bright::Vector4 v4;
    ::bright::datetime t1;
    ::bright::Vector<::bright::int32> k1;
    ::bright::Vector<::bright::int32> k2;
    ::bright::HashSet<::bright::int32> k5;
    ::bright::HashMap<::bright::int32, ::bright::int32> k8;
    ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9;
    ::bright::Vector<::bright::SharedPtr<test::DemoDynamic>> k15;

    static constexpr int __ID__ = -367048295;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoType1 : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoType1(ByteBuf& _buf, ::bright::SharedPtr<DemoType1>& _out);

    DemoType1()
    { 

    }

    DemoType1(::bright::int32 x1 ) 
    {

        this->x1 = x1;
    }
    virtual ~DemoType1() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x1;

    static constexpr int __ID__ = -367048296;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoDynamic : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoDynamic(ByteBuf& _buf, ::bright::SharedPtr<DemoDynamic>& _out);

    DemoDynamic()
    { 

    }

    DemoDynamic(::bright::int32 x1 ) 
    {

        this->x1 = x1;
    }
    virtual ~DemoDynamic() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x1;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoD2 : public  test::DemoDynamic 
{
    public:

    static bool deserializeDemoD2(ByteBuf& _buf, ::bright::SharedPtr<DemoD2>& _out);

    DemoD2()
    { 

    }

    DemoD2(::bright::int32 x1, ::bright::int32 x2 ) 
            : test::DemoDynamic(x1)
    {

        this->x2 = x2;
    }
    virtual ~DemoD2() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x2;

    static constexpr int __ID__ = -2138341747;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoD3 : public  test::DemoDynamic 
{
    public:

    static bool deserializeDemoD3(ByteBuf& _buf, ::bright::SharedPtr<DemoD3>& _out);

    DemoD3()
    { 

    }

    DemoD3(::bright::int32 x1, ::bright::int32 x3 ) 
            : test::DemoDynamic(x1)
    {

        this->x3 = x3;
    }
    virtual ~DemoD3() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x3;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoE1 : public  test::DemoD3 
{
    public:

    static bool deserializeDemoE1(ByteBuf& _buf, ::bright::SharedPtr<DemoE1>& _out);

    DemoE1()
    { 

    }

    DemoE1(::bright::int32 x1, ::bright::int32 x3, ::bright::int32 x4 ) 
            : test::DemoD3(x1, x3)
    {

        this->x4 = x4;
    }
    virtual ~DemoE1() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x4;

    static constexpr int __ID__ = -2138341717;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {namespace login {



class RoleInfo : public  test::DemoD3 
{
    public:

    static bool deserializeRoleInfo(ByteBuf& _buf, ::bright::SharedPtr<RoleInfo>& _out);

    RoleInfo()
    { 

    }

    RoleInfo(::bright::int32 x1, ::bright::int32 x3, ::bright::int64 role_id ) 
            : test::DemoD3(x1, x3)
    {

        this->roleId = role_id;
    }
    virtual ~RoleInfo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int64 roleId;

    static constexpr int __ID__ = -989153243;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}}

namespace test {



class DemoD5 : public  test::DemoDynamic 
{
    public:

    static bool deserializeDemoD5(ByteBuf& _buf, ::bright::SharedPtr<DemoD5>& _out);

    DemoD5()
    { 

    }

    DemoD5(::bright::int32 x1, ::bright::SharedPtr<test::DateTimeRange> time ) 
            : test::DemoDynamic(x1)
    {

        this->time = time;
    }
    virtual ~DemoD5() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<test::DateTimeRange> time;

    static constexpr int __ID__ = -2138341744;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DateTimeRange : public  bright::CfgBean 
{
    public:

    static bool deserializeDateTimeRange(ByteBuf& _buf, ::bright::SharedPtr<DateTimeRange>& _out);

    DateTimeRange()
    { 

    }

    DateTimeRange(::bright::datetime start_time, ::bright::datetime end_time ) 
    {

        this->startTime = start_time;
        this->endTime = end_time;
    }
    virtual ~DateTimeRange() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::datetime startTime;
    ::bright::datetime endTime;

    static constexpr int __ID__ = 495315430;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoE2 : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoE2(ByteBuf& _buf, ::bright::SharedPtr<DemoE2>& _out);

    DemoE2()
    { 

    }

    DemoE2(::bright::SharedPtr<::bright::int32> y1, bool y2 ) 
    {

        this->y1 = y1;
        this->y2 = y2;
    }
    virtual ~DemoE2() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<::bright::int32> y1;
    bool y2;

    static constexpr int __ID__ = -2138341716;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoSingletonType : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoSingletonType(ByteBuf& _buf, ::bright::SharedPtr<DemoSingletonType>& _out);

    DemoSingletonType()
    { 

    }

    DemoSingletonType(::bright::int32 id, ::bright::String name, ::bright::SharedPtr<test::DemoDynamic> date ) 
    {

        this->id = id;
        this->name = name;
        this->date = date;
    }
    virtual ~DemoSingletonType() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String name;
    ::bright::SharedPtr<test::DemoDynamic> date;

    static constexpr int __ID__ = 539196998;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class NotIndexList : public  bright::CfgBean 
{
    public:

    static bool deserializeNotIndexList(ByteBuf& _buf, ::bright::SharedPtr<NotIndexList>& _out);

    NotIndexList()
    { 

    }

    NotIndexList(::bright::int32 x, ::bright::int32 y ) 
    {

        this->x = x;
        this->y = y;
    }
    virtual ~NotIndexList() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x;
    ::bright::int32 y;

    static constexpr int __ID__ = -50446599;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class MultiUnionIndexList : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiUnionIndexList(ByteBuf& _buf, ::bright::SharedPtr<MultiUnionIndexList>& _out);

    MultiUnionIndexList()
    { 

    }

    MultiUnionIndexList(::bright::int32 id1, ::bright::int64 id2, ::bright::String id3, ::bright::int32 num, ::bright::String desc ) 
    {

        this->id1 = id1;
        this->id2 = id2;
        this->id3 = id3;
        this->num = num;
        this->desc = desc;
    }
    virtual ~MultiUnionIndexList() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id1;
    ::bright::int64 id2;
    ::bright::String id3;
    ::bright::int32 num;
    ::bright::String desc;

    static constexpr int __ID__ = 1966847134;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class MultiIndexList : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiIndexList(ByteBuf& _buf, ::bright::SharedPtr<MultiIndexList>& _out);

    MultiIndexList()
    { 

    }

    MultiIndexList(::bright::int32 id1, ::bright::int64 id2, ::bright::String id3, ::bright::int32 num, ::bright::String desc ) 
    {

        this->id1 = id1;
        this->id2 = id2;
        this->id3 = id3;
        this->num = num;
        this->desc = desc;
    }
    virtual ~MultiIndexList() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id1;
    ::bright::int64 id2;
    ::bright::String id3;
    ::bright::int32 num;
    ::bright::String desc;

    static constexpr int __ID__ = 2016237651;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class MultiRowRecord : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowRecord(ByteBuf& _buf, ::bright::SharedPtr<MultiRowRecord>& _out);

    MultiRowRecord()
    { 

    }

    MultiRowRecord(::bright::int32 id, ::bright::String name, ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> one_rows, ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> multi_rows1, ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> multi_rows2, ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowType2>> multi_rows4, ::bright::Vector<::bright::SharedPtr<test::MultiRowType3>> multi_rows5, ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowType2>> multi_rows6, ::bright::HashMap<::bright::int32, ::bright::int32> multi_rows7 ) 
    {

        this->id = id;
        this->name = name;
        this->oneRows = one_rows;
        this->multiRows1 = multi_rows1;
        this->multiRows2 = multi_rows2;
        this->multiRows4 = multi_rows4;
        this->multiRows5 = multi_rows5;
        this->multiRows6 = multi_rows6;
        this->multiRows7 = multi_rows7;
    }
    virtual ~MultiRowRecord() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String name;
    ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> oneRows;
    ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> multiRows1;
    ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> multiRows2;
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowType2>> multiRows4;
    ::bright::Vector<::bright::SharedPtr<test::MultiRowType3>> multiRows5;
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowType2>> multiRows6;
    ::bright::HashMap<::bright::int32, ::bright::int32> multiRows7;

    static constexpr int __ID__ = -501249394;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class MultiRowType1 : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowType1(ByteBuf& _buf, ::bright::SharedPtr<MultiRowType1>& _out);

    MultiRowType1()
    { 

    }

    MultiRowType1(::bright::int32 id, ::bright::int32 x ) 
    {

        this->id = id;
        this->x = x;
    }
    virtual ~MultiRowType1() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 x;

    static constexpr int __ID__ = 540474970;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class MultiRowType2 : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowType2(ByteBuf& _buf, ::bright::SharedPtr<MultiRowType2>& _out);

    MultiRowType2()
    { 

    }

    MultiRowType2(::bright::int32 id, ::bright::int32 x, ::bright::float32 y ) 
    {

        this->id = id;
        this->x = x;
        this->y = y;
    }
    virtual ~MultiRowType2() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 x;
    ::bright::float32 y;

    static constexpr int __ID__ = 540474971;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class MultiRowType3 : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowType3(ByteBuf& _buf, ::bright::SharedPtr<MultiRowType3>& _out);

    MultiRowType3()
    { 

    }

    MultiRowType3(::bright::int32 id, ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> items ) 
    {

        this->id = id;
        this->items = items;
    }
    virtual ~MultiRowType3() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::Vector<::bright::SharedPtr<test::MultiRowType1>> items;

    static constexpr int __ID__ = 540474972;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestMultiColumn : public  bright::CfgBean 
{
    public:

    static bool deserializeTestMultiColumn(ByteBuf& _buf, ::bright::SharedPtr<TestMultiColumn>& _out);

    TestMultiColumn()
    { 

    }

    TestMultiColumn(::bright::int32 id, ::bright::SharedPtr<test::Foo> a, ::bright::SharedPtr<test::Foo> b, ::bright::SharedPtr<test::Foo> c ) 
    {

        this->id = id;
        this->a = a;
        this->b = b;
        this->c = c;
    }
    virtual ~TestMultiColumn() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::SharedPtr<test::Foo> a;
    ::bright::SharedPtr<test::Foo> b;
    ::bright::SharedPtr<test::Foo> c;

    static constexpr int __ID__ = -294473599;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class Foo : public  bright::CfgBean 
{
    public:

    static bool deserializeFoo(ByteBuf& _buf, ::bright::SharedPtr<Foo>& _out);

    Foo()
    { 

    }

    Foo(::bright::int32 y1, ::bright::int32 y2, ::bright::int32 y3 ) 
    {

        this->y1 = y1;
        this->y2 = y2;
        this->y3 = y3;
    }
    virtual ~Foo() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 y1;
    ::bright::int32 y2;
    ::bright::int32 y3;

    static constexpr int __ID__ = -1147950774;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class MultiRowTitle : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowTitle(ByteBuf& _buf, ::bright::SharedPtr<MultiRowTitle>& _out);

    MultiRowTitle()
    { 

    }

    MultiRowTitle(::bright::int32 id, ::bright::String name, ::bright::SharedPtr<test::H1> x1, ::bright::SharedPtr<test::H2> x2_0, ::bright::Vector<::bright::SharedPtr<test::H2>> x2, ::bright::Vector<::bright::SharedPtr<test::H2>> x3, ::bright::Vector<::bright::SharedPtr<test::H2>> x4 ) 
    {

        this->id = id;
        this->name = name;
        this->x1 = x1;
        this->x20 = x2_0;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
    }
    virtual ~MultiRowTitle() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String name;
    ::bright::SharedPtr<test::H1> x1;
    ::bright::SharedPtr<test::H2> x20;
    ::bright::Vector<::bright::SharedPtr<test::H2>> x2;
    ::bright::Vector<::bright::SharedPtr<test::H2>> x3;
    ::bright::Vector<::bright::SharedPtr<test::H2>> x4;

    static constexpr int __ID__ = 540002427;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class H1 : public  bright::CfgBean 
{
    public:

    static bool deserializeH1(ByteBuf& _buf, ::bright::SharedPtr<H1>& _out);

    H1()
    { 

    }

    H1(::bright::SharedPtr<test::H2> y2, ::bright::int32 y3 ) 
    {

        this->y2 = y2;
        this->y3 = y3;
    }
    virtual ~H1() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::SharedPtr<test::H2> y2;
    ::bright::int32 y3;

    static constexpr int __ID__ = -1422503995;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class H2 : public  bright::CfgBean 
{
    public:

    static bool deserializeH2(ByteBuf& _buf, ::bright::SharedPtr<H2>& _out);

    H2()
    { 

    }

    H2(::bright::int32 z2, ::bright::int32 z3 ) 
    {

        this->z2 = z2;
        this->z3 = z3;
    }
    virtual ~H2() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 z2;
    ::bright::int32 z3;

    static constexpr int __ID__ = -1422503994;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestNull : public  bright::CfgBean 
{
    public:

    static bool deserializeTestNull(ByteBuf& _buf, ::bright::SharedPtr<TestNull>& _out);

    TestNull()
    { 

    }

    TestNull(::bright::int32 id, ::bright::SharedPtr<::bright::int32> x1, ::bright::SharedPtr<test::DemoEnum> x2, ::bright::SharedPtr<test::DemoType1> x3, ::bright::SharedPtr<test::DemoDynamic> x4, ::bright::SharedPtr<::bright::String> s1, ::bright::SharedPtr<::bright::String> s2 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
        this->s1 = s1;
        this->s2 = s2;
    }
    virtual ~TestNull() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::SharedPtr<::bright::int32> x1;
    ::bright::SharedPtr<test::DemoEnum> x2;
    ::bright::SharedPtr<test::DemoType1> x3;
    ::bright::SharedPtr<test::DemoDynamic> x4;
    ::bright::SharedPtr<::bright::String> s1;
    ::bright::SharedPtr<::bright::String> s2;

    static constexpr int __ID__ = 339868469;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoPrimitiveTypesTable : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoPrimitiveTypesTable(ByteBuf& _buf, ::bright::SharedPtr<DemoPrimitiveTypesTable>& _out);

    DemoPrimitiveTypesTable()
    { 

    }

    DemoPrimitiveTypesTable(bool x1, ::bright::byte x2, ::bright::int16 x3, ::bright::int32 x4, ::bright::int64 x5, ::bright::float32 x6, ::bright::float64 x7, ::bright::String s1, ::bright::String s2, ::bright::Vector2 v2, ::bright::Vector3 v3, ::bright::Vector4 v4, ::bright::datetime t1 ) 
    {

        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
        this->x5 = x5;
        this->x6 = x6;
        this->x7 = x7;
        this->s1 = s1;
        this->s2 = s2;
        this->v2 = v2;
        this->v3 = v3;
        this->v4 = v4;
        this->t1 = t1;
    }
    virtual ~DemoPrimitiveTypesTable() {}

    bool deserialize(ByteBuf& _buf);

    bool x1;
    ::bright::byte x2;
    ::bright::int16 x3;
    ::bright::int32 x4;
    ::bright::int64 x5;
    ::bright::float32 x6;
    ::bright::float64 x7;
    ::bright::String s1;
    ::bright::String s2;
    ::bright::Vector2 v2;
    ::bright::Vector3 v3;
    ::bright::Vector4 v4;
    ::bright::datetime t1;

    static constexpr int __ID__ = -370934083;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestString : public  bright::CfgBean 
{
    public:

    static bool deserializeTestString(ByteBuf& _buf, ::bright::SharedPtr<TestString>& _out);

    TestString()
    { 

    }

    TestString(::bright::int32 id, ::bright::String s1, ::bright::SharedPtr<test::CompactString> cs1, ::bright::SharedPtr<test::CompactString> cs2 ) 
    {

        this->id = id;
        this->s1 = s1;
        this->cs1 = cs1;
        this->cs2 = cs2;
    }
    virtual ~TestString() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String s1;
    ::bright::SharedPtr<test::CompactString> cs1;
    ::bright::SharedPtr<test::CompactString> cs2;

    static constexpr int __ID__ = 338485823;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class CompactString : public  bright::CfgBean 
{
    public:

    static bool deserializeCompactString(ByteBuf& _buf, ::bright::SharedPtr<CompactString>& _out);

    CompactString()
    { 

    }

    CompactString(::bright::int32 id, ::bright::String s2, ::bright::String s3 ) 
    {

        this->id = id;
        this->s2 = s2;
        this->s3 = s3;
    }
    virtual ~CompactString() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String s2;
    ::bright::String s3;

    static constexpr int __ID__ = 1968089240;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DemoGroup : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoGroup(ByteBuf& _buf, ::bright::SharedPtr<DemoGroup>& _out);

    DemoGroup()
    { 

    }

    DemoGroup(::bright::int32 id, ::bright::int32 x1, ::bright::int32 x2, ::bright::int32 x3, ::bright::int32 x4, ::bright::SharedPtr<test::InnerGroup> x5 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
        this->x5 = x5;
    }
    virtual ~DemoGroup() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 x1;
    ::bright::SharedPtr<test::DemoGroup> x1_Ref;
    ::bright::int32 x2;
    ::bright::SharedPtr<test::DemoGroup> x2_Ref;
    ::bright::int32 x3;
    ::bright::SharedPtr<test::DemoGroup> x3_Ref;
    ::bright::int32 x4;
    ::bright::SharedPtr<test::InnerGroup> x5;

    static constexpr int __ID__ = -379263008;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class InnerGroup : public  bright::CfgBean 
{
    public:

    static bool deserializeInnerGroup(ByteBuf& _buf, ::bright::SharedPtr<InnerGroup>& _out);

    InnerGroup()
    { 

    }

    InnerGroup(::bright::int32 y1, ::bright::int32 y2, ::bright::int32 y3, ::bright::int32 y4 ) 
    {

        this->y1 = y1;
        this->y2 = y2;
        this->y3 = y3;
        this->y4 = y4;
    }
    virtual ~InnerGroup() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 y1;
    ::bright::int32 y2;
    ::bright::int32 y3;
    ::bright::int32 y4;

    static constexpr int __ID__ = -587873083;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestGlobal : public  bright::CfgBean 
{
    public:

    static bool deserializeTestGlobal(ByteBuf& _buf, ::bright::SharedPtr<TestGlobal>& _out);

    TestGlobal()
    { 

    }

    TestGlobal(::bright::int32 unlock_equip, ::bright::int32 unlock_hero ) 
    {

        this->unlockEquip = unlock_equip;
        this->unlockHero = unlock_hero;
    }
    virtual ~TestGlobal() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 unlockEquip;
    ::bright::int32 unlockHero;

    static constexpr int __ID__ = -12548655;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestBeRef : public  bright::CfgBean 
{
    public:

    static bool deserializeTestBeRef(ByteBuf& _buf, ::bright::SharedPtr<TestBeRef>& _out);

    TestBeRef()
    { 

    }

    TestBeRef(::bright::int32 id, ::bright::int32 count ) 
    {

        this->id = id;
        this->count = count;
    }
    virtual ~TestBeRef() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 count;

    static constexpr int __ID__ = 1934403938;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestRef : public  bright::CfgBean 
{
    public:

    static bool deserializeTestRef(ByteBuf& _buf, ::bright::SharedPtr<TestRef>& _out);

    TestRef()
    { 

    }

    TestRef(::bright::int32 id, ::bright::int32 x1, ::bright::int32 x1_2, ::bright::int32 x2, ::bright::int32 x3, ::bright::Vector<::bright::int32> a1, ::bright::Vector<::bright::int32> a2, ::bright::Vector<::bright::int32> b1, ::bright::Vector<::bright::int32> b2, ::bright::HashSet<::bright::int32> c1, ::bright::HashSet<::bright::int32> c2, ::bright::HashMap<::bright::int32, ::bright::int32> d1, ::bright::HashMap<::bright::int32, ::bright::int32> d2, ::bright::int32 e1, ::bright::int64 e2, ::bright::String e3, ::bright::int32 f1, ::bright::int64 f2, ::bright::String f3 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x12 = x1_2;
        this->x2 = x2;
        this->x3 = x3;
        this->a1 = a1;
        this->a2 = a2;
        this->b1 = b1;
        this->b2 = b2;
        this->c1 = c1;
        this->c2 = c2;
        this->d1 = d1;
        this->d2 = d2;
        this->e1 = e1;
        this->e2 = e2;
        this->e3 = e3;
        this->f1 = f1;
        this->f2 = f2;
        this->f3 = f3;
    }
    virtual ~TestRef() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 x1;
    ::bright::SharedPtr<test::TestBeRef> x1_Ref;
    ::bright::int32 x12;
    ::bright::int32 x2;
    ::bright::int32 x3;
    ::bright::Vector<::bright::int32> a1;
    ::bright::Vector<::bright::int32> a2;
    ::bright::Vector<::bright::int32> b1;
    ::bright::Vector<::bright::int32> b2;
    ::bright::HashSet<::bright::int32> c1;
    ::bright::HashSet<::bright::int32> c2;
    ::bright::HashMap<::bright::int32, ::bright::int32> d1;
    ::bright::HashMap<::bright::int32, ::bright::int32> d2;
    ::bright::int32 e1;
    ::bright::int64 e2;
    ::bright::String e3;
    ::bright::int32 f1;
    ::bright::int64 f2;
    ::bright::String f3;

    static constexpr int __ID__ = -543222491;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestSize : public  bright::CfgBean 
{
    public:

    static bool deserializeTestSize(ByteBuf& _buf, ::bright::SharedPtr<TestSize>& _out);

    TestSize()
    { 

    }

    TestSize(::bright::int32 id, ::bright::Vector<::bright::int32> x1, ::bright::Vector<::bright::int32> x2, ::bright::HashSet<::bright::int32> x3, ::bright::HashMap<::bright::int32, ::bright::int32> x4 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
    }
    virtual ~TestSize() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::Vector<::bright::int32> x1;
    ::bright::Vector<::bright::int32> x2;
    ::bright::HashSet<::bright::int32> x3;
    ::bright::HashMap<::bright::int32, ::bright::int32> x4;

    static constexpr int __ID__ = 340006319;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestSet : public  bright::CfgBean 
{
    public:

    static bool deserializeTestSet(ByteBuf& _buf, ::bright::SharedPtr<TestSet>& _out);

    TestSet()
    { 

    }

    TestSet(::bright::int32 id, ::bright::String x0, ::bright::Vector<::bright::int32> x1, ::bright::Vector<::bright::int64> x2, ::bright::Vector<::bright::String> x3, ::bright::Vector<test::DemoEnum> x4 ) 
    {

        this->id = id;
        this->x0 = x0;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
    }
    virtual ~TestSet() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String x0;
    ::bright::Vector<::bright::int32> x1;
    ::bright::Vector<::bright::int64> x2;
    ::bright::Vector<::bright::String> x3;
    ::bright::Vector<test::DemoEnum> x4;

    static constexpr int __ID__ = -543221516;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DetectEncoding : public  bright::CfgBean 
{
    public:

    static bool deserializeDetectEncoding(ByteBuf& _buf, ::bright::SharedPtr<DetectEncoding>& _out);

    DetectEncoding()
    { 

    }

    DetectEncoding(::bright::int32 id, ::bright::String name ) 
    {

        this->id = id;
        this->name = name;
    }
    virtual ~DetectEncoding() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String name;

    static constexpr int __ID__ = -1154609646;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class ItemBase : public  bright::CfgBean 
{
    public:

    static bool deserializeItemBase(ByteBuf& _buf, ::bright::SharedPtr<ItemBase>& _out);

    ItemBase()
    { 

    }

    ItemBase(::bright::int32 id, ::bright::String name, ::bright::String desc ) 
    {

        this->id = id;
        this->name = name;
        this->desc = desc;
    }
    virtual ~ItemBase() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String name;
    ::bright::String desc;


    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class Item : public  test::ItemBase 
{
    public:

    static bool deserializeItem(ByteBuf& _buf, ::bright::SharedPtr<Item>& _out);

    Item()
    { 

    }

    Item(::bright::int32 id, ::bright::String name, ::bright::String desc, ::bright::int32 num, ::bright::int32 price ) 
            : test::ItemBase(id, name, desc)
    {

        this->num = num;
        this->price = price;
    }
    virtual ~Item() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 num;
    ::bright::int32 price;

    static constexpr int __ID__ = -1226641649;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class Equipment : public  test::ItemBase 
{
    public:

    static bool deserializeEquipment(ByteBuf& _buf, ::bright::SharedPtr<Equipment>& _out);

    Equipment()
    { 

    }

    Equipment(::bright::int32 id, ::bright::String name, ::bright::String desc, test::DemoEnum attr, ::bright::int32 value ) 
            : test::ItemBase(id, name, desc)
    {

        this->attr = attr;
        this->value = value;
    }
    virtual ~Equipment() {}

    bool deserialize(ByteBuf& _buf);

    test::DemoEnum attr;
    ::bright::int32 value;

    static constexpr int __ID__ = -76837102;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class Decorator : public  test::ItemBase 
{
    public:

    static bool deserializeDecorator(ByteBuf& _buf, ::bright::SharedPtr<Decorator>& _out);

    Decorator()
    { 

    }

    Decorator(::bright::int32 id, ::bright::String name, ::bright::String desc, ::bright::int32 duration ) 
            : test::ItemBase(id, name, desc)
    {

        this->duration = duration;
    }
    virtual ~Decorator() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 duration;

    static constexpr int __ID__ = -625155649;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DefineFromExcel : public  bright::CfgBean 
{
    public:

    static bool deserializeDefineFromExcel(ByteBuf& _buf, ::bright::SharedPtr<DefineFromExcel>& _out);

    DefineFromExcel()
    { 

    }

    DefineFromExcel(::bright::int32 id, bool x1, ::bright::int64 x5, ::bright::float32 x6, ::bright::int32 x8, ::bright::String x10, test::ETestQuality x13, ::bright::SharedPtr<test::DemoDynamic> x14, ::bright::SharedPtr<test::Shape> x15, ::bright::Vector2 v2, ::bright::datetime t1, ::bright::Vector<::bright::int32> k1, ::bright::Vector<::bright::int32> k2, ::bright::HashMap<::bright::int32, ::bright::int32> k8, ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x5 = x5;
        this->x6 = x6;
        this->x8 = x8;
        this->x10 = x10;
        this->x13 = x13;
        this->x14 = x14;
        this->x15 = x15;
        this->v2 = v2;
        this->t1 = t1;
        this->k1 = k1;
        this->k2 = k2;
        this->k8 = k8;
        this->k9 = k9;
    }
    virtual ~DefineFromExcel() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 这是id
     */
    ::bright::int32 id;
    /**
     * 字段x1
     */
    bool x1;
    ::bright::int64 x5;
    ::bright::float32 x6;
    ::bright::int32 x8;
    ::bright::String x10;
    test::ETestQuality x13;
    ::bright::SharedPtr<test::DemoDynamic> x14;
    ::bright::SharedPtr<test::Shape> x15;
    ::bright::Vector2 v2;
    ::bright::datetime t1;
    ::bright::Vector<::bright::int32> k1;
    ::bright::Vector<::bright::int32> k2;
    ::bright::HashMap<::bright::int32, ::bright::int32> k8;
    ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9;

    static constexpr int __ID__ = 2100429878;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class Shape : public  bright::CfgBean 
{
    public:

    static bool deserializeShape(ByteBuf& _buf, ::bright::SharedPtr<Shape>& _out);

    Shape()
    { 

    }

    virtual ~Shape() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



/**
 * 圆
 */
class Circle : public  test::Shape 
{
    public:

    static bool deserializeCircle(ByteBuf& _buf, ::bright::SharedPtr<Circle>& _out);

    Circle()
    { 

    }

    Circle(::bright::float32 radius ) 
            : test::Shape()
    {

        this->radius = radius;
    }
    virtual ~Circle() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 半径
     */
    ::bright::float32 radius;

    static constexpr int __ID__ = 2131829196;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test2 {



/**
 * 矩形
 */
class Rectangle : public  test::Shape 
{
    public:

    static bool deserializeRectangle(ByteBuf& _buf, ::bright::SharedPtr<Rectangle>& _out);

    Rectangle()
    { 

    }

    Rectangle(::bright::float32 width, ::bright::float32 height ) 
            : test::Shape()
    {

        this->width = width;
        this->height = height;
    }
    virtual ~Rectangle() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 宽度
     */
    ::bright::float32 width;
    /**
     * 高度
     */
    ::bright::float32 height;

    static constexpr int __ID__ = 694982337;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DefineFromExcelOne : public  bright::CfgBean 
{
    public:

    static bool deserializeDefineFromExcelOne(ByteBuf& _buf, ::bright::SharedPtr<DefineFromExcelOne>& _out);

    DefineFromExcelOne()
    { 

    }

    DefineFromExcelOne(::bright::int32 unlock_equip, ::bright::int32 unlock_hero, ::bright::String default_avatar, ::bright::String default_item ) 
    {

        this->unlockEquip = unlock_equip;
        this->unlockHero = unlock_hero;
        this->defaultAvatar = default_avatar;
        this->defaultItem = default_item;
    }
    virtual ~DefineFromExcelOne() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 装备解锁等级
     */
    ::bright::int32 unlockEquip;
    /**
     * 英雄解锁等级
     */
    ::bright::int32 unlockHero;
    ::bright::String defaultAvatar;
    ::bright::String defaultItem;

    static constexpr int __ID__ = 528039504;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestIndex : public  bright::CfgBean 
{
    public:

    static bool deserializeTestIndex(ByteBuf& _buf, ::bright::SharedPtr<TestIndex>& _out);

    TestIndex()
    { 

    }

    TestIndex(::bright::int32 id, ::bright::Vector<::bright::SharedPtr<test::DemoType1>> eles ) 
    {

        this->id = id;
        this->eles = eles;
    }
    virtual ~TestIndex() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::Vector<::bright::SharedPtr<test::DemoType1>> eles;

    static constexpr int __ID__ = 1941154020;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestMap : public  bright::CfgBean 
{
    public:

    static bool deserializeTestMap(ByteBuf& _buf, ::bright::SharedPtr<TestMap>& _out);

    TestMap()
    { 

    }

    TestMap(::bright::int32 id, ::bright::HashMap<::bright::int32, ::bright::int32> x1, ::bright::HashMap<::bright::int64, ::bright::int32> x2, ::bright::HashMap<::bright::String, ::bright::int32> x3, ::bright::HashMap<test::DemoEnum, ::bright::int32> x4 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
    }
    virtual ~TestMap() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::SharedPtr<test::TestIndex> id_Ref;
    ::bright::HashMap<::bright::int32, ::bright::int32> x1;
    ::bright::HashMap<::bright::int64, ::bright::int32> x2;
    ::bright::HashMap<::bright::String, ::bright::int32> x3;
    ::bright::HashMap<test::DemoEnum, ::bright::int32> x4;

    static constexpr int __ID__ = -543227410;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class ExcelFromJson : public  bright::CfgBean 
{
    public:

    static bool deserializeExcelFromJson(ByteBuf& _buf, ::bright::SharedPtr<ExcelFromJson>& _out);

    ExcelFromJson()
    { 

    }

    ExcelFromJson(::bright::int32 x4, bool x1, ::bright::int64 x5, ::bright::float32 x6, ::bright::String s1, ::bright::String s2, ::bright::Vector2 v2, ::bright::Vector3 v3, ::bright::Vector4 v4, ::bright::datetime t1, ::bright::SharedPtr<test::DemoType1> x12, test::DemoEnum x13, ::bright::SharedPtr<test::DemoDynamic> x14, ::bright::Vector<::bright::int32> k1, ::bright::HashMap<::bright::int32, ::bright::int32> k8, ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9, ::bright::Vector<::bright::SharedPtr<test::DemoDynamic>> k15 ) 
    {

        this->x4 = x4;
        this->x1 = x1;
        this->x5 = x5;
        this->x6 = x6;
        this->s1 = s1;
        this->s2 = s2;
        this->v2 = v2;
        this->v3 = v3;
        this->v4 = v4;
        this->t1 = t1;
        this->x12 = x12;
        this->x13 = x13;
        this->x14 = x14;
        this->k1 = k1;
        this->k8 = k8;
        this->k9 = k9;
        this->k15 = k15;
    }
    virtual ~ExcelFromJson() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x4;
    bool x1;
    ::bright::int64 x5;
    ::bright::float32 x6;
    ::bright::String s1;
    ::bright::String s2;
    ::bright::Vector2 v2;
    ::bright::Vector3 v3;
    ::bright::Vector4 v4;
    ::bright::datetime t1;
    ::bright::SharedPtr<test::DemoType1> x12;
    test::DemoEnum x13;
    ::bright::SharedPtr<test::DemoDynamic> x14;
    ::bright::Vector<::bright::int32> k1;
    ::bright::HashMap<::bright::int32, ::bright::int32> k8;
    ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9;
    ::bright::Vector<::bright::SharedPtr<test::DemoDynamic>> k15;

    static constexpr int __ID__ = -1485706483;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class CompositeJsonTable1 : public  bright::CfgBean 
{
    public:

    static bool deserializeCompositeJsonTable1(ByteBuf& _buf, ::bright::SharedPtr<CompositeJsonTable1>& _out);

    CompositeJsonTable1()
    { 

    }

    CompositeJsonTable1(::bright::int32 id, ::bright::String x ) 
    {

        this->id = id;
        this->x = x;
    }
    virtual ~CompositeJsonTable1() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String x;

    static constexpr int __ID__ = 1566207894;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class CompositeJsonTable2 : public  bright::CfgBean 
{
    public:

    static bool deserializeCompositeJsonTable2(ByteBuf& _buf, ::bright::SharedPtr<CompositeJsonTable2>& _out);

    CompositeJsonTable2()
    { 

    }

    CompositeJsonTable2(::bright::int32 id, ::bright::int32 y ) 
    {

        this->id = id;
        this->y = y;
    }
    virtual ~CompositeJsonTable2() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 y;

    static constexpr int __ID__ = 1566207895;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class CompositeJsonTable3 : public  bright::CfgBean 
{
    public:

    static bool deserializeCompositeJsonTable3(ByteBuf& _buf, ::bright::SharedPtr<CompositeJsonTable3>& _out);

    CompositeJsonTable3()
    { 

    }

    CompositeJsonTable3(::bright::int32 a, ::bright::int32 b ) 
    {

        this->a = a;
        this->b = b;
    }
    virtual ~CompositeJsonTable3() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 a;
    ::bright::int32 b;

    static constexpr int __ID__ = 1566207896;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class ExcelFromJsonMultiRow : public  bright::CfgBean 
{
    public:

    static bool deserializeExcelFromJsonMultiRow(ByteBuf& _buf, ::bright::SharedPtr<ExcelFromJsonMultiRow>& _out);

    ExcelFromJsonMultiRow()
    { 

    }

    ExcelFromJsonMultiRow(::bright::int32 id, ::bright::int32 x, ::bright::Vector<::bright::SharedPtr<test::TestRow>> items ) 
    {

        this->id = id;
        this->x = x;
        this->items = items;
    }
    virtual ~ExcelFromJsonMultiRow() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::int32 x;
    ::bright::Vector<::bright::SharedPtr<test::TestRow>> items;

    static constexpr int __ID__ = 715335694;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestRow : public  bright::CfgBean 
{
    public:

    static bool deserializeTestRow(ByteBuf& _buf, ::bright::SharedPtr<TestRow>& _out);

    TestRow()
    { 

    }

    TestRow(::bright::int32 x, bool y, ::bright::String z, ::bright::SharedPtr<test::Test3> a, ::bright::Vector<::bright::int32> b ) 
    {

        this->x = x;
        this->y = y;
        this->z = z;
        this->a = a;
        this->b = b;
    }
    virtual ~TestRow() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x;
    bool y;
    ::bright::String z;
    ::bright::SharedPtr<test::Test3> a;
    ::bright::Vector<::bright::int32> b;

    static constexpr int __ID__ = -543222164;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class Test3 : public  bright::CfgBean 
{
    public:

    static bool deserializeTest3(ByteBuf& _buf, ::bright::SharedPtr<Test3>& _out);

    Test3()
    { 

    }

    Test3(::bright::int32 x, ::bright::int32 y ) 
    {

        this->x = x;
        this->y = y;
    }
    virtual ~Test3() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x;
    ::bright::int32 y;

    static constexpr int __ID__ = 638540133;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestSep : public  bright::CfgBean 
{
    public:

    static bool deserializeTestSep(ByteBuf& _buf, ::bright::SharedPtr<TestSep>& _out);

    TestSep()
    { 

    }

    TestSep(::bright::int32 id, ::bright::String x1, ::bright::SharedPtr<test::SepBean1> x2, ::bright::SharedPtr<test::SepVector> x3, ::bright::Vector<::bright::SharedPtr<test::SepVector>> x4, ::bright::Vector<::bright::SharedPtr<test::SepBean1>> x5, ::bright::Vector<::bright::SharedPtr<test::SepBean1>> x6 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
        this->x5 = x5;
        this->x6 = x6;
    }
    virtual ~TestSep() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String x1;
    ::bright::SharedPtr<test::SepBean1> x2;
    /**
     * SepVector已经定义了sep=,属性
     */
    ::bright::SharedPtr<test::SepVector> x3;
    /**
     * 用;来分割数据，然后顺序读入SepVector
     */
    ::bright::Vector<::bright::SharedPtr<test::SepVector>> x4;
    /**
     * 用,分割数据，然后顺序读入
     */
    ::bright::Vector<::bright::SharedPtr<test::SepBean1>> x5;
    /**
     * 用;分割数据，然后再将每个数据用,分割，读入
     */
    ::bright::Vector<::bright::SharedPtr<test::SepBean1>> x6;

    static constexpr int __ID__ = -543221520;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class SepBean1 : public  bright::CfgBean 
{
    public:

    static bool deserializeSepBean1(ByteBuf& _buf, ::bright::SharedPtr<SepBean1>& _out);

    SepBean1()
    { 

    }

    SepBean1(::bright::int32 a, ::bright::int32 b, ::bright::String c ) 
    {

        this->a = a;
        this->b = b;
        this->c = c;
    }
    virtual ~SepBean1() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 a;
    ::bright::int32 b;
    ::bright::String c;

    static constexpr int __ID__ = -1534339393;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class SepVector : public  bright::CfgBean 
{
    public:

    static bool deserializeSepVector(ByteBuf& _buf, ::bright::SharedPtr<SepVector>& _out);

    SepVector()
    { 

    }

    SepVector(::bright::int32 x, ::bright::int32 y, ::bright::int32 z ) 
    {

        this->x = x;
        this->y = y;
        this->z = z;
    }
    virtual ~SepVector() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 x;
    ::bright::int32 y;
    ::bright::int32 z;

    static constexpr int __ID__ = 252769477;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestScriptableObject : public  bright::CfgBean 
{
    public:

    static bool deserializeTestScriptableObject(ByteBuf& _buf, ::bright::SharedPtr<TestScriptableObject>& _out);

    TestScriptableObject()
    { 

    }

    TestScriptableObject(::bright::int32 id, ::bright::String desc, ::bright::float32 rate, ::bright::int32 num, ::bright::Vector2 v2, ::bright::Vector3 v3, ::bright::Vector4 v4 ) 
    {

        this->id = id;
        this->desc = desc;
        this->rate = rate;
        this->num = num;
        this->v2 = v2;
        this->v3 = v3;
        this->v4 = v4;
    }
    virtual ~TestScriptableObject() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    ::bright::String desc;
    ::bright::float32 rate;
    ::bright::int32 num;
    ::bright::Vector2 v2;
    ::bright::Vector3 v3;
    ::bright::Vector4 v4;

    static constexpr int __ID__ = -1896814350;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestExternalType : public  bright::CfgBean 
{
    public:

    static bool deserializeTestExternalType(ByteBuf& _buf, ::bright::SharedPtr<TestExternalType>& _out);

    TestExternalType()
    { 

    }

    TestExternalType(::bright::int32 id, test::AudioType audio_type, ::bright::SharedPtr<test::Color> color ) 
    {

        this->id = id;
        this->audioType = audio_type;
        this->color = color;
    }
    virtual ~TestExternalType() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    test::AudioType audioType;
    ::bright::SharedPtr<test::Color> color;

    static constexpr int __ID__ = -990826157;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class Color : public  bright::CfgBean 
{
    public:

    static bool deserializeColor(ByteBuf& _buf, ::bright::SharedPtr<Color>& _out);

    Color()
    { 

    }

    Color(::bright::float32 r, ::bright::float32 g, ::bright::float32 b, ::bright::float32 a ) 
    {

        this->r = r;
        this->g = g;
        this->b = b;
        this->a = a;
    }
    virtual ~Color() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::float32 r;
    ::bright::float32 g;
    ::bright::float32 b;
    ::bright::float32 a;

    static constexpr int __ID__ = 623131367;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class DefineFromExcel2 : public  bright::CfgBean 
{
    public:

    static bool deserializeDefineFromExcel2(ByteBuf& _buf, ::bright::SharedPtr<DefineFromExcel2>& _out);

    DefineFromExcel2()
    { 

    }

    DefineFromExcel2(::bright::int32 id, bool x1, ::bright::int64 x5, ::bright::float32 x6, ::bright::int32 x8, ::bright::String x10, test::ETestQuality x13, ::bright::SharedPtr<test::DemoDynamic> x14, ::bright::SharedPtr<test::Shape> x15, ::bright::Vector2 v2, ::bright::datetime t1, ::bright::Vector<::bright::int32> k1, ::bright::Vector<::bright::int32> k2, ::bright::HashMap<::bright::int32, ::bright::int32> k8, ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x5 = x5;
        this->x6 = x6;
        this->x8 = x8;
        this->x10 = x10;
        this->x13 = x13;
        this->x14 = x14;
        this->x15 = x15;
        this->v2 = v2;
        this->t1 = t1;
        this->k1 = k1;
        this->k2 = k2;
        this->k8 = k8;
        this->k9 = k9;
    }
    virtual ~DefineFromExcel2() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 这是id
     */
    ::bright::int32 id;
    /**
     * 字段x1
     */
    bool x1;
    ::bright::int64 x5;
    ::bright::float32 x6;
    ::bright::int32 x8;
    ::bright::String x10;
    test::ETestQuality x13;
    ::bright::SharedPtr<test::DemoDynamic> x14;
    ::bright::SharedPtr<test::Shape> x15;
    ::bright::Vector2 v2;
    ::bright::datetime t1;
    ::bright::Vector<::bright::int32> k1;
    ::bright::Vector<::bright::int32> k2;
    ::bright::HashMap<::bright::int32, ::bright::int32> k8;
    ::bright::Vector<::bright::SharedPtr<test::DemoE2>> k9;

    static constexpr int __ID__ = 688816828;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



/**
 * 这是个测试excel结构
 */
class TestExcelBean1 : public  bright::CfgBean 
{
    public:

    static bool deserializeTestExcelBean1(ByteBuf& _buf, ::bright::SharedPtr<TestExcelBean1>& _out);

    TestExcelBean1()
    { 

    }

    TestExcelBean1(::bright::int32 x1, ::bright::String x2, ::bright::int32 x3, ::bright::float32 x4 ) 
    {

        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
    }
    virtual ~TestExcelBean1() {}

    bool deserialize(ByteBuf& _buf);

    /**
     * 最高品质
     */
    ::bright::int32 x1;
    /**
     * 黑色的
     */
    ::bright::String x2;
    /**
     * 蓝色的
     */
    ::bright::int32 x3;
    /**
     * 最差品质
     */
    ::bright::float32 x4;

    static constexpr int __ID__ = -1738345160;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}

namespace test {



class TestDesc : public  bright::CfgBean 
{
    public:

    static bool deserializeTestDesc(ByteBuf& _buf, ::bright::SharedPtr<TestDesc>& _out);

    TestDesc()
    { 

    }

    TestDesc(::bright::int32 id, ::bright::String name, ::bright::int32 a1, ::bright::int32 a2, ::bright::SharedPtr<test::H1> x1, ::bright::Vector<::bright::SharedPtr<test::H2>> x2, ::bright::Vector<::bright::SharedPtr<test::H2>> x3 ) 
    {

        this->id = id;
        this->name = name;
        this->a1 = a1;
        this->a2 = a2;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
    }
    virtual ~TestDesc() {}

    bool deserialize(ByteBuf& _buf);

    ::bright::int32 id;
    /**
     * 禁止
     */
    ::bright::String name;
    /**
     * 测试换行<br/>第2行<br/>第3层
     */
    ::bright::int32 a1;
    /**
     * 测试转义 &lt; &amp; % / # &gt;
     */
    ::bright::int32 a2;
    ::bright::SharedPtr<test::H1> x1;
    /**
     * 这是x2
     */
    ::bright::Vector<::bright::SharedPtr<test::H2>> x2;
    ::bright::Vector<::bright::SharedPtr<test::H2>> x3;

    static constexpr int __ID__ = 339555391;

    int getTypeId() const { return __ID__; }

    virtual void resolve(::bright::HashMap<::bright::String, void*>& _tables);
};

}


namespace ai {


class TbBlackboard
{
    private:
    ::bright::HashMap<::bright::String, ::bright::SharedPtr<ai::Blackboard>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<ai::Blackboard>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<ai::Blackboard> _v;
            if(!ai::Blackboard::deserializeBlackboard(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->name] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::String, ::bright::SharedPtr<ai::Blackboard>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<ai::Blackboard>>& getDataList() const { return _dataList; }

    ai::Blackboard* getRaw(::bright::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<ai::Blackboard> get(::bright::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace ai {


class TbBehaviorTree
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<ai::BehaviorTree>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<ai::BehaviorTree>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<ai::BehaviorTree> _v;
            if(!ai::BehaviorTree::deserializeBehaviorTree(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<ai::BehaviorTree>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<ai::BehaviorTree>>& getDataList() const { return _dataList; }

    ai::BehaviorTree* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<ai::BehaviorTree> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace blueprint {


class TbClazz
{
    private:
    ::bright::HashMap<::bright::String, ::bright::SharedPtr<blueprint::Clazz>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<blueprint::Clazz>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<blueprint::Clazz> _v;
            if(!blueprint::Clazz::deserializeClazz(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->name] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::String, ::bright::SharedPtr<blueprint::Clazz>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<blueprint::Clazz>>& getDataList() const { return _dataList; }

    blueprint::Clazz* getRaw(::bright::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<blueprint::Clazz> get(::bright::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace bonus {


class TbDrop
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<bonus::DropInfo>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<bonus::DropInfo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<bonus::DropInfo> _v;
            if(!bonus::DropInfo::deserializeDropInfo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<bonus::DropInfo>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<bonus::DropInfo>>& getDataList() const { return _dataList; }

    bonus::DropInfo* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<bonus::DropInfo> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace common {


class TbGlobalConfig
{
     private:
    ::bright::SharedPtr<common::GlobalConfig> _data;

    public:
    ::bright::SharedPtr<common::GlobalConfig> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!common::GlobalConfig::deserializeGlobalConfig(_buf, _data)) return false;
        return true;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    /**
     * 背包容量
     */
    ::bright::int32& getBagCapacity() const { return _data->bagCapacity; }
    ::bright::int32& getBagCapacitySpecial() const { return _data->bagCapacitySpecial; }
    ::bright::int32& getBagTempExpendableCapacity() const { return _data->bagTempExpendableCapacity; }
    ::bright::int32& getBagTempToolCapacity() const { return _data->bagTempToolCapacity; }
    ::bright::int32& getBagInitCapacity() const { return _data->bagInitCapacity; }
    ::bright::int32& getQuickBagCapacity() const { return _data->quickBagCapacity; }
    ::bright::int32& getClothBagCapacity() const { return _data->clothBagCapacity; }
    ::bright::int32& getClothBagInitCapacity() const { return _data->clothBagInitCapacity; }
    ::bright::int32& getClothBagCapacitySpecial() const { return _data->clothBagCapacitySpecial; }
    ::bright::SharedPtr<::bright::int32>& getBagInitItemsDropId() const { return _data->bagInitItemsDropId; }
    ::bright::int32& getMailBoxCapacity() const { return _data->mailBoxCapacity; }
    ::bright::float32& getDamageParamC() const { return _data->damageParamC; }
    ::bright::float32& getDamageParamE() const { return _data->damageParamE; }
    ::bright::float32& getDamageParamF() const { return _data->damageParamF; }
    ::bright::float32& getDamageParamD() const { return _data->damageParamD; }
    ::bright::float32& getRoleSpeed() const { return _data->roleSpeed; }
    ::bright::float32& getMonsterSpeed() const { return _data->monsterSpeed; }
    ::bright::int32& getInitEnergy() const { return _data->initEnergy; }
    ::bright::int32& getInitViality() const { return _data->initViality; }
    ::bright::int32& getMaxViality() const { return _data->maxViality; }
    ::bright::int32& getPerVialityRecoveryTime() const { return _data->perVialityRecoveryTime; }
};
}
namespace error {


class TbErrorInfo
{
    private:
    ::bright::HashMap<::bright::String, ::bright::SharedPtr<error::ErrorInfo>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<error::ErrorInfo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<error::ErrorInfo> _v;
            if(!error::ErrorInfo::deserializeErrorInfo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->code] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::String, ::bright::SharedPtr<error::ErrorInfo>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<error::ErrorInfo>>& getDataList() const { return _dataList; }

    error::ErrorInfo* getRaw(::bright::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<error::ErrorInfo> get(::bright::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace error {


class TbCodeInfo
{
    private:
    ::bright::HashMap<error::EErrorCode, ::bright::SharedPtr<error::CodeInfo>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<error::CodeInfo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<error::CodeInfo> _v;
            if(!error::CodeInfo::deserializeCodeInfo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->code] = _v;
        }
        return true;
    }

    const ::bright::HashMap<error::EErrorCode, ::bright::SharedPtr<error::CodeInfo>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<error::CodeInfo>>& getDataList() const { return _dataList; }

    error::CodeInfo* getRaw(error::EErrorCode key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<error::CodeInfo> get(error::EErrorCode key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace item {


/**
 * 道具表
 */
class TbItem
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<item::Item>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<item::Item>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<item::Item> _v;
            if(!item::Item::deserializeItem(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<item::Item>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<item::Item>>& getDataList() const { return _dataList; }

    item::Item* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<item::Item> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace item {


class TbItemFunc
{
    private:
    ::bright::HashMap<item::EMinorType, ::bright::SharedPtr<item::ItemFunction>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<item::ItemFunction>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<item::ItemFunction> _v;
            if(!item::ItemFunction::deserializeItemFunction(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->minorType] = _v;
        }
        return true;
    }

    const ::bright::HashMap<item::EMinorType, ::bright::SharedPtr<item::ItemFunction>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<item::ItemFunction>>& getDataList() const { return _dataList; }

    item::ItemFunction* getRaw(item::EMinorType key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<item::ItemFunction> get(item::EMinorType key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace item {


class TbItemExtra
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<item::ItemExtra>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<item::ItemExtra>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<item::ItemExtra> _v;
            if(!item::ItemExtra::deserializeItemExtra(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<item::ItemExtra>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<item::ItemExtra>>& getDataList() const { return _dataList; }

    item::ItemExtra* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<item::ItemExtra> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace l10n {


class TbL10NDemo
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<l10n::L10NDemo>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<l10n::L10NDemo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<l10n::L10NDemo> _v;
            if(!l10n::L10NDemo::deserializeL10NDemo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<l10n::L10NDemo>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<l10n::L10NDemo>>& getDataList() const { return _dataList; }

    l10n::L10NDemo* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<l10n::L10NDemo> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace l10n {


class TbPatchDemo
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<l10n::PatchDemo>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<l10n::PatchDemo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<l10n::PatchDemo> _v;
            if(!l10n::PatchDemo::deserializePatchDemo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<l10n::PatchDemo>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<l10n::PatchDemo>>& getDataList() const { return _dataList; }

    l10n::PatchDemo* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<l10n::PatchDemo> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace mail {


class TbSystemMail
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<mail::SystemMail>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<mail::SystemMail>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<mail::SystemMail> _v;
            if(!mail::SystemMail::deserializeSystemMail(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<mail::SystemMail>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<mail::SystemMail>>& getDataList() const { return _dataList; }

    mail::SystemMail* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<mail::SystemMail> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace mail {


class TbGlobalMail
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<mail::GlobalMail>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<mail::GlobalMail>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<mail::GlobalMail> _v;
            if(!mail::GlobalMail::deserializeGlobalMail(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<mail::GlobalMail>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<mail::GlobalMail>>& getDataList() const { return _dataList; }

    mail::GlobalMail* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<mail::GlobalMail> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace role {


class TbRoleLevelExpAttr
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<role::LevelExpAttr>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<role::LevelExpAttr>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<role::LevelExpAttr> _v;
            if(!role::LevelExpAttr::deserializeLevelExpAttr(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->level] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<role::LevelExpAttr>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<role::LevelExpAttr>>& getDataList() const { return _dataList; }

    role::LevelExpAttr* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<role::LevelExpAttr> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace role {


class TbRoleLevelBonusCoefficient
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<role::LevelBonus>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<role::LevelBonus>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<role::LevelBonus> _v;
            if(!role::LevelBonus::deserializeLevelBonus(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<role::LevelBonus>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<role::LevelBonus>>& getDataList() const { return _dataList; }

    role::LevelBonus* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<role::LevelBonus> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace tag {


class TbTestTag
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<tag::TestTag>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<tag::TestTag>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<tag::TestTag> _v;
            if(!tag::TestTag::deserializeTestTag(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<tag::TestTag>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<tag::TestTag>>& getDataList() const { return _dataList; }

    tag::TestTag* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<tag::TestTag> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbFullTypes
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoType2>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoType2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoType2> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbSingleton
{
     private:
    ::bright::SharedPtr<test::DemoSingletonType> _data;

    public:
    ::bright::SharedPtr<test::DemoSingletonType> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::DemoSingletonType::deserializeDemoSingletonType(_buf, _data)) return false;
        return true;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    ::bright::int32& getId() const { return _data->id; }
    ::bright::String& getName() const { return _data->name; }
    ::bright::SharedPtr<test::DemoDynamic>& getDate() const { return _data->date; }
};
}
namespace test {


class TbNotIndexList
{
    private:
    ::bright::Vector<::bright::SharedPtr<test::NotIndexList>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::NotIndexList> _v;
            if(!test::NotIndexList::deserializeNotIndexList(_buf, _v)) return false;
            _dataList.push_back(_v);
        }
        return true;
    }

    const ::bright::Vector<::bright::SharedPtr<test::NotIndexList>>& getDataList() const { return _dataList; }

    test::NotIndexList* getRaw(size_t index) const
    { 
        return _dataList[index].get();
    }

    ::bright::SharedPtr<test::NotIndexList> get(size_t index) const
    { 
        return _dataList[index];
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }
};
}
namespace test {


class TbMultiUnionIndexList
{
    private:
    ::bright::Vector<::bright::SharedPtr<test::MultiUnionIndexList>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::MultiUnionIndexList> _v;
            if(!test::MultiUnionIndexList::deserializeMultiUnionIndexList(_buf, _v)) return false;
            _dataList.push_back(_v);
        }
        return true;
    }

    const ::bright::Vector<::bright::SharedPtr<test::MultiUnionIndexList>>& getDataList() const { return _dataList; }

    test::MultiUnionIndexList* getRaw(size_t index) const
    { 
        return _dataList[index].get();
    }

    ::bright::SharedPtr<test::MultiUnionIndexList> get(size_t index) const
    { 
        return _dataList[index];
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }
};
}
namespace test {


class TbMultiIndexList
{
    private:
    ::bright::Vector<::bright::SharedPtr<test::MultiIndexList>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::MultiIndexList> _v;
            if(!test::MultiIndexList::deserializeMultiIndexList(_buf, _v)) return false;
            _dataList.push_back(_v);
        }
        return true;
    }

    const ::bright::Vector<::bright::SharedPtr<test::MultiIndexList>>& getDataList() const { return _dataList; }

    test::MultiIndexList* getRaw(size_t index) const
    { 
        return _dataList[index].get();
    }

    ::bright::SharedPtr<test::MultiIndexList> get(size_t index) const
    { 
        return _dataList[index];
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }
};
}
namespace test {


class TbDataFromMisc
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoType2>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoType2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoType2> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbMultiRowRecord
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowRecord>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::MultiRowRecord>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::MultiRowRecord> _v;
            if(!test::MultiRowRecord::deserializeMultiRowRecord(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowRecord>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::MultiRowRecord>>& getDataList() const { return _dataList; }

    test::MultiRowRecord* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::MultiRowRecord> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestMultiColumn
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestMultiColumn>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestMultiColumn>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestMultiColumn> _v;
            if(!test::TestMultiColumn::deserializeTestMultiColumn(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestMultiColumn>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestMultiColumn>>& getDataList() const { return _dataList; }

    test::TestMultiColumn* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestMultiColumn> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbMultiRowTitle
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowTitle>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::MultiRowTitle>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::MultiRowTitle> _v;
            if(!test::MultiRowTitle::deserializeMultiRowTitle(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::MultiRowTitle>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::MultiRowTitle>>& getDataList() const { return _dataList; }

    test::MultiRowTitle* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::MultiRowTitle> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestNull
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestNull>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestNull>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestNull> _v;
            if(!test::TestNull::deserializeTestNull(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestNull>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestNull>>& getDataList() const { return _dataList; }

    test::TestNull* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestNull> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDemoPrimitive
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoPrimitiveTypesTable>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoPrimitiveTypesTable>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoPrimitiveTypesTable> _v;
            if(!test::DemoPrimitiveTypesTable::deserializeDemoPrimitiveTypesTable(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoPrimitiveTypesTable>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoPrimitiveTypesTable>>& getDataList() const { return _dataList; }

    test::DemoPrimitiveTypesTable* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoPrimitiveTypesTable> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestString
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestString>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestString>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestString> _v;
            if(!test::TestString::deserializeTestString(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestString>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestString>>& getDataList() const { return _dataList; }

    test::TestString* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestString> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDemoGroup
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoGroup> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDemoGroup_C
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoGroup> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDemoGroup_S
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoGroup> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDemoGroup_E
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoGroup> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestGlobal
{
     private:
    ::bright::SharedPtr<test::TestGlobal> _data;

    public:
    ::bright::SharedPtr<test::TestGlobal> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::TestGlobal::deserializeTestGlobal(_buf, _data)) return false;
        return true;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    ::bright::int32& getUnlockEquip() const { return _data->unlockEquip; }
    ::bright::int32& getUnlockHero() const { return _data->unlockHero; }
};
}
namespace test {


class TbTestBeRef
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestBeRef>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestBeRef>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestBeRef> _v;
            if(!test::TestBeRef::deserializeTestBeRef(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestBeRef>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestBeRef>>& getDataList() const { return _dataList; }

    test::TestBeRef* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestBeRef> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestBeRef2
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestBeRef>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestBeRef>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestBeRef> _v;
            if(!test::TestBeRef::deserializeTestBeRef(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestBeRef>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestBeRef>>& getDataList() const { return _dataList; }

    test::TestBeRef* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestBeRef> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestRef
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestRef>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestRef>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestRef> _v;
            if(!test::TestRef::deserializeTestRef(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestRef>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestRef>>& getDataList() const { return _dataList; }

    test::TestRef* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestRef> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestSize
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestSize>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestSize>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestSize> _v;
            if(!test::TestSize::deserializeTestSize(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestSize>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestSize>>& getDataList() const { return _dataList; }

    test::TestSize* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestSize> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestSet
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestSet>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestSet>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestSet> _v;
            if(!test::TestSet::deserializeTestSet(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestSet>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestSet>>& getDataList() const { return _dataList; }

    test::TestSet* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestSet> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDetectCsvEncoding
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DetectEncoding>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DetectEncoding>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DetectEncoding> _v;
            if(!test::DetectEncoding::deserializeDetectEncoding(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DetectEncoding>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DetectEncoding>>& getDataList() const { return _dataList; }

    test::DetectEncoding* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DetectEncoding> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbItem2
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::ItemBase>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::ItemBase>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::ItemBase> _v;
            if(!test::ItemBase::deserializeItemBase(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::ItemBase>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::ItemBase>>& getDataList() const { return _dataList; }

    test::ItemBase* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::ItemBase> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDefineFromExcel
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DefineFromExcel>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DefineFromExcel>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DefineFromExcel> _v;
            if(!test::DefineFromExcel::deserializeDefineFromExcel(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DefineFromExcel>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DefineFromExcel>>& getDataList() const { return _dataList; }

    test::DefineFromExcel* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DefineFromExcel> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDefineFromExcelOne
{
     private:
    ::bright::SharedPtr<test::DefineFromExcelOne> _data;

    public:
    ::bright::SharedPtr<test::DefineFromExcelOne> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::DefineFromExcelOne::deserializeDefineFromExcelOne(_buf, _data)) return false;
        return true;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    /**
     * 装备解锁等级
     */
    ::bright::int32& getUnlockEquip() const { return _data->unlockEquip; }
    /**
     * 英雄解锁等级
     */
    ::bright::int32& getUnlockHero() const { return _data->unlockHero; }
    ::bright::String& getDefaultAvatar() const { return _data->defaultAvatar; }
    ::bright::String& getDefaultItem() const { return _data->defaultItem; }
};
}
namespace test {


class TbTestIndex
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestIndex>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestIndex>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestIndex> _v;
            if(!test::TestIndex::deserializeTestIndex(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestIndex>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestIndex>>& getDataList() const { return _dataList; }

    test::TestIndex* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestIndex> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestMap
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestMap>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestMap>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestMap> _v;
            if(!test::TestMap::deserializeTestMap(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestMap>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestMap>>& getDataList() const { return _dataList; }

    test::TestMap* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestMap> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbExcelFromJson
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::ExcelFromJson>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::ExcelFromJson>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::ExcelFromJson> _v;
            if(!test::ExcelFromJson::deserializeExcelFromJson(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::ExcelFromJson>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::ExcelFromJson>>& getDataList() const { return _dataList; }

    test::ExcelFromJson* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::ExcelFromJson> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbCompositeJsonTable1
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::CompositeJsonTable1>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::CompositeJsonTable1>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::CompositeJsonTable1> _v;
            if(!test::CompositeJsonTable1::deserializeCompositeJsonTable1(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::CompositeJsonTable1>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::CompositeJsonTable1>>& getDataList() const { return _dataList; }

    test::CompositeJsonTable1* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::CompositeJsonTable1> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbCompositeJsonTable2
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::CompositeJsonTable2>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::CompositeJsonTable2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::CompositeJsonTable2> _v;
            if(!test::CompositeJsonTable2::deserializeCompositeJsonTable2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::CompositeJsonTable2>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::CompositeJsonTable2>>& getDataList() const { return _dataList; }

    test::CompositeJsonTable2* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::CompositeJsonTable2> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbCompositeJsonTable3
{
     private:
    ::bright::SharedPtr<test::CompositeJsonTable3> _data;

    public:
    ::bright::SharedPtr<test::CompositeJsonTable3> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::CompositeJsonTable3::deserializeCompositeJsonTable3(_buf, _data)) return false;
        return true;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    ::bright::int32& getA() const { return _data->a; }
    ::bright::int32& getB() const { return _data->b; }
};
}
namespace test {


class TbExcelFromJsonMultiRow
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::ExcelFromJsonMultiRow>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::ExcelFromJsonMultiRow>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::ExcelFromJsonMultiRow> _v;
            if(!test::ExcelFromJsonMultiRow::deserializeExcelFromJsonMultiRow(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::ExcelFromJsonMultiRow>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::ExcelFromJsonMultiRow>>& getDataList() const { return _dataList; }

    test::ExcelFromJsonMultiRow* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::ExcelFromJsonMultiRow> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestSep
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestSep>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestSep>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestSep> _v;
            if(!test::TestSep::deserializeTestSep(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestSep>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestSep>>& getDataList() const { return _dataList; }

    test::TestSep* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestSep> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestScriptableObject
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestScriptableObject>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestScriptableObject>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestScriptableObject> _v;
            if(!test::TestScriptableObject::deserializeTestScriptableObject(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestScriptableObject>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestScriptableObject>>& getDataList() const { return _dataList; }

    test::TestScriptableObject* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestScriptableObject> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestExternalType
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestExternalType>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestExternalType>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestExternalType> _v;
            if(!test::TestExternalType::deserializeTestExternalType(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestExternalType>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestExternalType>>& getDataList() const { return _dataList; }

    test::TestExternalType* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestExternalType> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDemoGroupDefineFromExcel
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DemoGroup> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbDefineFromExcel2
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DefineFromExcel2>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::DefineFromExcel2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::DefineFromExcel2> _v;
            if(!test::DefineFromExcel2::deserializeDefineFromExcel2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::DefineFromExcel2>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::DefineFromExcel2>>& getDataList() const { return _dataList; }

    test::DefineFromExcel2* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::DefineFromExcel2> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestExcelBean
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestExcelBean1>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestExcelBean1>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestExcelBean1> _v;
            if(!test::TestExcelBean1::deserializeTestExcelBean1(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x1] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestExcelBean1>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestExcelBean1>>& getDataList() const { return _dataList; }

    test::TestExcelBean1* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestExcelBean1> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}
namespace test {


class TbTestDesc
{
    private:
    ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestDesc>> _dataMap;
    ::bright::Vector<::bright::SharedPtr<test::TestDesc>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::bright::SharedPtr<test::TestDesc> _v;
            if(!test::TestDesc::deserializeTestDesc(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::bright::HashMap<::bright::int32, ::bright::SharedPtr<test::TestDesc>>& getDataMap() const { return _dataMap; }
    const ::bright::Vector<::bright::SharedPtr<test::TestDesc>>& getDataList() const { return _dataList; }

    test::TestDesc* getRaw(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::bright::SharedPtr<test::TestDesc> get(::bright::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}

class Tables
{
    public:
     ai::TbBlackboard TbBlackboard;
     ai::TbBehaviorTree TbBehaviorTree;
     blueprint::TbClazz TbClazz;
     bonus::TbDrop TbDrop;
     common::TbGlobalConfig TbGlobalConfig;
     error::TbErrorInfo TbErrorInfo;
     error::TbCodeInfo TbCodeInfo;
    /**
     * 道具表
     */
     item::TbItem TbItem;
     item::TbItemFunc TbItemFunc;
     item::TbItemExtra TbItemExtra;
     l10n::TbL10NDemo TbL10NDemo;
     l10n::TbPatchDemo TbPatchDemo;
     mail::TbSystemMail TbSystemMail;
     mail::TbGlobalMail TbGlobalMail;
     role::TbRoleLevelExpAttr TbRoleLevelExpAttr;
     role::TbRoleLevelBonusCoefficient TbRoleLevelBonusCoefficient;
     tag::TbTestTag TbTestTag;
     test::TbFullTypes TbFullTypes;
     test::TbSingleton TbSingleton;
     test::TbNotIndexList TbNotIndexList;
     test::TbMultiUnionIndexList TbMultiUnionIndexList;
     test::TbMultiIndexList TbMultiIndexList;
     test::TbDataFromMisc TbDataFromMisc;
     test::TbMultiRowRecord TbMultiRowRecord;
     test::TbTestMultiColumn TbTestMultiColumn;
     test::TbMultiRowTitle TbMultiRowTitle;
     test::TbTestNull TbTestNull;
     test::TbDemoPrimitive TbDemoPrimitive;
     test::TbTestString TbTestString;
     test::TbDemoGroup TbDemoGroup;
     test::TbDemoGroup_C TbDemoGroup_C;
     test::TbDemoGroup_S TbDemoGroup_S;
     test::TbDemoGroup_E TbDemoGroup_E;
     test::TbTestGlobal TbTestGlobal;
     test::TbTestBeRef TbTestBeRef;
     test::TbTestBeRef2 TbTestBeRef2;
     test::TbTestRef TbTestRef;
     test::TbTestSize TbTestSize;
     test::TbTestSet TbTestSet;
     test::TbDetectCsvEncoding TbDetectCsvEncoding;
     test::TbItem2 TbItem2;
     test::TbDefineFromExcel TbDefineFromExcel;
     test::TbDefineFromExcelOne TbDefineFromExcelOne;
     test::TbTestIndex TbTestIndex;
     test::TbTestMap TbTestMap;
     test::TbExcelFromJson TbExcelFromJson;
     test::TbCompositeJsonTable1 TbCompositeJsonTable1;
     test::TbCompositeJsonTable2 TbCompositeJsonTable2;
     test::TbCompositeJsonTable3 TbCompositeJsonTable3;
     test::TbExcelFromJsonMultiRow TbExcelFromJsonMultiRow;
     test::TbTestSep TbTestSep;
     test::TbTestScriptableObject TbTestScriptableObject;
     test::TbTestExternalType TbTestExternalType;
     test::TbDemoGroupDefineFromExcel TbDemoGroupDefineFromExcel;
     test::TbDefineFromExcel2 TbDefineFromExcel2;
     test::TbTestExcelBean TbTestExcelBean;
     test::TbTestDesc TbTestDesc;

    bool load(::bright::Loader<ByteBuf> loader)
    {
        ::bright::HashMap<::bright::String, void*> __tables__;

        ByteBuf buf;
        if (!loader(buf, "ai_tbblackboard")) return false;
        if (!TbBlackboard.load(buf)) return false;
        __tables__["ai.TbBlackboard"] = &TbBlackboard;
        if (!loader(buf, "ai_tbbehaviortree")) return false;
        if (!TbBehaviorTree.load(buf)) return false;
        __tables__["ai.TbBehaviorTree"] = &TbBehaviorTree;
        if (!loader(buf, "blueprint_tbclazz")) return false;
        if (!TbClazz.load(buf)) return false;
        __tables__["blueprint.TbClazz"] = &TbClazz;
        if (!loader(buf, "bonus_tbdrop")) return false;
        if (!TbDrop.load(buf)) return false;
        __tables__["bonus.TbDrop"] = &TbDrop;
        if (!loader(buf, "common_tbglobalconfig")) return false;
        if (!TbGlobalConfig.load(buf)) return false;
        __tables__["common.TbGlobalConfig"] = &TbGlobalConfig;
        if (!loader(buf, "error_tberrorinfo")) return false;
        if (!TbErrorInfo.load(buf)) return false;
        __tables__["error.TbErrorInfo"] = &TbErrorInfo;
        if (!loader(buf, "error_tbcodeinfo")) return false;
        if (!TbCodeInfo.load(buf)) return false;
        __tables__["error.TbCodeInfo"] = &TbCodeInfo;
        if (!loader(buf, "item_tbitem")) return false;
        if (!TbItem.load(buf)) return false;
        __tables__["item.TbItem"] = &TbItem;
        if (!loader(buf, "item_tbitemfunc")) return false;
        if (!TbItemFunc.load(buf)) return false;
        __tables__["item.TbItemFunc"] = &TbItemFunc;
        if (!loader(buf, "item_tbitemextra")) return false;
        if (!TbItemExtra.load(buf)) return false;
        __tables__["item.TbItemExtra"] = &TbItemExtra;
        if (!loader(buf, "l10n_tbl10ndemo")) return false;
        if (!TbL10NDemo.load(buf)) return false;
        __tables__["l10n.TbL10NDemo"] = &TbL10NDemo;
        if (!loader(buf, "l10n_tbpatchdemo")) return false;
        if (!TbPatchDemo.load(buf)) return false;
        __tables__["l10n.TbPatchDemo"] = &TbPatchDemo;
        if (!loader(buf, "mail_tbsystemmail")) return false;
        if (!TbSystemMail.load(buf)) return false;
        __tables__["mail.TbSystemMail"] = &TbSystemMail;
        if (!loader(buf, "mail_tbglobalmail")) return false;
        if (!TbGlobalMail.load(buf)) return false;
        __tables__["mail.TbGlobalMail"] = &TbGlobalMail;
        if (!loader(buf, "role_tbrolelevelexpattr")) return false;
        if (!TbRoleLevelExpAttr.load(buf)) return false;
        __tables__["role.TbRoleLevelExpAttr"] = &TbRoleLevelExpAttr;
        if (!loader(buf, "role_tbrolelevelbonuscoefficient")) return false;
        if (!TbRoleLevelBonusCoefficient.load(buf)) return false;
        __tables__["role.TbRoleLevelBonusCoefficient"] = &TbRoleLevelBonusCoefficient;
        if (!loader(buf, "tag_tbtesttag")) return false;
        if (!TbTestTag.load(buf)) return false;
        __tables__["tag.TbTestTag"] = &TbTestTag;
        if (!loader(buf, "test_tbfulltypes")) return false;
        if (!TbFullTypes.load(buf)) return false;
        __tables__["test.TbFullTypes"] = &TbFullTypes;
        if (!loader(buf, "test_tbsingleton")) return false;
        if (!TbSingleton.load(buf)) return false;
        __tables__["test.TbSingleton"] = &TbSingleton;
        if (!loader(buf, "test_tbnotindexlist")) return false;
        if (!TbNotIndexList.load(buf)) return false;
        __tables__["test.TbNotIndexList"] = &TbNotIndexList;
        if (!loader(buf, "test_tbmultiunionindexlist")) return false;
        if (!TbMultiUnionIndexList.load(buf)) return false;
        __tables__["test.TbMultiUnionIndexList"] = &TbMultiUnionIndexList;
        if (!loader(buf, "test_tbmultiindexlist")) return false;
        if (!TbMultiIndexList.load(buf)) return false;
        __tables__["test.TbMultiIndexList"] = &TbMultiIndexList;
        if (!loader(buf, "test_tbdatafrommisc")) return false;
        if (!TbDataFromMisc.load(buf)) return false;
        __tables__["test.TbDataFromMisc"] = &TbDataFromMisc;
        if (!loader(buf, "test_tbmultirowrecord")) return false;
        if (!TbMultiRowRecord.load(buf)) return false;
        __tables__["test.TbMultiRowRecord"] = &TbMultiRowRecord;
        if (!loader(buf, "test_tbtestmulticolumn")) return false;
        if (!TbTestMultiColumn.load(buf)) return false;
        __tables__["test.TbTestMultiColumn"] = &TbTestMultiColumn;
        if (!loader(buf, "test_tbmultirowtitle")) return false;
        if (!TbMultiRowTitle.load(buf)) return false;
        __tables__["test.TbMultiRowTitle"] = &TbMultiRowTitle;
        if (!loader(buf, "test_tbtestnull")) return false;
        if (!TbTestNull.load(buf)) return false;
        __tables__["test.TbTestNull"] = &TbTestNull;
        if (!loader(buf, "test_tbdemoprimitive")) return false;
        if (!TbDemoPrimitive.load(buf)) return false;
        __tables__["test.TbDemoPrimitive"] = &TbDemoPrimitive;
        if (!loader(buf, "test_tbteststring")) return false;
        if (!TbTestString.load(buf)) return false;
        __tables__["test.TbTestString"] = &TbTestString;
        if (!loader(buf, "test_tbdemogroup")) return false;
        if (!TbDemoGroup.load(buf)) return false;
        __tables__["test.TbDemoGroup"] = &TbDemoGroup;
        if (!loader(buf, "test_tbdemogroup_c")) return false;
        if (!TbDemoGroup_C.load(buf)) return false;
        __tables__["test.TbDemoGroup_C"] = &TbDemoGroup_C;
        if (!loader(buf, "test_tbdemogroup_s")) return false;
        if (!TbDemoGroup_S.load(buf)) return false;
        __tables__["test.TbDemoGroup_S"] = &TbDemoGroup_S;
        if (!loader(buf, "test_tbdemogroup_e")) return false;
        if (!TbDemoGroup_E.load(buf)) return false;
        __tables__["test.TbDemoGroup_E"] = &TbDemoGroup_E;
        if (!loader(buf, "test_tbtestglobal")) return false;
        if (!TbTestGlobal.load(buf)) return false;
        __tables__["test.TbTestGlobal"] = &TbTestGlobal;
        if (!loader(buf, "test_tbtestberef")) return false;
        if (!TbTestBeRef.load(buf)) return false;
        __tables__["test.TbTestBeRef"] = &TbTestBeRef;
        if (!loader(buf, "test_tbtestberef2")) return false;
        if (!TbTestBeRef2.load(buf)) return false;
        __tables__["test.TbTestBeRef2"] = &TbTestBeRef2;
        if (!loader(buf, "test_tbtestref")) return false;
        if (!TbTestRef.load(buf)) return false;
        __tables__["test.TbTestRef"] = &TbTestRef;
        if (!loader(buf, "test_tbtestsize")) return false;
        if (!TbTestSize.load(buf)) return false;
        __tables__["test.TbTestSize"] = &TbTestSize;
        if (!loader(buf, "test_tbtestset")) return false;
        if (!TbTestSet.load(buf)) return false;
        __tables__["test.TbTestSet"] = &TbTestSet;
        if (!loader(buf, "test_tbdetectcsvencoding")) return false;
        if (!TbDetectCsvEncoding.load(buf)) return false;
        __tables__["test.TbDetectCsvEncoding"] = &TbDetectCsvEncoding;
        if (!loader(buf, "test_tbitem2")) return false;
        if (!TbItem2.load(buf)) return false;
        __tables__["test.TbItem2"] = &TbItem2;
        if (!loader(buf, "test_tbdefinefromexcel")) return false;
        if (!TbDefineFromExcel.load(buf)) return false;
        __tables__["test.TbDefineFromExcel"] = &TbDefineFromExcel;
        if (!loader(buf, "test_tbdefinefromexcelone")) return false;
        if (!TbDefineFromExcelOne.load(buf)) return false;
        __tables__["test.TbDefineFromExcelOne"] = &TbDefineFromExcelOne;
        if (!loader(buf, "test_tbtestindex")) return false;
        if (!TbTestIndex.load(buf)) return false;
        __tables__["test.TbTestIndex"] = &TbTestIndex;
        if (!loader(buf, "test_tbtestmap")) return false;
        if (!TbTestMap.load(buf)) return false;
        __tables__["test.TbTestMap"] = &TbTestMap;
        if (!loader(buf, "test_tbexcelfromjson")) return false;
        if (!TbExcelFromJson.load(buf)) return false;
        __tables__["test.TbExcelFromJson"] = &TbExcelFromJson;
        if (!loader(buf, "test_tbcompositejsontable1")) return false;
        if (!TbCompositeJsonTable1.load(buf)) return false;
        __tables__["test.TbCompositeJsonTable1"] = &TbCompositeJsonTable1;
        if (!loader(buf, "test_tbcompositejsontable2")) return false;
        if (!TbCompositeJsonTable2.load(buf)) return false;
        __tables__["test.TbCompositeJsonTable2"] = &TbCompositeJsonTable2;
        if (!loader(buf, "test_tbcompositejsontable3")) return false;
        if (!TbCompositeJsonTable3.load(buf)) return false;
        __tables__["test.TbCompositeJsonTable3"] = &TbCompositeJsonTable3;
        if (!loader(buf, "test_tbexcelfromjsonmultirow")) return false;
        if (!TbExcelFromJsonMultiRow.load(buf)) return false;
        __tables__["test.TbExcelFromJsonMultiRow"] = &TbExcelFromJsonMultiRow;
        if (!loader(buf, "test_tbtestsep")) return false;
        if (!TbTestSep.load(buf)) return false;
        __tables__["test.TbTestSep"] = &TbTestSep;
        if (!loader(buf, "test_tbtestscriptableobject")) return false;
        if (!TbTestScriptableObject.load(buf)) return false;
        __tables__["test.TbTestScriptableObject"] = &TbTestScriptableObject;
        if (!loader(buf, "test_tbtestexternaltype")) return false;
        if (!TbTestExternalType.load(buf)) return false;
        __tables__["test.TbTestExternalType"] = &TbTestExternalType;
        if (!loader(buf, "test_tbdemogroupdefinefromexcel")) return false;
        if (!TbDemoGroupDefineFromExcel.load(buf)) return false;
        __tables__["test.TbDemoGroupDefineFromExcel"] = &TbDemoGroupDefineFromExcel;
        if (!loader(buf, "test_tbdefinefromexcel2")) return false;
        if (!TbDefineFromExcel2.load(buf)) return false;
        __tables__["test.TbDefineFromExcel2"] = &TbDefineFromExcel2;
        if (!loader(buf, "test_tbtestexcelbean")) return false;
        if (!TbTestExcelBean.load(buf)) return false;
        __tables__["test.TbTestExcelBean"] = &TbTestExcelBean;
        if (!loader(buf, "test_tbtestdesc")) return false;
        if (!TbTestDesc.load(buf)) return false;
        __tables__["test.TbTestDesc"] = &TbTestDesc;

        TbBlackboard.resolve(__tables__); 
        TbBehaviorTree.resolve(__tables__); 
        TbClazz.resolve(__tables__); 
        TbDrop.resolve(__tables__); 
        TbGlobalConfig.resolve(__tables__); 
        TbErrorInfo.resolve(__tables__); 
        TbCodeInfo.resolve(__tables__); 
        TbItem.resolve(__tables__); 
        TbItemFunc.resolve(__tables__); 
        TbItemExtra.resolve(__tables__); 
        TbL10NDemo.resolve(__tables__); 
        TbPatchDemo.resolve(__tables__); 
        TbSystemMail.resolve(__tables__); 
        TbGlobalMail.resolve(__tables__); 
        TbRoleLevelExpAttr.resolve(__tables__); 
        TbRoleLevelBonusCoefficient.resolve(__tables__); 
        TbTestTag.resolve(__tables__); 
        TbFullTypes.resolve(__tables__); 
        TbSingleton.resolve(__tables__); 
        TbNotIndexList.resolve(__tables__); 
        TbMultiUnionIndexList.resolve(__tables__); 
        TbMultiIndexList.resolve(__tables__); 
        TbDataFromMisc.resolve(__tables__); 
        TbMultiRowRecord.resolve(__tables__); 
        TbTestMultiColumn.resolve(__tables__); 
        TbMultiRowTitle.resolve(__tables__); 
        TbTestNull.resolve(__tables__); 
        TbDemoPrimitive.resolve(__tables__); 
        TbTestString.resolve(__tables__); 
        TbDemoGroup.resolve(__tables__); 
        TbDemoGroup_C.resolve(__tables__); 
        TbDemoGroup_S.resolve(__tables__); 
        TbDemoGroup_E.resolve(__tables__); 
        TbTestGlobal.resolve(__tables__); 
        TbTestBeRef.resolve(__tables__); 
        TbTestBeRef2.resolve(__tables__); 
        TbTestRef.resolve(__tables__); 
        TbTestSize.resolve(__tables__); 
        TbTestSet.resolve(__tables__); 
        TbDetectCsvEncoding.resolve(__tables__); 
        TbItem2.resolve(__tables__); 
        TbDefineFromExcel.resolve(__tables__); 
        TbDefineFromExcelOne.resolve(__tables__); 
        TbTestIndex.resolve(__tables__); 
        TbTestMap.resolve(__tables__); 
        TbExcelFromJson.resolve(__tables__); 
        TbCompositeJsonTable1.resolve(__tables__); 
        TbCompositeJsonTable2.resolve(__tables__); 
        TbCompositeJsonTable3.resolve(__tables__); 
        TbExcelFromJsonMultiRow.resolve(__tables__); 
        TbTestSep.resolve(__tables__); 
        TbTestScriptableObject.resolve(__tables__); 
        TbTestExternalType.resolve(__tables__); 
        TbDemoGroupDefineFromExcel.resolve(__tables__); 
        TbDefineFromExcel2.resolve(__tables__); 
        TbTestExcelBean.resolve(__tables__); 
        TbTestDesc.resolve(__tables__); 
        return true;
    }
};


}
