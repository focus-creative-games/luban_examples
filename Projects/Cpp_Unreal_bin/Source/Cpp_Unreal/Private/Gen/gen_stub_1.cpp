
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include <algorithm>
#include "gen_types.h"

using ByteBuf = bright::serialization::ByteBuf;

namespace cfg
{

    bool cost::CostCurrency::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; type = item::ECurrencyType(__enum_temp__); }
        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool cost::CostCurrency::deserializeCostCurrency(ByteBuf& _buf, ::bright::SharedPtr<cost::CostCurrency>& _out)
    {
        _out.reset(new cost::CostCurrency());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostCurrency::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
    }

    bool cost::CostCurrencies::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); currencies.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<cost::CostCurrency> _e;  if(!cost::CostCurrency::deserializeCostCurrency(_buf, _e)) return false; currencies.push_back(_e);}}

        return true;
    }

    bool cost::CostCurrencies::deserializeCostCurrencies(ByteBuf& _buf, ::bright::SharedPtr<cost::CostCurrencies>& _out)
    {
        _out.reset(new cost::CostCurrencies());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostCurrencies::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        for(auto _e : currencies) { _e->resolve(_tables); }
    }

    bool cost::CostOneItem::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;

        return true;
    }

    bool cost::CostOneItem::deserializeCostOneItem(ByteBuf& _buf, ::bright::SharedPtr<cost::CostOneItem>& _out)
    {
        _out.reset(new cost::CostOneItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostOneItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool cost::CostItem::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(amount)) return false;

        return true;
    }

    bool cost::CostItem::deserializeCostItem(ByteBuf& _buf, ::bright::SharedPtr<cost::CostItem>& _out)
    {
        _out.reset(new cost::CostItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool cost::CostItems::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));itemList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<cost::CostItem> _e;if(!cost::CostItem::deserializeCostItem(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool cost::CostItems::deserializeCostItems(ByteBuf& _buf, ::bright::SharedPtr<cost::CostItems>& _out)
    {
        _out.reset(new cost::CostItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostItems::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool l10n::L10NDemo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(text)) return false; /* key */ if(!_buf.readString(text)) return false; /* text */

        return true;
    }

    bool l10n::L10NDemo::deserializeL10NDemo(ByteBuf& _buf, ::bright::SharedPtr<l10n::L10NDemo>& _out)
    {
        _out.reset(new l10n::L10NDemo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void l10n::L10NDemo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool l10n::PatchDemo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool l10n::PatchDemo::deserializePatchDemo(ByteBuf& _buf, ::bright::SharedPtr<l10n::PatchDemo>& _out)
    {
        _out.reset(new l10n::PatchDemo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void l10n::PatchDemo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool mail::SystemMail::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(title)) return false;
        if(!_buf.readString(sender)) return false;
        if(!_buf.readString(content)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); award.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; award.push_back(_e);}}

        return true;
    }

    bool mail::SystemMail::deserializeSystemMail(ByteBuf& _buf, ::bright::SharedPtr<mail::SystemMail>& _out)
    {
        _out.reset(new mail::SystemMail());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void mail::SystemMail::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool mail::GlobalMail::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(title)) return false;
        if(!_buf.readString(sender)) return false;
        if(!_buf.readString(content)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); award.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; award.push_back(_e);}}
        if (!_buf.readBool(allServer)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); serverList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; serverList.push_back(_e);}}
        if(!_buf.readString(platform)) return false;
        if(!_buf.readString(channel)) return false;
        if(!condition::MinMaxLevel::deserializeMinMaxLevel(_buf, minMaxLevel)) return false;
        if(!condition::TimeRange::deserializeTimeRange(_buf, registerTime)) return false;
        if(!condition::TimeRange::deserializeTimeRange(_buf, mailTime)) return false;

        return true;
    }

    bool mail::GlobalMail::deserializeGlobalMail(ByteBuf& _buf, ::bright::SharedPtr<mail::GlobalMail>& _out)
    {
        _out.reset(new mail::GlobalMail());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void mail::GlobalMail::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        minMaxLevel->resolve(_tables);
        registerTime->resolve(_tables);
        mailTime->resolve(_tables);
    }

    bool role::LevelExpAttr::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(level)) return false;
        if(!_buf.readLong(needExp)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); clothesAttrs.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; clothesAttrs.push_back(_e);}}

        return true;
    }

    bool role::LevelExpAttr::deserializeLevelExpAttr(ByteBuf& _buf, ::bright::SharedPtr<role::LevelExpAttr>& _out)
    {
        _out.reset(new role::LevelExpAttr());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::LevelExpAttr::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool role::LevelBonus::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); distinctBonusInfos.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<role::DistinctBonusInfos> _e;  if(!role::DistinctBonusInfos::deserializeDistinctBonusInfos(_buf, _e)) return false; distinctBonusInfos.push_back(_e);}}

        return true;
    }

    bool role::LevelBonus::deserializeLevelBonus(ByteBuf& _buf, ::bright::SharedPtr<role::LevelBonus>& _out)
    {
        _out.reset(new role::LevelBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::LevelBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : distinctBonusInfos) { _e->resolve(_tables); }
    }

    bool role::DistinctBonusInfos::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(effectiveLevel)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); bonusInfo.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<role::BonusInfo> _e;  if(!role::BonusInfo::deserializeBonusInfo(_buf, _e)) return false; bonusInfo.push_back(_e);}}

        return true;
    }

    bool role::DistinctBonusInfos::deserializeDistinctBonusInfos(ByteBuf& _buf, ::bright::SharedPtr<role::DistinctBonusInfos>& _out)
    {
        _out.reset(new role::DistinctBonusInfos());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::DistinctBonusInfos::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : bonusInfo) { _e->resolve(_tables); }
    }

    bool role::BonusInfo::deserialize(ByteBuf& _buf)
    {

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; type = item::ECurrencyType(__enum_temp__); }
        if(!_buf.readFloat(coefficient)) return false;

        return true;
    }

    bool role::BonusInfo::deserializeBonusInfo(ByteBuf& _buf, ::bright::SharedPtr<role::BonusInfo>& _out)
    {
        _out.reset(new role::BonusInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::BonusInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool tag::TestTag::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(value)) return false;

        return true;
    }

    bool tag::TestTag::deserializeTestTag(ByteBuf& _buf, ::bright::SharedPtr<tag::TestTag>& _out)
    {
        _out.reset(new tag::TestTag());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void tag::TestTag::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoType2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x4)) return false;
        if (!_buf.readBool(x1)) return false;
        if(!_buf.readByte(x2)) return false;
        if(!_buf.readShort(x3)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readDouble(x7)) return false;
        if(!_buf.readFshort(x80)) return false;
        if(!_buf.readFint(x8)) return false;
        if(!_buf.readFlong(x9)) return false;
        if(!_buf.readString(x10)) return false;
        if(!test::DemoType1::deserializeDemoType1(_buf, x12)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::DemoEnum(__enum_temp__); }
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x14)) return false;
        if(!_buf.readString(s1)) return false; /* key */ if(!_buf.readString(s1)) return false; /* text */
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readVector3(v3)) return false;
        if(!_buf.readVector4(v4)) return false;
        if(!_buf.readInt(t1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; k2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k5.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; k5.insert(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     k8[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoE2> _e;  if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k15.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoDynamic> _e;if(!test::DemoDynamic::deserializeDemoDynamic(_buf, _e)) return false; k15.push_back(_e);}}

        return true;
    }

    bool test::DemoType2::deserializeDemoType2(ByteBuf& _buf, ::bright::SharedPtr<test::DemoType2>& _out)
    {
        _out.reset(new test::DemoType2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoType2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x12->resolve(_tables);
        x14->resolve(_tables);
        for(auto _e : k9) { _e->resolve(_tables); }
        for(auto _e : k15) { _e->resolve(_tables); }
    }

    bool test::DemoType1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x1)) return false;

        return true;
    }

    bool test::DemoType1::deserializeDemoType1(ByteBuf& _buf, ::bright::SharedPtr<test::DemoType1>& _out)
    {
        _out.reset(new test::DemoType1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoType1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoDynamic::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x1)) return false;

        return true;
    }

    bool test::DemoDynamic::deserializeDemoDynamic(ByteBuf& _buf, ::bright::SharedPtr<test::DemoDynamic>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case test::DemoD2::__ID__: { _out.reset(new test::DemoD2()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case test::DemoE1::__ID__: { _out.reset(new test::DemoE1()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case test::DemoD5::__ID__: { _out.reset(new test::DemoD5()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void test::DemoDynamic::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoD2::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoDynamic::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(x2)) return false;

        return true;
    }

    bool test::DemoD2::deserializeDemoD2(ByteBuf& _buf, ::bright::SharedPtr<test::DemoD2>& _out)
    {
        _out.reset(new test::DemoD2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoD2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoDynamic::resolve(_tables);
    }

    bool test::DemoD3::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoDynamic::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(x3)) return false;

        return true;
    }

    bool test::DemoD3::deserializeDemoD3(ByteBuf& _buf, ::bright::SharedPtr<test::DemoD3>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case test::DemoE1::__ID__: { _out.reset(new test::DemoE1()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void test::DemoD3::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoDynamic::resolve(_tables);
    }

    bool test::DemoE1::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoD3::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(x4)) return false;

        return true;
    }

    bool test::DemoE1::deserializeDemoE1(ByteBuf& _buf, ::bright::SharedPtr<test::DemoE1>& _out)
    {
        _out.reset(new test::DemoE1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoE1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoD3::resolve(_tables);
    }

    bool test::DemoD5::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoDynamic::deserialize(_buf))
        {
            return false;
        }

        if(!test::DateTimeRange::deserializeDateTimeRange(_buf, time)) return false;

        return true;
    }

    bool test::DemoD5::deserializeDemoD5(ByteBuf& _buf, ::bright::SharedPtr<test::DemoD5>& _out)
    {
        _out.reset(new test::DemoD5());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoD5::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoDynamic::resolve(_tables);
        time->resolve(_tables);
    }

    bool test::DateTimeRange::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(startTime)) return false;
        if(!_buf.readInt(endTime)) return false;

        return true;
    }

    bool test::DateTimeRange::deserializeDateTimeRange(ByteBuf& _buf, ::bright::SharedPtr<test::DateTimeRange>& _out)
    {
        _out.reset(new test::DateTimeRange());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DateTimeRange::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoE2::deserialize(ByteBuf& _buf)
    {

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { y1.reset(new ::bright::int32()); if(!_buf.readInt(*y1)) return false; } else { y1.reset(); } }
        if (!_buf.readBool(y2)) return false;

        return true;
    }

    bool test::DemoE2::deserializeDemoE2(ByteBuf& _buf, ::bright::SharedPtr<test::DemoE2>& _out)
    {
        _out.reset(new test::DemoE2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoE2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoSingletonType::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false; /* key */ if(!_buf.readString(name)) return false; /* text */
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, date)) return false;

        return true;
    }

    bool test::DemoSingletonType::deserializeDemoSingletonType(ByteBuf& _buf, ::bright::SharedPtr<test::DemoSingletonType>& _out)
    {
        _out.reset(new test::DemoSingletonType());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoSingletonType::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        date->resolve(_tables);
    }

    bool test::NotIndexList::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x)) return false;
        if(!_buf.readInt(y)) return false;

        return true;
    }

    bool test::NotIndexList::deserializeNotIndexList(ByteBuf& _buf, ::bright::SharedPtr<test::NotIndexList>& _out)
    {
        _out.reset(new test::NotIndexList());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::NotIndexList::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::MultiUnionIndexList::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id1)) return false;
        if(!_buf.readLong(id2)) return false;
        if(!_buf.readString(id3)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readString(desc)) return false;

        return true;
    }

    bool test::MultiUnionIndexList::deserializeMultiUnionIndexList(ByteBuf& _buf, ::bright::SharedPtr<test::MultiUnionIndexList>& _out)
    {
        _out.reset(new test::MultiUnionIndexList());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiUnionIndexList::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::MultiIndexList::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id1)) return false;
        if(!_buf.readLong(id2)) return false;
        if(!_buf.readString(id3)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readString(desc)) return false;

        return true;
    }

    bool test::MultiIndexList::deserializeMultiIndexList(ByteBuf& _buf, ::bright::SharedPtr<test::MultiIndexList>& _out)
    {
        _out.reset(new test::MultiIndexList());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiIndexList::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::MultiRowRecord::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); oneRows.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;  if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; oneRows.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); multiRows1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;  if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; multiRows1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));multiRows2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; multiRows2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); multiRows4.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::SharedPtr<test::MultiRowType2> _v;  if(!test::MultiRowType2::deserializeMultiRowType2(_buf, _v)) return false;     multiRows4[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); multiRows5.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType3> _e;  if(!test::MultiRowType3::deserializeMultiRowType3(_buf, _e)) return false; multiRows5.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); multiRows6.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::SharedPtr<test::MultiRowType2> _v;  if(!test::MultiRowType2::deserializeMultiRowType2(_buf, _v)) return false;     multiRows6[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); multiRows7.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     multiRows7[_k] = _v;}}

        return true;
    }

    bool test::MultiRowRecord::deserializeMultiRowRecord(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowRecord>& _out)
    {
        _out.reset(new test::MultiRowRecord());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowRecord::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : oneRows) { _e->resolve(_tables); }
        for(auto _e : multiRows1) { _e->resolve(_tables); }
        for(auto _e : multiRows2) { _e->resolve(_tables); }
        for(auto _e : multiRows4) { _e.second->resolve(_tables); }
        for(auto _e : multiRows5) { _e->resolve(_tables); }
        for(auto _e : multiRows6) { _e.second->resolve(_tables); }
    }

    bool test::MultiRowType1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x)) return false;

        return true;
    }

    bool test::MultiRowType1::deserializeMultiRowType1(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowType1>& _out)
    {
        _out.reset(new test::MultiRowType1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowType1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::MultiRowType2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x)) return false;
        if(!_buf.readFloat(y)) return false;

        return true;
    }

    bool test::MultiRowType2::deserializeMultiRowType2(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowType2>& _out)
    {
        _out.reset(new test::MultiRowType2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowType2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::MultiRowType3::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); items.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;  if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; items.push_back(_e);}}

        return true;
    }

    bool test::MultiRowType3::deserializeMultiRowType3(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowType3>& _out)
    {
        _out.reset(new test::MultiRowType3());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowType3::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : items) { _e->resolve(_tables); }
    }

    bool test::MultiRowTitle::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        if(!test::H1::deserializeH1(_buf, x1)) return false;
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x20.reset(); if(!test::H2::deserializeH2(_buf, x20)) return false; } else { x20.reset(); } }
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::H2> _e;  if(!test::H2::deserializeH2(_buf, _e)) return false; x2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));x3.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::H2> _e;if(!test::H2::deserializeH2(_buf, _e)) return false; x3.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));x4.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::H2> _e;if(!test::H2::deserializeH2(_buf, _e)) return false; x4.push_back(_e);}}

        return true;
    }

    bool test::MultiRowTitle::deserializeMultiRowTitle(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowTitle>& _out)
    {
        _out.reset(new test::MultiRowTitle());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowTitle::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x1->resolve(_tables);
        if (x20 != nullptr) x20->resolve(_tables);
        for(auto _e : x2) { _e->resolve(_tables); }
        for(auto _e : x3) { _e->resolve(_tables); }
        for(auto _e : x4) { _e->resolve(_tables); }
    }

    bool test::H1::deserialize(ByteBuf& _buf)
    {

        if(!test::H2::deserializeH2(_buf, y2)) return false;
        if(!_buf.readInt(y3)) return false;

        return true;
    }

    bool test::H1::deserializeH1(ByteBuf& _buf, ::bright::SharedPtr<test::H1>& _out)
    {
        _out.reset(new test::H1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::H1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        y2->resolve(_tables);
    }

    bool test::H2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(z2)) return false;
        if(!_buf.readInt(z3)) return false;

        return true;
    }

    bool test::H2::deserializeH2(ByteBuf& _buf, ::bright::SharedPtr<test::H2>& _out)
    {
        _out.reset(new test::H2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::H2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestNull::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x1.reset(new ::bright::int32()); if(!_buf.readInt(*x1)) return false; } else { x1.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x2.reset(new test::DemoEnum()); {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; *x2 = test::DemoEnum(__enum_temp__); } } else { x2.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x3.reset(); if(!test::DemoType1::deserializeDemoType1(_buf, x3)) return false; } else { x3.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x4.reset(); if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x4)) return false; } else { x4.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { s1.reset(new ::bright::String()); if(!_buf.readString(*s1)) return false; } else { s1.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { s2.reset(new ::bright::String()); if(!_buf.readString(*s2)) return false; /* key */ if(!_buf.readString(*s2)) return false; /* text */ } else { s2.reset(); } }

        return true;
    }

    bool test::TestNull::deserializeTestNull(ByteBuf& _buf, ::bright::SharedPtr<test::TestNull>& _out)
    {
        _out.reset(new test::TestNull());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestNull::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        if (x3 != nullptr) x3->resolve(_tables);
        if (x4 != nullptr) x4->resolve(_tables);
    }

    bool test::DemoPrimitiveTypesTable::deserialize(ByteBuf& _buf)
    {

        if (!_buf.readBool(x1)) return false;
        if(!_buf.readByte(x2)) return false;
        if(!_buf.readShort(x3)) return false;
        if(!_buf.readInt(x4)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readDouble(x7)) return false;
        if(!_buf.readString(s1)) return false;
        if(!_buf.readString(s2)) return false; /* key */ if(!_buf.readString(s2)) return false; /* text */
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readVector3(v3)) return false;
        if(!_buf.readVector4(v4)) return false;
        if(!_buf.readInt(t1)) return false;

        return true;
    }

    bool test::DemoPrimitiveTypesTable::deserializeDemoPrimitiveTypesTable(ByteBuf& _buf, ::bright::SharedPtr<test::DemoPrimitiveTypesTable>& _out)
    {
        _out.reset(new test::DemoPrimitiveTypesTable());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoPrimitiveTypesTable::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestString::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(s1)) return false;
        if(!test::CompactString::deserializeCompactString(_buf, cs1)) return false;
        if(!test::CompactString::deserializeCompactString(_buf, cs2)) return false;

        return true;
    }

    bool test::TestString::deserializeTestString(ByteBuf& _buf, ::bright::SharedPtr<test::TestString>& _out)
    {
        _out.reset(new test::TestString());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestString::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        cs1->resolve(_tables);
        cs2->resolve(_tables);
    }

    bool test::CompactString::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(s2)) return false;
        if(!_buf.readString(s3)) return false;

        return true;
    }

    bool test::CompactString::deserializeCompactString(ByteBuf& _buf, ::bright::SharedPtr<test::CompactString>& _out)
    {
        _out.reset(new test::CompactString());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::CompactString::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoGroup::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x1)) return false;
        if(!_buf.readInt(x2)) return false;
        if(!_buf.readInt(x3)) return false;
        if(!_buf.readInt(x4)) return false;
        if(!test::InnerGroup::deserializeInnerGroup(_buf, x5)) return false;

        return true;
    }

    bool test::DemoGroup::deserializeDemoGroup(ByteBuf& _buf, ::bright::SharedPtr<test::DemoGroup>& _out)
    {
        _out.reset(new test::DemoGroup());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoGroup::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->x1_Ref = ((test::TbDemoGroup_C*)(_tables["test.TbDemoGroup_C"]))->get(x1);
        this->x2_Ref = ((test::TbDemoGroup_S*)(_tables["test.TbDemoGroup_S"]))->get(x2);
        this->x3_Ref = ((test::TbDemoGroup_E*)(_tables["test.TbDemoGroup_E"]))->get(x3);
        x5->resolve(_tables);
    }

    bool test::InnerGroup::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(y1)) return false;
        if(!_buf.readInt(y2)) return false;
        if(!_buf.readInt(y3)) return false;
        if(!_buf.readInt(y4)) return false;

        return true;
    }

    bool test::InnerGroup::deserializeInnerGroup(ByteBuf& _buf, ::bright::SharedPtr<test::InnerGroup>& _out)
    {
        _out.reset(new test::InnerGroup());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::InnerGroup::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestGlobal::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(unlockEquip)) return false;
        if(!_buf.readInt(unlockHero)) return false;

        return true;
    }

    bool test::TestGlobal::deserializeTestGlobal(ByteBuf& _buf, ::bright::SharedPtr<test::TestGlobal>& _out)
    {
        _out.reset(new test::TestGlobal());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestGlobal::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestBeRef::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(count)) return false;

        return true;
    }

    bool test::TestBeRef::deserializeTestBeRef(ByteBuf& _buf, ::bright::SharedPtr<test::TestBeRef>& _out)
    {
        _out.reset(new test::TestBeRef());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestBeRef::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestRef::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x1)) return false;
        if(!_buf.readInt(x12)) return false;
        if(!_buf.readInt(x2)) return false;
        if(!_buf.readInt(x3)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));a1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; a1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));a2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; a2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); b1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; b1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); b2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; b2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); c1.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; c1.insert(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); c2.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; c2.insert(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); d1.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     d1[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); d2.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     d2[_k] = _v;}}
        if(!_buf.readInt(e1)) return false;
        if(!_buf.readLong(e2)) return false;
        if(!_buf.readString(e3)) return false;
        if(!_buf.readInt(f1)) return false;
        if(!_buf.readLong(f2)) return false;
        if(!_buf.readString(f3)) return false;

        return true;
    }

    bool test::TestRef::deserializeTestRef(ByteBuf& _buf, ::bright::SharedPtr<test::TestRef>& _out)
    {
        _out.reset(new test::TestRef());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestRef::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->x1_Ref = ((test::TbTestBeRef*)(_tables["test.TbTestBeRef"]))->get(x1);
        this->x2_Ref = ((test::TbTestBeRef*)(_tables["test.TbTestBeRef"]))->get(x2);
    }

    bool test::TestSize::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));x1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; x1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; x2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x3.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; x3.insert(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); x4.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     x4[_k] = _v;}}

        return true;
    }

    bool test::TestSize::deserializeTestSize(ByteBuf& _buf, ::bright::SharedPtr<test::TestSize>& _out)
    {
        _out.reset(new test::TestSize());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestSize::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestSet::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; x1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int64 _e;  if(!_buf.readLong(_e)) return false; x2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x3.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::String _e;  if(!_buf.readString(_e)) return false; x3.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x4.reserve(n);for(int i = 0 ; i < n ; i++) { test::DemoEnum _e;  {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; _e = test::DemoEnum(__enum_temp__); } x4.push_back(_e);}}

        return true;
    }

    bool test::TestSet::deserializeTestSet(ByteBuf& _buf, ::bright::SharedPtr<test::TestSet>& _out)
    {
        _out.reset(new test::TestSet());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestSet::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DetectEncoding::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;

        return true;
    }

    bool test::DetectEncoding::deserializeDetectEncoding(ByteBuf& _buf, ::bright::SharedPtr<test::DetectEncoding>& _out)
    {
        _out.reset(new test::DetectEncoding());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DetectEncoding::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DefineFromExcel::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if (!_buf.readBool(x1)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readInt(x8)) return false;
        if(!_buf.readString(x10)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::ETestQuality(__enum_temp__); }
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x14)) return false;
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readInt(t1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     k8[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoE2> _e;  if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}

        return true;
    }

    bool test::DefineFromExcel::deserializeDefineFromExcel(ByteBuf& _buf, ::bright::SharedPtr<test::DefineFromExcel>& _out)
    {
        _out.reset(new test::DefineFromExcel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DefineFromExcel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x14->resolve(_tables);
        for(auto _e : k9) { _e->resolve(_tables); }
    }

    bool test::DefineFromExcelOne::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(unlockEquip)) return false;
        if(!_buf.readInt(unlockHero)) return false;
        if(!_buf.readString(defaultAvatar)) return false;
        if(!_buf.readString(defaultItem)) return false;

        return true;
    }

    bool test::DefineFromExcelOne::deserializeDefineFromExcelOne(ByteBuf& _buf, ::bright::SharedPtr<test::DefineFromExcelOne>& _out)
    {
        _out.reset(new test::DefineFromExcelOne());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DefineFromExcelOne::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestIndex::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); eles.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoType1> _e;  if(!test::DemoType1::deserializeDemoType1(_buf, _e)) return false; eles.push_back(_e);}}

        return true;
    }

    bool test::TestIndex::deserializeTestIndex(ByteBuf& _buf, ::bright::SharedPtr<test::TestIndex>& _out)
    {
        _out.reset(new test::TestIndex());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestIndex::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : eles) { _e->resolve(_tables); }
    }

    bool test::TestMap::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); x1.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     x1[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); x2.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int64 _k;  if(!_buf.readLong(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     x2[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); x3.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::String _k;  if(!_buf.readString(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     x3[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); x4.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { test::DemoEnum _k;  {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; _k = test::DemoEnum(__enum_temp__); } ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     x4[_k] = _v;}}

        return true;
    }

    bool test::TestMap::deserializeTestMap(ByteBuf& _buf, ::bright::SharedPtr<test::TestMap>& _out)
    {
        _out.reset(new test::TestMap());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestMap::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->id_Ref = ((test::TbTestIndex*)(_tables["test.TbTestIndex"]))->get(id);
    }

    bool test::ExcelFromJson::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x4)) return false;
        if (!_buf.readBool(x1)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readString(s1)) return false;
        if(!_buf.readString(s2)) return false; /* key */ if(!_buf.readString(s2)) return false; /* text */
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readVector3(v3)) return false;
        if(!_buf.readVector4(v4)) return false;
        if(!_buf.readInt(t1)) return false;
        if(!test::DemoType1::deserializeDemoType1(_buf, x12)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::DemoEnum(__enum_temp__); }
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x14)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     k8[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoE2> _e;  if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k15.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoDynamic> _e;if(!test::DemoDynamic::deserializeDemoDynamic(_buf, _e)) return false; k15.push_back(_e);}}

        return true;
    }

    bool test::ExcelFromJson::deserializeExcelFromJson(ByteBuf& _buf, ::bright::SharedPtr<test::ExcelFromJson>& _out)
    {
        _out.reset(new test::ExcelFromJson());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::ExcelFromJson::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x12->resolve(_tables);
        x14->resolve(_tables);
        for(auto _e : k9) { _e->resolve(_tables); }
        for(auto _e : k15) { _e->resolve(_tables); }
    }

    bool test::CompositeJsonTable1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(x)) return false;

        return true;
    }

    bool test::CompositeJsonTable1::deserializeCompositeJsonTable1(ByteBuf& _buf, ::bright::SharedPtr<test::CompositeJsonTable1>& _out)
    {
        _out.reset(new test::CompositeJsonTable1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::CompositeJsonTable1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::CompositeJsonTable2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(y)) return false;

        return true;
    }

    bool test::CompositeJsonTable2::deserializeCompositeJsonTable2(ByteBuf& _buf, ::bright::SharedPtr<test::CompositeJsonTable2>& _out)
    {
        _out.reset(new test::CompositeJsonTable2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::CompositeJsonTable2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::CompositeJsonTable3::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(a)) return false;
        if(!_buf.readInt(b)) return false;

        return true;
    }

    bool test::CompositeJsonTable3::deserializeCompositeJsonTable3(ByteBuf& _buf, ::bright::SharedPtr<test::CompositeJsonTable3>& _out)
    {
        _out.reset(new test::CompositeJsonTable3());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::CompositeJsonTable3::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::ExcelFromJsonMultiRow::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); items.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::TestRow> _e;  if(!test::TestRow::deserializeTestRow(_buf, _e)) return false; items.push_back(_e);}}

        return true;
    }

    bool test::ExcelFromJsonMultiRow::deserializeExcelFromJsonMultiRow(ByteBuf& _buf, ::bright::SharedPtr<test::ExcelFromJsonMultiRow>& _out)
    {
        _out.reset(new test::ExcelFromJsonMultiRow());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::ExcelFromJsonMultiRow::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : items) { _e->resolve(_tables); }
    }

    bool test::TestRow::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x)) return false;
        if (!_buf.readBool(y)) return false;
        if(!_buf.readString(z)) return false;
        if(!test::Test3::deserializeTest3(_buf, a)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); b.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; b.push_back(_e);}}

        return true;
    }

    bool test::TestRow::deserializeTestRow(ByteBuf& _buf, ::bright::SharedPtr<test::TestRow>& _out)
    {
        _out.reset(new test::TestRow());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestRow::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        a->resolve(_tables);
    }

    bool test::Test3::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x)) return false;
        if(!_buf.readInt(y)) return false;

        return true;
    }

    bool test::Test3::deserializeTest3(ByteBuf& _buf, ::bright::SharedPtr<test::Test3>& _out)
    {
        _out.reset(new test::Test3());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::Test3::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestSep::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(x1)) return false; /* key */ if(!_buf.readString(x1)) return false; /* text */
        if(!test::SepBean1::deserializeSepBean1(_buf, x2)) return false;
        if(!test::SepVector::deserializeSepVector(_buf, x3)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x4.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::SepVector> _e;  if(!test::SepVector::deserializeSepVector(_buf, _e)) return false; x4.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x5.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::SepBean1> _e;  if(!test::SepBean1::deserializeSepBean1(_buf, _e)) return false; x5.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x6.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::SepBean1> _e;  if(!test::SepBean1::deserializeSepBean1(_buf, _e)) return false; x6.push_back(_e);}}

        return true;
    }

    bool test::TestSep::deserializeTestSep(ByteBuf& _buf, ::bright::SharedPtr<test::TestSep>& _out)
    {
        _out.reset(new test::TestSep());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestSep::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x2->resolve(_tables);
        x3->resolve(_tables);
        for(auto _e : x4) { _e->resolve(_tables); }
        for(auto _e : x5) { _e->resolve(_tables); }
        for(auto _e : x6) { _e->resolve(_tables); }
    }

    bool test::SepBean1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(a)) return false;
        if(!_buf.readInt(b)) return false;
        if(!_buf.readString(c)) return false;

        return true;
    }

    bool test::SepBean1::deserializeSepBean1(ByteBuf& _buf, ::bright::SharedPtr<test::SepBean1>& _out)
    {
        _out.reset(new test::SepBean1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::SepBean1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::SepVector::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x)) return false;
        if(!_buf.readInt(y)) return false;
        if(!_buf.readInt(z)) return false;

        return true;
    }

    bool test::SepVector::deserializeSepVector(ByteBuf& _buf, ::bright::SharedPtr<test::SepVector>& _out)
    {
        _out.reset(new test::SepVector());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::SepVector::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestExternalType::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; audioType = test::AudioType(__enum_temp__); }
        if(!test::Color::deserializeColor(_buf, color)) return false;

        return true;
    }

    bool test::TestExternalType::deserializeTestExternalType(ByteBuf& _buf, ::bright::SharedPtr<test::TestExternalType>& _out)
    {
        _out.reset(new test::TestExternalType());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestExternalType::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        color->resolve(_tables);
    }

    bool test::Color::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readFloat(r)) return false;
        if(!_buf.readFloat(g)) return false;
        if(!_buf.readFloat(b)) return false;
        if(!_buf.readFloat(a)) return false;

        return true;
    }

    bool test::Color::deserializeColor(ByteBuf& _buf, ::bright::SharedPtr<test::Color>& _out)
    {
        _out.reset(new test::Color());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::Color::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DefineFromExcel2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if (!_buf.readBool(x1)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readInt(x8)) return false;
        if(!_buf.readString(x10)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::ETestQuality(__enum_temp__); }
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x14)) return false;
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readInt(t1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     k8[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoE2> _e;  if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}

        return true;
    }

    bool test::DefineFromExcel2::deserializeDefineFromExcel2(ByteBuf& _buf, ::bright::SharedPtr<test::DefineFromExcel2>& _out)
    {
        _out.reset(new test::DefineFromExcel2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DefineFromExcel2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x14->resolve(_tables);
        for(auto _e : k9) { _e->resolve(_tables); }
    }

    bool test::TestExcelBean1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x1)) return false;
        if(!_buf.readString(x2)) return false;
        if(!_buf.readInt(x3)) return false;
        if(!_buf.readFloat(x4)) return false;

        return true;
    }

    bool test::TestExcelBean1::deserializeTestExcelBean1(ByteBuf& _buf, ::bright::SharedPtr<test::TestExcelBean1>& _out)
    {
        _out.reset(new test::TestExcelBean1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestExcelBean1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestDesc::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        if(!_buf.readInt(a1)) return false;
        if(!_buf.readInt(a2)) return false;
        if(!test::H1::deserializeH1(_buf, x1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::H2> _e;  if(!test::H2::deserializeH2(_buf, _e)) return false; x2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));x3.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::H2> _e;if(!test::H2::deserializeH2(_buf, _e)) return false; x3.push_back(_e);}}

        return true;
    }

    bool test::TestDesc::deserializeTestDesc(ByteBuf& _buf, ::bright::SharedPtr<test::TestDesc>& _out)
    {
        _out.reset(new test::TestDesc());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestDesc::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x1->resolve(_tables);
        for(auto _e : x2) { _e->resolve(_tables); }
        for(auto _e : x3) { _e->resolve(_tables); }
    }
}