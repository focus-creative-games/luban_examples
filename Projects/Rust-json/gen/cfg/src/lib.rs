
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

pub mod ai;
pub mod common;
pub mod item;
pub mod l10n;
pub mod tag;
pub mod test;
pub mod test2;

use serde::Deserialize;

#[derive(Deserialize, Debug, Hash, Eq, PartialEq)]
pub enum AudioType {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
}

impl From<i32> for AudioType {
    fn from(value: i32) -> Self {
        match value { 
            0 => AudioType::UNKNOWN,
            1 => AudioType::ACC,
            2 => AudioType::AIFF,
            _ => panic!("Invalid value for AudioType:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct vec2 {
    pub x: f32,
    pub y: f32,
}

impl vec2{
    pub fn new(json: &serde_json::Value) -> vec2 {
        let x = json["x"].as_f64().unwrap() as f32;
        let y = json["y"].as_f64().unwrap() as f32;
        
        vec2 { x, y, }
    }
}

#[derive(Debug)]
pub struct vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl vec3{
    pub fn new(json: &serde_json::Value) -> vec3 {
        let x = json["x"].as_f64().unwrap() as f32;
        let y = json["y"].as_f64().unwrap() as f32;
        let z = json["z"].as_f64().unwrap() as f32;
        
        vec3 { x, y, z, }
    }
}

#[derive(Debug)]
pub struct vec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl vec4{
    pub fn new(json: &serde_json::Value) -> vec4 {
        let x = json["x"].as_f64().unwrap() as f32;
        let y = json["y"].as_f64().unwrap() as f32;
        let z = json["z"].as_f64().unwrap() as f32;
        let w = json["w"].as_f64().unwrap() as f32;
        
        vec4 { x, y, z, w, }
    }
}

#[derive(Debug)]
pub struct DefineFromExcel2 {
    /// 这是id
    pub id: i32,
    /// 字段x1
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub x8: i32,
    pub x10: String,
    pub x13: crate::test::DemoEnum,
    pub x13_2: crate::test::DemoFlag,
    pub x14: std::sync::Arc<AbstractBase>,
    pub x15: std::sync::Arc<AbstractBase>,
    pub v2: crate::vec2,
    pub t1: u64,
    pub k1: Box<[i32]>,
    pub k2: Box<[i32]>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k10: Vec<crate::vec3>,
    pub k11: Vec<crate::vec4>,
    pub v11: Option<crate::vec3>,
}

impl DefineFromExcel2{
    pub fn new(json: &serde_json::Value) -> DefineFromExcel2 {
        let id = json["id"].as_i64().unwrap() as i32;
        let x1 = json["x1"].as_bool().unwrap();
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = json["x6"].as_f64().unwrap() as f32;
        let x8 = json["x8"].as_i64().unwrap() as i32;
        let x10 = json["x10"].as_str().unwrap().to_string();
        let x13 = <i32 as std::str::FromStr>::from_str(&json["x13"].to_string()).unwrap().into();
        let x13_2 = crate::test::DemoFlag::from_bits_truncate(<u32 as std::str::FromStr>::from_str(&json["x13_2"].to_string()).unwrap());
        let x14 = crate::test::DemoDynamic::new(&json["x14"]);
        let x15 = crate::test::Shape::new(&json["x15"]);
        let v2 = crate::vec2::new(&json["v2"]);
        let t1 = json["t1"].as_i64().unwrap() as u64;
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| field.as_i64().unwrap() as i32).collect();
        let k2 = json["k2"].as_array().unwrap().iter().map(|field| field.as_i64().unwrap() as i32).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();(array[0].as_i64().unwrap() as i32, array[1].as_i64().unwrap() as i32)}).collect::<Vec<(i32, i32)>>());
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| crate::test::DemoE2::new(&field)).collect();
        let k10 = json["k10"].as_array().unwrap().iter().map(|field| crate::vec3::new(&field)).collect();
        let k11 = json["k11"].as_array().unwrap().iter().map(|field| crate::vec4::new(&field)).collect();
        let mut v11 = None; if let Some(value) = json.get("v11") { v11 = Some(crate::vec3::new(&json["v11"])); }
        
        DefineFromExcel2 { id, x1, x5, x6, x8, x10, x13, x13_2, x14, x15, v2, t1, k1, k2, k8, k9, k10, k11, v11, }
    }
}


pub mod prelude{
    pub use crate::*;
    pub use crate::ai::*;
    pub use crate::common::*;
    pub use crate::item::*;
    pub use crate::l10n::*;
    pub use crate::tag::*;
    pub use crate::test::*;
    pub use crate::test::login::*;
    pub use crate::test2::*;
}

type AbstractBase = dyn std::any::Any + Sync + Send;

pub trait GetBase<'a, T> {
    fn get_base(&'a self) -> T;
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::Node {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::Node>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::Node".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::Service {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::Service>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::Service".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeSetDefaultFocus {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeSetDefaultFocus>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeSetDefaultFocus".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::ExecuteTimeStatistic {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::ExecuteTimeStatistic>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::ExecuteTimeStatistic".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::ChooseTarget {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::ChooseTarget>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::ChooseTarget".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::KeepFaceTarget {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::KeepFaceTarget>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::KeepFaceTarget".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::GetOwnerPlayer {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::GetOwnerPlayer>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::GetOwnerPlayer".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UpdateDailyBehaviorProps {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UpdateDailyBehaviorProps>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UpdateDailyBehaviorProps".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::Decorator {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::Decorator>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::Decorator".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeLoop {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeLoop>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeLoop".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeCooldown {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeCooldown>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeCooldown".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeTimeLimit {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeTimeLimit>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeTimeLimit".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeBlackboard {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeBlackboard>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeBlackboard".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::KeyQueryOperator {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::KeyQueryOperator>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::KeyQueryOperator".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::IsSet2 {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::IsSet2>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::IsSet2".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::IsNotSet {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::IsNotSet>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::IsNotSet".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::BinaryOperator {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::BinaryOperator>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::BinaryOperator".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::KeyData {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::KeyData>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::KeyData".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::FloatKeyData {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::FloatKeyData>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::FloatKeyData".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::IntKeyData {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::IntKeyData>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::IntKeyData".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::StringKeyData {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::StringKeyData>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::StringKeyData".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::BlackboardKeyData {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::BlackboardKeyData>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::BlackboardKeyData".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeForceSuccess {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeForceSuccess>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeForceSuccess".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::IsAtLocation {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::IsAtLocation>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::IsAtLocation".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::DistanceLessThan {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::DistanceLessThan>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::DistanceLessThan".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::FlowNode {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::FlowNode>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::FlowNode".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::ComposeNode {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::ComposeNode>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::ComposeNode".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::Sequence {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::Sequence>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::Sequence".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::Selector {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::Selector>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::Selector".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::SimpleParallel {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::SimpleParallel>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::SimpleParallel".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::Task {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::Task>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::Task".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeWait {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeWait>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeWait".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::UeWaitBlackboardTime {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::UeWaitBlackboardTime>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::UeWaitBlackboardTime".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::MoveToTarget {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::MoveToTarget>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::MoveToTarget".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::ChooseSkill {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::ChooseSkill>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::ChooseSkill".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::MoveToRandomLocation {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::MoveToRandomLocation>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::MoveToRandomLocation".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::MoveToLocation {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::MoveToLocation>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::MoveToLocation".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::ai::DebugPrint {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::ai::DebugPrint>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::ai::DebugPrint".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::DemoDynamic {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::DemoDynamic>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::DemoDynamic".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::DemoD2 {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::DemoD2>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::DemoD2".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::DemoD3 {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::DemoD3>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::DemoD3".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::DemoE1 {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::DemoE1>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::DemoE1".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::login::RoleInfo {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::login::RoleInfo>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::login::RoleInfo".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::DemoD5 {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::DemoD5>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::DemoD5".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::RefDynamicBase {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::RefDynamicBase>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::RefDynamicBase".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::RefBean {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::RefBean>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::RefBean".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::ItemBase {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::ItemBase>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::ItemBase".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::Item {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::Item>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::Item".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::Equipment {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::Equipment>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::Equipment".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::Decorator {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::Decorator>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::Decorator".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::Shape {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::Shape>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::Shape".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test::Circle {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test::Circle>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test::Circle".to_string())
    }
}

impl<'a> TryFrom<&'a AbstractBase> for &'a crate::test2::Rectangle {
    type Error = String;

    fn try_from(value: &'a AbstractBase) -> Result<Self, Self::Error> {
        let r = value.downcast_ref::<crate::test2::Rectangle>();
        if let Some(v) = r {
            return Ok(v);
        }

        Err("can not into to crate::test2::Rectangle".to_string())
    }
}

pub struct Tables{
    pub TbBlackboard: std::sync::Arc<crate::ai::TbBlackboard>,
    pub TbBehaviorTree: std::sync::Arc<crate::ai::TbBehaviorTree>,
    pub TbGlobalConfig: std::sync::Arc<crate::common::TbGlobalConfig>,
    pub TbItem: std::sync::Arc<crate::item::TbItem>,
    pub TbL10NDemo: std::sync::Arc<crate::l10n::TbL10NDemo>,
    pub TbPatchDemo: std::sync::Arc<crate::l10n::TbPatchDemo>,
    pub TbTestTag: std::sync::Arc<crate::tag::TbTestTag>,
    pub TbFullTypes: std::sync::Arc<crate::test::TbFullTypes>,
    pub TbSingleton: std::sync::Arc<crate::test::TbSingleton>,
    pub TbNotIndexList: std::sync::Arc<crate::test::TbNotIndexList>,
    pub TbMultiUnionIndexList: std::sync::Arc<crate::test::TbMultiUnionIndexList>,
    pub TbMultiIndexList: std::sync::Arc<crate::test::TbMultiIndexList>,
    pub TbDataFromMisc: std::sync::Arc<crate::test::TbDataFromMisc>,
    pub TbMultiRowRecord: std::sync::Arc<crate::test::TbMultiRowRecord>,
    pub TbTestMultiColumn: std::sync::Arc<crate::test::TbTestMultiColumn>,
    pub TbMultiRowTitle: std::sync::Arc<crate::test::TbMultiRowTitle>,
    pub TbTestNull: std::sync::Arc<crate::test::TbTestNull>,
    pub TbDemoPrimitive: std::sync::Arc<crate::test::TbDemoPrimitive>,
    pub TbTestString: std::sync::Arc<crate::test::TbTestString>,
    pub TbDemoGroup: std::sync::Arc<crate::test::TbDemoGroup>,
    pub TbDemoGroup_C: std::sync::Arc<crate::test::TbDemoGroup_C>,
    pub TbDemoGroup_S: std::sync::Arc<crate::test::TbDemoGroup_S>,
    pub TbDemoGroup_E: std::sync::Arc<crate::test::TbDemoGroup_E>,
    pub TbTestGlobal: std::sync::Arc<crate::test::TbTestGlobal>,
    pub TbTestBeRef: std::sync::Arc<crate::test::TbTestBeRef>,
    pub TbTestBeRef2: std::sync::Arc<crate::test::TbTestBeRef2>,
    pub TbTestRef: std::sync::Arc<crate::test::TbTestRef>,
    pub TbTestSize: std::sync::Arc<crate::test::TbTestSize>,
    pub TbTestSet: std::sync::Arc<crate::test::TbTestSet>,
    pub TbDetectCsvEncoding: std::sync::Arc<crate::test::TbDetectCsvEncoding>,
    pub TbItem2: std::sync::Arc<crate::test::TbItem2>,
    pub TbTestIndex: std::sync::Arc<crate::test::TbTestIndex>,
    pub TbTestMap: std::sync::Arc<crate::test::TbTestMap>,
    pub TbExcelFromJson: std::sync::Arc<crate::test::TbExcelFromJson>,
    pub TbCompositeJsonTable1: std::sync::Arc<crate::test::TbCompositeJsonTable1>,
    pub TbCompositeJsonTable2: std::sync::Arc<crate::test::TbCompositeJsonTable2>,
    pub TbCompositeJsonTable3: std::sync::Arc<crate::test::TbCompositeJsonTable3>,
    pub TbExcelFromJsonMultiRow: std::sync::Arc<crate::test::TbExcelFromJsonMultiRow>,
    pub TbTestScriptableObject: std::sync::Arc<crate::test::TbTestScriptableObject>,
    pub TbPath: std::sync::Arc<crate::test::TbPath>,
    pub TbTestMapper: std::sync::Arc<crate::test::TbTestMapper>,
    pub TbDefineFromExcel2: std::sync::Arc<crate::test::TbDefineFromExcel2>,
}

impl Tables {
    pub fn new<T: Fn(&str) -> serde_json::Value>(loader: T) -> Tables {
        Tables {
            TbBlackboard: crate::ai::TbBlackboard::new(&loader("ai_tbblackboard")),
            TbBehaviorTree: crate::ai::TbBehaviorTree::new(&loader("ai_tbbehaviortree")),
            TbGlobalConfig: crate::common::TbGlobalConfig::new(&loader("common_tbglobalconfig")),
            TbItem: crate::item::TbItem::new(&loader("item_tbitem")),
            TbL10NDemo: crate::l10n::TbL10NDemo::new(&loader("l10n_tbl10ndemo")),
            TbPatchDemo: crate::l10n::TbPatchDemo::new(&loader("l10n_tbpatchdemo")),
            TbTestTag: crate::tag::TbTestTag::new(&loader("tag_tbtesttag")),
            TbFullTypes: crate::test::TbFullTypes::new(&loader("test_tbfulltypes")),
            TbSingleton: crate::test::TbSingleton::new(&loader("test_tbsingleton")),
            TbNotIndexList: crate::test::TbNotIndexList::new(&loader("test_tbnotindexlist")),
            TbMultiUnionIndexList: crate::test::TbMultiUnionIndexList::new(&loader("test_tbmultiunionindexlist")),
            TbMultiIndexList: crate::test::TbMultiIndexList::new(&loader("test_tbmultiindexlist")),
            TbDataFromMisc: crate::test::TbDataFromMisc::new(&loader("test_tbdatafrommisc")),
            TbMultiRowRecord: crate::test::TbMultiRowRecord::new(&loader("test_tbmultirowrecord")),
            TbTestMultiColumn: crate::test::TbTestMultiColumn::new(&loader("test_tbtestmulticolumn")),
            TbMultiRowTitle: crate::test::TbMultiRowTitle::new(&loader("test_tbmultirowtitle")),
            TbTestNull: crate::test::TbTestNull::new(&loader("test_tbtestnull")),
            TbDemoPrimitive: crate::test::TbDemoPrimitive::new(&loader("test_tbdemoprimitive")),
            TbTestString: crate::test::TbTestString::new(&loader("test_tbteststring")),
            TbDemoGroup: crate::test::TbDemoGroup::new(&loader("test_tbdemogroup")),
            TbDemoGroup_C: crate::test::TbDemoGroup_C::new(&loader("test_tbdemogroup_c")),
            TbDemoGroup_S: crate::test::TbDemoGroup_S::new(&loader("test_tbdemogroup_s")),
            TbDemoGroup_E: crate::test::TbDemoGroup_E::new(&loader("test_tbdemogroup_e")),
            TbTestGlobal: crate::test::TbTestGlobal::new(&loader("test_tbtestglobal")),
            TbTestBeRef: crate::test::TbTestBeRef::new(&loader("test_tbtestberef")),
            TbTestBeRef2: crate::test::TbTestBeRef2::new(&loader("test_tbtestberef2")),
            TbTestRef: crate::test::TbTestRef::new(&loader("test_tbtestref")),
            TbTestSize: crate::test::TbTestSize::new(&loader("test_tbtestsize")),
            TbTestSet: crate::test::TbTestSet::new(&loader("test_tbtestset")),
            TbDetectCsvEncoding: crate::test::TbDetectCsvEncoding::new(&loader("test_tbdetectcsvencoding")),
            TbItem2: crate::test::TbItem2::new(&loader("test_tbitem2")),
            TbTestIndex: crate::test::TbTestIndex::new(&loader("test_tbtestindex")),
            TbTestMap: crate::test::TbTestMap::new(&loader("test_tbtestmap")),
            TbExcelFromJson: crate::test::TbExcelFromJson::new(&loader("test_tbexcelfromjson")),
            TbCompositeJsonTable1: crate::test::TbCompositeJsonTable1::new(&loader("test_tbcompositejsontable1")),
            TbCompositeJsonTable2: crate::test::TbCompositeJsonTable2::new(&loader("test_tbcompositejsontable2")),
            TbCompositeJsonTable3: crate::test::TbCompositeJsonTable3::new(&loader("test_tbcompositejsontable3")),
            TbExcelFromJsonMultiRow: crate::test::TbExcelFromJsonMultiRow::new(&loader("test_tbexcelfromjsonmultirow")),
            TbTestScriptableObject: crate::test::TbTestScriptableObject::new(&loader("test_tbtestscriptableobject")),
            TbPath: crate::test::TbPath::new(&loader("test_tbpath")),
            TbTestMapper: crate::test::TbTestMapper::new(&loader("test_tbtestmapper")),
            TbDefineFromExcel2: crate::test::TbDefineFromExcel2::new(&loader("test_tbdefinefromexcel2")),
        }
    }
}
