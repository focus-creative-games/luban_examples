
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

pub mod login;

use super::*;
use serde::Deserialize;

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum DemoEnum {
    NONE = 0,
    ///aa
    A = 1,
    ///bb
    B = 2,
    ///cc
    C = 4,
    ///dd
    D = 5,
    Any = 6,
}

impl From<i32> for DemoEnum {
    fn from(value: i32) -> Self {
        match value { 
            0 => DemoEnum::NONE,
            1 => DemoEnum::A,
            2 => DemoEnum::B,
            4 => DemoEnum::C,
            5 => DemoEnum::D,
            6 => DemoEnum::Any,
            _ => panic!("Invalid value for DemoEnum:{}", value),
        }
    }
}

bitflags::bitflags!{    
    #[derive(Debug, Hash, Eq, PartialEq)]
    pub struct DemoFlag : u32 {
        const A = 1;
        const B = 2;
        const C = 4;
        const D = 8;
    }
}
#[derive(Debug)]
pub struct TestExcelBean1 {
    /// 最高品质
    pub x1: i32,
    /// 黑色的
    pub x2: String,
    /// 蓝色的
    pub x3: i32,
    /// 最差品质
    pub x4: f32,
}

impl TestExcelBean1{
    pub fn new(json: &serde_json::Value) -> Result<TestExcelBean1, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x2 = json["x2"].as_str().unwrap().to_string();
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_f64().unwrap() as f32);
        
        Ok(TestExcelBean1 { x1, x2, x3, x4, })
    }
}

#[derive(Debug)]
pub struct DemoType2 {
    pub x4: i32,
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub x8_0: i16,
    pub x8: i32,
    pub x9: i64,
    pub x10: String,
    pub x12: crate::test::DemoType1,
    pub x13: crate::test::DemoEnum,
    pub x14: std::sync::Arc<AbstractBase>,
    pub s1: String,
    pub t1: u64,
    pub k1: Box<[i32]>,
    pub k2: Vec<i32>,
    pub k5: std::collections::HashSet<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k15: Box<[std::sync::Arc<AbstractBase>]>,
}

impl DemoType2{
    pub fn new(json: &serde_json::Value) -> Result<DemoType2, LubanError> {
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_bool().unwrap();
        let x2 = (json["x2"].as_u64().unwrap() as u8);
        let x3 = (json["x3"].as_i64().unwrap() as i16);
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let x7 = json["x7"].as_f64().unwrap();
        let x8_0 = (json["x8_0"].as_i64().unwrap() as i16);
        let x8 = (json["x8"].as_i64().unwrap() as i32);
        let x9 = json["x9"].as_i64().unwrap();
        let x10 = json["x10"].as_str().unwrap().to_string();
        let x12 = crate::test::DemoType1::new(&json["x12"])?;
        let x13 = json["x13"].as_i64().unwrap().into();
        let x14 = crate::test::DemoDynamic::new(&json["x14"])?;
        let s1 = json["s1"].as_str().unwrap().to_string();
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k2 = json["k2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k5 = json["k5"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| crate::test::DemoE2::new(&field).unwrap()).collect();
        let k15 = json["k15"].as_array().unwrap().iter().map(|field| crate::test::DemoDynamic::new(&field).unwrap()).collect();
        
        Ok(DemoType2 { x4, x1, x2, x3, x5, x6, x7, x8_0, x8, x9, x10, x12, x13, x14, s1, t1, k1, k2, k5, k8, k9, k15, })
    }
}

#[derive(Debug)]
pub struct DemoType1 {
    pub x1: i32,
}

impl DemoType1{
    pub fn new(json: &serde_json::Value) -> Result<DemoType1, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        
        Ok(DemoType1 { x1, })
    }
}

#[derive(Debug)]
pub struct DemoDynamic {
    pub x1: i32,
}

impl DemoDynamic {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "DemoD2" => Ok(std::sync::Arc::new(crate::test::DemoD2::new(json)?)),
            "DemoE1" => Ok(std::sync::Arc::new(crate::test::DemoE1::new(json)?)),
            "test.login.RoleInfo" => Ok(std::sync::Arc::new(crate::test::login::RoleInfo::new(json)?)),
            "DemoD5" => Ok(std::sync::Arc::new(crate::test::DemoD5::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoDynamic:{}", type_id)))
        }
    }
}

pub trait TDemoDynamic {
    fn get_x1(&self) -> &i32;
}

impl crate::test::TDemoDynamic for crate::test::DemoD2 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl crate::test::TDemoDynamic for crate::test::DemoE1 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl crate::test::TDemoDynamic for crate::test::login::RoleInfo {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl crate::test::TDemoDynamic for crate::test::DemoD5 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TDemoDynamic> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TDemoDynamic, LubanError> {
        let base: Result<&crate::test::DemoD2, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::DemoE1, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::login::RoleInfo, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::DemoD5, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoD2 {
    pub x1: i32,
    pub x2: i32,
}

impl DemoD2{
    pub fn new(json: &serde_json::Value) -> Result<DemoD2, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x2 = (json["x2"].as_i64().unwrap() as i32);
        
        Ok(DemoD2 { x1, x2, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoD3 {
    pub x1: i32,
    pub x3: i32,
}

impl DemoD3 {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "DemoE1" => Ok(std::sync::Arc::new(crate::test::DemoE1::new(json)?)),
            "test.login.RoleInfo" => Ok(std::sync::Arc::new(crate::test::login::RoleInfo::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoD3:{}", type_id)))
        }
    }
}

pub trait TDemoD3 {
    fn get_x1(&self) -> &i32;
    fn get_x3(&self) -> &i32;
}

impl crate::test::TDemoD3 for crate::test::DemoE1 {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
    fn get_x3(&self) -> &i32 {
        &self.x3
    }
}

impl crate::test::TDemoD3 for crate::test::login::RoleInfo {
    fn get_x1(&self) -> &i32 {
        &self.x1
    }
    fn get_x3(&self) -> &i32 {
        &self.x3
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TDemoD3> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TDemoD3, LubanError> {
        let base: Result<&crate::test::DemoE1, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::login::RoleInfo, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoE1 {
    pub x1: i32,
    pub x3: i32,
    pub x4: i32,
}

impl DemoE1{
    pub fn new(json: &serde_json::Value) -> Result<DemoE1, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        
        Ok(DemoE1 { x1, x3, x4, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DemoD5 {
    pub x1: i32,
    pub time: crate::test::DateTimeRange,
}

impl DemoD5{
    pub fn new(json: &serde_json::Value) -> Result<DemoD5, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let time = crate::test::DateTimeRange::new(&json["time"])?;
        
        Ok(DemoD5 { x1, time, })
    }
}

#[derive(Debug)]
pub struct DateTimeRange {
    pub start_time: u64,
    pub end_time: u64,
}

impl DateTimeRange{
    pub fn new(json: &serde_json::Value) -> Result<DateTimeRange, LubanError> {
        let start_time = (json["start_time"].as_i64().unwrap() as u64);
        let end_time = (json["end_time"].as_i64().unwrap() as u64);
        
        Ok(DateTimeRange { start_time, end_time, })
    }
}

#[derive(Debug)]
pub struct DemoE2 {
    pub y1: Option<i32>,
    pub y2: bool,
}

impl DemoE2{
    pub fn new(json: &serde_json::Value) -> Result<DemoE2, LubanError> {
        let mut y1 = None; if let Some(value) = json.get("y1") { y1 = Some((json["y1"].as_i64().unwrap() as i32)); }
        let y2 = json["y2"].as_bool().unwrap();
        
        Ok(DemoE2 { y1, y2, })
    }
}

#[derive(Debug)]
pub struct DemoSingletonType {
    pub id: i32,
    pub name: String,
    pub date: std::sync::Arc<AbstractBase>,
}

impl DemoSingletonType{
    pub fn new(json: &serde_json::Value) -> Result<DemoSingletonType, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let date = crate::test::DemoDynamic::new(&json["date"])?;
        
        Ok(DemoSingletonType { id, name, date, })
    }
}

#[derive(Debug)]
pub struct NotIndexList {
    pub x: i32,
    pub y: i32,
}

impl NotIndexList{
    pub fn new(json: &serde_json::Value) -> Result<NotIndexList, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        
        Ok(NotIndexList { x, y, })
    }
}

#[derive(Debug)]
pub struct MultiUnionIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiUnionIndexList{
    pub fn new(json: &serde_json::Value) -> Result<MultiUnionIndexList, LubanError> {
        let id1 = (json["id1"].as_i64().unwrap() as i32);
        let id2 = json["id2"].as_i64().unwrap();
        let id3 = json["id3"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        
        Ok(MultiUnionIndexList { id1, id2, id3, num, desc, })
    }
}

#[derive(Debug)]
pub struct MultiIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiIndexList{
    pub fn new(json: &serde_json::Value) -> Result<MultiIndexList, LubanError> {
        let id1 = (json["id1"].as_i64().unwrap() as i32);
        let id2 = json["id2"].as_i64().unwrap();
        let id3 = json["id3"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        
        Ok(MultiIndexList { id1, id2, id3, num, desc, })
    }
}

#[derive(Debug)]
pub struct MultiRowRecord {
    pub id: i32,
    pub name: String,
    pub one_rows: Vec<crate::test::MultiRowType1>,
    pub multi_rows1: Vec<crate::test::MultiRowType1>,
    pub multi_rows2: Box<[crate::test::MultiRowType1]>,
    pub multi_rows4: std::collections::HashMap<i32, crate::test::MultiRowType2>,
    pub multi_rows5: Vec<crate::test::MultiRowType3>,
    pub multi_rows6: std::collections::HashMap<i32, crate::test::MultiRowType2>,
    pub multi_rows7: std::collections::HashMap<i32, i32>,
}

impl MultiRowRecord{
    pub fn new(json: &serde_json::Value) -> Result<MultiRowRecord, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let one_rows = json["one_rows"].as_array().unwrap().iter().map(|field| crate::test::MultiRowType1::new(&field).unwrap()).collect();
        let multi_rows1 = json["multi_rows1"].as_array().unwrap().iter().map(|field| crate::test::MultiRowType1::new(&field).unwrap()).collect();
        let multi_rows2 = json["multi_rows2"].as_array().unwrap().iter().map(|field| crate::test::MultiRowType1::new(&field).unwrap()).collect();
        let multi_rows4 = std::collections::HashMap::from_iter(json["multi_rows4"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), crate::test::MultiRowType2::new(&array[1]).unwrap())}).collect::<Vec<(i32, crate::test::MultiRowType2)>>());
        let multi_rows5 = json["multi_rows5"].as_array().unwrap().iter().map(|field| crate::test::MultiRowType3::new(&field).unwrap()).collect();
        let multi_rows6 = std::collections::HashMap::from_iter(json["multi_rows6"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), crate::test::MultiRowType2::new(&array[1]).unwrap())}).collect::<Vec<(i32, crate::test::MultiRowType2)>>());
        let multi_rows7 = std::collections::HashMap::from_iter(json["multi_rows7"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        
        Ok(MultiRowRecord { id, name, one_rows, multi_rows1, multi_rows2, multi_rows4, multi_rows5, multi_rows6, multi_rows7, })
    }
}

#[derive(Debug)]
pub struct MultiRowType1 {
    pub id: i32,
    pub x: i32,
}

impl MultiRowType1{
    pub fn new(json: &serde_json::Value) -> Result<MultiRowType1, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = (json["x"].as_i64().unwrap() as i32);
        
        Ok(MultiRowType1 { id, x, })
    }
}

#[derive(Debug)]
pub struct MultiRowType2 {
    pub id: i32,
    pub x: i32,
    pub y: f32,
}

impl MultiRowType2{
    pub fn new(json: &serde_json::Value) -> Result<MultiRowType2, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_f64().unwrap() as f32);
        
        Ok(MultiRowType2 { id, x, y, })
    }
}

#[derive(Debug)]
pub struct MultiRowType3 {
    pub id: i32,
    pub items: Vec<crate::test::MultiRowType1>,
}

impl MultiRowType3{
    pub fn new(json: &serde_json::Value) -> Result<MultiRowType3, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let items = json["items"].as_array().unwrap().iter().map(|field| crate::test::MultiRowType1::new(&field).unwrap()).collect();
        
        Ok(MultiRowType3 { id, items, })
    }
}

#[derive(Debug)]
pub struct TestMultiColumn {
    pub id: i32,
    pub a: crate::test::Foo,
    pub b: crate::test::Foo,
    pub c: crate::test::Foo,
}

impl TestMultiColumn{
    pub fn new(json: &serde_json::Value) -> Result<TestMultiColumn, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let a = crate::test::Foo::new(&json["a"])?;
        let b = crate::test::Foo::new(&json["b"])?;
        let c = crate::test::Foo::new(&json["c"])?;
        
        Ok(TestMultiColumn { id, a, b, c, })
    }
}

#[derive(Debug)]
pub struct Foo {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
}

impl Foo{
    pub fn new(json: &serde_json::Value) -> Result<Foo, LubanError> {
        let y1 = (json["y1"].as_i64().unwrap() as i32);
        let y2 = (json["y2"].as_i64().unwrap() as i32);
        let y3 = (json["y3"].as_i64().unwrap() as i32);
        
        Ok(Foo { y1, y2, y3, })
    }
}

#[derive(Debug)]
pub struct MultiRowTitle {
    pub id: i32,
    pub name: String,
    pub x1: crate::test::H1,
    pub x2_0: Option<crate::test::H2>,
    pub x2: Vec<crate::test::H2>,
    pub x3: Box<[crate::test::H2]>,
    pub x4: Box<[crate::test::H2]>,
}

impl MultiRowTitle{
    pub fn new(json: &serde_json::Value) -> Result<MultiRowTitle, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let x1 = crate::test::H1::new(&json["x1"])?;
        let mut x2_0 = None; if let Some(value) = json.get("x2_0") { x2_0 = Some(crate::test::H2::new(&json["x2_0"])?); }
        let x2 = json["x2"].as_array().unwrap().iter().map(|field| crate::test::H2::new(&field).unwrap()).collect();
        let x3 = json["x3"].as_array().unwrap().iter().map(|field| crate::test::H2::new(&field).unwrap()).collect();
        let x4 = json["x4"].as_array().unwrap().iter().map(|field| crate::test::H2::new(&field).unwrap()).collect();
        
        Ok(MultiRowTitle { id, name, x1, x2_0, x2, x3, x4, })
    }
}

#[derive(Debug)]
pub struct H1 {
    pub y2: crate::test::H2,
    pub y3: i32,
}

impl H1{
    pub fn new(json: &serde_json::Value) -> Result<H1, LubanError> {
        let y2 = crate::test::H2::new(&json["y2"])?;
        let y3 = (json["y3"].as_i64().unwrap() as i32);
        
        Ok(H1 { y2, y3, })
    }
}

#[derive(Debug)]
pub struct H2 {
    pub z2: i32,
    pub z3: i32,
}

impl H2{
    pub fn new(json: &serde_json::Value) -> Result<H2, LubanError> {
        let z2 = (json["z2"].as_i64().unwrap() as i32);
        let z3 = (json["z3"].as_i64().unwrap() as i32);
        
        Ok(H2 { z2, z3, })
    }
}

#[derive(Debug)]
pub struct TestNull {
    pub id: i32,
    pub x1: Option<i32>,
    pub x2: Option<crate::test::DemoEnum>,
    pub x3: Option<crate::test::DemoType1>,
    pub x4: Option<std::sync::Arc<AbstractBase>>,
    pub s1: Option<String>,
    pub s2: Option<String>,
}

impl TestNull{
    pub fn new(json: &serde_json::Value) -> Result<TestNull, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let mut x1 = None; if let Some(value) = json.get("x1") { x1 = Some((json["x1"].as_i64().unwrap() as i32)); }
        let mut x2 = None; if let Some(value) = json.get("x2") { x2 = Some(json["x2"].as_i64().unwrap().into()); }
        let mut x3 = None; if let Some(value) = json.get("x3") { x3 = Some(crate::test::DemoType1::new(&json["x3"])?); }
        let mut x4 = None; if let Some(value) = json.get("x4") { x4 = Some(crate::test::DemoDynamic::new(&json["x4"])?); }
        let mut s1 = None; if let Some(value) = json.get("s1") { s1 = Some(json["s1"].as_str().unwrap().to_string()); }
        let mut s2 = None; if let Some(value) = json.get("s2") { s2 = Some(json["s2"].as_str().unwrap().to_string()); }
        
        Ok(TestNull { id, x1, x2, x3, x4, s1, s2, })
    }
}

#[derive(Debug)]
pub struct DemoPrimitiveTypesTable {
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x4: i32,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub s1: String,
    pub s2: String,
    pub v2: crate::vec2,
    pub v3: crate::vec3,
    pub v4: crate::vec4,
    pub t1: u64,
}

impl DemoPrimitiveTypesTable{
    pub fn new(json: &serde_json::Value) -> Result<DemoPrimitiveTypesTable, LubanError> {
        let x1 = json["x1"].as_bool().unwrap();
        let x2 = (json["x2"].as_u64().unwrap() as u8);
        let x3 = (json["x3"].as_i64().unwrap() as i16);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let x7 = json["x7"].as_f64().unwrap();
        let s1 = json["s1"].as_str().unwrap().to_string();
        let s2 = json["s2"].as_str().unwrap().to_string();
        let v2 = crate::vec2::new(&json["v2"])?;
        let v3 = crate::vec3::new(&json["v3"])?;
        let v4 = crate::vec4::new(&json["v4"])?;
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        
        Ok(DemoPrimitiveTypesTable { x1, x2, x3, x4, x5, x6, x7, s1, s2, v2, v3, v4, t1, })
    }
}

#[derive(Debug)]
pub struct TestString {
    pub id: String,
    pub s1: String,
    pub s2: String,
    pub cs1: crate::test::CompactString,
    pub cs2: crate::test::CompactString,
}

impl TestString{
    pub fn new(json: &serde_json::Value) -> Result<TestString, LubanError> {
        let id = json["id"].as_str().unwrap().to_string();
        let s1 = json["s1"].as_str().unwrap().to_string();
        let s2 = json["s2"].as_str().unwrap().to_string();
        let cs1 = crate::test::CompactString::new(&json["cs1"])?;
        let cs2 = crate::test::CompactString::new(&json["cs2"])?;
        
        Ok(TestString { id, s1, s2, cs1, cs2, })
    }
}

#[derive(Debug)]
pub struct CompactString {
    pub id: i32,
    pub s2: String,
    pub s3: String,
}

impl CompactString{
    pub fn new(json: &serde_json::Value) -> Result<CompactString, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let s2 = json["s2"].as_str().unwrap().to_string();
        let s3 = json["s3"].as_str().unwrap().to_string();
        
        Ok(CompactString { id, s2, s3, })
    }
}

#[derive(Debug)]
pub struct DemoGroup {
    pub id: i32,
    pub x1: i32,
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub x5: crate::test::InnerGroup,
}

impl DemoGroup{
    pub fn new(json: &serde_json::Value) -> Result<DemoGroup, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x2 = (json["x2"].as_i64().unwrap() as i32);
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x5 = crate::test::InnerGroup::new(&json["x5"])?;
        
        Ok(DemoGroup { id, x1, x2, x3, x4, x5, })
    }
}

#[derive(Debug)]
pub struct InnerGroup {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
    pub y4: i32,
}

impl InnerGroup{
    pub fn new(json: &serde_json::Value) -> Result<InnerGroup, LubanError> {
        let y1 = (json["y1"].as_i64().unwrap() as i32);
        let y2 = (json["y2"].as_i64().unwrap() as i32);
        let y3 = (json["y3"].as_i64().unwrap() as i32);
        let y4 = (json["y4"].as_i64().unwrap() as i32);
        
        Ok(InnerGroup { y1, y2, y3, y4, })
    }
}

#[derive(Debug)]
pub struct TestGlobal {
    pub unlock_equip: i32,
    pub unlock_hero: i32,
}

impl TestGlobal{
    pub fn new(json: &serde_json::Value) -> Result<TestGlobal, LubanError> {
        let unlock_equip = (json["unlock_equip"].as_i64().unwrap() as i32);
        let unlock_hero = (json["unlock_hero"].as_i64().unwrap() as i32);
        
        Ok(TestGlobal { unlock_equip, unlock_hero, })
    }
}

#[derive(Debug)]
pub struct TestBeRef {
    pub id: i32,
    pub count: i32,
}

impl TestBeRef{
    pub fn new(json: &serde_json::Value) -> Result<TestBeRef, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let count = (json["count"].as_i64().unwrap() as i32);
        
        Ok(TestBeRef { id, count, })
    }
}

#[derive(Debug)]
pub struct TestRef {
    pub id: i32,
    pub x1: i32,
    pub x1_2: i32,
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub a1: Box<[i32]>,
    pub a2: Box<[i32]>,
    pub b1: Vec<i32>,
    pub b2: Vec<i32>,
    pub c1: std::collections::HashSet<i32>,
    pub c2: std::collections::HashSet<i32>,
    pub d1: std::collections::HashMap<i32, i32>,
    pub d2: std::collections::HashMap<i32, i32>,
    pub e1: i32,
    pub e2: i64,
    pub e3: String,
    pub f1: i32,
    pub f2: i64,
    pub f3: String,
    pub s1: std::sync::Arc<AbstractBase>,
}

impl TestRef{
    pub fn new(json: &serde_json::Value) -> Result<TestRef, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x1_2 = (json["x1_2"].as_i64().unwrap() as i32);
        let x2 = (json["x2"].as_i64().unwrap() as i32);
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let a1 = json["a1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let a2 = json["a2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b1 = json["b1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b2 = json["b2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c1 = json["c1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c2 = json["c2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let d1 = std::collections::HashMap::from_iter(json["d1"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let d2 = std::collections::HashMap::from_iter(json["d2"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let e1 = (json["e1"].as_i64().unwrap() as i32);
        let e2 = json["e2"].as_i64().unwrap();
        let e3 = json["e3"].as_str().unwrap().to_string();
        let f1 = (json["f1"].as_i64().unwrap() as i32);
        let f2 = json["f2"].as_i64().unwrap();
        let f3 = json["f3"].as_str().unwrap().to_string();
        let s1 = crate::test::RefDynamicBase::new(&json["s1"])?;
        
        Ok(TestRef { id, x1, x1_2, x2, x3, x4, a1, a2, b1, b2, c1, c2, d1, d2, e1, e2, e3, f1, f2, f3, s1, })
    }
}

#[derive(Debug)]
pub struct RefDynamicBase {
    pub x: i32,
}

impl RefDynamicBase {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "RefBean" => Ok(std::sync::Arc::new(crate::test::RefBean::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for RefDynamicBase:{}", type_id)))
        }
    }
}

pub trait TRefDynamicBase {
    fn get_x(&self) -> &i32;
}

impl crate::test::TRefDynamicBase for crate::test::RefBean {
    fn get_x(&self) -> &i32 {
        &self.x
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TRefDynamicBase> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TRefDynamicBase, LubanError> {
        let base: Result<&crate::test::RefBean, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct RefBean {
    pub x: i32,
    pub arr: Vec<i32>,
}

impl RefBean{
    pub fn new(json: &serde_json::Value) -> Result<RefBean, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let arr = json["arr"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        
        Ok(RefBean { x, arr, })
    }
}

#[derive(Debug)]
pub struct TestSize {
    pub id: i32,
    pub x1: Box<[i32]>,
    pub x2: Vec<i32>,
    pub x3: std::collections::HashSet<i32>,
    pub x4: std::collections::HashMap<i32, i32>,
}

impl TestSize{
    pub fn new(json: &serde_json::Value) -> Result<TestSize, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x2 = json["x2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x3 = json["x3"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x4 = std::collections::HashMap::from_iter(json["x4"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        
        Ok(TestSize { id, x1, x2, x3, x4, })
    }
}

#[derive(Debug)]
pub struct TestSet {
    pub id: i32,
    pub x0: String,
    pub x1: Vec<i32>,
    pub x2: Vec<i64>,
    pub x3: Vec<String>,
    pub x4: Vec<crate::test::DemoEnum>,
}

impl TestSet{
    pub fn new(json: &serde_json::Value) -> Result<TestSet, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x0 = json["x0"].as_str().unwrap().to_string();
        let x1 = json["x1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x2 = json["x2"].as_array().unwrap().iter().map(|field| field.as_i64().unwrap()).collect();
        let x3 = json["x3"].as_array().unwrap().iter().map(|field| field.as_str().unwrap().to_string()).collect();
        let x4 = json["x4"].as_array().unwrap().iter().map(|field| field.as_i64().unwrap().into()).collect();
        
        Ok(TestSet { id, x0, x1, x2, x3, x4, })
    }
}

#[derive(Debug)]
pub struct DetectEncoding {
    pub id: i32,
    pub name: String,
}

impl DetectEncoding{
    pub fn new(json: &serde_json::Value) -> Result<DetectEncoding, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        
        Ok(DetectEncoding { id, name, })
    }
}

#[derive(Debug)]
pub struct ItemBase {
    pub id: i32,
    pub name: String,
    pub desc: String,
}

impl ItemBase {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Item" => Ok(std::sync::Arc::new(crate::test::Item::new(json)?)),
            "Equipment" => Ok(std::sync::Arc::new(crate::test::Equipment::new(json)?)),
            "Decorator" => Ok(std::sync::Arc::new(crate::test::Decorator::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for ItemBase:{}", type_id)))
        }
    }
}

pub trait TItemBase {
    fn get_id(&self) -> &i32;
    fn get_name(&self) -> &String;
    fn get_desc(&self) -> &String;
}

impl crate::test::TItemBase for crate::test::Item {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_name(&self) -> &String {
        &self.name
    }
    fn get_desc(&self) -> &String {
        &self.desc
    }
}

impl crate::test::TItemBase for crate::test::Equipment {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_name(&self) -> &String {
        &self.name
    }
    fn get_desc(&self) -> &String {
        &self.desc
    }
}

impl crate::test::TItemBase for crate::test::Decorator {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_name(&self) -> &String {
        &self.name
    }
    fn get_desc(&self) -> &String {
        &self.desc
    }
}

impl<'a> GetBase<'a, &'a dyn crate::test::TItemBase> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TItemBase, LubanError> {
        let base: Result<&crate::test::Item, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::Equipment, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::Decorator, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Item {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub num: i32,
    pub price: i32,
}

impl Item{
    pub fn new(json: &serde_json::Value) -> Result<Item, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let price = (json["price"].as_i64().unwrap() as i32);
        
        Ok(Item { id, name, desc, num, price, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Equipment {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub attr: crate::test::DemoEnum,
    pub value: i32,
}

impl Equipment{
    pub fn new(json: &serde_json::Value) -> Result<Equipment, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let attr = json["attr"].as_i64().unwrap().into();
        let value = (json["value"].as_i64().unwrap() as i32);
        
        Ok(Equipment { id, name, desc, attr, value, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Decorator {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub duration: i32,
}

impl Decorator{
    pub fn new(json: &serde_json::Value) -> Result<Decorator, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let duration = (json["duration"].as_i64().unwrap() as i32);
        
        Ok(Decorator { id, name, desc, duration, })
    }
}

#[derive(Debug)]
pub struct TestIndex {
    pub id: i32,
    pub eles: Vec<crate::test::DemoType1>,
}

impl TestIndex{
    pub fn new(json: &serde_json::Value) -> Result<TestIndex, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let eles = json["eles"].as_array().unwrap().iter().map(|field| crate::test::DemoType1::new(&field).unwrap()).collect();
        
        Ok(TestIndex { id, eles, })
    }
}

#[derive(Debug)]
pub struct TestMap {
    pub id: i32,
    pub x1: std::collections::HashMap<i32, i32>,
    pub x2: std::collections::HashMap<i64, i32>,
    pub x3: std::collections::HashMap<String, i32>,
    pub x4: std::collections::HashMap<crate::test::DemoEnum, i32>,
}

impl TestMap{
    pub fn new(json: &serde_json::Value) -> Result<TestMap, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = std::collections::HashMap::from_iter(json["x1"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let x2 = std::collections::HashMap::from_iter(json["x2"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();(array[0].as_i64().unwrap(), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i64, i32)>>());
        let x3 = std::collections::HashMap::from_iter(json["x3"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();(array[0].as_str().unwrap().to_string(), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(String, i32)>>());
        let x4 = std::collections::HashMap::from_iter(json["x4"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();(array[0].as_i64().unwrap().into(), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(crate::test::DemoEnum, i32)>>());
        
        Ok(TestMap { id, x1, x2, x3, x4, })
    }
}

#[derive(Debug)]
pub struct ExcelFromJson {
    pub x4: i32,
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub s1: String,
    pub s2: String,
    pub t1: u64,
    pub x12: crate::test::DemoType1,
    pub x13: crate::test::DemoEnum,
    pub x14: std::sync::Arc<AbstractBase>,
    pub k1: Box<[i32]>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k15: Box<[std::sync::Arc<AbstractBase>]>,
}

impl ExcelFromJson{
    pub fn new(json: &serde_json::Value) -> Result<ExcelFromJson, LubanError> {
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_bool().unwrap();
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let s1 = json["s1"].as_str().unwrap().to_string();
        let s2 = json["s2"].as_str().unwrap().to_string();
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        let x12 = crate::test::DemoType1::new(&json["x12"])?;
        let x13 = json["x13"].as_i64().unwrap().into();
        let x14 = crate::test::DemoDynamic::new(&json["x14"])?;
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| crate::test::DemoE2::new(&field).unwrap()).collect();
        let k15 = json["k15"].as_array().unwrap().iter().map(|field| crate::test::DemoDynamic::new(&field).unwrap()).collect();
        
        Ok(ExcelFromJson { x4, x1, x5, x6, s1, s2, t1, x12, x13, x14, k1, k8, k9, k15, })
    }
}

#[derive(Debug)]
pub struct CompositeJsonTable1 {
    pub id: i32,
    pub x: String,
}

impl CompositeJsonTable1{
    pub fn new(json: &serde_json::Value) -> Result<CompositeJsonTable1, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = json["x"].as_str().unwrap().to_string();
        
        Ok(CompositeJsonTable1 { id, x, })
    }
}

#[derive(Debug)]
pub struct CompositeJsonTable2 {
    pub id: i32,
    pub y: i32,
}

impl CompositeJsonTable2{
    pub fn new(json: &serde_json::Value) -> Result<CompositeJsonTable2, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        
        Ok(CompositeJsonTable2 { id, y, })
    }
}

#[derive(Debug)]
pub struct CompositeJsonTable3 {
    pub a: i32,
    pub b: i32,
}

impl CompositeJsonTable3{
    pub fn new(json: &serde_json::Value) -> Result<CompositeJsonTable3, LubanError> {
        let a = (json["a"].as_i64().unwrap() as i32);
        let b = (json["b"].as_i64().unwrap() as i32);
        
        Ok(CompositeJsonTable3 { a, b, })
    }
}

#[derive(Debug)]
pub struct ExcelFromJsonMultiRow {
    pub id: i32,
    pub x: i32,
    pub items: Vec<crate::test::TestRow>,
}

impl ExcelFromJsonMultiRow{
    pub fn new(json: &serde_json::Value) -> Result<ExcelFromJsonMultiRow, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = (json["x"].as_i64().unwrap() as i32);
        let items = json["items"].as_array().unwrap().iter().map(|field| crate::test::TestRow::new(&field).unwrap()).collect();
        
        Ok(ExcelFromJsonMultiRow { id, x, items, })
    }
}

#[derive(Debug)]
pub struct TestRow {
    pub x: i32,
    pub y: bool,
    pub z: String,
    pub a: crate::test::Test3,
    pub b: Vec<i32>,
}

impl TestRow{
    pub fn new(json: &serde_json::Value) -> Result<TestRow, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = json["y"].as_bool().unwrap();
        let z = json["z"].as_str().unwrap().to_string();
        let a = crate::test::Test3::new(&json["a"])?;
        let b = json["b"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        
        Ok(TestRow { x, y, z, a, b, })
    }
}

#[derive(Debug)]
pub struct Test3 {
    pub x: i32,
    pub y: i32,
}

impl Test3{
    pub fn new(json: &serde_json::Value) -> Result<Test3, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        
        Ok(Test3 { x, y, })
    }
}

#[derive(Debug)]
pub struct TestScriptableObject {
    pub id: i32,
    pub desc: String,
    pub rate: f32,
    pub num: i32,
    pub v2: crate::vec2,
    pub v3: crate::vec3,
    pub v4: crate::vec4,
}

impl TestScriptableObject{
    pub fn new(json: &serde_json::Value) -> Result<TestScriptableObject, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        let rate = (json["rate"].as_f64().unwrap() as f32);
        let num = (json["num"].as_i64().unwrap() as i32);
        let v2 = crate::vec2::new(&json["v2"])?;
        let v3 = crate::vec3::new(&json["v3"])?;
        let v4 = crate::vec4::new(&json["v4"])?;
        
        Ok(TestScriptableObject { id, desc, rate, num, v2, v3, v4, })
    }
}

#[derive(Debug)]
pub struct Path {
    pub id: i32,
    pub res: String,
}

impl Path{
    pub fn new(json: &serde_json::Value) -> Result<Path, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let res = json["res"].as_str().unwrap().to_string();
        
        Ok(Path { id, res, })
    }
}

#[derive(Debug)]
pub struct TestMapper {
    pub id: i32,
    pub audio_type: crate::AudioType,
    pub v2: crate::vec2,
}

impl TestMapper{
    pub fn new(json: &serde_json::Value) -> Result<TestMapper, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let audio_type = json["audio_type"].as_i64().unwrap().into();
        let v2 = crate::vec2::new(&json["v2"])?;
        
        Ok(TestMapper { id, audio_type, v2, })
    }
}

#[derive(Debug)]
pub struct Shape {
}

impl Shape {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Circle" => Ok(std::sync::Arc::new(crate::test::Circle::new(json)?)),
            "test2.Rectangle" => Ok(std::sync::Arc::new(crate::test2::Rectangle::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Shape:{}", type_id)))
        }
    }
}

pub trait TShape {
}

impl crate::test::TShape for crate::test::Circle {
}

impl crate::test::TShape for crate::test2::Rectangle {
}

impl<'a> GetBase<'a, &'a dyn crate::test::TShape> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TShape, LubanError> {
        let base: Result<&crate::test::Circle, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test2::Rectangle, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Circle {
    /// 半径
    pub radius: f32,
}

impl Circle{
    pub fn new(json: &serde_json::Value) -> Result<Circle, LubanError> {
        let radius = (json["radius"].as_f64().unwrap() as f32);
        
        Ok(Circle { radius, })
    }
}


#[derive(Debug)]
pub struct TbFullTypes {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>>,
}

impl TbFullTypes {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbFullTypes>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoType2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DemoType2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbFullTypes { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbFullTypes {
    type Output = std::sync::Arc<crate::test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbSingleton {
    pub data: crate::test::DemoSingletonType,
}

impl TbSingleton {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbSingleton>, LubanError> {
        let json = json.as_array().unwrap();
        let n = json.len();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::DemoSingletonType::new(&json[0])?;
        Ok(std::sync::Arc::new(TbSingleton { data }))
    }
}


#[derive(Debug)]
pub struct TbNotIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::NotIndexList>>,
}

impl TbNotIndexList {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbNotIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::NotIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::NotIndexList::new(&x)?);
            data_list.push(row.clone());
        }

    Ok(std::sync::Arc::new(TbNotIndexList { 
            data_list,
        }))
    }

}


#[derive(Debug)]
pub struct TbMultiUnionIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>>,
    pub data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<crate::test::MultiUnionIndexList>>,
}

impl TbMultiUnionIndexList {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiUnionIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::MultiUnionIndexList::new(&x)?);
            data_list.push(row.clone());
        }
        let mut data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<crate::test::MultiUnionIndexList>> = Default::default();
        for x in &data_list {
            data_map_union.insert((x.id1, x.id2, x.id3.clone()), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiUnionIndexList { 
            data_list,
            data_map_union,
        }))
    }

    pub fn get(&self, key: &(i32, i64, String)) -> Option<std::sync::Arc<crate::test::MultiUnionIndexList>> {
        self.data_map_union.get(key).map(|x| x.clone())
    }
}


#[derive(Debug)]
pub struct TbMultiIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id1: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id2: std::collections::HashMap<i64, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id3: std::collections::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>>,
}

impl TbMultiIndexList {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::MultiIndexList::new(&x)?);
            data_list.push(row.clone());
        }
        let mut data_map_id1: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id2: std::collections::HashMap<i64, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id3: std::collections::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        for x in &data_list {
            data_map_id1.insert(x.id1.clone(), x.clone());
            data_map_id2.insert(x.id2.clone(), x.clone());
            data_map_id3.insert(x.id3.clone(), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiIndexList { 
            data_list,
            data_map_id1,
            data_map_id2,
            data_map_id3,
        }))
    }

    pub fn get_by_id1(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id1.get(key).map(|x| x.clone())
    }
    pub fn get_by_id2(&self, key: &i64) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id2.get(key).map(|x| x.clone())
    }
    pub fn get_by_id3(&self, key: &String) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id3.get(key).map(|x| x.clone())
    }
}


#[derive(Debug)]
pub struct TbDataFromMisc {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>>,
}

impl TbDataFromMisc {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDataFromMisc>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoType2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DemoType2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDataFromMisc { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDataFromMisc {
    type Output = std::sync::Arc<crate::test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowRecord {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiRowRecord>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowRecord>>,
}

impl TbMultiRowRecord {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiRowRecord>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowRecord>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiRowRecord>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::MultiRowRecord::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowRecord { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiRowRecord>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbMultiRowRecord {
    type Output = std::sync::Arc<crate::test::MultiRowRecord>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMultiColumn {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMultiColumn>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMultiColumn>>,
}

impl TbTestMultiColumn {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestMultiColumn>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMultiColumn>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMultiColumn>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestMultiColumn::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMultiColumn { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMultiColumn>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestMultiColumn {
    type Output = std::sync::Arc<crate::test::TestMultiColumn>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowTitle {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiRowTitle>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowTitle>>,
}

impl TbMultiRowTitle {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiRowTitle>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowTitle>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiRowTitle>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::MultiRowTitle::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowTitle { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiRowTitle>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbMultiRowTitle {
    type Output = std::sync::Arc<crate::test::MultiRowTitle>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestNull {
    pub data_list: Vec<std::sync::Arc<crate::test::TestNull>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestNull>>,
}

impl TbTestNull {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestNull>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestNull>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestNull>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestNull::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestNull { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestNull>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestNull {
    type Output = std::sync::Arc<crate::test::TestNull>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoPrimitive {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoPrimitiveTypesTable>>,
}

impl TbDemoPrimitive {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoPrimitive>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DemoPrimitiveTypesTable::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoPrimitive { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoPrimitive {
    type Output = std::sync::Arc<crate::test::DemoPrimitiveTypesTable>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestString {
    pub data_list: Vec<std::sync::Arc<crate::test::TestString>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::test::TestString>>,
}

impl TbTestString {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestString>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<crate::test::TestString>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestString>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestString::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestString { data_map, data_list }))
    }

    pub fn get(&self, key: &String) -> Option<std::sync::Arc<crate::test::TestString>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<String> for TbTestString {
    type Output = std::sync::Arc<crate::test::TestString>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_C {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_C {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup_C>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_C { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup_C {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_S {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_S {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup_S>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_S { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup_S {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_E {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_E {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup_E>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_E { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDemoGroup_E {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestGlobal {
    pub data: crate::test::TestGlobal,
}

impl TbTestGlobal {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestGlobal>, LubanError> {
        let json = json.as_array().unwrap();
        let n = json.len();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::TestGlobal::new(&json[0])?;
        Ok(std::sync::Arc::new(TbTestGlobal { data }))
    }
}


#[derive(Debug)]
pub struct TbTestBeRef {
    pub data_list: Vec<std::sync::Arc<crate::test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>>,
}

impl TbTestBeRef {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestBeRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestBeRef>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestBeRef::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestBeRef {
    type Output = std::sync::Arc<crate::test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestBeRef2 {
    pub data_list: Vec<std::sync::Arc<crate::test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>>,
}

impl TbTestBeRef2 {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestBeRef2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestBeRef>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestBeRef::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestBeRef2 {
    type Output = std::sync::Arc<crate::test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestRef {
    pub data_list: Vec<std::sync::Arc<crate::test::TestRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRef>>,
}

impl TbTestRef {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestRef>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestRef::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestRef {
    type Output = std::sync::Arc<crate::test::TestRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSize {
    pub data_list: Vec<std::sync::Arc<crate::test::TestSize>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSize>>,
}

impl TbTestSize {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestSize>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSize>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestSize>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestSize::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSize { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestSize>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestSize {
    type Output = std::sync::Arc<crate::test::TestSize>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSet {
    pub data_list: Vec<std::sync::Arc<crate::test::TestSet>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSet>>,
}

impl TbTestSet {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestSet>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSet>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestSet>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestSet::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSet { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestSet>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestSet {
    type Output = std::sync::Arc<crate::test::TestSet>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDetectCsvEncoding {
    pub data_list: Vec<std::sync::Arc<crate::test::DetectEncoding>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DetectEncoding>>,
}

impl TbDetectCsvEncoding {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDetectCsvEncoding>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DetectEncoding>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DetectEncoding>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::DetectEncoding::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDetectCsvEncoding { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DetectEncoding>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDetectCsvEncoding {
    type Output = std::sync::Arc<crate::test::DetectEncoding>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbItem2 {
    pub data_list: Vec<std::sync::Arc<AbstractBase>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<AbstractBase>>,
}

impl TbItem2 {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbItem2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<AbstractBase>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<AbstractBase>> = vec![];

        for x in json.as_array().unwrap() {
            let row = crate::test::ItemBase::new(&x)?;
            data_list.push(row.clone());
            let key = <AbstractBase as GetBase<&dyn crate::test::TItemBase>>::get_base(std::ops::Deref::deref(&row))?;
            data_map.insert(key.get_id().clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbItem2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<AbstractBase>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbItem2 {
    type Output = std::sync::Arc<AbstractBase>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestIndex {
    pub data_list: Vec<std::sync::Arc<crate::test::TestIndex>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestIndex>>,
}

impl TbTestIndex {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestIndex>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestIndex>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestIndex>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestIndex::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestIndex { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestIndex>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestIndex {
    type Output = std::sync::Arc<crate::test::TestIndex>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMap {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMap>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMap>>,
}

impl TbTestMap {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestMap>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMap>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMap>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestMap::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMap { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMap>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestMap {
    type Output = std::sync::Arc<crate::test::TestMap>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbExcelFromJson {
    pub data_list: Vec<std::sync::Arc<crate::test::ExcelFromJson>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJson>>,
}

impl TbExcelFromJson {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbExcelFromJson>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJson>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::ExcelFromJson>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::ExcelFromJson::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJson { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::ExcelFromJson>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbExcelFromJson {
    type Output = std::sync::Arc<crate::test::ExcelFromJson>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable1 {
    pub data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable1>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable1>>,
}

impl TbCompositeJsonTable1 {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbCompositeJsonTable1>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable1>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable1>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::CompositeJsonTable1::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable1 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::CompositeJsonTable1>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable1 {
    type Output = std::sync::Arc<crate::test::CompositeJsonTable1>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable2 {
    pub data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable2>>,
}

impl TbCompositeJsonTable2 {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbCompositeJsonTable2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::CompositeJsonTable2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::CompositeJsonTable2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable2 {
    type Output = std::sync::Arc<crate::test::CompositeJsonTable2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable3 {
    pub data: crate::test::CompositeJsonTable3,
}

impl TbCompositeJsonTable3 {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbCompositeJsonTable3>, LubanError> {
        let json = json.as_array().unwrap();
        let n = json.len();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::CompositeJsonTable3::new(&json[0])?;
        Ok(std::sync::Arc::new(TbCompositeJsonTable3 { data }))
    }
}


#[derive(Debug)]
pub struct TbExcelFromJsonMultiRow {
    pub data_list: Vec<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJsonMultiRow>>,
}

impl TbExcelFromJsonMultiRow {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbExcelFromJsonMultiRow>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::ExcelFromJsonMultiRow::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJsonMultiRow { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbExcelFromJsonMultiRow {
    type Output = std::sync::Arc<crate::test::ExcelFromJsonMultiRow>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestScriptableObject {
    pub data_list: Vec<std::sync::Arc<crate::test::TestScriptableObject>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestScriptableObject>>,
}

impl TbTestScriptableObject {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestScriptableObject>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestScriptableObject>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestScriptableObject>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestScriptableObject::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestScriptableObject { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestScriptableObject>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestScriptableObject {
    type Output = std::sync::Arc<crate::test::TestScriptableObject>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbPath {
    pub data_list: Vec<std::sync::Arc<crate::test::Path>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::Path>>,
}

impl TbPath {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbPath>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::Path>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::Path>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::Path::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbPath { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::Path>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbPath {
    type Output = std::sync::Arc<crate::test::Path>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMapper {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMapper>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMapper>>,
}

impl TbTestMapper {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestMapper>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMapper>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMapper>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::TestMapper::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMapper { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMapper>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbTestMapper {
    type Output = std::sync::Arc<crate::test::TestMapper>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDefineFromExcel2 {
    pub data_list: Vec<std::sync::Arc<crate::DefineFromExcel2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::DefineFromExcel2>>,
}

impl TbDefineFromExcel2 {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDefineFromExcel2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::DefineFromExcel2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::DefineFromExcel2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::DefineFromExcel2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDefineFromExcel2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::DefineFromExcel2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbDefineFromExcel2 {
    type Output = std::sync::Arc<crate::DefineFromExcel2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


