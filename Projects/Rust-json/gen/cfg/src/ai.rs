
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use serde::Deserialize;

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS1 = 8,
    ENUM1 = 9,
    OBJECT = 10,
}

impl From<i32> for EKeyType {
    fn from(value: i32) -> Self {
        match value { 
            1 => EKeyType::BOOL,
            2 => EKeyType::INT,
            3 => EKeyType::FLOAT,
            4 => EKeyType::STRING,
            5 => EKeyType::VECTOR,
            6 => EKeyType::ROTATOR,
            7 => EKeyType::NAME,
            8 => EKeyType::CLASS1,
            9 => EKeyType::ENUM1,
            10 => EKeyType::OBJECT,
            _ => panic!("Invalid value for EKeyType:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}

impl From<i32> for EFlowAbortMode {
    fn from(value: i32) -> Self {
        match value { 
            0 => EFlowAbortMode::NONE,
            1 => EFlowAbortMode::LOWER_PRIORITY,
            2 => EFlowAbortMode::SELF,
            3 => EFlowAbortMode::BOTH,
            _ => panic!("Invalid value for EFlowAbortMode:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}

impl From<i32> for ENotifyObserverMode {
    fn from(value: i32) -> Self {
        match value { 
            0 => ENotifyObserverMode::ON_VALUE_CHANGE,
            1 => ENotifyObserverMode::ON_RESULT_CHANGE,
            _ => panic!("Invalid value for ENotifyObserverMode:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}

impl From<i32> for EOperator {
    fn from(value: i32) -> Self {
        match value { 
            0 => EOperator::IS_EQUAL_TO,
            1 => EOperator::IS_NOT_EQUAL_TO,
            2 => EOperator::IS_LESS_THAN,
            3 => EOperator::IS_LESS_THAN_OR_EQUAL_TO,
            4 => EOperator::IS_GREAT_THAN,
            5 => EOperator::IS_GREAT_THAN_OR_EQUAL_TO,
            6 => EOperator::CONTAINS,
            7 => EOperator::NOT_CONTAINS,
            _ => panic!("Invalid value for EOperator:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}

impl From<i32> for EFinishMode {
    fn from(value: i32) -> Self {
        match value { 
            0 => EFinishMode::IMMEDIATE,
            1 => EFinishMode::DELAYED,
            _ => panic!("Invalid value for EFinishMode:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct Blackboard {
    pub name: String,
    pub desc: String,
    pub parent_name: String,
    pub keys: Vec<crate::ai::BlackboardKey>,
}

impl Blackboard{
    pub fn new(json: &serde_json::Value) -> Result<Blackboard, LubanError> {
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let parent_name = json["parent_name"].as_str().unwrap().to_string();
        let keys = json["keys"].as_array().unwrap().iter().map(|field| crate::ai::BlackboardKey::new(&field).unwrap()).collect();
        
        Ok(Blackboard { name, desc, parent_name, keys, })
    }
}

#[derive(Debug)]
pub struct BlackboardKey {
    pub name: String,
    pub desc: String,
    pub is_static: bool,
    pub key_type: crate::ai::EKeyType,
    pub type_class_name: String,
}

impl BlackboardKey{
    pub fn new(json: &serde_json::Value) -> Result<BlackboardKey, LubanError> {
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let is_static = json["is_static"].as_bool().unwrap();
        let key_type = json["key_type"].as_i64().unwrap().into();
        let type_class_name = json["type_class_name"].as_str().unwrap().to_string();
        
        Ok(BlackboardKey { name, desc, is_static, key_type, type_class_name, })
    }
}

#[derive(Debug)]
pub struct BehaviorTree {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub blackboard_id: String,
    pub root: std::sync::Arc<AbstractBase>,
}

impl BehaviorTree{
    pub fn new(json: &serde_json::Value) -> Result<BehaviorTree, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let blackboard_id = json["blackboard_id"].as_str().unwrap().to_string();
        let root = crate::ai::ComposeNode::new(&json["root"])?;
        
        Ok(BehaviorTree { id, name, desc, blackboard_id, root, })
    }
}

#[derive(Debug)]
pub struct Node {
    pub id: i32,
    pub node_name: String,
}

impl Node {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeSetDefaultFocus" => Ok(std::sync::Arc::new(crate::ai::UeSetDefaultFocus::new(json)?)),
            "ExecuteTimeStatistic" => Ok(std::sync::Arc::new(crate::ai::ExecuteTimeStatistic::new(json)?)),
            "ChooseTarget" => Ok(std::sync::Arc::new(crate::ai::ChooseTarget::new(json)?)),
            "KeepFaceTarget" => Ok(std::sync::Arc::new(crate::ai::KeepFaceTarget::new(json)?)),
            "GetOwnerPlayer" => Ok(std::sync::Arc::new(crate::ai::GetOwnerPlayer::new(json)?)),
            "UpdateDailyBehaviorProps" => Ok(std::sync::Arc::new(crate::ai::UpdateDailyBehaviorProps::new(json)?)),
            "UeLoop" => Ok(std::sync::Arc::new(crate::ai::UeLoop::new(json)?)),
            "UeCooldown" => Ok(std::sync::Arc::new(crate::ai::UeCooldown::new(json)?)),
            "UeTimeLimit" => Ok(std::sync::Arc::new(crate::ai::UeTimeLimit::new(json)?)),
            "UeBlackboard" => Ok(std::sync::Arc::new(crate::ai::UeBlackboard::new(json)?)),
            "UeForceSuccess" => Ok(std::sync::Arc::new(crate::ai::UeForceSuccess::new(json)?)),
            "IsAtLocation" => Ok(std::sync::Arc::new(crate::ai::IsAtLocation::new(json)?)),
            "DistanceLessThan" => Ok(std::sync::Arc::new(crate::ai::DistanceLessThan::new(json)?)),
            "Sequence" => Ok(std::sync::Arc::new(crate::ai::Sequence::new(json)?)),
            "Selector" => Ok(std::sync::Arc::new(crate::ai::Selector::new(json)?)),
            "SimpleParallel" => Ok(std::sync::Arc::new(crate::ai::SimpleParallel::new(json)?)),
            "UeWait" => Ok(std::sync::Arc::new(crate::ai::UeWait::new(json)?)),
            "UeWaitBlackboardTime" => Ok(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(json)?)),
            "MoveToTarget" => Ok(std::sync::Arc::new(crate::ai::MoveToTarget::new(json)?)),
            "ChooseSkill" => Ok(std::sync::Arc::new(crate::ai::ChooseSkill::new(json)?)),
            "MoveToRandomLocation" => Ok(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(json)?)),
            "MoveToLocation" => Ok(std::sync::Arc::new(crate::ai::MoveToLocation::new(json)?)),
            "DebugPrint" => Ok(std::sync::Arc::new(crate::ai::DebugPrint::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Node:{}", type_id)))
        }
    }
}

pub trait TNode {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
}

impl crate::ai::TNode for crate::ai::UeSetDefaultFocus {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::ExecuteTimeStatistic {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::ChooseTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::KeepFaceTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::GetOwnerPlayer {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UpdateDailyBehaviorProps {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeLoop {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeCooldown {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeTimeLimit {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeBlackboard {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeForceSuccess {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::IsAtLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::DistanceLessThan {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::Sequence {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::Selector {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::SimpleParallel {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeWait {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::UeWaitBlackboardTime {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::MoveToTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::ChooseSkill {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::MoveToRandomLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::MoveToLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TNode for crate::ai::DebugPrint {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TNode> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TNode, LubanError> {
        let base: Result<&crate::ai::UeSetDefaultFocus, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ExecuteTimeStatistic, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::KeepFaceTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::GetOwnerPlayer, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UpdateDailyBehaviorProps, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeLoop, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeCooldown, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeTimeLimit, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeBlackboard, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeForceSuccess, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IsAtLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DistanceLessThan, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Sequence, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Selector, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::SimpleParallel, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWait, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWaitBlackboardTime, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseSkill, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToRandomLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DebugPrint, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Service {
    pub id: i32,
    pub node_name: String,
}

impl Service {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeSetDefaultFocus" => Ok(std::sync::Arc::new(crate::ai::UeSetDefaultFocus::new(json)?)),
            "ExecuteTimeStatistic" => Ok(std::sync::Arc::new(crate::ai::ExecuteTimeStatistic::new(json)?)),
            "ChooseTarget" => Ok(std::sync::Arc::new(crate::ai::ChooseTarget::new(json)?)),
            "KeepFaceTarget" => Ok(std::sync::Arc::new(crate::ai::KeepFaceTarget::new(json)?)),
            "GetOwnerPlayer" => Ok(std::sync::Arc::new(crate::ai::GetOwnerPlayer::new(json)?)),
            "UpdateDailyBehaviorProps" => Ok(std::sync::Arc::new(crate::ai::UpdateDailyBehaviorProps::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Service:{}", type_id)))
        }
    }
}

pub trait TService {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
}

impl crate::ai::TService for crate::ai::UeSetDefaultFocus {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::ExecuteTimeStatistic {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::ChooseTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::KeepFaceTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::GetOwnerPlayer {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl crate::ai::TService for crate::ai::UpdateDailyBehaviorProps {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TService> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TService, LubanError> {
        let base: Result<&crate::ai::UeSetDefaultFocus, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ExecuteTimeStatistic, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::KeepFaceTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::GetOwnerPlayer, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UpdateDailyBehaviorProps, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeSetDefaultFocus {
    pub id: i32,
    pub node_name: String,
    pub keyboard_key: String,
}

impl UeSetDefaultFocus{
    pub fn new(json: &serde_json::Value) -> Result<UeSetDefaultFocus, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let keyboard_key = json["keyboard_key"].as_str().unwrap().to_string();
        
        Ok(UeSetDefaultFocus { id, node_name, keyboard_key, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ExecuteTimeStatistic {
    pub id: i32,
    pub node_name: String,
}

impl ExecuteTimeStatistic{
    pub fn new(json: &serde_json::Value) -> Result<ExecuteTimeStatistic, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        
        Ok(ExecuteTimeStatistic { id, node_name, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ChooseTarget {
    pub id: i32,
    pub node_name: String,
    pub result_target_key: String,
}

impl ChooseTarget{
    pub fn new(json: &serde_json::Value) -> Result<ChooseTarget, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let result_target_key = json["result_target_key"].as_str().unwrap().to_string();
        
        Ok(ChooseTarget { id, node_name, result_target_key, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct KeepFaceTarget {
    pub id: i32,
    pub node_name: String,
    pub target_actor_key: String,
}

impl KeepFaceTarget{
    pub fn new(json: &serde_json::Value) -> Result<KeepFaceTarget, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let target_actor_key = json["target_actor_key"].as_str().unwrap().to_string();
        
        Ok(KeepFaceTarget { id, node_name, target_actor_key, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct GetOwnerPlayer {
    pub id: i32,
    pub node_name: String,
    pub player_actor_key: String,
}

impl GetOwnerPlayer{
    pub fn new(json: &serde_json::Value) -> Result<GetOwnerPlayer, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let player_actor_key = json["player_actor_key"].as_str().unwrap().to_string();
        
        Ok(GetOwnerPlayer { id, node_name, player_actor_key, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UpdateDailyBehaviorProps {
    pub id: i32,
    pub node_name: String,
    pub satiety_key: String,
    pub energy_key: String,
    pub mood_key: String,
    pub satiety_lower_threshold_key: String,
    pub satiety_upper_threshold_key: String,
    pub energy_lower_threshold_key: String,
    pub energy_upper_threshold_key: String,
    pub mood_lower_threshold_key: String,
    pub mood_upper_threshold_key: String,
}

impl UpdateDailyBehaviorProps{
    pub fn new(json: &serde_json::Value) -> Result<UpdateDailyBehaviorProps, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let satiety_key = json["satiety_key"].as_str().unwrap().to_string();
        let energy_key = json["energy_key"].as_str().unwrap().to_string();
        let mood_key = json["mood_key"].as_str().unwrap().to_string();
        let satiety_lower_threshold_key = json["satiety_lower_threshold_key"].as_str().unwrap().to_string();
        let satiety_upper_threshold_key = json["satiety_upper_threshold_key"].as_str().unwrap().to_string();
        let energy_lower_threshold_key = json["energy_lower_threshold_key"].as_str().unwrap().to_string();
        let energy_upper_threshold_key = json["energy_upper_threshold_key"].as_str().unwrap().to_string();
        let mood_lower_threshold_key = json["mood_lower_threshold_key"].as_str().unwrap().to_string();
        let mood_upper_threshold_key = json["mood_upper_threshold_key"].as_str().unwrap().to_string();
        
        Ok(UpdateDailyBehaviorProps { id, node_name, satiety_key, energy_key, mood_key, satiety_lower_threshold_key, satiety_upper_threshold_key, energy_lower_threshold_key, energy_upper_threshold_key, mood_lower_threshold_key, mood_upper_threshold_key, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Decorator {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
}

impl Decorator {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeLoop" => Ok(std::sync::Arc::new(crate::ai::UeLoop::new(json)?)),
            "UeCooldown" => Ok(std::sync::Arc::new(crate::ai::UeCooldown::new(json)?)),
            "UeTimeLimit" => Ok(std::sync::Arc::new(crate::ai::UeTimeLimit::new(json)?)),
            "UeBlackboard" => Ok(std::sync::Arc::new(crate::ai::UeBlackboard::new(json)?)),
            "UeForceSuccess" => Ok(std::sync::Arc::new(crate::ai::UeForceSuccess::new(json)?)),
            "IsAtLocation" => Ok(std::sync::Arc::new(crate::ai::IsAtLocation::new(json)?)),
            "DistanceLessThan" => Ok(std::sync::Arc::new(crate::ai::DistanceLessThan::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Decorator:{}", type_id)))
        }
    }
}

pub trait TDecorator {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode;
}

impl crate::ai::TDecorator for crate::ai::UeLoop {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeCooldown {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeTimeLimit {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeBlackboard {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::UeForceSuccess {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::IsAtLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl crate::ai::TDecorator for crate::ai::DistanceLessThan {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        &self.flow_abort_mode
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TDecorator> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TDecorator, LubanError> {
        let base: Result<&crate::ai::UeLoop, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeCooldown, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeTimeLimit, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeBlackboard, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeForceSuccess, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IsAtLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DistanceLessThan, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeLoop {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub num_loops: i32,
    pub infinite_loop: bool,
    pub infinite_loop_timeout_time: f32,
}

impl UeLoop{
    pub fn new(json: &serde_json::Value) -> Result<UeLoop, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let num_loops = (json["num_loops"].as_i64().unwrap() as i32);
        let infinite_loop = json["infinite_loop"].as_bool().unwrap();
        let infinite_loop_timeout_time = (json["infinite_loop_timeout_time"].as_f64().unwrap() as f32);
        
        Ok(UeLoop { id, node_name, flow_abort_mode, num_loops, infinite_loop, infinite_loop_timeout_time, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeCooldown {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub cooldown_time: f32,
}

impl UeCooldown{
    pub fn new(json: &serde_json::Value) -> Result<UeCooldown, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let cooldown_time = (json["cooldown_time"].as_f64().unwrap() as f32);
        
        Ok(UeCooldown { id, node_name, flow_abort_mode, cooldown_time, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeTimeLimit {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub limit_time: f32,
}

impl UeTimeLimit{
    pub fn new(json: &serde_json::Value) -> Result<UeTimeLimit, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let limit_time = (json["limit_time"].as_f64().unwrap() as f32);
        
        Ok(UeTimeLimit { id, node_name, flow_abort_mode, limit_time, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeBlackboard {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub notify_observer: crate::ai::ENotifyObserverMode,
    pub blackboard_key: String,
    pub key_query: std::sync::Arc<AbstractBase>,
}

impl UeBlackboard{
    pub fn new(json: &serde_json::Value) -> Result<UeBlackboard, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let notify_observer = json["notify_observer"].as_i64().unwrap().into();
        let blackboard_key = json["blackboard_key"].as_str().unwrap().to_string();
        let key_query = crate::ai::KeyQueryOperator::new(&json["key_query"])?;
        
        Ok(UeBlackboard { id, node_name, flow_abort_mode, notify_observer, blackboard_key, key_query, })
    }
}

#[derive(Debug)]
pub struct KeyQueryOperator {
}

impl KeyQueryOperator {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "IsSet2" => Ok(std::sync::Arc::new(crate::ai::IsSet2::new(json)?)),
            "IsNotSet" => Ok(std::sync::Arc::new(crate::ai::IsNotSet::new(json)?)),
            "BinaryOperator" => Ok(std::sync::Arc::new(crate::ai::BinaryOperator::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyQueryOperator:{}", type_id)))
        }
    }
}

pub trait TKeyQueryOperator {
}

impl crate::ai::TKeyQueryOperator for crate::ai::IsSet2 {
}

impl crate::ai::TKeyQueryOperator for crate::ai::IsNotSet {
}

impl crate::ai::TKeyQueryOperator for crate::ai::BinaryOperator {
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TKeyQueryOperator> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TKeyQueryOperator, LubanError> {
        let base: Result<&crate::ai::IsSet2, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IsNotSet, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::BinaryOperator, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IsSet2 {
}

impl IsSet2{
    pub fn new(json: &serde_json::Value) -> Result<IsSet2, LubanError> {
        
        Ok(IsSet2 { })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IsNotSet {
}

impl IsNotSet{
    pub fn new(json: &serde_json::Value) -> Result<IsNotSet, LubanError> {
        
        Ok(IsNotSet { })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct BinaryOperator {
    pub oper: crate::ai::EOperator,
    pub data: std::sync::Arc<AbstractBase>,
}

impl BinaryOperator{
    pub fn new(json: &serde_json::Value) -> Result<BinaryOperator, LubanError> {
        let oper = json["oper"].as_i64().unwrap().into();
        let data = crate::ai::KeyData::new(&json["data"])?;
        
        Ok(BinaryOperator { oper, data, })
    }
}

#[derive(Debug)]
pub struct KeyData {
}

impl KeyData {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "FloatKeyData" => Ok(std::sync::Arc::new(crate::ai::FloatKeyData::new(json)?)),
            "IntKeyData" => Ok(std::sync::Arc::new(crate::ai::IntKeyData::new(json)?)),
            "StringKeyData" => Ok(std::sync::Arc::new(crate::ai::StringKeyData::new(json)?)),
            "BlackboardKeyData" => Ok(std::sync::Arc::new(crate::ai::BlackboardKeyData::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyData:{}", type_id)))
        }
    }
}

pub trait TKeyData {
}

impl crate::ai::TKeyData for crate::ai::FloatKeyData {
}

impl crate::ai::TKeyData for crate::ai::IntKeyData {
}

impl crate::ai::TKeyData for crate::ai::StringKeyData {
}

impl crate::ai::TKeyData for crate::ai::BlackboardKeyData {
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TKeyData> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TKeyData, LubanError> {
        let base: Result<&crate::ai::FloatKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::IntKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::StringKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::BlackboardKeyData, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct FloatKeyData {
    pub value: f32,
}

impl FloatKeyData{
    pub fn new(json: &serde_json::Value) -> Result<FloatKeyData, LubanError> {
        let value = (json["value"].as_f64().unwrap() as f32);
        
        Ok(FloatKeyData { value, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IntKeyData {
    pub value: i32,
}

impl IntKeyData{
    pub fn new(json: &serde_json::Value) -> Result<IntKeyData, LubanError> {
        let value = (json["value"].as_i64().unwrap() as i32);
        
        Ok(IntKeyData { value, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct StringKeyData {
    pub value: String,
}

impl StringKeyData{
    pub fn new(json: &serde_json::Value) -> Result<StringKeyData, LubanError> {
        let value = json["value"].as_str().unwrap().to_string();
        
        Ok(StringKeyData { value, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct BlackboardKeyData {
    pub value: String,
}

impl BlackboardKeyData{
    pub fn new(json: &serde_json::Value) -> Result<BlackboardKeyData, LubanError> {
        let value = json["value"].as_str().unwrap().to_string();
        
        Ok(BlackboardKeyData { value, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeForceSuccess {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
}

impl UeForceSuccess{
    pub fn new(json: &serde_json::Value) -> Result<UeForceSuccess, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        
        Ok(UeForceSuccess { id, node_name, flow_abort_mode, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct IsAtLocation {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub acceptable_radius: f32,
    pub keyboard_key: String,
    pub inverse_condition: bool,
}

impl IsAtLocation{
    pub fn new(json: &serde_json::Value) -> Result<IsAtLocation, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let acceptable_radius = (json["acceptable_radius"].as_f64().unwrap() as f32);
        let keyboard_key = json["keyboard_key"].as_str().unwrap().to_string();
        let inverse_condition = json["inverse_condition"].as_bool().unwrap();
        
        Ok(IsAtLocation { id, node_name, flow_abort_mode, acceptable_radius, keyboard_key, inverse_condition, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DistanceLessThan {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub actor1_key: String,
    pub actor2_key: String,
    pub distance: f32,
    pub reverse_result: bool,
}

impl DistanceLessThan{
    pub fn new(json: &serde_json::Value) -> Result<DistanceLessThan, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let actor1_key = json["actor1_key"].as_str().unwrap().to_string();
        let actor2_key = json["actor2_key"].as_str().unwrap().to_string();
        let distance = (json["distance"].as_f64().unwrap() as f32);
        let reverse_result = json["reverse_result"].as_bool().unwrap();
        
        Ok(DistanceLessThan { id, node_name, flow_abort_mode, actor1_key, actor2_key, distance, reverse_result, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct FlowNode {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
}

impl FlowNode {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Sequence" => Ok(std::sync::Arc::new(crate::ai::Sequence::new(json)?)),
            "Selector" => Ok(std::sync::Arc::new(crate::ai::Selector::new(json)?)),
            "SimpleParallel" => Ok(std::sync::Arc::new(crate::ai::SimpleParallel::new(json)?)),
            "UeWait" => Ok(std::sync::Arc::new(crate::ai::UeWait::new(json)?)),
            "UeWaitBlackboardTime" => Ok(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(json)?)),
            "MoveToTarget" => Ok(std::sync::Arc::new(crate::ai::MoveToTarget::new(json)?)),
            "ChooseSkill" => Ok(std::sync::Arc::new(crate::ai::ChooseSkill::new(json)?)),
            "MoveToRandomLocation" => Ok(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(json)?)),
            "MoveToLocation" => Ok(std::sync::Arc::new(crate::ai::MoveToLocation::new(json)?)),
            "DebugPrint" => Ok(std::sync::Arc::new(crate::ai::DebugPrint::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for FlowNode:{}", type_id)))
        }
    }
}

pub trait TFlowNode {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
}

impl crate::ai::TFlowNode for crate::ai::Sequence {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::Selector {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::SimpleParallel {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::UeWait {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::UeWaitBlackboardTime {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::MoveToTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::ChooseSkill {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::MoveToRandomLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::MoveToLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TFlowNode for crate::ai::DebugPrint {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TFlowNode> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TFlowNode, LubanError> {
        let base: Result<&crate::ai::Sequence, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Selector, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::SimpleParallel, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWait, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWaitBlackboardTime, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseSkill, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToRandomLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DebugPrint, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ComposeNode {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
}

impl ComposeNode {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Sequence" => Ok(std::sync::Arc::new(crate::ai::Sequence::new(json)?)),
            "Selector" => Ok(std::sync::Arc::new(crate::ai::Selector::new(json)?)),
            "SimpleParallel" => Ok(std::sync::Arc::new(crate::ai::SimpleParallel::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for ComposeNode:{}", type_id)))
        }
    }
}

pub trait TComposeNode {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
}

impl crate::ai::TComposeNode for crate::ai::Sequence {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TComposeNode for crate::ai::Selector {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl crate::ai::TComposeNode for crate::ai::SimpleParallel {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TComposeNode> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TComposeNode, LubanError> {
        let base: Result<&crate::ai::Sequence, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::Selector, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::SimpleParallel, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Sequence {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub children: Vec<std::sync::Arc<AbstractBase>>,
}

impl Sequence{
    pub fn new(json: &serde_json::Value) -> Result<Sequence, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let children = json["children"].as_array().unwrap().iter().map(|field| crate::ai::FlowNode::new(&field).unwrap()).collect();
        
        Ok(Sequence { id, node_name, decorators, services, children, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Selector {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub children: Vec<std::sync::Arc<AbstractBase>>,
}

impl Selector{
    pub fn new(json: &serde_json::Value) -> Result<Selector, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let children = json["children"].as_array().unwrap().iter().map(|field| crate::ai::FlowNode::new(&field).unwrap()).collect();
        
        Ok(Selector { id, node_name, decorators, services, children, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct SimpleParallel {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub finish_mode: crate::ai::EFinishMode,
    pub main_task: std::sync::Arc<AbstractBase>,
    pub background_node: std::sync::Arc<AbstractBase>,
}

impl SimpleParallel{
    pub fn new(json: &serde_json::Value) -> Result<SimpleParallel, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let finish_mode = json["finish_mode"].as_i64().unwrap().into();
        let main_task = crate::ai::Task::new(&json["main_task"])?;
        let background_node = crate::ai::FlowNode::new(&json["background_node"])?;
        
        Ok(SimpleParallel { id, node_name, decorators, services, finish_mode, main_task, background_node, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct Task {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
}

impl Task {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeWait" => Ok(std::sync::Arc::new(crate::ai::UeWait::new(json)?)),
            "UeWaitBlackboardTime" => Ok(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(json)?)),
            "MoveToTarget" => Ok(std::sync::Arc::new(crate::ai::MoveToTarget::new(json)?)),
            "ChooseSkill" => Ok(std::sync::Arc::new(crate::ai::ChooseSkill::new(json)?)),
            "MoveToRandomLocation" => Ok(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(json)?)),
            "MoveToLocation" => Ok(std::sync::Arc::new(crate::ai::MoveToLocation::new(json)?)),
            "DebugPrint" => Ok(std::sync::Arc::new(crate::ai::DebugPrint::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Task:{}", type_id)))
        }
    }
}

pub trait TTask {
    fn get_id(&self) -> &i32;
    fn get_node_name(&self) -> &String;
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>>;
    fn get_ignore_restart_self(&self) -> &bool;
}

impl crate::ai::TTask for crate::ai::UeWait {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::UeWaitBlackboardTime {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::MoveToTarget {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::ChooseSkill {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::MoveToRandomLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::MoveToLocation {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl crate::ai::TTask for crate::ai::DebugPrint {
    fn get_id(&self) -> &i32 {
        &self.id
    }
    fn get_node_name(&self) -> &String {
        &self.node_name
    }
    fn get_decorators(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.decorators
    }
    fn get_services(&self) -> &Vec<std::sync::Arc<AbstractBase>> {
        &self.services
    }
    fn get_ignore_restart_self(&self) -> &bool {
        &self.ignore_restart_self
    }
}

impl<'a> GetBase<'a, &'a dyn crate::ai::TTask> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::ai::TTask, LubanError> {
        let base: Result<&crate::ai::UeWait, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::UeWaitBlackboardTime, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToTarget, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::ChooseSkill, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToRandomLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::MoveToLocation, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::ai::DebugPrint, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic(format!("Invalid type for Shape")))
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeWait {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub wait_time: f32,
    pub random_deviation: f32,
}

impl UeWait{
    pub fn new(json: &serde_json::Value) -> Result<UeWait, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let wait_time = (json["wait_time"].as_f64().unwrap() as f32);
        let random_deviation = (json["random_deviation"].as_f64().unwrap() as f32);
        
        Ok(UeWait { id, node_name, decorators, services, ignore_restart_self, wait_time, random_deviation, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct UeWaitBlackboardTime {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub blackboard_key: String,
}

impl UeWaitBlackboardTime{
    pub fn new(json: &serde_json::Value) -> Result<UeWaitBlackboardTime, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let blackboard_key = json["blackboard_key"].as_str().unwrap().to_string();
        
        Ok(UeWaitBlackboardTime { id, node_name, decorators, services, ignore_restart_self, blackboard_key, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct MoveToTarget {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub acceptable_radius: f32,
}

impl MoveToTarget{
    pub fn new(json: &serde_json::Value) -> Result<MoveToTarget, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let target_actor_key = json["target_actor_key"].as_str().unwrap().to_string();
        let acceptable_radius = (json["acceptable_radius"].as_f64().unwrap() as f32);
        
        Ok(MoveToTarget { id, node_name, decorators, services, ignore_restart_self, target_actor_key, acceptable_radius, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct ChooseSkill {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub result_skill_id_key: String,
}

impl ChooseSkill{
    pub fn new(json: &serde_json::Value) -> Result<ChooseSkill, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let target_actor_key = json["target_actor_key"].as_str().unwrap().to_string();
        let result_skill_id_key = json["result_skill_id_key"].as_str().unwrap().to_string();
        
        Ok(ChooseSkill { id, node_name, decorators, services, ignore_restart_self, target_actor_key, result_skill_id_key, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct MoveToRandomLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub origin_position_key: String,
    pub radius: f32,
}

impl MoveToRandomLocation{
    pub fn new(json: &serde_json::Value) -> Result<MoveToRandomLocation, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let origin_position_key = json["origin_position_key"].as_str().unwrap().to_string();
        let radius = (json["radius"].as_f64().unwrap() as f32);
        
        Ok(MoveToRandomLocation { id, node_name, decorators, services, ignore_restart_self, origin_position_key, radius, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct MoveToLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub acceptable_radius: f32,
}

impl MoveToLocation{
    pub fn new(json: &serde_json::Value) -> Result<MoveToLocation, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let acceptable_radius = (json["acceptable_radius"].as_f64().unwrap() as f32);
        
        Ok(MoveToLocation { id, node_name, decorators, services, ignore_restart_self, acceptable_radius, })
    }
}

#[derive(Debug)]
#[derive(macros::TryIntoBase)]
pub struct DebugPrint {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<std::sync::Arc<AbstractBase>>,
    pub services: Vec<std::sync::Arc<AbstractBase>>,
    pub ignore_restart_self: bool,
    pub text: String,
}

impl DebugPrint{
    pub fn new(json: &serde_json::Value) -> Result<DebugPrint, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let text = json["text"].as_str().unwrap().to_string();
        
        Ok(DebugPrint { id, node_name, decorators, services, ignore_restart_self, text, })
    }
}


#[derive(Debug)]
pub struct TbBlackboard {
    pub data_list: Vec<std::sync::Arc<crate::ai::Blackboard>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::ai::Blackboard>>,
}

impl TbBlackboard {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbBlackboard>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<crate::ai::Blackboard>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::ai::Blackboard>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::ai::Blackboard::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.name.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBlackboard { data_map, data_list }))
    }

    pub fn get(&self, key: &String) -> Option<std::sync::Arc<crate::ai::Blackboard>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<String> for TbBlackboard {
    type Output = std::sync::Arc<crate::ai::Blackboard>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbBehaviorTree {
    pub data_list: Vec<std::sync::Arc<crate::ai::BehaviorTree>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::ai::BehaviorTree>>,
}

impl TbBehaviorTree {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbBehaviorTree>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::ai::BehaviorTree>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::ai::BehaviorTree>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::ai::BehaviorTree::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBehaviorTree { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::ai::BehaviorTree>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbBehaviorTree {
    type Output = std::sync::Arc<crate::ai::BehaviorTree>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


