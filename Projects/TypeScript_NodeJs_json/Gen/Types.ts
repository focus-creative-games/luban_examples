//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


export class Vector2 {
    static deserializeFromJson(json: any): Vector2 {
        let x = json.x
        let y = json.y
        if (x == null || y == null) {
            throw new Error()
        }
        return new Vector2(x, y)
    }

    x: number
    y: number
    constructor(x: number = 0, y: number = 0) {
        this.x = x
        this.y = y
    }
}

export class Vector3 {
    static deserializeFromJson(json: any): Vector3 {
        let x = json.x
        let y = json.y
        let z = json.z
        if (x == null || y == null || z == null) {
            throw new Error()
        }
        return new Vector3(x, y, z)
    }

    x: number
    y: number
    z: number

    constructor(x: number = 0, y: number = 0, z: number = 0) {
        this.x = x
        this.y = y
        this.z = z
    }
}

export class Vector4 {
    static deserializeFromJson(json: any): Vector4 {
        let x = json.x
        let y = json.y
        let z = json.z
        let w = json.w
        if (x == null || y == null || z == null || w == null) {
            throw new Error()
        }
        return new Vector4(x, y, z, w)
    }
    
    x: number
    y: number
    z: number
    w: number

    constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 0) {
        this.x = x
        this.y = y
        this.z = z
        this.w = w
    }
}


export namespace ai {
export enum EExecutor {
    CLIENT = 0,
    SERVER = 1,
}
}

export namespace ai {
export enum EKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS = 8,
    ENUM = 9,
    OBJECT = 10,
}
}

export namespace ai {
export enum EFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}
}

export namespace ai {
export enum EFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}
}

export namespace ai {
export enum ENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}
}

export namespace ai {
export enum EOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}
}

export namespace common {
export enum EBoolOperator {
    AND = 0,
    OR = 1,
}
}

export namespace error {
export enum EOperation {
    /**
     * 登出
     */
    LOGOUT = 0,
    /**
     * 重启
     */
    RESTART = 1,
}
}

export namespace error {
export enum EErrorCode {
    OK = 0,
    SERVER_NOT_EXISTS = 1,
    HAS_BIND_SERVER = 2,
    AUTH_FAIL = 3,
    NOT_BIND_SERVER = 4,
    SERVER_ACCESS_FAIL = 5,
    EXAMPLE_FLASH = 6,
    EXAMPLE_MSGBOX = 7,
    EXAMPLE_DLG_OK = 8,
    EXAMPLE_DLG_OK_CANCEL = 9,
    ROLE_CREATE_NAME_INVALID_CHAR = 100,
    ROLE_CREATE_NAME_EMPTY = 101,
    ROLE_CREATE_NAME_EXCEED_MAX_LENGTH = 102,
    ROLE_CREATE_ROLE_LIST_FULL = 103,
    ROLE_CREATE_INVALID_PROFESSION = 104,
    ROLE_CREATE_INVALID_GENDER = 105,
    ROLE_NOT_OWNED_BY_USER = 106,
    ROLE_LEVEL_NOT_ARRIVE = 107,
    PARAM_ILLEGAL = 200,
    TEMP_BAG_NOT_EMPTY = 201,
    ITEM_CAN_NOT_USE = 202,
    CURRENCY_NOT_ENOUGH = 203,
    BAG_IS_FULL = 204,
    ITEM_NOT_ENOUGH = 205,
    ITEM_IN_BAG = 206,
    GENDER_NOT_MATCH = 300,
    LEVEL_TOO_LOW = 301,
    LEVEL_TOO_HIGH = 302,
    EXCEED_LIMIT = 303,
    OVER_TIME = 304,
    SERVER_ERROR = 305,
    SKILL_NOT_IN_LIST = 400,
    SKILL_NOT_COOLDOWN = 401,
    SKILL_TARGET_NOT_EXIST = 402,
    SKILL_ANOTHER_CASTING = 403,
    SKILL_OUT_OF_DISTANCE = 404,
    SKILL_TARGET_CAMP_NOT_MATCH = 405,
    SKILL_INVALID_DIRECTION = 406,
    SKILL_NOT_IN_SELECT_SHAPE = 407,
    SKILL_ENERGY_NOT_ENOUGH = 408,
    DIALOG_NODE_NOT_CHOOSEN = 500,
    DIALOG_NOT_FINISH = 501,
    DIALOG_HAS_FINISH = 502,
    QUEST_STAGE_NOT_FINISHED = 503,
    QUEST_NOT_DOING = 504,
    QUEST_STAGE_NOT_DOING = 505,
    QUEST_HAS_ACCEPTED = 506,
    MAP_OBJECT_NOT_EXIST = 600,
    INTERACTION_OBJECT_NOT_SUPPORT_OPERATION = 601,
    HAS_NOT_EQUIP = 602,
    HANDHELD_EQUIP_ID_NOT_MATCH = 603,
    NOT_AVAILABLE_SUIT_ID = 604,
    NO_INTERACTION_COMPONENT = 605,
    HAS_INTERACTED = 606,
    VIALITY_NOT_ENOUGH = 607,
    PLAYER_SESSION_NOT_EXIST = 608,
    PLAYER_SESSION_WORLD_PLAYER_NOT_INIT = 609,
    MAP_NOT_EXIST = 610,
    MAIL_TYPE_ERROR = 700,
    MAIL_NOT_EXITST = 701,
    MAIL_HAVE_DELETED = 702,
    MAIL_AWARD_HAVE_RECEIVED = 703,
    MAIL_OPERATE_TYPE_ERROR = 704,
    MAIL_CONDITION_NOT_MEET = 705,
    MAIL_STATE_ERROR = 706,
    MAIL_NO_AWARD = 707,
    MAIL_BOX_IS_FULL = 708,
    PROP_SCORE_NOT_BIGGER_THAN = 800,
    NOT_WEAR_CLOTHES = 801,
    NOT_WEAR_SUIT = 802,
    SUIT_NOT_UNLOCK = 900,
    SUIT_COMPONENT_NOT_UNLOCK = 901,
    SUIT_STATE_ERROR = 902,
    SUIT_COMPONENT_STATE_ERROR = 903,
    SUIT_COMPONENT_NO_NEED_LEARN = 904,
    STORE_NOT_ENABLED = 1000,
    SHELF_NOT_ENABLED = 1001,
    GOODS_NOT_ENABLED = 1002,
    GOODS_NOT_IN_CUR_REFRESH = 1003,
    RETRY = 1100,
    NOT_COOLDOWN = 1101,
    SELFIE_UNLOCK = 1200,
    SELFIE_ALREADY_UNLOCK = 1201,
    SELFIE_LACK_STARTS = 1202,
    SELFIE_HAD_REWARD = 1203,
}
}

export namespace item {
/**
 * 道具品质
 */
export enum EItemQuality {
    /**
     * 白
     */
    WHITE = 0,
    /**
     * 绿
     */
    GREEN = 1,
    /**
     * 蓝
     */
    BLUE = 2,
    /**
     * 紫
     */
    PURPLE = 3,
    /**
     * 金
     */
    GOLDEN = 4,
}
}

export namespace item {
export enum ECurrencyType {
    /**
     * 钻石
     */
    DIAMOND = 1,
    /**
     * 金币
     */
    GOLD = 2,
    /**
     * 银币
     */
    SILVER = 3,
    /**
     * 经验
     */
    EXP = 4,
    /**
     * 能量点
     */
    POWER_POINT = 5,
}
}

export namespace item {
export enum EMajorType {
    /**
     * 货币
     */
    CURRENCY = 1,
    /**
     * 服装
     */
    CLOTH = 2,
    /**
     * 任务
     */
    QUEST = 3,
    /**
     * 消耗品
     */
    CONSUMABLES = 4,
    /**
     * 宝箱
     */
    TREASURE_BOX = 5,
    /**
     * 成就和称谓
     */
    ACHIEVEMENT_AND_TITLE = 6,
    /**
     * 头像框
     */
    HEAD_FRAME = 7,
    /**
     * 语音
     */
    VOICE = 8,
    /**
     * 动作
     */
    ACTION = 9,
    /**
     * 扩容道具
     */
    EXPANSION = 10,
    /**
     * 制作材料
     */
    MATERIAL = 11,
}
}

export namespace item {
export enum EMinorType {
    /**
     * 钻石
     */
    DIAMOND = 101,
    /**
     * 金币
     */
    GOLD = 102,
    /**
     * 银币
     */
    SILVER = 103,
    /**
     * 经验
     */
    EXP = 104,
    /**
     * 能量点
     */
    POWER_POINT = 105,
    /**
     * 发型
     */
    HAIR_STYLE = 210,
    /**
     * 外套
     */
    COAT = 220,
    /**
     * 上衣
     */
    UPPER_JACKET = 230,
    /**
     * 裤子
     */
    TROUSERS = 241,
    /**
     * 裙子
     */
    SKIRT = 242,
    /**
     * 袜子
     */
    SOCKS = 250,
    /**
     * 鞋子
     */
    SHOES = 260,
    /**
     * 发饰
     */
    HAIR_ACCESSORY = 271,
    /**
     * 帽子
     */
    HAT = 272,
    /**
     * 耳饰
     */
    EARRING = 273,
    /**
     * 颈饰
     */
    NECKLACE = 274,
    /**
     * 腕饰
     */
    BRACELET = 275,
    /**
     * 发箍
     */
    HAIR_CLASP = 276,
    /**
     * 手套
     */
    GLOVE = 277,
    /**
     * 手持物
     */
    HANDHELD_OBJECT = 278,
    /**
     * 特殊
     */
    SPECIAL = 279,
    /**
     * 底妆
     */
    BASE_COSMETIC = 281,
    /**
     * 眉妆
     */
    EYEBROW_COSMETIC = 282,
    /**
     * 睫毛
     */
    EYELASH = 283,
    /**
     * 美瞳
     */
    COSMETIC_CONTACT_LENSES = 284,
    /**
     * 唇妆
     */
    LIP_COSMETIC = 285,
    /**
     * 肤色
     */
    SKIN_COLOR = 286,
    /**
     * 连衣裙
     */
    ONE_PIECE_DRESS = 290,
    /**
     * 换装场景
     */
    SWITCH_CLOTHES_SCENE = 291,
    /**
     * 任务道具
     */
    QUEST = 301,
    /**
     * 投掷物
     */
    CAST = 401,
    /**
     * 刀剑
     */
    SWORD = 421,
    /**
     * 弓箭
     */
    BOW_ARROW = 422,
    /**
     * 法杖
     */
    WANDS = 423,
    /**
     * 特殊工具
     */
    SPECIAL_TOOL = 424,
    /**
     * 食物
     */
    FOOD = 403,
    /**
     * 宝箱
     */
    TREASURE_BOX = 501,
    /**
     * 钥匙
     */
    KEY = 502,
    /**
     * 多选一宝箱
     */
    MULTI_CHOOSE_TREASURE_BOX = 503,
    /**
     * 成就相关
     */
    ACHIEVEMENT = 601,
    /**
     * 称谓相关
     */
    TITLE = 602,
    /**
     * 头像框
     */
    AVATAR_FRAME = 701,
    /**
     * 语音
     */
    VOICE = 801,
    /**
     * 特殊待机动作
     */
    IDLE_POSE = 901,
    /**
     * 拍照动作
     */
    PHOTO_POSE = 902,
    /**
     * 背包
     */
    BAG = 1001,
    /**
     * 好友数量
     */
    FRIEND_CAPACITY = 1002,
    /**
     * 制作材料
     */
    CONSTRUCTION_MATERIAL = 1101,
    /**
     * 设计图纸
     */
    DESIGN_DRAWING = 1102,
}
}

export namespace item {
export enum EClothersStarQualityType {
    /**
     * 一星
     */
    ONE = 1,
    /**
     * 二星
     */
    TWO = 2,
    /**
     * 三星
     */
    THREE = 3,
    /**
     * 四星
     */
    FOUR = 4,
    /**
     * 五星
     */
    FIVE = 5,
    /**
     * 六星
     */
    SIX = 6,
    /**
     * 七星
     */
    SEVEN = 7,
    /**
     * 八星
     */
    EIGHT = 8,
    /**
     * 九星
     */
    NINE = 9,
    /**
     * 十星
     */
    TEN = 10,
}
}

export namespace item {
export enum EClothersTag {
    /**
     * 防晒
     */
    FANG_SHAI = 1,
    /**
     * 舞者
     */
    WU_ZHE = 2,
}
}

export namespace item {
export enum EUseType {
    /**
     * 手动
     */
    MANUAL = 0,
    /**
     * 自动
     */
    AUTO = 1,
}
}

export namespace item {
export enum EClothesHidePartType {
    /**
     * 胸部
     */
    CHEST = 0,
    /**
     * 手
     */
    HEAD = 1,
    /**
     * 脊柱上
     */
    SPINE_UPPER = 2,
    /**
     * 脊柱下
     */
    SPINE_LOWER = 3,
    /**
     * 臀部
     */
    HIP = 4,
    /**
     * 腿上
     */
    LEG_UPPER = 5,
    /**
     * 腿中
     */
    LEG_MIDDLE = 6,
    /**
     * 腿下
     */
    LEG_LOWER = 7,
}
}

export namespace item {
export enum EClothesPropertyType {
    /**
     * 简约
     */
    JIAN_YUE = 1,
    /**
     * 华丽
     */
    HUA_LI = 2,
    /**
     * 可爱
     */
    KE_AI = 3,
    /**
     * 成熟
     */
    CHENG_SHU = 4,
    /**
     * 活泼
     */
    HUO_PO = 5,
    /**
     * 优雅
     */
    YOU_YA = 6,
    /**
     * 清纯
     */
    QING_CHUN = 7,
    /**
     * 性感
     */
    XING_GAN = 8,
    /**
     * 清凉
     */
    QING_LIANG = 9,
    /**
     * 保暖
     */
    BAO_NUAN = 10,
}
}

export namespace item {
export enum EItemFunctionType {
    /**
     * 更换手持物
     */
    REPLACE_HANDHELD = 0,
    /**
     * 使用设计图纸
     */
    USE_DESIGN_DRAWING = 1,
}
}

export namespace limit {
export enum ENamespace {
    ITEM_DAILY_OBTAIN = 1,
    TREASURE_DAILY_USE = 2,
    STORE_GOODS_LIMIT_BUY = 3,
}
}

export namespace mail {
export enum EMailType {
    /**
     * 全局邮件
     */
    GLOBAL = 0,
    /**
     * 系统邮件
     */
    SYSTEM = 1,
}
}

export namespace role {
export enum EGenderType {
    /**
     * 男
     */
    MALE = 1,
    /**
     * 女
     */
    FEMALE = 2,
}
}

export namespace role {
export enum EProfession {
    TEST_PROFESSION = 1,
}
}

export namespace test {
export enum DemoEnum {
    NONE = 0,
    /**
     * aa
     */
    A = 1,
    /**
     * bb
     */
    B = 2,
    /**
     * cc
     */
    C = 4,
    /**
     * dd
     */
    D = 5,
}
}

export namespace test {
export enum DemoFlag {
    A = 1,
    B = 2,
    D = A|B,
}
}

export namespace test {
export enum ETestUeType {
    /**
     * 白
     */
    WHITE = 0,
    BLACK = 1,
}
}

export namespace test {
export enum ETestEmptyEnum {
}
}

export namespace test {
export enum ETestEmptyEnum2 {
    SMALL_THAN_256 = 255,
    X_256 = 256,
    X_257 = 257,
}
}

export namespace test {
export enum AudioType {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
}
}

export namespace test {
export enum ETestQuality {
    /**
     * 最高品质
     */
    A = 1,
    /**
     * 黑色的
     */
    B = 2,
    /**
     * 蓝色的
     */
    C = 3,
    /**
     * 最差品质
     */
    D = 4,
}
}

export namespace test {
export enum AccessFlag {
    WRITE = 1,
    READ = 2,
    TRUNCATE = 4,
    NEW = 8,
    READ_WRITE = WRITE|READ,
}
}

export namespace ai {
export class TbBlackboard{
    private _dataMap: Map<string, ai.Blackboard>
    private _dataList: ai.Blackboard[]
    constructor(_json_: any) {
        this._dataMap = new Map<string, ai.Blackboard>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: ai.Blackboard
            _v = new ai.Blackboard(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.name, _v)
        }
    }

    getDataMap(): Map<string, ai.Blackboard> { return this._dataMap; }
    getDataList(): ai.Blackboard[] { return this._dataList; }

    get(key: string): ai.Blackboard | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace ai {
export class Blackboard {

    constructor(_json_: any) {
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.parent_name === undefined) { throw new Error() }
        this.parentName = _json_.parent_name
        if (_json_.keys === undefined) { throw new Error() }
        { this.keys = []; for(let _ele of _json_.keys) { let _e : ai.BlackboardKey; _e = new ai.BlackboardKey(_ele); this.keys.push(_e);}}
    }

    readonly name: string
    readonly desc: string
    readonly parentName: string
    parentName_Ref : ai.Blackboard = undefined!
    readonly keys: ai.BlackboardKey[]

    resolve(_tables: Map<string, any>) {
        this.parentName_Ref = (_tables.get('ai.TbBlackboard') as ai.TbBlackboard).get(this.parentName)!
        for(let _e of this.keys) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace ai {
export class BlackboardKey {

    constructor(_json_: any) {
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.is_static === undefined) { throw new Error() }
        this.isStatic = _json_.is_static
        if (_json_.type === undefined) { throw new Error() }
        this.type = _json_.type
        if (_json_.type_class_name === undefined) { throw new Error() }
        this.typeClassName = _json_.type_class_name
    }

    readonly name: string
    readonly desc: string
    readonly isStatic: boolean
    readonly type: ai.EKeyType
    readonly typeClassName: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace ai {
export class TbBehaviorTree{
    private _dataMap: Map<number, ai.BehaviorTree>
    private _dataList: ai.BehaviorTree[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, ai.BehaviorTree>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: ai.BehaviorTree
            _v = new ai.BehaviorTree(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, ai.BehaviorTree> { return this._dataMap; }
    getDataList(): ai.BehaviorTree[] { return this._dataList; }

    get(key: number): ai.BehaviorTree | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace ai {
export class BehaviorTree {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.blackboard_id === undefined) { throw new Error() }
        this.blackboardId = _json_.blackboard_id
        if (_json_.root === undefined) { throw new Error() }
        this.root = ai.ComposeNode.constructorFrom(_json_.root)
    }

    readonly id: number
    readonly name: string
    readonly desc: string
    readonly blackboardId: string
    blackboardId_Ref : ai.Blackboard = undefined!
    readonly root: ai.ComposeNode

    resolve(_tables: Map<string, any>) {
        this.blackboardId_Ref = (_tables.get('ai.TbBlackboard') as ai.TbBlackboard).get(this.blackboardId)!
        if (this.root != null) { this.root.resolve(_tables);}
    }
}

}



export namespace ai {
export abstract class Node {
    static constructorFrom(_json_: any): Node{
        switch (_json_.__type__) {
            case 'UeSetDefaultFocus': return new ai.UeSetDefaultFocus(_json_)
            case 'ExecuteTimeStatistic': return new ai.ExecuteTimeStatistic(_json_)
            case 'ChooseTarget': return new ai.ChooseTarget(_json_)
            case 'KeepFaceTarget': return new ai.KeepFaceTarget(_json_)
            case 'GetOwnerPlayer': return new ai.GetOwnerPlayer(_json_)
            case 'UpdateDailyBehaviorProps': return new ai.UpdateDailyBehaviorProps(_json_)
            case 'UeLoop': return new ai.UeLoop(_json_)
            case 'UeCooldown': return new ai.UeCooldown(_json_)
            case 'UeTimeLimit': return new ai.UeTimeLimit(_json_)
            case 'UeBlackboard': return new ai.UeBlackboard(_json_)
            case 'UeForceSuccess': return new ai.UeForceSuccess(_json_)
            case 'IsAtLocation': return new ai.IsAtLocation(_json_)
            case 'DistanceLessThan': return new ai.DistanceLessThan(_json_)
            case 'Sequence': return new ai.Sequence(_json_)
            case 'Selector': return new ai.Selector(_json_)
            case 'SimpleParallel': return new ai.SimpleParallel(_json_)
            case 'UeWait': return new ai.UeWait(_json_)
            case 'UeWaitBlackboardTime': return new ai.UeWaitBlackboardTime(_json_)
            case 'MoveToTarget': return new ai.MoveToTarget(_json_)
            case 'ChooseSkill': return new ai.ChooseSkill(_json_)
            case 'MoveToRandomLocation': return new ai.MoveToRandomLocation(_json_)
            case 'MoveToLocation': return new ai.MoveToLocation(_json_)
            case 'DebugPrint': return new ai.DebugPrint(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.node_name === undefined) { throw new Error() }
        this.nodeName = _json_.node_name
    }

    readonly id: number
    readonly nodeName: string

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace ai {
export abstract class Service extends ai.Node {
    static constructorFrom(_json_: any): Service{
        switch (_json_.__type__) {
            case 'UeSetDefaultFocus': return new ai.UeSetDefaultFocus(_json_)
            case 'ExecuteTimeStatistic': return new ai.ExecuteTimeStatistic(_json_)
            case 'ChooseTarget': return new ai.ChooseTarget(_json_)
            case 'KeepFaceTarget': return new ai.KeepFaceTarget(_json_)
            case 'GetOwnerPlayer': return new ai.GetOwnerPlayer(_json_)
            case 'UpdateDailyBehaviorProps': return new ai.UpdateDailyBehaviorProps(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeSetDefaultFocus extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.keyboard_key === undefined) { throw new Error() }
        this.keyboardKey = _json_.keyboard_key
    }

    readonly keyboardKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class ExecuteTimeStatistic extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class ChooseTarget extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.result_target_key === undefined) { throw new Error() }
        this.resultTargetKey = _json_.result_target_key
    }

    readonly resultTargetKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class KeepFaceTarget extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.target_actor_key === undefined) { throw new Error() }
        this.targetActorKey = _json_.target_actor_key
    }

    readonly targetActorKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class GetOwnerPlayer extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.player_actor_key === undefined) { throw new Error() }
        this.playerActorKey = _json_.player_actor_key
    }

    readonly playerActorKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UpdateDailyBehaviorProps extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.satiety_key === undefined) { throw new Error() }
        this.satietyKey = _json_.satiety_key
        if (_json_.energy_key === undefined) { throw new Error() }
        this.energyKey = _json_.energy_key
        if (_json_.mood_key === undefined) { throw new Error() }
        this.moodKey = _json_.mood_key
        if (_json_.satiety_lower_threshold_key === undefined) { throw new Error() }
        this.satietyLowerThresholdKey = _json_.satiety_lower_threshold_key
        if (_json_.satiety_upper_threshold_key === undefined) { throw new Error() }
        this.satietyUpperThresholdKey = _json_.satiety_upper_threshold_key
        if (_json_.energy_lower_threshold_key === undefined) { throw new Error() }
        this.energyLowerThresholdKey = _json_.energy_lower_threshold_key
        if (_json_.energy_upper_threshold_key === undefined) { throw new Error() }
        this.energyUpperThresholdKey = _json_.energy_upper_threshold_key
        if (_json_.mood_lower_threshold_key === undefined) { throw new Error() }
        this.moodLowerThresholdKey = _json_.mood_lower_threshold_key
        if (_json_.mood_upper_threshold_key === undefined) { throw new Error() }
        this.moodUpperThresholdKey = _json_.mood_upper_threshold_key
    }

    readonly satietyKey: string
    readonly energyKey: string
    readonly moodKey: string
    readonly satietyLowerThresholdKey: string
    readonly satietyUpperThresholdKey: string
    readonly energyLowerThresholdKey: string
    readonly energyUpperThresholdKey: string
    readonly moodLowerThresholdKey: string
    readonly moodUpperThresholdKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export abstract class Decorator extends ai.Node {
    static constructorFrom(_json_: any): Decorator{
        switch (_json_.__type__) {
            case 'UeLoop': return new ai.UeLoop(_json_)
            case 'UeCooldown': return new ai.UeCooldown(_json_)
            case 'UeTimeLimit': return new ai.UeTimeLimit(_json_)
            case 'UeBlackboard': return new ai.UeBlackboard(_json_)
            case 'UeForceSuccess': return new ai.UeForceSuccess(_json_)
            case 'IsAtLocation': return new ai.IsAtLocation(_json_)
            case 'DistanceLessThan': return new ai.DistanceLessThan(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.flow_abort_mode === undefined) { throw new Error() }
        this.flowAbortMode = _json_.flow_abort_mode
    }

    readonly flowAbortMode: ai.EFlowAbortMode

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeLoop extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.num_loops === undefined) { throw new Error() }
        this.numLoops = _json_.num_loops
        if (_json_.infinite_loop === undefined) { throw new Error() }
        this.infiniteLoop = _json_.infinite_loop
        if (_json_.infinite_loop_timeout_time === undefined) { throw new Error() }
        this.infiniteLoopTimeoutTime = _json_.infinite_loop_timeout_time
    }

    readonly numLoops: number
    readonly infiniteLoop: boolean
    readonly infiniteLoopTimeoutTime: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeCooldown extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.cooldown_time === undefined) { throw new Error() }
        this.cooldownTime = _json_.cooldown_time
    }

    readonly cooldownTime: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeTimeLimit extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.limit_time === undefined) { throw new Error() }
        this.limitTime = _json_.limit_time
    }

    readonly limitTime: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeBlackboard extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.notify_observer === undefined) { throw new Error() }
        this.notifyObserver = _json_.notify_observer
        if (_json_.blackboard_key === undefined) { throw new Error() }
        this.blackboardKey = _json_.blackboard_key
        if (_json_.key_query === undefined) { throw new Error() }
        this.keyQuery = ai.KeyQueryOperator.constructorFrom(_json_.key_query)
    }

    readonly notifyObserver: ai.ENotifyObserverMode
    readonly blackboardKey: string
    readonly keyQuery: ai.KeyQueryOperator

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.keyQuery != null) { this.keyQuery.resolve(_tables);}
    }
}

}



export namespace ai {
export abstract class KeyQueryOperator {
    static constructorFrom(_json_: any): KeyQueryOperator{
        switch (_json_.__type__) {
            case 'IsSet': return new ai.IsSet(_json_)
            case 'IsNotSet': return new ai.IsNotSet(_json_)
            case 'BinaryOperator': return new ai.BinaryOperator(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace ai {
export class IsSet extends ai.KeyQueryOperator {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class IsNotSet extends ai.KeyQueryOperator {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class BinaryOperator extends ai.KeyQueryOperator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.oper === undefined) { throw new Error() }
        this.oper = _json_.oper
        if (_json_.data === undefined) { throw new Error() }
        this.data = ai.KeyData.constructorFrom(_json_.data)
    }

    readonly oper: ai.EOperator
    readonly data: ai.KeyData

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.data != null) { this.data.resolve(_tables);}
    }
}

}



export namespace ai {
export abstract class KeyData {
    static constructorFrom(_json_: any): KeyData{
        switch (_json_.__type__) {
            case 'FloatKeyData': return new ai.FloatKeyData(_json_)
            case 'IntKeyData': return new ai.IntKeyData(_json_)
            case 'StringKeyData': return new ai.StringKeyData(_json_)
            case 'BlackboardKeyData': return new ai.BlackboardKeyData(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace ai {
export class FloatKeyData extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class IntKeyData extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class StringKeyData extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class BlackboardKeyData extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeForceSuccess extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class IsAtLocation extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.acceptable_radius === undefined) { throw new Error() }
        this.acceptableRadius = _json_.acceptable_radius
        if (_json_.keyboard_key === undefined) { throw new Error() }
        this.keyboardKey = _json_.keyboard_key
        if (_json_.inverse_condition === undefined) { throw new Error() }
        this.inverseCondition = _json_.inverse_condition
    }

    readonly acceptableRadius: number
    readonly keyboardKey: string
    readonly inverseCondition: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class DistanceLessThan extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.actor1_key === undefined) { throw new Error() }
        this.actor1Key = _json_.actor1_key
        if (_json_.actor2_key === undefined) { throw new Error() }
        this.actor2Key = _json_.actor2_key
        if (_json_.distance === undefined) { throw new Error() }
        this.distance = _json_.distance
        if (_json_.reverse_result === undefined) { throw new Error() }
        this.reverseResult = _json_.reverse_result
    }

    readonly actor1Key: string
    readonly actor2Key: string
    readonly distance: number
    readonly reverseResult: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export abstract class FlowNode extends ai.Node {
    static constructorFrom(_json_: any): FlowNode{
        switch (_json_.__type__) {
            case 'Sequence': return new ai.Sequence(_json_)
            case 'Selector': return new ai.Selector(_json_)
            case 'SimpleParallel': return new ai.SimpleParallel(_json_)
            case 'UeWait': return new ai.UeWait(_json_)
            case 'UeWaitBlackboardTime': return new ai.UeWaitBlackboardTime(_json_)
            case 'MoveToTarget': return new ai.MoveToTarget(_json_)
            case 'ChooseSkill': return new ai.ChooseSkill(_json_)
            case 'MoveToRandomLocation': return new ai.MoveToRandomLocation(_json_)
            case 'MoveToLocation': return new ai.MoveToLocation(_json_)
            case 'DebugPrint': return new ai.DebugPrint(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.decorators === undefined) { throw new Error() }
        { this.decorators = []; for(let _ele of _json_.decorators) { let _e : ai.Decorator; _e = ai.Decorator.constructorFrom(_ele); this.decorators.push(_e);}}
        if (_json_.services === undefined) { throw new Error() }
        { this.services = []; for(let _ele of _json_.services) { let _e : ai.Service; _e = ai.Service.constructorFrom(_ele); this.services.push(_e);}}
    }

    readonly decorators: ai.Decorator[]
    readonly services: ai.Service[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.decorators) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.services) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace ai {
export abstract class ComposeNode extends ai.FlowNode {
    static constructorFrom(_json_: any): ComposeNode{
        switch (_json_.__type__) {
            case 'Sequence': return new ai.Sequence(_json_)
            case 'Selector': return new ai.Selector(_json_)
            case 'SimpleParallel': return new ai.SimpleParallel(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class Sequence extends ai.ComposeNode {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.children === undefined) { throw new Error() }
        { this.children = []; for(let _ele of _json_.children) { let _e : ai.FlowNode; _e = ai.FlowNode.constructorFrom(_ele); this.children.push(_e);}}
    }

    readonly children: ai.FlowNode[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.children) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace ai {
export class Selector extends ai.ComposeNode {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.children === undefined) { throw new Error() }
        { this.children = []; for(let _ele of _json_.children) { let _e : ai.FlowNode; _e = ai.FlowNode.constructorFrom(_ele); this.children.push(_e);}}
    }

    readonly children: ai.FlowNode[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.children) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace ai {
export class SimpleParallel extends ai.ComposeNode {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.finish_mode === undefined) { throw new Error() }
        this.finishMode = _json_.finish_mode
        if (_json_.main_task === undefined) { throw new Error() }
        this.mainTask = ai.Task.constructorFrom(_json_.main_task)
        if (_json_.background_node === undefined) { throw new Error() }
        this.backgroundNode = ai.FlowNode.constructorFrom(_json_.background_node)
    }

    readonly finishMode: ai.EFinishMode
    readonly mainTask: ai.Task
    readonly backgroundNode: ai.FlowNode

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.mainTask != null) { this.mainTask.resolve(_tables);}
        if (this.backgroundNode != null) { this.backgroundNode.resolve(_tables);}
    }
}

}



export namespace ai {
export abstract class Task extends ai.FlowNode {
    static constructorFrom(_json_: any): Task{
        switch (_json_.__type__) {
            case 'UeWait': return new ai.UeWait(_json_)
            case 'UeWaitBlackboardTime': return new ai.UeWaitBlackboardTime(_json_)
            case 'MoveToTarget': return new ai.MoveToTarget(_json_)
            case 'ChooseSkill': return new ai.ChooseSkill(_json_)
            case 'MoveToRandomLocation': return new ai.MoveToRandomLocation(_json_)
            case 'MoveToLocation': return new ai.MoveToLocation(_json_)
            case 'DebugPrint': return new ai.DebugPrint(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.ignore_restart_self === undefined) { throw new Error() }
        this.ignoreRestartSelf = _json_.ignore_restart_self
    }

    readonly ignoreRestartSelf: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeWait extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.wait_time === undefined) { throw new Error() }
        this.waitTime = _json_.wait_time
        if (_json_.random_deviation === undefined) { throw new Error() }
        this.randomDeviation = _json_.random_deviation
    }

    readonly waitTime: number
    readonly randomDeviation: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class UeWaitBlackboardTime extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.blackboard_key === undefined) { throw new Error() }
        this.blackboardKey = _json_.blackboard_key
    }

    readonly blackboardKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class MoveToTarget extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.target_actor_key === undefined) { throw new Error() }
        this.targetActorKey = _json_.target_actor_key
        if (_json_.acceptable_radius === undefined) { throw new Error() }
        this.acceptableRadius = _json_.acceptable_radius
    }

    readonly targetActorKey: string
    readonly acceptableRadius: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class ChooseSkill extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.target_actor_key === undefined) { throw new Error() }
        this.targetActorKey = _json_.target_actor_key
        if (_json_.result_skill_id_key === undefined) { throw new Error() }
        this.resultSkillIdKey = _json_.result_skill_id_key
    }

    readonly targetActorKey: string
    readonly resultSkillIdKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class MoveToRandomLocation extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.origin_position_key === undefined) { throw new Error() }
        this.originPositionKey = _json_.origin_position_key
        if (_json_.radius === undefined) { throw new Error() }
        this.radius = _json_.radius
    }

    readonly originPositionKey: string
    readonly radius: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class MoveToLocation extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.location === undefined) { throw new Error() }
        this.location = Vector3.deserializeFromJson(_json_.location)
        if (_json_.acceptable_radius === undefined) { throw new Error() }
        this.acceptableRadius = _json_.acceptable_radius
    }

    readonly location: Vector3
    readonly acceptableRadius: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace ai {
export class DebugPrint extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.text === undefined) { throw new Error() }
        this.text = _json_.text
    }

    readonly text: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}

export namespace blueprint {
export class TbClazz{
    private _dataMap: Map<string, blueprint.Clazz>
    private _dataList: blueprint.Clazz[]
    constructor(_json_: any) {
        this._dataMap = new Map<string, blueprint.Clazz>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: blueprint.Clazz
            _v = blueprint.Clazz.constructorFrom(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.name, _v)
        }
    }

    getDataMap(): Map<string, blueprint.Clazz> { return this._dataMap; }
    getDataList(): blueprint.Clazz[] { return this._dataList; }

    get(key: string): blueprint.Clazz | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace blueprint {
export abstract class Clazz {
    static constructorFrom(_json_: any): Clazz{
        switch (_json_.__type__) {
            case 'Interface': return new blueprint.Interface(_json_)
            case 'NormalClazz': return new blueprint.NormalClazz(_json_)
            case 'EnumClazz': return new blueprint.EnumClazz(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.parents === undefined) { throw new Error() }
        { this.parents = []; for(let _ele of _json_.parents) { let _e : blueprint.Clazz; _e = blueprint.Clazz.constructorFrom(_ele); this.parents.push(_e);}}
        if (_json_.methods === undefined) { throw new Error() }
        { this.methods = []; for(let _ele of _json_.methods) { let _e : blueprint.Method; _e = blueprint.Method.constructorFrom(_ele); this.methods.push(_e);}}
    }

    readonly name: string
    readonly desc: string
    readonly parents: blueprint.Clazz[]
    readonly methods: blueprint.Method[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.parents) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.methods) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace blueprint {
export abstract class Method {
    static constructorFrom(_json_: any): Method{
        switch (_json_.__type__) {
            case 'AbstraceMethod': return new blueprint.AbstraceMethod(_json_)
            case 'ExternalMethod': return new blueprint.ExternalMethod(_json_)
            case 'BlueprintMethod': return new blueprint.BlueprintMethod(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.is_static === undefined) { throw new Error() }
        this.isStatic = _json_.is_static
        if (_json_.return_type === undefined) { throw new Error() }
        this.returnType = _json_.return_type
        if (_json_.parameters === undefined) { throw new Error() }
        { this.parameters = []; for(let _ele of _json_.parameters) { let _e : blueprint.ParamInfo; _e = new blueprint.ParamInfo(_ele); this.parameters.push(_e);}}
    }

    readonly name: string
    readonly desc: string
    readonly isStatic: boolean
    readonly returnType: string
    readonly parameters: blueprint.ParamInfo[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.parameters) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace blueprint {
export class ParamInfo {

    constructor(_json_: any) {
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.type === undefined) { throw new Error() }
        this.type = _json_.type
        if (_json_.is_ref === undefined) { throw new Error() }
        this.isRef = _json_.is_ref
    }

    readonly name: string
    readonly type: string
    readonly isRef: boolean

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace blueprint {
export class AbstraceMethod extends blueprint.Method {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace blueprint {
export class ExternalMethod extends blueprint.Method {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace blueprint {
export class BlueprintMethod extends blueprint.Method {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace blueprint {
export class Interface extends blueprint.Clazz {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace blueprint {
export class NormalClazz extends blueprint.Clazz {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.is_abstract === undefined) { throw new Error() }
        this.isAbstract = _json_.is_abstract
        if (_json_.fields === undefined) { throw new Error() }
        { this.fields = []; for(let _ele of _json_.fields) { let _e : blueprint.Field; _e = new blueprint.Field(_ele); this.fields.push(_e);}}
    }

    readonly isAbstract: boolean
    readonly fields: blueprint.Field[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.fields) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace blueprint {
export class Field {

    constructor(_json_: any) {
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.type === undefined) { throw new Error() }
        this.type = _json_.type
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
    }

    readonly name: string
    readonly type: string
    readonly desc: string

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace blueprint {
export class EnumClazz extends blueprint.Clazz {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.enums === undefined) { throw new Error() }
        { this.enums = []; for(let _ele of _json_.enums) { let _e : blueprint.EnumField; _e = new blueprint.EnumField(_ele); this.enums.push(_e);}}
    }

    readonly enums: blueprint.EnumField[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.enums) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace blueprint {
export class EnumField {

    constructor(_json_: any) {
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly name: string
    readonly value: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace bonus {
export class TbDrop{
    private _dataMap: Map<number, bonus.DropInfo>
    private _dataList: bonus.DropInfo[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, bonus.DropInfo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: bonus.DropInfo
            _v = new bonus.DropInfo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, bonus.DropInfo> { return this._dataMap; }
    getDataList(): bonus.DropInfo[] { return this._dataList; }

    get(key: number): bonus.DropInfo | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace bonus {
export class DropInfo {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.client_show_items === undefined) { throw new Error() }
        { this.clientShowItems = []; for(let _ele of _json_.client_show_items) { let _e : bonus.ShowItemInfo; _e = new bonus.ShowItemInfo(_ele); this.clientShowItems.push(_e);}}
        if (_json_.bonus === undefined) { throw new Error() }
        this.bonus = bonus.Bonus.constructorFrom(_json_.bonus)
    }

    readonly id: number
    readonly desc: string
    readonly clientShowItems: bonus.ShowItemInfo[]
    readonly bonus: bonus.Bonus

    resolve(_tables: Map<string, any>) {
        for(let _e of this.clientShowItems) { if (_e != null ) {_e.resolve(_tables);} }
        if (this.bonus != null) { this.bonus.resolve(_tables);}
    }
}

}



export namespace bonus {
export class ShowItemInfo {

    constructor(_json_: any) {
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.item_num === undefined) { throw new Error() }
        this.itemNum = _json_.item_num
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!
    readonly itemNum: number

    resolve(_tables: Map<string, any>) {
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace bonus {
export abstract class Bonus {
    static constructorFrom(_json_: any): Bonus{
        switch (_json_.__type__) {
            case 'OneItem': return new bonus.OneItem(_json_)
            case 'OneItems': return new bonus.OneItems(_json_)
            case 'Item': return new bonus.Item(_json_)
            case 'Items': return new bonus.Items(_json_)
            case 'CoefficientItem': return new bonus.CoefficientItem(_json_)
            case 'WeightItems': return new bonus.WeightItems(_json_)
            case 'ProbabilityItems': return new bonus.ProbabilityItems(_json_)
            case 'MultiBonus': return new bonus.MultiBonus(_json_)
            case 'ProbabilityBonus': return new bonus.ProbabilityBonus(_json_)
            case 'WeightBonus': return new bonus.WeightBonus(_json_)
            case 'DropBonus': return new bonus.DropBonus(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace bonus {
export class OneItem extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace bonus {
export class OneItems extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.items === undefined) { throw new Error() }
        this.items = _json_.items
    }

    readonly items: Int32Array

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace bonus {
export class Item extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.amount === undefined) { throw new Error() }
        this.amount = _json_.amount
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!
    readonly amount: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace bonus {
export class Items extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list === undefined) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :bonus.Item; _e = new bonus.Item(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: bonus.Item[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace bonus {
export class CoefficientItem extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonus_id === undefined) { throw new Error() }
        this.bonusId = _json_.bonus_id
        if (_json_.bonus_list === undefined) { throw new Error() }
        this.bonusList = new bonus.Items(_json_.bonus_list)
    }

    readonly bonusId: number
    readonly bonusList: bonus.Items

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.bonusList != null) { this.bonusList.resolve(_tables);}
    }
}

}



export namespace bonus {
export class WeightItems extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list === undefined) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :bonus.WeightItemInfo; _e = new bonus.WeightItemInfo(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: bonus.WeightItemInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace bonus {
export class WeightItemInfo {

    constructor(_json_: any) {
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
        if (_json_.weight === undefined) { throw new Error() }
        this.weight = _json_.weight
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!
    readonly num: number
    readonly weight: number

    resolve(_tables: Map<string, any>) {
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace bonus {
export class ProbabilityItems extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list === undefined) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :bonus.ProbabilityItemInfo; _e = new bonus.ProbabilityItemInfo(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: bonus.ProbabilityItemInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace bonus {
export class ProbabilityItemInfo {

    constructor(_json_: any) {
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
        if (_json_.probability === undefined) { throw new Error() }
        this.probability = _json_.probability
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!
    readonly num: number
    readonly probability: number

    resolve(_tables: Map<string, any>) {
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace bonus {
export class MultiBonus extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonuses === undefined) { throw new Error() }
        { this.bonuses = []; for(let _ele of _json_.bonuses) { let _e :bonus.Bonus; _e = bonus.Bonus.constructorFrom(_ele); this.bonuses.push(_e);}}
    }

    readonly bonuses: bonus.Bonus[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.bonuses) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace bonus {
export class ProbabilityBonus extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonuses === undefined) { throw new Error() }
        { this.bonuses = []; for(let _ele of _json_.bonuses) { let _e :bonus.ProbabilityBonusInfo; _e = new bonus.ProbabilityBonusInfo(_ele); this.bonuses.push(_e);}}
    }

    readonly bonuses: bonus.ProbabilityBonusInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.bonuses) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace bonus {
export class ProbabilityBonusInfo {

    constructor(_json_: any) {
        if (_json_.bonus === undefined) { throw new Error() }
        this.bonus = bonus.Bonus.constructorFrom(_json_.bonus)
        if (_json_.probability === undefined) { throw new Error() }
        this.probability = _json_.probability
    }

    readonly bonus: bonus.Bonus
    readonly probability: number

    resolve(_tables: Map<string, any>) {
        if (this.bonus != null) { this.bonus.resolve(_tables);}
    }
}

}



export namespace bonus {
export class WeightBonus extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonuses === undefined) { throw new Error() }
        { this.bonuses = []; for(let _ele of _json_.bonuses) { let _e :bonus.WeightBonusInfo; _e = new bonus.WeightBonusInfo(_ele); this.bonuses.push(_e);}}
    }

    readonly bonuses: bonus.WeightBonusInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.bonuses) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace bonus {
export class WeightBonusInfo {

    constructor(_json_: any) {
        if (_json_.bonus === undefined) { throw new Error() }
        this.bonus = bonus.Bonus.constructorFrom(_json_.bonus)
        if (_json_.weight === undefined) { throw new Error() }
        this.weight = _json_.weight
    }

    readonly bonus: bonus.Bonus
    readonly weight: number

    resolve(_tables: Map<string, any>) {
        if (this.bonus != null) { this.bonus.resolve(_tables);}
    }
}

}



export namespace bonus {
export class DropBonus extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
    }

    readonly id: number
    id_Ref : bonus.DropInfo = undefined!

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.id_Ref = (_tables.get('bonus.TbDrop') as bonus.TbDrop).get(this.id)!
    }
}

}

export namespace common {
export class TbGlobalConfig{

     private _data: common.GlobalConfig
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new common.GlobalConfig(_json_[0])
    }

    getData(): common.GlobalConfig { return this._data; }

    /**
     * 背包容量
     */
     get  bagCapacity(): number { return this._data.bagCapacity; }
     get  bagCapacitySpecial(): number { return this._data.bagCapacitySpecial; }
     get  bagTempExpendableCapacity(): number { return this._data.bagTempExpendableCapacity; }
     get  bagTempToolCapacity(): number { return this._data.bagTempToolCapacity; }
     get  bagInitCapacity(): number { return this._data.bagInitCapacity; }
     get  quickBagCapacity(): number { return this._data.quickBagCapacity; }
     get  clothBagCapacity(): number { return this._data.clothBagCapacity; }
     get  clothBagInitCapacity(): number { return this._data.clothBagInitCapacity; }
     get  clothBagCapacitySpecial(): number { return this._data.clothBagCapacitySpecial; }
     get  bagInitItemsDropId(): number|undefined { return this._data.bagInitItemsDropId; }
     get  mailBoxCapacity(): number { return this._data.mailBoxCapacity; }
     get  damageParamC(): number { return this._data.damageParamC; }
     get  damageParamE(): number { return this._data.damageParamE; }
     get  damageParamF(): number { return this._data.damageParamF; }
     get  damageParamD(): number { return this._data.damageParamD; }
     get  roleSpeed(): number { return this._data.roleSpeed; }
     get  monsterSpeed(): number { return this._data.monsterSpeed; }
     get  initEnergy(): number { return this._data.initEnergy; }
     get  initViality(): number { return this._data.initViality; }
     get  maxViality(): number { return this._data.maxViality; }
     get  perVialityRecoveryTime(): number { return this._data.perVialityRecoveryTime; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}



export namespace common {
export class GlobalConfig {

    constructor(_json_: any) {
        if (_json_.bag_capacity === undefined) { throw new Error() }
        this.bagCapacity = _json_.bag_capacity
        if (_json_.bag_capacity_special === undefined) { throw new Error() }
        this.bagCapacitySpecial = _json_.bag_capacity_special
        if (_json_.bag_temp_expendable_capacity === undefined) { throw new Error() }
        this.bagTempExpendableCapacity = _json_.bag_temp_expendable_capacity
        if (_json_.bag_temp_tool_capacity === undefined) { throw new Error() }
        this.bagTempToolCapacity = _json_.bag_temp_tool_capacity
        if (_json_.bag_init_capacity === undefined) { throw new Error() }
        this.bagInitCapacity = _json_.bag_init_capacity
        if (_json_.quick_bag_capacity === undefined) { throw new Error() }
        this.quickBagCapacity = _json_.quick_bag_capacity
        if (_json_.cloth_bag_capacity === undefined) { throw new Error() }
        this.clothBagCapacity = _json_.cloth_bag_capacity
        if (_json_.cloth_bag_init_capacity === undefined) { throw new Error() }
        this.clothBagInitCapacity = _json_.cloth_bag_init_capacity
        if (_json_.cloth_bag_capacity_special === undefined) { throw new Error() }
        this.clothBagCapacitySpecial = _json_.cloth_bag_capacity_special
        if(_json_.bag_init_items_drop_id != undefined) { this.bagInitItemsDropId = _json_.bag_init_items_drop_id } else { this.bagInitItemsDropId = undefined }
        if (_json_.mail_box_capacity === undefined) { throw new Error() }
        this.mailBoxCapacity = _json_.mail_box_capacity
        if (_json_.damage_param_c === undefined) { throw new Error() }
        this.damageParamC = _json_.damage_param_c
        if (_json_.damage_param_e === undefined) { throw new Error() }
        this.damageParamE = _json_.damage_param_e
        if (_json_.damage_param_f === undefined) { throw new Error() }
        this.damageParamF = _json_.damage_param_f
        if (_json_.damage_param_d === undefined) { throw new Error() }
        this.damageParamD = _json_.damage_param_d
        if (_json_.role_speed === undefined) { throw new Error() }
        this.roleSpeed = _json_.role_speed
        if (_json_.monster_speed === undefined) { throw new Error() }
        this.monsterSpeed = _json_.monster_speed
        if (_json_.init_energy === undefined) { throw new Error() }
        this.initEnergy = _json_.init_energy
        if (_json_.init_viality === undefined) { throw new Error() }
        this.initViality = _json_.init_viality
        if (_json_.max_viality === undefined) { throw new Error() }
        this.maxViality = _json_.max_viality
        if (_json_.per_viality_recovery_time === undefined) { throw new Error() }
        this.perVialityRecoveryTime = _json_.per_viality_recovery_time
    }

    /**
     * 背包容量
     */
    readonly bagCapacity: number
    readonly bagCapacitySpecial: number
    readonly bagTempExpendableCapacity: number
    readonly bagTempToolCapacity: number
    readonly bagInitCapacity: number
    readonly quickBagCapacity: number
    readonly clothBagCapacity: number
    readonly clothBagInitCapacity: number
    readonly clothBagCapacitySpecial: number
    readonly bagInitItemsDropId: number|undefined
    bagInitItemsDropId_Ref : bonus.DropInfo
    readonly mailBoxCapacity: number
    readonly damageParamC: number
    readonly damageParamE: number
    readonly damageParamF: number
    readonly damageParamD: number
    readonly roleSpeed: number
    readonly monsterSpeed: number
    readonly initEnergy: number
    readonly initViality: number
    readonly maxViality: number
    readonly perVialityRecoveryTime: number

    resolve(_tables: Map<string, any>) {
        this.bagInitItemsDropId_Ref = this.bagInitItemsDropId != undefined ? (_tables.get('bonus.TbDrop') as  bonus.TbDrop).get(this.bagInitItemsDropId) : undefined
    }
}

}

export namespace error {
export class TbErrorInfo{
    private _dataMap: Map<string, error.ErrorInfo>
    private _dataList: error.ErrorInfo[]
    constructor(_json_: any) {
        this._dataMap = new Map<string, error.ErrorInfo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: error.ErrorInfo
            _v = new error.ErrorInfo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.code, _v)
        }
    }

    getDataMap(): Map<string, error.ErrorInfo> { return this._dataMap; }
    getDataList(): error.ErrorInfo[] { return this._dataList; }

    get(key: string): error.ErrorInfo | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace error {
export class ErrorInfo {

    constructor(_json_: any) {
        if (_json_.code === undefined) { throw new Error() }
        this.code = _json_.code
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.style === undefined) { throw new Error() }
        this.style = error.ErrorStyle.constructorFrom(_json_.style)
    }

    readonly code: string
    readonly desc: string
    readonly style: error.ErrorStyle

    resolve(_tables: Map<string, any>) {
        if (this.style != null) { this.style.resolve(_tables);}
    }
}

}



export namespace error {
export abstract class ErrorStyle {
    static constructorFrom(_json_: any): ErrorStyle{
        switch (_json_.__type__) {
            case 'ErrorStyleTip': return new error.ErrorStyleTip(_json_)
            case 'ErrorStyleMsgbox': return new error.ErrorStyleMsgbox(_json_)
            case 'ErrorStyleDlgOk': return new error.ErrorStyleDlgOk(_json_)
            case 'ErrorStyleDlgOkCancel': return new error.ErrorStyleDlgOkCancel(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace error {
export class ErrorStyleTip extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace error {
export class ErrorStyleMsgbox extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.btn_name === undefined) { throw new Error() }
        this.btnName = _json_.btn_name
        if (_json_.operation === undefined) { throw new Error() }
        this.operation = _json_.operation
    }

    readonly btnName: string
    readonly operation: error.EOperation

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace error {
export class ErrorStyleDlgOk extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.btn_name === undefined) { throw new Error() }
        this.btnName = _json_.btn_name
    }

    readonly btnName: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace error {
export class ErrorStyleDlgOkCancel extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.btn1_name === undefined) { throw new Error() }
        this.btn1Name = _json_.btn1_name
        if (_json_.btn2_name === undefined) { throw new Error() }
        this.btn2Name = _json_.btn2_name
    }

    readonly btn1Name: string
    readonly btn2Name: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}

export namespace error {
export class TbCodeInfo{
    private _dataMap: Map<error.EErrorCode, error.CodeInfo>
    private _dataList: error.CodeInfo[]
    constructor(_json_: any) {
        this._dataMap = new Map<error.EErrorCode, error.CodeInfo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: error.CodeInfo
            _v = new error.CodeInfo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.code, _v)
        }
    }

    getDataMap(): Map<error.EErrorCode, error.CodeInfo> { return this._dataMap; }
    getDataList(): error.CodeInfo[] { return this._dataList; }

    get(key: error.EErrorCode): error.CodeInfo | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace error {
export class CodeInfo {

    constructor(_json_: any) {
        if (_json_.code === undefined) { throw new Error() }
        this.code = _json_.code
        if (_json_.key === undefined) { throw new Error() }
        this.key = _json_.key
    }

    readonly code: error.EErrorCode
    readonly key: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace item {
/**
 * 道具表
 */
export class TbItem{
    private _dataMap: Map<number, item.Item>
    private _dataList: item.Item[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, item.Item>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: item.Item
            _v = new item.Item(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, item.Item> { return this._dataMap; }
    getDataList(): item.Item[] { return this._dataList; }

    get(key: number): item.Item | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace item {
/**
 * 道具
 */
export class Item {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.major_type === undefined) { throw new Error() }
        this.majorType = _json_.major_type
        if (_json_.minor_type === undefined) { throw new Error() }
        this.minorType = _json_.minor_type
        if (_json_.max_pile_num === undefined) { throw new Error() }
        this.maxPileNum = _json_.max_pile_num
        if (_json_.quality === undefined) { throw new Error() }
        this.quality = _json_.quality
        if (_json_.icon === undefined) { throw new Error() }
        this.icon = _json_.icon
        if (_json_.icon_backgroud === undefined) { throw new Error() }
        this.iconBackgroud = _json_.icon_backgroud
        if (_json_.icon_mask === undefined) { throw new Error() }
        this.iconMask = _json_.icon_mask
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.show_order === undefined) { throw new Error() }
        this.showOrder = _json_.show_order
        if (_json_.quantifier === undefined) { throw new Error() }
        this.quantifier = _json_.quantifier
        if (_json_.show_in_bag === undefined) { throw new Error() }
        this.showInBag = _json_.show_in_bag
        if (_json_.min_show_level === undefined) { throw new Error() }
        this.minShowLevel = _json_.min_show_level
        if (_json_.batch_usable === undefined) { throw new Error() }
        this.batchUsable = _json_.batch_usable
        if (_json_.progress_time_when_use === undefined) { throw new Error() }
        this.progressTimeWhenUse = _json_.progress_time_when_use
        if (_json_.show_hint_when_use === undefined) { throw new Error() }
        this.showHintWhenUse = _json_.show_hint_when_use
        if (_json_.droppable === undefined) { throw new Error() }
        this.droppable = _json_.droppable
        if(_json_.price != undefined) { this.price = _json_.price } else { this.price = undefined }
        if (_json_.use_type === undefined) { throw new Error() }
        this.useType = _json_.use_type
        if(_json_.level_up_id != undefined) { this.levelUpId = _json_.level_up_id } else { this.levelUpId = undefined }
    }

    /**
     * 道具id
     */
    readonly id: number
    readonly name: string
    readonly majorType: item.EMajorType
    readonly minorType: item.EMinorType
    readonly maxPileNum: number
    readonly quality: item.EItemQuality
    readonly icon: string
    readonly iconBackgroud: string
    readonly iconMask: string
    readonly desc: string
    readonly showOrder: number
    readonly quantifier: string
    readonly showInBag: boolean
    readonly minShowLevel: number
    readonly batchUsable: boolean
    readonly progressTimeWhenUse: number
    readonly showHintWhenUse: boolean
    readonly droppable: boolean
    readonly price: number|undefined
    readonly useType: item.EUseType
    readonly levelUpId: number|undefined

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace item {
export class TbItemFunc{
    private _dataMap: Map<item.EMinorType, item.ItemFunction>
    private _dataList: item.ItemFunction[]
    constructor(_json_: any) {
        this._dataMap = new Map<item.EMinorType, item.ItemFunction>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: item.ItemFunction
            _v = new item.ItemFunction(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.minorType, _v)
        }
    }

    getDataMap(): Map<item.EMinorType, item.ItemFunction> { return this._dataMap; }
    getDataList(): item.ItemFunction[] { return this._dataList; }

    get(key: item.EMinorType): item.ItemFunction | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace item {
export class ItemFunction {

    constructor(_json_: any) {
        if (_json_.minor_type === undefined) { throw new Error() }
        this.minorType = _json_.minor_type
        if (_json_.func_type === undefined) { throw new Error() }
        this.funcType = _json_.func_type
        if (_json_.method === undefined) { throw new Error() }
        this.method = _json_.method
        if (_json_.close_bag_ui === undefined) { throw new Error() }
        this.closeBagUi = _json_.close_bag_ui
    }

    readonly minorType: item.EMinorType
    readonly funcType: item.EItemFunctionType
    readonly method: string
    readonly closeBagUi: boolean

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace item {
export class TbItemExtra{
    private _dataMap: Map<number, item.ItemExtra>
    private _dataList: item.ItemExtra[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, item.ItemExtra>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: item.ItemExtra
            _v = item.ItemExtra.constructorFrom(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, item.ItemExtra> { return this._dataMap; }
    getDataList(): item.ItemExtra[] { return this._dataList; }

    get(key: number): item.ItemExtra | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace item {
export abstract class ItemExtra {
    static constructorFrom(_json_: any): ItemExtra{
        switch (_json_.__type__) {
            case 'TreasureBox': return new item.TreasureBox(_json_)
            case 'InteractionItem': return new item.InteractionItem(_json_)
            case 'Clothes': return new item.Clothes(_json_)
            case 'DesignDrawing': return new item.DesignDrawing(_json_)
            case 'Dymmy': return new item.Dymmy(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
    }

    readonly id: number

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace item {
export class TreasureBox extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if(_json_.key_item_id != undefined) { this.keyItemId = _json_.key_item_id } else { this.keyItemId = undefined }
        if (_json_.open_level === undefined) { throw new Error() }
        this.openLevel = new condition.MinLevel(_json_.open_level)
        if (_json_.use_on_obtain === undefined) { throw new Error() }
        this.useOnObtain = _json_.use_on_obtain
        if (_json_.drop_ids === undefined) { throw new Error() }
        this.dropIds = _json_.drop_ids
        if (_json_.choose_list === undefined) { throw new Error() }
        { this.chooseList = []; for(let _ele of _json_.choose_list) { let _e : item.ChooseOneBonus; _e = new item.ChooseOneBonus(_ele); this.chooseList.push(_e);}}
    }

    readonly keyItemId: number|undefined
    readonly openLevel: condition.MinLevel
    readonly useOnObtain: boolean
    readonly dropIds: number[]
    readonly chooseList: item.ChooseOneBonus[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.openLevel != null) { this.openLevel.resolve(_tables);}
        for(let _e of this.chooseList) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace condition {
export abstract class Condition {
    static constructorFrom(_json_: any): Condition{
        switch (_json_.__type__) {
            case 'TimeRange': return new condition.TimeRange(_json_)
            case 'MultiRoleCondition': return new condition.MultiRoleCondition(_json_)
            case 'GenderLimit': return new condition.GenderLimit(_json_)
            case 'MinLevel': return new condition.MinLevel(_json_)
            case 'MaxLevel': return new condition.MaxLevel(_json_)
            case 'MinMaxLevel': return new condition.MinMaxLevel(_json_)
            case 'ClothesPropertyScoreGreaterThan': return new condition.ClothesPropertyScoreGreaterThan(_json_)
            case 'ContainsItem': return new condition.ContainsItem(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace condition {
export class TimeRange extends condition.Condition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.date_time_range === undefined) { throw new Error() }
        this.dateTimeRange = new common.DateTimeRange(_json_.date_time_range)
    }

    readonly dateTimeRange: common.DateTimeRange

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.dateTimeRange != null) { this.dateTimeRange.resolve(_tables);}
    }
}

}



export namespace common {
export class DateTimeRange {

    constructor(_json_: any) {
        if(_json_.start_time != undefined) { this.startTime = _json_.start_time } else { this.startTime = undefined }
        if(_json_.end_time != undefined) { this.endTime = _json_.end_time } else { this.endTime = undefined }
    }

    readonly startTime: number|undefined
    readonly endTime: number|undefined

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace condition {
export abstract class RoleCondition extends condition.Condition {
    static constructorFrom(_json_: any): RoleCondition{
        switch (_json_.__type__) {
            case 'MultiRoleCondition': return new condition.MultiRoleCondition(_json_)
            case 'GenderLimit': return new condition.GenderLimit(_json_)
            case 'MinLevel': return new condition.MinLevel(_json_)
            case 'MaxLevel': return new condition.MaxLevel(_json_)
            case 'MinMaxLevel': return new condition.MinMaxLevel(_json_)
            case 'ClothesPropertyScoreGreaterThan': return new condition.ClothesPropertyScoreGreaterThan(_json_)
            case 'ContainsItem': return new condition.ContainsItem(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace condition {
export class MultiRoleCondition extends condition.RoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.conditions === undefined) { throw new Error() }
        { this.conditions = []; for(let _ele of _json_.conditions) { let _e :condition.RoleCondition; _e = condition.RoleCondition.constructorFrom(_ele); this.conditions.push(_e);}}
    }

    readonly conditions: condition.RoleCondition[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.conditions) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace condition {
export abstract class BoolRoleCondition extends condition.RoleCondition {
    static constructorFrom(_json_: any): BoolRoleCondition{
        switch (_json_.__type__) {
            case 'GenderLimit': return new condition.GenderLimit(_json_)
            case 'MinLevel': return new condition.MinLevel(_json_)
            case 'MaxLevel': return new condition.MaxLevel(_json_)
            case 'MinMaxLevel': return new condition.MinMaxLevel(_json_)
            case 'ClothesPropertyScoreGreaterThan': return new condition.ClothesPropertyScoreGreaterThan(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace condition {
export class GenderLimit extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.gender === undefined) { throw new Error() }
        this.gender = _json_.gender
    }

    readonly gender: role.EGenderType

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace condition {
export class MinLevel extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.level === undefined) { throw new Error() }
        this.level = _json_.level
    }

    readonly level: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace condition {
export class MaxLevel extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.level === undefined) { throw new Error() }
        this.level = _json_.level
    }

    readonly level: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace condition {
export class MinMaxLevel extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.min === undefined) { throw new Error() }
        this.min = _json_.min
        if (_json_.max === undefined) { throw new Error() }
        this.max = _json_.max
    }

    readonly min: number
    readonly max: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace condition {
export class ClothesPropertyScoreGreaterThan extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.prop === undefined) { throw new Error() }
        this.prop = _json_.prop
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly prop: item.EClothesPropertyType
    readonly value: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace condition {
export class ContainsItem extends condition.RoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
        if (_json_.reverse === undefined) { throw new Error() }
        this.reverse = _json_.reverse
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!
    readonly num: number
    readonly reverse: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace item {
export class ChooseOneBonus {

    constructor(_json_: any) {
        if (_json_.drop_id === undefined) { throw new Error() }
        this.dropId = _json_.drop_id
        if (_json_.is_unique === undefined) { throw new Error() }
        this.isUnique = _json_.is_unique
    }

    readonly dropId: number
    dropId_Ref : bonus.DropInfo = undefined!
    readonly isUnique: boolean

    resolve(_tables: Map<string, any>) {
        this.dropId_Ref = (_tables.get('bonus.TbDrop') as bonus.TbDrop).get(this.dropId)!
    }
}

}



export namespace item {
export class InteractionItem extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if(_json_.attack_num != undefined) { this.attackNum = _json_.attack_num } else { this.attackNum = undefined }
        if (_json_.holding_static_mesh === undefined) { throw new Error() }
        this.holdingStaticMesh = _json_.holding_static_mesh
        if (_json_.holding_static_mesh_mat === undefined) { throw new Error() }
        this.holdingStaticMeshMat = _json_.holding_static_mesh_mat
    }

    readonly attackNum: number|undefined
    readonly holdingStaticMesh: string
    readonly holdingStaticMeshMat: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace item {
export class Clothes extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.attack === undefined) { throw new Error() }
        this.attack = _json_.attack
        if (_json_.hp === undefined) { throw new Error() }
        this.hp = _json_.hp
        if (_json_.energy_limit === undefined) { throw new Error() }
        this.energyLimit = _json_.energy_limit
        if (_json_.energy_resume === undefined) { throw new Error() }
        this.energyResume = _json_.energy_resume
    }

    readonly attack: number
    readonly hp: number
    readonly energyLimit: number
    readonly energyResume: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace item {
export class DesignDrawing extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.learn_component_id === undefined) { throw new Error() }
        this.learnComponentId = _json_.learn_component_id
    }

    readonly learnComponentId: number[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace item {
export class Dymmy extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.cost === undefined) { throw new Error() }
        this.cost = cost.Cost.constructorFrom(_json_.cost)
    }

    readonly cost: cost.Cost

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.cost != null) { this.cost.resolve(_tables);}
    }
}

}



export namespace cost {
export abstract class Cost {
    static constructorFrom(_json_: any): Cost{
        switch (_json_.__type__) {
            case 'CostCurrency': return new cost.CostCurrency(_json_)
            case 'CostCurrencies': return new cost.CostCurrencies(_json_)
            case 'CostOneItem': return new cost.CostOneItem(_json_)
            case 'CostItem': return new cost.CostItem(_json_)
            case 'CostItems': return new cost.CostItems(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace cost {
export class CostCurrency extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.type === undefined) { throw new Error() }
        this.type = _json_.type
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
    }

    readonly type: item.ECurrencyType
    readonly num: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace cost {
export class CostCurrencies extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.currencies === undefined) { throw new Error() }
        { this.currencies = []; for(let _ele of _json_.currencies) { let _e : cost.CostCurrency; _e = new cost.CostCurrency(_ele); this.currencies.push(_e);}}
    }

    readonly currencies: cost.CostCurrency[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.currencies) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace cost {
export class CostOneItem extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace cost {
export class CostItem extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id === undefined) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.amount === undefined) { throw new Error() }
        this.amount = _json_.amount
    }

    readonly itemId: number
    itemId_Ref : item.Item = undefined!
    readonly amount: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)!
    }
}

}



export namespace cost {
export class CostItems extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list === undefined) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :cost.CostItem; _e = new cost.CostItem(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: cost.CostItem[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}

export namespace l10n {
export class TbL10NDemo{
    private _dataMap: Map<number, l10n.L10NDemo>
    private _dataList: l10n.L10NDemo[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, l10n.L10NDemo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: l10n.L10NDemo
            _v = new l10n.L10NDemo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, l10n.L10NDemo> { return this._dataMap; }
    getDataList(): l10n.L10NDemo[] { return this._dataList; }

    get(key: number): l10n.L10NDemo | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace l10n {
export class L10NDemo {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.text === undefined) { throw new Error() }
        this.text = _json_.text['text']
    }

    readonly id: number
    readonly text: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace l10n {
export class TbPatchDemo{
    private _dataMap: Map<number, l10n.PatchDemo>
    private _dataList: l10n.PatchDemo[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, l10n.PatchDemo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: l10n.PatchDemo
            _v = new l10n.PatchDemo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, l10n.PatchDemo> { return this._dataMap; }
    getDataList(): l10n.PatchDemo[] { return this._dataList; }

    get(key: number): l10n.PatchDemo | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace l10n {
export class PatchDemo {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly id: number
    readonly value: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace mail {
export class TbSystemMail{
    private _dataMap: Map<number, mail.SystemMail>
    private _dataList: mail.SystemMail[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, mail.SystemMail>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: mail.SystemMail
            _v = new mail.SystemMail(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, mail.SystemMail> { return this._dataMap; }
    getDataList(): mail.SystemMail[] { return this._dataList; }

    get(key: number): mail.SystemMail | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace mail {
export class SystemMail {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.title === undefined) { throw new Error() }
        this.title = _json_.title
        if (_json_.sender === undefined) { throw new Error() }
        this.sender = _json_.sender
        if (_json_.content === undefined) { throw new Error() }
        this.content = _json_.content
        if (_json_.award === undefined) { throw new Error() }
        this.award = _json_.award
    }

    readonly id: number
    readonly title: string
    readonly sender: string
    readonly content: string
    readonly award: number[]

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace mail {
export class TbGlobalMail{
    private _dataMap: Map<number, mail.GlobalMail>
    private _dataList: mail.GlobalMail[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, mail.GlobalMail>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: mail.GlobalMail
            _v = new mail.GlobalMail(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, mail.GlobalMail> { return this._dataMap; }
    getDataList(): mail.GlobalMail[] { return this._dataList; }

    get(key: number): mail.GlobalMail | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace mail {
export class GlobalMail {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.title === undefined) { throw new Error() }
        this.title = _json_.title
        if (_json_.sender === undefined) { throw new Error() }
        this.sender = _json_.sender
        if (_json_.content === undefined) { throw new Error() }
        this.content = _json_.content
        if (_json_.award === undefined) { throw new Error() }
        this.award = _json_.award
        if (_json_.all_server === undefined) { throw new Error() }
        this.allServer = _json_.all_server
        if (_json_.server_list === undefined) { throw new Error() }
        this.serverList = _json_.server_list
        if (_json_.platform === undefined) { throw new Error() }
        this.platform = _json_.platform
        if (_json_.channel === undefined) { throw new Error() }
        this.channel = _json_.channel
        if (_json_.min_max_level === undefined) { throw new Error() }
        this.minMaxLevel = new condition.MinMaxLevel(_json_.min_max_level)
        if (_json_.register_time === undefined) { throw new Error() }
        this.registerTime = new condition.TimeRange(_json_.register_time)
        if (_json_.mail_time === undefined) { throw new Error() }
        this.mailTime = new condition.TimeRange(_json_.mail_time)
    }

    readonly id: number
    readonly title: string
    readonly sender: string
    readonly content: string
    readonly award: number[]
    readonly allServer: boolean
    readonly serverList: number[]
    readonly platform: string
    readonly channel: string
    readonly minMaxLevel: condition.MinMaxLevel
    readonly registerTime: condition.TimeRange
    readonly mailTime: condition.TimeRange

    resolve(_tables: Map<string, any>) {
        if (this.minMaxLevel != null) { this.minMaxLevel.resolve(_tables);}
        if (this.registerTime != null) { this.registerTime.resolve(_tables);}
        if (this.mailTime != null) { this.mailTime.resolve(_tables);}
    }
}

}

export namespace role {
export class TbRoleLevelExpAttr{
    private _dataMap: Map<number, role.LevelExpAttr>
    private _dataList: role.LevelExpAttr[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, role.LevelExpAttr>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: role.LevelExpAttr
            _v = new role.LevelExpAttr(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.level, _v)
        }
    }

    getDataMap(): Map<number, role.LevelExpAttr> { return this._dataMap; }
    getDataList(): role.LevelExpAttr[] { return this._dataList; }

    get(key: number): role.LevelExpAttr | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace role {
export class LevelExpAttr {

    constructor(_json_: any) {
        if (_json_.level === undefined) { throw new Error() }
        this.level = _json_.level
        if (_json_.need_exp === undefined) { throw new Error() }
        this.needExp = _json_.need_exp
        if (_json_.clothes_attrs === undefined) { throw new Error() }
        this.clothesAttrs = _json_.clothes_attrs
    }

    readonly level: number
    readonly needExp: number
    readonly clothesAttrs: number[]

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace role {
export class TbRoleLevelBonusCoefficient{
    private _dataMap: Map<number, role.LevelBonus>
    private _dataList: role.LevelBonus[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, role.LevelBonus>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: role.LevelBonus
            _v = new role.LevelBonus(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, role.LevelBonus> { return this._dataMap; }
    getDataList(): role.LevelBonus[] { return this._dataList; }

    get(key: number): role.LevelBonus | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace role {
export class LevelBonus {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.distinct_bonus_infos === undefined) { throw new Error() }
        { this.distinctBonusInfos = []; for(let _ele of _json_.distinct_bonus_infos) { let _e : role.DistinctBonusInfos; _e = new role.DistinctBonusInfos(_ele); this.distinctBonusInfos.push(_e);}}
    }

    readonly id: number
    readonly distinctBonusInfos: role.DistinctBonusInfos[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.distinctBonusInfos) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace role {
export class DistinctBonusInfos {

    constructor(_json_: any) {
        if (_json_.effective_level === undefined) { throw new Error() }
        this.effectiveLevel = _json_.effective_level
        if (_json_.bonus_info === undefined) { throw new Error() }
        { this.bonusInfo = []; for(let _ele of _json_.bonus_info) { let _e : role.BonusInfo; _e = new role.BonusInfo(_ele); this.bonusInfo.push(_e);}}
    }

    readonly effectiveLevel: number
    readonly bonusInfo: role.BonusInfo[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.bonusInfo) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace role {
export class BonusInfo {

    constructor(_json_: any) {
        if (_json_.type === undefined) { throw new Error() }
        this.type = _json_.type
        if (_json_.coefficient === undefined) { throw new Error() }
        this.coefficient = _json_.coefficient
    }

    readonly type: item.ECurrencyType
    readonly coefficient: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace tag {
export class TbTestTag{
    private _dataMap: Map<number, tag.TestTag>
    private _dataList: tag.TestTag[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, tag.TestTag>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: tag.TestTag
            _v = new tag.TestTag(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, tag.TestTag> { return this._dataMap; }
    getDataList(): tag.TestTag[] { return this._dataList; }

    get(key: number): tag.TestTag | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace tag {
export class TestTag {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly id: number
    readonly value: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbFullTypes{
    private _dataMap: Map<number, test.DemoType2>
    private _dataList: test.DemoType2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoType2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoType2
            _v = new test.DemoType2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.DemoType2> { return this._dataMap; }
    getDataList(): test.DemoType2[] { return this._dataList; }

    get(key: number): test.DemoType2 | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class DemoType2 {

    constructor(_json_: any) {
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = _json_.x4
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x5 === undefined) { throw new Error() }
        this.x5 = _json_.x5
        if (_json_.x6 === undefined) { throw new Error() }
        this.x6 = _json_.x6
        if (_json_.x7 === undefined) { throw new Error() }
        this.x7 = _json_.x7
        if (_json_.x8_0 === undefined) { throw new Error() }
        this.x80 = _json_.x8_0
        if (_json_.x8 === undefined) { throw new Error() }
        this.x8 = _json_.x8
        if (_json_.x9 === undefined) { throw new Error() }
        this.x9 = _json_.x9
        if (_json_.x10 === undefined) { throw new Error() }
        this.x10 = _json_.x10
        if (_json_.x12 === undefined) { throw new Error() }
        this.x12 = new test.DemoType1(_json_.x12)
        if (_json_.x13 === undefined) { throw new Error() }
        this.x13 = _json_.x13
        if (_json_.x14 === undefined) { throw new Error() }
        this.x14 = test.DemoDynamic.constructorFrom(_json_.x14)
        if (_json_.s1 === undefined) { throw new Error() }
        this.s1 = _json_.s1['text']
        if (_json_.v2 === undefined) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.v3 === undefined) { throw new Error() }
        this.v3 = Vector3.deserializeFromJson(_json_.v3)
        if (_json_.v4 === undefined) { throw new Error() }
        this.v4 = Vector4.deserializeFromJson(_json_.v4)
        if (_json_.t1 === undefined) { throw new Error() }
        this.t1 = _json_.t1
        if (_json_.k1 === undefined) { throw new Error() }
        this.k1 = _json_.k1
        if (_json_.k2 === undefined) { throw new Error() }
        this.k2 = _json_.k2
        if (_json_.k5 === undefined) { throw new Error() }
        this.k5 = _json_.k5
        if (_json_.k8 === undefined) { throw new Error() }
        this.k8 = new Map<number, number>(); for(var _entry_ of _json_.k8) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.k8.set(_k, _v);  }
        if (_json_.k9 === undefined) { throw new Error() }
        { this.k9 = []; for(let _ele of _json_.k9) { let _e : test.DemoE2; _e = new test.DemoE2(_ele); this.k9.push(_e);}}
        if (_json_.k15 === undefined) { throw new Error() }
        { this.k15 = []; for(let _ele of _json_.k15) { let _e :test.DemoDynamic; _e = test.DemoDynamic.constructorFrom(_ele); this.k15.push(_e);}}
    }

    readonly x4: number
    readonly x1: boolean
    readonly x2: number
    readonly x3: number
    readonly x5: number
    readonly x6: number
    readonly x7: number
    readonly x80: number
    readonly x8: number
    readonly x9: bigint
    readonly x10: string
    readonly x12: test.DemoType1
    readonly x13: test.DemoEnum
    readonly x14: test.DemoDynamic
    readonly s1: string
    readonly v2: Vector2
    readonly v3: Vector3
    readonly v4: Vector4
    readonly t1: number
    readonly k1: Int32Array
    readonly k2: number[]
    readonly k5: Set<number>
    readonly k8: Map<number, number>
    readonly k9: test.DemoE2[]
    readonly k15: test.DemoDynamic[]

    resolve(_tables: Map<string, any>) {
        if (this.x12 != null) { this.x12.resolve(_tables);}
        if (this.x14 != null) { this.x14.resolve(_tables);}
        for(let _e of this.k9) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.k15) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace test {
export class DemoType1 {

    constructor(_json_: any) {
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
    }

    readonly x1: number

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
export abstract class DemoDynamic {
    static constructorFrom(_json_: any): DemoDynamic{
        switch (_json_.__type__) {
            case 'DemoD2': return new test.DemoD2(_json_)
            case 'DemoE1': return new test.DemoE1(_json_)
            case 'test.login.RoleInfo': return new test.login.RoleInfo(_json_)
            case 'DemoD5': return new test.DemoD5(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
    }

    readonly x1: number

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
export class DemoD2 extends test.DemoDynamic {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
    }

    readonly x2: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace test {
export abstract class DemoD3 extends test.DemoDynamic {
    static constructorFrom(_json_: any): DemoD3{
        switch (_json_.__type__) {
            case 'DemoE1': return new test.DemoE1(_json_)
            case 'test.login.RoleInfo': return new test.login.RoleInfo(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
    }

    readonly x3: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace test {
export class DemoE1 extends test.DemoD3 {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = _json_.x4
    }

    readonly x4: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace test {export namespace login {
export class RoleInfo extends test.DemoD3 {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.role_id === undefined) { throw new Error() }
        this.roleId = _json_.role_id
    }

    readonly roleId: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}}



export namespace test {
export class DemoD5 extends test.DemoDynamic {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.time === undefined) { throw new Error() }
        this.time = new test.DateTimeRange(_json_.time)
    }

    readonly time: test.DateTimeRange

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.time != null) { this.time.resolve(_tables);}
    }
}

}



export namespace test {
export class DateTimeRange {

    constructor(_json_: any) {
        if (_json_.start_time === undefined) { throw new Error() }
        this.startTime = _json_.start_time
        if (_json_.end_time === undefined) { throw new Error() }
        this.endTime = _json_.end_time
    }

    readonly startTime: number
    readonly endTime: number

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
export class DemoE2 {

    constructor(_json_: any) {
        if(_json_.y1 != undefined) { this.y1 = _json_.y1 } else { this.y1 = undefined }
        if (_json_.y2 === undefined) { throw new Error() }
        this.y2 = _json_.y2
    }

    readonly y1: number|undefined
    readonly y2: boolean

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbSingleton{

     private _data: test.DemoSingletonType
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new test.DemoSingletonType(_json_[0])
    }

    getData(): test.DemoSingletonType { return this._data; }

     get  id(): number { return this._data.id; }
     get  name(): string { return this._data.name; }
     get  date(): test.DemoDynamic { return this._data.date; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}



export namespace test {
export class DemoSingletonType {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name['text']
        if (_json_.date === undefined) { throw new Error() }
        this.date = test.DemoDynamic.constructorFrom(_json_.date)
    }

    readonly id: number
    readonly name: string
    readonly date: test.DemoDynamic

    resolve(_tables: Map<string, any>) {
        if (this.date != null) { this.date.resolve(_tables);}
    }
}

}

export namespace test {
export class TbNotIndexList{
    private _dataList: test.NotIndexList[]
    
    constructor(_json_: any) {
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.NotIndexList
            _v = new test.NotIndexList(_json2_)
            this._dataList.push(_v)
        }
    }

    getDataList(): test.NotIndexList[] { return this._dataList }

    get(index: number): test.NotIndexList | undefined { return this._dataList[index] }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}



export namespace test {
export class NotIndexList {

    constructor(_json_: any) {
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
        if (_json_.y === undefined) { throw new Error() }
        this.y = _json_.y
    }

    readonly x: number
    readonly y: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbMultiUnionIndexList{
    private _dataList: test.MultiUnionIndexList[]
    
    constructor(_json_: any) {
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.MultiUnionIndexList
            _v = new test.MultiUnionIndexList(_json2_)
            this._dataList.push(_v)
        }
    }

    getDataList(): test.MultiUnionIndexList[] { return this._dataList }

    get(index: number): test.MultiUnionIndexList | undefined { return this._dataList[index] }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}



export namespace test {
export class MultiUnionIndexList {

    constructor(_json_: any) {
        if (_json_.id1 === undefined) { throw new Error() }
        this.id1 = _json_.id1
        if (_json_.id2 === undefined) { throw new Error() }
        this.id2 = _json_.id2
        if (_json_.id3 === undefined) { throw new Error() }
        this.id3 = _json_.id3
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
    }

    readonly id1: number
    readonly id2: number
    readonly id3: string
    readonly num: number
    readonly desc: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbMultiIndexList{
    private _dataList: test.MultiIndexList[]
    
    constructor(_json_: any) {
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.MultiIndexList
            _v = new test.MultiIndexList(_json2_)
            this._dataList.push(_v)
        }
    }

    getDataList(): test.MultiIndexList[] { return this._dataList }

    get(index: number): test.MultiIndexList | undefined { return this._dataList[index] }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}



export namespace test {
export class MultiIndexList {

    constructor(_json_: any) {
        if (_json_.id1 === undefined) { throw new Error() }
        this.id1 = _json_.id1
        if (_json_.id2 === undefined) { throw new Error() }
        this.id2 = _json_.id2
        if (_json_.id3 === undefined) { throw new Error() }
        this.id3 = _json_.id3
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
    }

    readonly id1: number
    readonly id2: number
    readonly id3: string
    readonly num: number
    readonly desc: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbDataFromMisc{
    private _dataMap: Map<number, test.DemoType2>
    private _dataList: test.DemoType2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoType2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoType2
            _v = new test.DemoType2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.DemoType2> { return this._dataMap; }
    getDataList(): test.DemoType2[] { return this._dataList; }

    get(key: number): test.DemoType2 | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}

export namespace test {
export class TbMultiRowRecord{
    private _dataMap: Map<number, test.MultiRowRecord>
    private _dataList: test.MultiRowRecord[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.MultiRowRecord>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.MultiRowRecord
            _v = new test.MultiRowRecord(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.MultiRowRecord> { return this._dataMap; }
    getDataList(): test.MultiRowRecord[] { return this._dataList; }

    get(key: number): test.MultiRowRecord | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class MultiRowRecord {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.one_rows === undefined) { throw new Error() }
        { this.oneRows = []; for(let _ele of _json_.one_rows) { let _e : test.MultiRowType1; _e = new test.MultiRowType1(_ele); this.oneRows.push(_e);}}
        if (_json_.multi_rows1 === undefined) { throw new Error() }
        { this.multiRows1 = []; for(let _ele of _json_.multi_rows1) { let _e : test.MultiRowType1; _e = new test.MultiRowType1(_ele); this.multiRows1.push(_e);}}
        if (_json_.multi_rows2 === undefined) { throw new Error() }
        { this.multiRows2 = []; for(let _ele of _json_.multi_rows2) { let _e :test.MultiRowType1; _e = new test.MultiRowType1(_ele); this.multiRows2.push(_e);}}
        if (_json_.multi_rows4 === undefined) { throw new Error() }
        this.multiRows4 = new Map<number, test.MultiRowType2>(); for(var _entry_ of _json_.multi_rows4) { let _k:number; _k = _entry_[0];  let _v:test.MultiRowType2;  _v = new test.MultiRowType2(_entry_[1]); this.multiRows4.set(_k, _v);  }
        if (_json_.multi_rows5 === undefined) { throw new Error() }
        { this.multiRows5 = []; for(let _ele of _json_.multi_rows5) { let _e : test.MultiRowType3; _e = new test.MultiRowType3(_ele); this.multiRows5.push(_e);}}
        if (_json_.multi_rows6 === undefined) { throw new Error() }
        this.multiRows6 = new Map<number, test.MultiRowType2>(); for(var _entry_ of _json_.multi_rows6) { let _k:number; _k = _entry_[0];  let _v:test.MultiRowType2;  _v = new test.MultiRowType2(_entry_[1]); this.multiRows6.set(_k, _v);  }
        if (_json_.multi_rows7 === undefined) { throw new Error() }
        this.multiRows7 = new Map<number, number>(); for(var _entry_ of _json_.multi_rows7) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.multiRows7.set(_k, _v);  }
    }

    readonly id: number
    readonly name: string
    readonly oneRows: test.MultiRowType1[]
    readonly multiRows1: test.MultiRowType1[]
    readonly multiRows2: test.MultiRowType1[]
    readonly multiRows4: Map<number, test.MultiRowType2>
    readonly multiRows5: test.MultiRowType3[]
    readonly multiRows6: Map<number, test.MultiRowType2>
    readonly multiRows7: Map<number, number>

    resolve(_tables: Map<string, any>) {
        for(let _e of this.oneRows) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.multiRows1) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.multiRows2) { if (_e != null) { _e.resolve(_tables); } }
        for(let _e of this.multiRows4.values()) { if (_e != null) {_e.resolve(_tables);} }
        for(let _e of this.multiRows5) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.multiRows6.values()) { if (_e != null) {_e.resolve(_tables);} }
    }
}

}



export namespace test {
export class MultiRowType1 {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
    }

    readonly id: number
    readonly x: number

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
export class MultiRowType2 {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
        if (_json_.y === undefined) { throw new Error() }
        this.y = _json_.y
    }

    readonly id: number
    readonly x: number
    readonly y: number

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
export class MultiRowType3 {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.items === undefined) { throw new Error() }
        { this.items = []; for(let _ele of _json_.items) { let _e : test.MultiRowType1; _e = new test.MultiRowType1(_ele); this.items.push(_e);}}
    }

    readonly id: number
    readonly items: test.MultiRowType1[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.items) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}

export namespace test {
export class TbTestMultiColumn{
    private _dataMap: Map<number, test.TestMultiColumn>
    private _dataList: test.TestMultiColumn[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestMultiColumn>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestMultiColumn
            _v = new test.TestMultiColumn(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestMultiColumn> { return this._dataMap; }
    getDataList(): test.TestMultiColumn[] { return this._dataList; }

    get(key: number): test.TestMultiColumn | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestMultiColumn {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.a === undefined) { throw new Error() }
        this.a = new test.Foo(_json_.a)
        if (_json_.b === undefined) { throw new Error() }
        this.b = new test.Foo(_json_.b)
        if (_json_.c === undefined) { throw new Error() }
        this.c = new test.Foo(_json_.c)
    }

    readonly id: number
    readonly a: test.Foo
    readonly b: test.Foo
    readonly c: test.Foo

    resolve(_tables: Map<string, any>) {
        if (this.a != null) { this.a.resolve(_tables);}
        if (this.b != null) { this.b.resolve(_tables);}
        if (this.c != null) { this.c.resolve(_tables);}
    }
}

}



export namespace test {
export class Foo {

    constructor(_json_: any) {
        if (_json_.y1 === undefined) { throw new Error() }
        this.y1 = _json_.y1
        if (_json_.y2 === undefined) { throw new Error() }
        this.y2 = _json_.y2
        if (_json_.y3 === undefined) { throw new Error() }
        this.y3 = _json_.y3
    }

    readonly y1: number
    readonly y2: number
    readonly y3: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbMultiRowTitle{
    private _dataMap: Map<number, test.MultiRowTitle>
    private _dataList: test.MultiRowTitle[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.MultiRowTitle>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.MultiRowTitle
            _v = new test.MultiRowTitle(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.MultiRowTitle> { return this._dataMap; }
    getDataList(): test.MultiRowTitle[] { return this._dataList; }

    get(key: number): test.MultiRowTitle | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class MultiRowTitle {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = new test.H1(_json_.x1)
        if(_json_.x2_0 != undefined) { this.x20 = new test.H2(_json_.x2_0) } else { this.x20 = undefined }
        if (_json_.x2 === undefined) { throw new Error() }
        { this.x2 = []; for(let _ele of _json_.x2) { let _e : test.H2; _e = new test.H2(_ele); this.x2.push(_e);}}
        if (_json_.x3 === undefined) { throw new Error() }
        { this.x3 = []; for(let _ele of _json_.x3) { let _e :test.H2; _e = new test.H2(_ele); this.x3.push(_e);}}
        if (_json_.x4 === undefined) { throw new Error() }
        { this.x4 = []; for(let _ele of _json_.x4) { let _e :test.H2; _e = new test.H2(_ele); this.x4.push(_e);}}
    }

    readonly id: number
    readonly name: string
    readonly x1: test.H1
    readonly x20: test.H2|undefined
    readonly x2: test.H2[]
    readonly x3: test.H2[]
    readonly x4: test.H2[]

    resolve(_tables: Map<string, any>) {
        if (this.x1 != null) { this.x1.resolve(_tables);}
        if (this.x20 != null) { this.x20.resolve(_tables);}
        for(let _e of this.x2) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.x3) { if (_e != null) { _e.resolve(_tables); } }
        for(let _e of this.x4) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}



export namespace test {
export class H1 {

    constructor(_json_: any) {
        if (_json_.y2 === undefined) { throw new Error() }
        this.y2 = new test.H2(_json_.y2)
        if (_json_.y3 === undefined) { throw new Error() }
        this.y3 = _json_.y3
    }

    readonly y2: test.H2
    readonly y3: number

    resolve(_tables: Map<string, any>) {
        if (this.y2 != null) { this.y2.resolve(_tables);}
    }
}

}



export namespace test {
export class H2 {

    constructor(_json_: any) {
        if (_json_.z2 === undefined) { throw new Error() }
        this.z2 = _json_.z2
        if (_json_.z3 === undefined) { throw new Error() }
        this.z3 = _json_.z3
    }

    readonly z2: number
    readonly z3: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestNull{
    private _dataMap: Map<number, test.TestNull>
    private _dataList: test.TestNull[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestNull>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestNull
            _v = new test.TestNull(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestNull> { return this._dataMap; }
    getDataList(): test.TestNull[] { return this._dataList; }

    get(key: number): test.TestNull | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestNull {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if(_json_.x1 != undefined) { this.x1 = _json_.x1 } else { this.x1 = undefined }
        if(_json_.x2 != undefined) { this.x2 = _json_.x2 } else { this.x2 = undefined }
        if(_json_.x3 != undefined) { this.x3 = new test.DemoType1(_json_.x3) } else { this.x3 = undefined }
        if(_json_.x4 != undefined) { this.x4 = test.DemoDynamic.constructorFrom(_json_.x4) } else { this.x4 = undefined }
        if(_json_.s1 != undefined) { this.s1 = _json_.s1 } else { this.s1 = undefined }
        if(_json_.s2 != undefined) { this.s2 = _json_.s2['text'] } else { this.s2 = undefined }
    }

    readonly id: number
    readonly x1: number|undefined
    readonly x2: test.DemoEnum|undefined
    readonly x3: test.DemoType1|undefined
    readonly x4: test.DemoDynamic|undefined
    readonly s1: string|undefined
    readonly s2: string|undefined

    resolve(_tables: Map<string, any>) {
        if (this.x3 != null) { this.x3.resolve(_tables);}
        if (this.x4 != null) { this.x4.resolve(_tables);}
    }
}

}

export namespace test {
export class TbDemoPrimitive{
    private _dataMap: Map<number, test.DemoPrimitiveTypesTable>
    private _dataList: test.DemoPrimitiveTypesTable[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoPrimitiveTypesTable>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoPrimitiveTypesTable
            _v = new test.DemoPrimitiveTypesTable(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.DemoPrimitiveTypesTable> { return this._dataMap; }
    getDataList(): test.DemoPrimitiveTypesTable[] { return this._dataList; }

    get(key: number): test.DemoPrimitiveTypesTable | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class DemoPrimitiveTypesTable {

    constructor(_json_: any) {
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = _json_.x4
        if (_json_.x5 === undefined) { throw new Error() }
        this.x5 = _json_.x5
        if (_json_.x6 === undefined) { throw new Error() }
        this.x6 = _json_.x6
        if (_json_.x7 === undefined) { throw new Error() }
        this.x7 = _json_.x7
        if (_json_.s1 === undefined) { throw new Error() }
        this.s1 = _json_.s1
        if (_json_.s2 === undefined) { throw new Error() }
        this.s2 = _json_.s2['text']
        if (_json_.v2 === undefined) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.v3 === undefined) { throw new Error() }
        this.v3 = Vector3.deserializeFromJson(_json_.v3)
        if (_json_.v4 === undefined) { throw new Error() }
        this.v4 = Vector4.deserializeFromJson(_json_.v4)
        if (_json_.t1 === undefined) { throw new Error() }
        this.t1 = _json_.t1
    }

    readonly x1: boolean
    readonly x2: number
    readonly x3: number
    readonly x4: number
    readonly x5: number
    readonly x6: number
    readonly x7: number
    readonly s1: string
    readonly s2: string
    readonly v2: Vector2
    readonly v3: Vector3
    readonly v4: Vector4
    readonly t1: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestString{
    private _dataMap: Map<number, test.TestString>
    private _dataList: test.TestString[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestString>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestString
            _v = new test.TestString(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestString> { return this._dataMap; }
    getDataList(): test.TestString[] { return this._dataList; }

    get(key: number): test.TestString | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestString {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.s1 === undefined) { throw new Error() }
        this.s1 = _json_.s1
        if (_json_.cs1 === undefined) { throw new Error() }
        this.cs1 = new test.CompactString(_json_.cs1)
        if (_json_.cs2 === undefined) { throw new Error() }
        this.cs2 = new test.CompactString(_json_.cs2)
    }

    readonly id: number
    readonly s1: string
    readonly cs1: test.CompactString
    readonly cs2: test.CompactString

    resolve(_tables: Map<string, any>) {
        if (this.cs1 != null) { this.cs1.resolve(_tables);}
        if (this.cs2 != null) { this.cs2.resolve(_tables);}
    }
}

}



export namespace test {
export class CompactString {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.s2 === undefined) { throw new Error() }
        this.s2 = _json_.s2
        if (_json_.s3 === undefined) { throw new Error() }
        this.s3 = _json_.s3
    }

    readonly id: number
    readonly s2: string
    readonly s3: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbDemoGroup{
    private _dataMap: Map<number, test.DemoGroup>
    private _dataList: test.DemoGroup[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoGroup>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoGroup
            _v = new test.DemoGroup(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DemoGroup> { return this._dataMap; }
    getDataList(): test.DemoGroup[] { return this._dataList; }

    get(key: number): test.DemoGroup | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class DemoGroup {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = _json_.x4
        if (_json_.x5 === undefined) { throw new Error() }
        this.x5 = new test.InnerGroup(_json_.x5)
    }

    readonly id: number
    readonly x1: number
    x1_Ref : test.DemoGroup = undefined!
    readonly x2: number
    x2_Ref : test.DemoGroup = undefined!
    readonly x3: number
    x3_Ref : test.DemoGroup = undefined!
    readonly x4: number
    readonly x5: test.InnerGroup

    resolve(_tables: Map<string, any>) {
        this.x1_Ref = (_tables.get('test.TbDemoGroup_C') as test.TbDemoGroup_C).get(this.x1)!
        this.x2_Ref = (_tables.get('test.TbDemoGroup_S') as test.TbDemoGroup_S).get(this.x2)!
        this.x3_Ref = (_tables.get('test.TbDemoGroup_E') as test.TbDemoGroup_E).get(this.x3)!
        if (this.x5 != null) { this.x5.resolve(_tables);}
    }
}

}



export namespace test {
export class InnerGroup {

    constructor(_json_: any) {
        if (_json_.y1 === undefined) { throw new Error() }
        this.y1 = _json_.y1
        if (_json_.y2 === undefined) { throw new Error() }
        this.y2 = _json_.y2
        if (_json_.y3 === undefined) { throw new Error() }
        this.y3 = _json_.y3
        if (_json_.y4 === undefined) { throw new Error() }
        this.y4 = _json_.y4
    }

    readonly y1: number
    readonly y2: number
    readonly y3: number
    readonly y4: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbDemoGroup_C{
    private _dataMap: Map<number, test.DemoGroup>
    private _dataList: test.DemoGroup[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoGroup>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoGroup
            _v = new test.DemoGroup(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DemoGroup> { return this._dataMap; }
    getDataList(): test.DemoGroup[] { return this._dataList; }

    get(key: number): test.DemoGroup | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}

export namespace test {
export class TbDemoGroup_S{
    private _dataMap: Map<number, test.DemoGroup>
    private _dataList: test.DemoGroup[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoGroup>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoGroup
            _v = new test.DemoGroup(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DemoGroup> { return this._dataMap; }
    getDataList(): test.DemoGroup[] { return this._dataList; }

    get(key: number): test.DemoGroup | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}

export namespace test {
export class TbDemoGroup_E{
    private _dataMap: Map<number, test.DemoGroup>
    private _dataList: test.DemoGroup[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoGroup>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoGroup
            _v = new test.DemoGroup(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DemoGroup> { return this._dataMap; }
    getDataList(): test.DemoGroup[] { return this._dataList; }

    get(key: number): test.DemoGroup | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}

export namespace test {
export class TbTestGlobal{

     private _data: test.TestGlobal
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new test.TestGlobal(_json_[0])
    }

    getData(): test.TestGlobal { return this._data; }

     get  unlockEquip(): number { return this._data.unlockEquip; }
     get  unlockHero(): number { return this._data.unlockHero; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}



export namespace test {
export class TestGlobal {

    constructor(_json_: any) {
        if (_json_.unlock_equip === undefined) { throw new Error() }
        this.unlockEquip = _json_.unlock_equip
        if (_json_.unlock_hero === undefined) { throw new Error() }
        this.unlockHero = _json_.unlock_hero
    }

    readonly unlockEquip: number
    readonly unlockHero: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestBeRef{
    private _dataMap: Map<number, test.TestBeRef>
    private _dataList: test.TestBeRef[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestBeRef>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestBeRef
            _v = new test.TestBeRef(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestBeRef> { return this._dataMap; }
    getDataList(): test.TestBeRef[] { return this._dataList; }

    get(key: number): test.TestBeRef | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestBeRef {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.count === undefined) { throw new Error() }
        this.count = _json_.count
    }

    readonly id: number
    readonly count: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestBeRef2{
    private _dataMap: Map<number, test.TestBeRef>
    private _dataList: test.TestBeRef[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestBeRef>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestBeRef
            _v = new test.TestBeRef(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestBeRef> { return this._dataMap; }
    getDataList(): test.TestBeRef[] { return this._dataList; }

    get(key: number): test.TestBeRef | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}

export namespace test {
export class TbTestRef{
    private _dataMap: Map<number, test.TestRef>
    private _dataList: test.TestRef[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestRef>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestRef
            _v = new test.TestRef(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestRef> { return this._dataMap; }
    getDataList(): test.TestRef[] { return this._dataList; }

    get(key: number): test.TestRef | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestRef {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x1_2 === undefined) { throw new Error() }
        this.x12 = _json_.x1_2
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.a1 === undefined) { throw new Error() }
        this.a1 = _json_.a1
        if (_json_.a2 === undefined) { throw new Error() }
        this.a2 = _json_.a2
        if (_json_.b1 === undefined) { throw new Error() }
        this.b1 = _json_.b1
        if (_json_.b2 === undefined) { throw new Error() }
        this.b2 = _json_.b2
        if (_json_.c1 === undefined) { throw new Error() }
        this.c1 = _json_.c1
        if (_json_.c2 === undefined) { throw new Error() }
        this.c2 = _json_.c2
        if (_json_.d1 === undefined) { throw new Error() }
        this.d1 = new Map<number, number>(); for(var _entry_ of _json_.d1) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.d1.set(_k, _v);  }
        if (_json_.d2 === undefined) { throw new Error() }
        this.d2 = new Map<number, number>(); for(var _entry_ of _json_.d2) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.d2.set(_k, _v);  }
        if (_json_.e1 === undefined) { throw new Error() }
        this.e1 = _json_.e1
        if (_json_.e2 === undefined) { throw new Error() }
        this.e2 = _json_.e2
        if (_json_.e3 === undefined) { throw new Error() }
        this.e3 = _json_.e3
        if (_json_.f1 === undefined) { throw new Error() }
        this.f1 = _json_.f1
        if (_json_.f2 === undefined) { throw new Error() }
        this.f2 = _json_.f2
        if (_json_.f3 === undefined) { throw new Error() }
        this.f3 = _json_.f3
    }

    readonly id: number
    readonly x1: number
    x1_Ref : test.TestBeRef = undefined!
    readonly x12: number
    readonly x2: number
    readonly x3: number
    readonly a1: Int32Array
    readonly a2: Int32Array
    readonly b1: number[]
    readonly b2: number[]
    readonly c1: Set<number>
    readonly c2: Set<number>
    readonly d1: Map<number, number>
    readonly d2: Map<number, number>
    readonly e1: number
    readonly e2: number
    readonly e3: string
    readonly f1: number
    readonly f2: number
    readonly f3: string

    resolve(_tables: Map<string, any>) {
        this.x1_Ref = (_tables.get('test.TbTestBeRef') as test.TbTestBeRef).get(this.x1)!
    }
}

}

export namespace test {
export class TbTestSize{
    private _dataMap: Map<number, test.TestSize>
    private _dataList: test.TestSize[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestSize>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestSize
            _v = new test.TestSize(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestSize> { return this._dataMap; }
    getDataList(): test.TestSize[] { return this._dataList; }

    get(key: number): test.TestSize | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestSize {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = new Map<number, number>(); for(var _entry_ of _json_.x4) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.x4.set(_k, _v);  }
    }

    readonly id: number
    readonly x1: Int32Array
    readonly x2: number[]
    readonly x3: Set<number>
    readonly x4: Map<number, number>

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestSet{
    private _dataMap: Map<number, test.TestSet>
    private _dataList: test.TestSet[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestSet>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestSet
            _v = new test.TestSet(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestSet> { return this._dataMap; }
    getDataList(): test.TestSet[] { return this._dataList; }

    get(key: number): test.TestSet | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestSet {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x0 === undefined) { throw new Error() }
        this.x0 = _json_.x0
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x4 === undefined) { throw new Error() }
        { this.x4 = []; for(let _ele of _json_.x4) { let _e : test.DemoEnum; _e = _ele; this.x4.push(_e);}}
    }

    readonly id: number
    readonly x0: string
    readonly x1: number[]
    readonly x2: number[]
    readonly x3: string[]
    readonly x4: test.DemoEnum[]

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbDetectCsvEncoding{
    private _dataMap: Map<number, test.DetectEncoding>
    private _dataList: test.DetectEncoding[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DetectEncoding>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DetectEncoding
            _v = new test.DetectEncoding(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DetectEncoding> { return this._dataMap; }
    getDataList(): test.DetectEncoding[] { return this._dataList; }

    get(key: number): test.DetectEncoding | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class DetectEncoding {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
    }

    readonly id: number
    readonly name: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbItem2{
    private _dataMap: Map<number, test.ItemBase>
    private _dataList: test.ItemBase[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.ItemBase>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.ItemBase
            _v = test.ItemBase.constructorFrom(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.ItemBase> { return this._dataMap; }
    getDataList(): test.ItemBase[] { return this._dataList; }

    get(key: number): test.ItemBase | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export abstract class ItemBase {
    static constructorFrom(_json_: any): ItemBase{
        switch (_json_.__type__) {
            case 'Item': return new test.Item(_json_)
            case 'Equipment': return new test.Equipment(_json_)
            case 'Decorator': return new test.Decorator(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
    }

    readonly id: number
    readonly name: string
    readonly desc: string

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
export class Item extends test.ItemBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
        if (_json_.price === undefined) { throw new Error() }
        this.price = _json_.price
    }

    readonly num: number
    readonly price: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace test {
export class Equipment extends test.ItemBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.attr === undefined) { throw new Error() }
        this.attr = _json_.attr
        if (_json_.value === undefined) { throw new Error() }
        this.value = _json_.value
    }

    readonly attr: test.DemoEnum
    readonly value: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace test {
export class Decorator extends test.ItemBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.duration === undefined) { throw new Error() }
        this.duration = _json_.duration
    }

    readonly duration: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}

export namespace test {
export class TbDefineFromExcel{
    private _dataMap: Map<number, test.DefineFromExcel>
    private _dataList: test.DefineFromExcel[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DefineFromExcel>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DefineFromExcel
            _v = new test.DefineFromExcel(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DefineFromExcel> { return this._dataMap; }
    getDataList(): test.DefineFromExcel[] { return this._dataList; }

    get(key: number): test.DefineFromExcel | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class DefineFromExcel {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x5 === undefined) { throw new Error() }
        this.x5 = _json_.x5
        if (_json_.x6 === undefined) { throw new Error() }
        this.x6 = _json_.x6
        if (_json_.x8 === undefined) { throw new Error() }
        this.x8 = _json_.x8
        if (_json_.x10 === undefined) { throw new Error() }
        this.x10 = _json_.x10
        if (_json_.x13 === undefined) { throw new Error() }
        this.x13 = _json_.x13
        if (_json_.x14 === undefined) { throw new Error() }
        this.x14 = test.DemoDynamic.constructorFrom(_json_.x14)
        if (_json_.x15 === undefined) { throw new Error() }
        this.x15 = test.Shape.constructorFrom(_json_.x15)
        if (_json_.v2 === undefined) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.t1 === undefined) { throw new Error() }
        this.t1 = _json_.t1
        if (_json_.k1 === undefined) { throw new Error() }
        this.k1 = _json_.k1
        if (_json_.k2 === undefined) { throw new Error() }
        this.k2 = _json_.k2
        if (_json_.k8 === undefined) { throw new Error() }
        this.k8 = new Map<number, number>(); for(var _entry_ of _json_.k8) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.k8.set(_k, _v);  }
        if (_json_.k9 === undefined) { throw new Error() }
        { this.k9 = []; for(let _ele of _json_.k9) { let _e : test.DemoE2; _e = new test.DemoE2(_ele); this.k9.push(_e);}}
    }

    /**
     * 这是id
     */
    readonly id: number
    /**
     * 字段x1
     */
    readonly x1: boolean
    readonly x5: number
    readonly x6: number
    readonly x8: number
    readonly x10: string
    readonly x13: test.ETestQuality
    readonly x14: test.DemoDynamic
    readonly x15: test.Shape
    readonly v2: Vector2
    readonly t1: number
    readonly k1: Int32Array
    readonly k2: Int32Array
    readonly k8: Map<number, number>
    readonly k9: test.DemoE2[]

    resolve(_tables: Map<string, any>) {
        if (this.x14 != null) { this.x14.resolve(_tables);}
        if (this.x15 != null) { this.x15.resolve(_tables);}
        for(let _e of this.k9) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace test {
export abstract class Shape {
    static constructorFrom(_json_: any): Shape{
        switch (_json_.__type__) {
            case 'Circle': return new test.Circle(_json_)
            case 'Rectangle': return new test.Rectangle(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
/**
 * 圆
 */
export class Circle extends Shape {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.radius === undefined) { throw new Error() }
        this.radius = _json_.radius
    }

    /**
     * 半径
     */
    readonly radius: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}



export namespace test {
/**
 * 矩形
 */
export class Rectangle extends Shape {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.width === undefined) { throw new Error() }
        this.width = _json_.width
        if (_json_.height === undefined) { throw new Error() }
        this.height = _json_.height
    }

    /**
     * 宽度
     */
    readonly width: number
    /**
     * 高度
     */
    readonly height: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}

export namespace test {
export class TbDefineFromExcelOne{

     private _data: test.DefineFromExcelOne
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new test.DefineFromExcelOne(_json_[0])
    }

    getData(): test.DefineFromExcelOne { return this._data; }

    /**
     * 装备解锁等级
     */
     get  unlockEquip(): number { return this._data.unlockEquip; }
    /**
     * 英雄解锁等级
     */
     get  unlockHero(): number { return this._data.unlockHero; }
     get  defaultAvatar(): string { return this._data.defaultAvatar; }
     get  defaultItem(): string { return this._data.defaultItem; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}



export namespace test {
export class DefineFromExcelOne {

    constructor(_json_: any) {
        if (_json_.unlock_equip === undefined) { throw new Error() }
        this.unlockEquip = _json_.unlock_equip
        if (_json_.unlock_hero === undefined) { throw new Error() }
        this.unlockHero = _json_.unlock_hero
        if (_json_.default_avatar === undefined) { throw new Error() }
        this.defaultAvatar = _json_.default_avatar
        if (_json_.default_item === undefined) { throw new Error() }
        this.defaultItem = _json_.default_item
    }

    /**
     * 装备解锁等级
     */
    readonly unlockEquip: number
    /**
     * 英雄解锁等级
     */
    readonly unlockHero: number
    readonly defaultAvatar: string
    readonly defaultItem: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestIndex{
    private _dataMap: Map<number, test.TestIndex>
    private _dataList: test.TestIndex[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestIndex>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestIndex
            _v = new test.TestIndex(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestIndex> { return this._dataMap; }
    getDataList(): test.TestIndex[] { return this._dataList; }

    get(key: number): test.TestIndex | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestIndex {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.eles === undefined) { throw new Error() }
        { this.eles = []; for(let _ele of _json_.eles) { let _e : test.DemoType1; _e = new test.DemoType1(_ele); this.eles.push(_e);}}
    }

    readonly id: number
    readonly eles: test.DemoType1[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.eles) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}

export namespace test {
export class TbTestMap{
    private _dataMap: Map<number, test.TestMap>
    private _dataList: test.TestMap[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestMap>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestMap
            _v = new test.TestMap(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestMap> { return this._dataMap; }
    getDataList(): test.TestMap[] { return this._dataList; }

    get(key: number): test.TestMap | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestMap {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = new Map<number, number>(); for(var _entry_ of _json_.x1) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.x1.set(_k, _v);  }
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = new Map<number, number>(); for(var _entry_ of _json_.x2) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.x2.set(_k, _v);  }
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = new Map<string, number>(); for(var _entry_ of _json_.x3) { let _k:string; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.x3.set(_k, _v);  }
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = new Map<test.DemoEnum, number>(); for(var _entry_ of _json_.x4) { let _k:test.DemoEnum; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.x4.set(_k, _v);  }
    }

    readonly id: number
    id_Ref : test.TestIndex = undefined!
    readonly x1: Map<number, number>
    readonly x2: Map<number, number>
    readonly x3: Map<string, number>
    readonly x4: Map<test.DemoEnum, number>

    resolve(_tables: Map<string, any>) {
        this.id_Ref = (_tables.get('test.TbTestIndex') as test.TbTestIndex).get(this.id)!
    }
}

}

export namespace test {
export class TbExcelFromJson{
    private _dataMap: Map<number, test.ExcelFromJson>
    private _dataList: test.ExcelFromJson[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.ExcelFromJson>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.ExcelFromJson
            _v = new test.ExcelFromJson(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.ExcelFromJson> { return this._dataMap; }
    getDataList(): test.ExcelFromJson[] { return this._dataList; }

    get(key: number): test.ExcelFromJson | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class ExcelFromJson {

    constructor(_json_: any) {
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = _json_.x4
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x5 === undefined) { throw new Error() }
        this.x5 = _json_.x5
        if (_json_.x6 === undefined) { throw new Error() }
        this.x6 = _json_.x6
        if (_json_.s1 === undefined) { throw new Error() }
        this.s1 = _json_.s1
        if (_json_.s2 === undefined) { throw new Error() }
        this.s2 = _json_.s2['text']
        if (_json_.v2 === undefined) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.v3 === undefined) { throw new Error() }
        this.v3 = Vector3.deserializeFromJson(_json_.v3)
        if (_json_.v4 === undefined) { throw new Error() }
        this.v4 = Vector4.deserializeFromJson(_json_.v4)
        if (_json_.t1 === undefined) { throw new Error() }
        this.t1 = _json_.t1
        if (_json_.x12 === undefined) { throw new Error() }
        this.x12 = new test.DemoType1(_json_.x12)
        if (_json_.x13 === undefined) { throw new Error() }
        this.x13 = _json_.x13
        if (_json_.x14 === undefined) { throw new Error() }
        this.x14 = test.DemoDynamic.constructorFrom(_json_.x14)
        if (_json_.k1 === undefined) { throw new Error() }
        this.k1 = _json_.k1
        if (_json_.k8 === undefined) { throw new Error() }
        this.k8 = new Map<number, number>(); for(var _entry_ of _json_.k8) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.k8.set(_k, _v);  }
        if (_json_.k9 === undefined) { throw new Error() }
        { this.k9 = []; for(let _ele of _json_.k9) { let _e : test.DemoE2; _e = new test.DemoE2(_ele); this.k9.push(_e);}}
        if (_json_.k15 === undefined) { throw new Error() }
        { this.k15 = []; for(let _ele of _json_.k15) { let _e :test.DemoDynamic; _e = test.DemoDynamic.constructorFrom(_ele); this.k15.push(_e);}}
    }

    readonly x4: number
    readonly x1: boolean
    readonly x5: number
    readonly x6: number
    readonly s1: string
    readonly s2: string
    readonly v2: Vector2
    readonly v3: Vector3
    readonly v4: Vector4
    readonly t1: number
    readonly x12: test.DemoType1
    readonly x13: test.DemoEnum
    readonly x14: test.DemoDynamic
    readonly k1: Int32Array
    readonly k8: Map<number, number>
    readonly k9: test.DemoE2[]
    readonly k15: test.DemoDynamic[]

    resolve(_tables: Map<string, any>) {
        if (this.x12 != null) { this.x12.resolve(_tables);}
        if (this.x14 != null) { this.x14.resolve(_tables);}
        for(let _e of this.k9) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.k15) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}

export namespace test {
export class TbCompositeJsonTable1{
    private _dataMap: Map<number, test.CompositeJsonTable1>
    private _dataList: test.CompositeJsonTable1[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.CompositeJsonTable1>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.CompositeJsonTable1
            _v = new test.CompositeJsonTable1(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.CompositeJsonTable1> { return this._dataMap; }
    getDataList(): test.CompositeJsonTable1[] { return this._dataList; }

    get(key: number): test.CompositeJsonTable1 | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class CompositeJsonTable1 {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
    }

    readonly id: number
    readonly x: string

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbCompositeJsonTable2{
    private _dataMap: Map<number, test.CompositeJsonTable2>
    private _dataList: test.CompositeJsonTable2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.CompositeJsonTable2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.CompositeJsonTable2
            _v = new test.CompositeJsonTable2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.CompositeJsonTable2> { return this._dataMap; }
    getDataList(): test.CompositeJsonTable2[] { return this._dataList; }

    get(key: number): test.CompositeJsonTable2 | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class CompositeJsonTable2 {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.y === undefined) { throw new Error() }
        this.y = _json_.y
    }

    readonly id: number
    readonly y: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbCompositeJsonTable3{

     private _data: test.CompositeJsonTable3
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new test.CompositeJsonTable3(_json_[0])
    }

    getData(): test.CompositeJsonTable3 { return this._data; }

     get  a(): number { return this._data.a; }
     get  b(): number { return this._data.b; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}



export namespace test {
export class CompositeJsonTable3 {

    constructor(_json_: any) {
        if (_json_.a === undefined) { throw new Error() }
        this.a = _json_.a
        if (_json_.b === undefined) { throw new Error() }
        this.b = _json_.b
    }

    readonly a: number
    readonly b: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbExcelFromJsonMultiRow{
    private _dataMap: Map<number, test.ExcelFromJsonMultiRow>
    private _dataList: test.ExcelFromJsonMultiRow[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.ExcelFromJsonMultiRow>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.ExcelFromJsonMultiRow
            _v = new test.ExcelFromJsonMultiRow(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.ExcelFromJsonMultiRow> { return this._dataMap; }
    getDataList(): test.ExcelFromJsonMultiRow[] { return this._dataList; }

    get(key: number): test.ExcelFromJsonMultiRow | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class ExcelFromJsonMultiRow {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
        if (_json_.items === undefined) { throw new Error() }
        { this.items = []; for(let _ele of _json_.items) { let _e : test.TestRow; _e = new test.TestRow(_ele); this.items.push(_e);}}
    }

    readonly id: number
    readonly x: number
    readonly items: test.TestRow[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.items) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace test {
export class TestRow {

    constructor(_json_: any) {
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
        if (_json_.y === undefined) { throw new Error() }
        this.y = _json_.y
        if (_json_.z === undefined) { throw new Error() }
        this.z = _json_.z
        if (_json_.a === undefined) { throw new Error() }
        this.a = new test.Test3(_json_.a)
        if (_json_.b === undefined) { throw new Error() }
        this.b = _json_.b
    }

    readonly x: number
    readonly y: boolean
    readonly z: string
    readonly a: test.Test3
    readonly b: number[]

    resolve(_tables: Map<string, any>) {
        if (this.a != null) { this.a.resolve(_tables);}
    }
}

}



export namespace test {
export class Test3 {

    constructor(_json_: any) {
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
        if (_json_.y === undefined) { throw new Error() }
        this.y = _json_.y
    }

    readonly x: number
    readonly y: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestSep{
    private _dataMap: Map<number, test.TestSep>
    private _dataList: test.TestSep[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestSep>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestSep
            _v = new test.TestSep(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestSep> { return this._dataMap; }
    getDataList(): test.TestSep[] { return this._dataList; }

    get(key: number): test.TestSep | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestSep {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1['text']
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = new test.SepBean1(_json_.x2)
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = new test.SepVector(_json_.x3)
        if (_json_.x4 === undefined) { throw new Error() }
        { this.x4 = []; for(let _ele of _json_.x4) { let _e : test.SepVector; _e = new test.SepVector(_ele); this.x4.push(_e);}}
        if (_json_.x5 === undefined) { throw new Error() }
        { this.x5 = []; for(let _ele of _json_.x5) { let _e : test.SepBean1; _e = new test.SepBean1(_ele); this.x5.push(_e);}}
        if (_json_.x6 === undefined) { throw new Error() }
        { this.x6 = []; for(let _ele of _json_.x6) { let _e : test.SepBean1; _e = new test.SepBean1(_ele); this.x6.push(_e);}}
    }

    readonly id: number
    readonly x1: string
    readonly x2: test.SepBean1
    /**
     * SepVector已经定义了sep=,属性
     */
    readonly x3: test.SepVector
    /**
     * 用;来分割数据，然后顺序读入SepVector
     */
    readonly x4: test.SepVector[]
    /**
     * 用,分割数据，然后顺序读入
     */
    readonly x5: test.SepBean1[]
    /**
     * 用;分割数据，然后再将每个数据用,分割，读入
     */
    readonly x6: test.SepBean1[]

    resolve(_tables: Map<string, any>) {
        if (this.x2 != null) { this.x2.resolve(_tables);}
        if (this.x3 != null) { this.x3.resolve(_tables);}
        for(let _e of this.x4) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.x5) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.x6) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}



export namespace test {
export class SepBean1 {

    constructor(_json_: any) {
        if (_json_.a === undefined) { throw new Error() }
        this.a = _json_.a
        if (_json_.b === undefined) { throw new Error() }
        this.b = _json_.b
        if (_json_.c === undefined) { throw new Error() }
        this.c = _json_.c
    }

    readonly a: number
    readonly b: number
    readonly c: string

    resolve(_tables: Map<string, any>) {
    }
}

}



export namespace test {
export class SepVector {

    constructor(_json_: any) {
        if (_json_.x === undefined) { throw new Error() }
        this.x = _json_.x
        if (_json_.y === undefined) { throw new Error() }
        this.y = _json_.y
        if (_json_.z === undefined) { throw new Error() }
        this.z = _json_.z
    }

    readonly x: number
    readonly y: number
    readonly z: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestScriptableObject{
    private _dataMap: Map<number, test.TestScriptableObject>
    private _dataList: test.TestScriptableObject[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestScriptableObject>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestScriptableObject
            _v = new test.TestScriptableObject(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestScriptableObject> { return this._dataMap; }
    getDataList(): test.TestScriptableObject[] { return this._dataList; }

    get(key: number): test.TestScriptableObject | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestScriptableObject {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.desc === undefined) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.rate === undefined) { throw new Error() }
        this.rate = _json_.rate
        if (_json_.num === undefined) { throw new Error() }
        this.num = _json_.num
        if (_json_.v2 === undefined) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.v3 === undefined) { throw new Error() }
        this.v3 = Vector3.deserializeFromJson(_json_.v3)
        if (_json_.v4 === undefined) { throw new Error() }
        this.v4 = Vector4.deserializeFromJson(_json_.v4)
    }

    readonly id: number
    readonly desc: string
    readonly rate: number
    readonly num: number
    readonly v2: Vector2
    readonly v3: Vector3
    readonly v4: Vector4

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestExternalType{
    private _dataMap: Map<number, test.TestExternalType>
    private _dataList: test.TestExternalType[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestExternalType>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestExternalType
            _v = new test.TestExternalType(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestExternalType> { return this._dataMap; }
    getDataList(): test.TestExternalType[] { return this._dataList; }

    get(key: number): test.TestExternalType | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestExternalType {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.audio_type === undefined) { throw new Error() }
        this.audioType = _json_.audio_type
        if (_json_.color === undefined) { throw new Error() }
        this.color = new test.Color(_json_.color)
    }

    readonly id: number
    readonly audioType: test.AudioType
    readonly color: test.Color

    resolve(_tables: Map<string, any>) {
        if (this.color != null) { this.color.resolve(_tables);}
    }
}

}



export namespace test {
export class Color {

    constructor(_json_: any) {
        if (_json_.r === undefined) { throw new Error() }
        this.r = _json_.r
        if (_json_.g === undefined) { throw new Error() }
        this.g = _json_.g
        if (_json_.b === undefined) { throw new Error() }
        this.b = _json_.b
        if (_json_.a === undefined) { throw new Error() }
        this.a = _json_.a
    }

    readonly r: number
    readonly g: number
    readonly b: number
    readonly a: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbDemoGroupDefineFromExcel{
    private _dataMap: Map<number, test.DemoGroup>
    private _dataList: test.DemoGroup[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoGroup>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoGroup
            _v = new test.DemoGroup(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DemoGroup> { return this._dataMap; }
    getDataList(): test.DemoGroup[] { return this._dataList; }

    get(key: number): test.DemoGroup | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}

export namespace test {
export class TbDefineFromExcel2{
    private _dataMap: Map<number, test.DefineFromExcel2>
    private _dataList: test.DefineFromExcel2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DefineFromExcel2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DefineFromExcel2
            _v = new test.DefineFromExcel2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DefineFromExcel2> { return this._dataMap; }
    getDataList(): test.DefineFromExcel2[] { return this._dataList; }

    get(key: number): test.DefineFromExcel2 | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class DefineFromExcel2 {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x5 === undefined) { throw new Error() }
        this.x5 = _json_.x5
        if (_json_.x6 === undefined) { throw new Error() }
        this.x6 = _json_.x6
        if (_json_.x8 === undefined) { throw new Error() }
        this.x8 = _json_.x8
        if (_json_.x10 === undefined) { throw new Error() }
        this.x10 = _json_.x10
        if (_json_.x13 === undefined) { throw new Error() }
        this.x13 = _json_.x13
        if (_json_.x14 === undefined) { throw new Error() }
        this.x14 = test.DemoDynamic.constructorFrom(_json_.x14)
        if (_json_.x15 === undefined) { throw new Error() }
        this.x15 = test.Shape.constructorFrom(_json_.x15)
        if (_json_.v2 === undefined) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.t1 === undefined) { throw new Error() }
        this.t1 = _json_.t1
        if (_json_.k1 === undefined) { throw new Error() }
        this.k1 = _json_.k1
        if (_json_.k2 === undefined) { throw new Error() }
        this.k2 = _json_.k2
        if (_json_.k8 === undefined) { throw new Error() }
        this.k8 = new Map<number, number>(); for(var _entry_ of _json_.k8) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.k8.set(_k, _v);  }
        if (_json_.k9 === undefined) { throw new Error() }
        { this.k9 = []; for(let _ele of _json_.k9) { let _e : test.DemoE2; _e = new test.DemoE2(_ele); this.k9.push(_e);}}
    }

    /**
     * 这是id
     */
    readonly id: number
    /**
     * 字段x1
     */
    readonly x1: boolean
    readonly x5: number
    readonly x6: number
    readonly x8: number
    readonly x10: string
    readonly x13: test.ETestQuality
    readonly x14: test.DemoDynamic
    readonly x15: test.Shape
    readonly v2: Vector2
    readonly t1: number
    readonly k1: Int32Array
    readonly k2: Int32Array
    readonly k8: Map<number, number>
    readonly k9: test.DemoE2[]

    resolve(_tables: Map<string, any>) {
        if (this.x14 != null) { this.x14.resolve(_tables);}
        if (this.x15 != null) { this.x15.resolve(_tables);}
        for(let _e of this.k9) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}

export namespace test {
export class TbTestExcelBean{
    private _dataMap: Map<number, test.TestExcelBean1>
    private _dataList: test.TestExcelBean1[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestExcelBean1>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestExcelBean1
            _v = new test.TestExcelBean1(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x1, _v)
        }
    }

    getDataMap(): Map<number, test.TestExcelBean1> { return this._dataMap; }
    getDataList(): test.TestExcelBean1[] { return this._dataList; }

    get(key: number): test.TestExcelBean1 | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
/**
 * 这是个测试excel结构
 */
export class TestExcelBean1 {

    constructor(_json_: any) {
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 === undefined) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 === undefined) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x4 === undefined) { throw new Error() }
        this.x4 = _json_.x4
    }

    /**
     * 最高品质
     */
    readonly x1: number
    /**
     * 黑色的
     */
    readonly x2: string
    /**
     * 蓝色的
     */
    readonly x3: number
    /**
     * 最差品质
     */
    readonly x4: number

    resolve(_tables: Map<string, any>) {
    }
}

}

export namespace test {
export class TbTestDesc{
    private _dataMap: Map<number, test.TestDesc>
    private _dataList: test.TestDesc[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestDesc>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestDesc
            _v = new test.TestDesc(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestDesc> { return this._dataMap; }
    getDataList(): test.TestDesc[] { return this._dataList; }

    get(key: number): test.TestDesc | undefined { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }

}
}



export namespace test {
export class TestDesc {

    constructor(_json_: any) {
        if (_json_.id === undefined) { throw new Error() }
        this.id = _json_.id
        if (_json_.name === undefined) { throw new Error() }
        this.name = _json_.name
        if (_json_.a1 === undefined) { throw new Error() }
        this.a1 = _json_.a1
        if (_json_.a2 === undefined) { throw new Error() }
        this.a2 = _json_.a2
        if (_json_.x1 === undefined) { throw new Error() }
        this.x1 = new test.H1(_json_.x1)
        if (_json_.x2 === undefined) { throw new Error() }
        { this.x2 = []; for(let _ele of _json_.x2) { let _e : test.H2; _e = new test.H2(_ele); this.x2.push(_e);}}
        if (_json_.x3 === undefined) { throw new Error() }
        { this.x3 = []; for(let _ele of _json_.x3) { let _e :test.H2; _e = new test.H2(_ele); this.x3.push(_e);}}
    }

    readonly id: number
    /**
     * 禁止
     */
    readonly name: string
    /**
     * 测试换行<br/>第2行<br/>第3层
     */
    readonly a1: number
    /**
     * 测试转义 &lt; &amp; % / # &gt;
     */
    readonly a2: number
    readonly x1: test.H1
    /**
     * 这是x2
     */
    readonly x2: test.H2[]
    readonly x3: test.H2[]

    resolve(_tables: Map<string, any>) {
        if (this.x1 != null) { this.x1.resolve(_tables);}
        for(let _e of this.x2) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.x3) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}


type JsonLoader = (file: string) => any

export class Tables {
    private _TbBlackboard: ai.TbBlackboard
    get TbBlackboard(): ai.TbBlackboard  { return this._TbBlackboard;}
    private _TbBehaviorTree: ai.TbBehaviorTree
    get TbBehaviorTree(): ai.TbBehaviorTree  { return this._TbBehaviorTree;}
    private _TbClazz: blueprint.TbClazz
    get TbClazz(): blueprint.TbClazz  { return this._TbClazz;}
    private _TbDrop: bonus.TbDrop
    get TbDrop(): bonus.TbDrop  { return this._TbDrop;}
    private _TbGlobalConfig: common.TbGlobalConfig
    get TbGlobalConfig(): common.TbGlobalConfig  { return this._TbGlobalConfig;}
    private _TbErrorInfo: error.TbErrorInfo
    get TbErrorInfo(): error.TbErrorInfo  { return this._TbErrorInfo;}
    private _TbCodeInfo: error.TbCodeInfo
    get TbCodeInfo(): error.TbCodeInfo  { return this._TbCodeInfo;}
    private _TbItem: item.TbItem
    /**
     * 道具表
     */
    get TbItem(): item.TbItem  { return this._TbItem;}
    private _TbItemFunc: item.TbItemFunc
    get TbItemFunc(): item.TbItemFunc  { return this._TbItemFunc;}
    private _TbItemExtra: item.TbItemExtra
    get TbItemExtra(): item.TbItemExtra  { return this._TbItemExtra;}
    private _TbL10NDemo: l10n.TbL10NDemo
    get TbL10NDemo(): l10n.TbL10NDemo  { return this._TbL10NDemo;}
    private _TbPatchDemo: l10n.TbPatchDemo
    get TbPatchDemo(): l10n.TbPatchDemo  { return this._TbPatchDemo;}
    private _TbSystemMail: mail.TbSystemMail
    get TbSystemMail(): mail.TbSystemMail  { return this._TbSystemMail;}
    private _TbGlobalMail: mail.TbGlobalMail
    get TbGlobalMail(): mail.TbGlobalMail  { return this._TbGlobalMail;}
    private _TbRoleLevelExpAttr: role.TbRoleLevelExpAttr
    get TbRoleLevelExpAttr(): role.TbRoleLevelExpAttr  { return this._TbRoleLevelExpAttr;}
    private _TbRoleLevelBonusCoefficient: role.TbRoleLevelBonusCoefficient
    get TbRoleLevelBonusCoefficient(): role.TbRoleLevelBonusCoefficient  { return this._TbRoleLevelBonusCoefficient;}
    private _TbTestTag: tag.TbTestTag
    get TbTestTag(): tag.TbTestTag  { return this._TbTestTag;}
    private _TbFullTypes: test.TbFullTypes
    get TbFullTypes(): test.TbFullTypes  { return this._TbFullTypes;}
    private _TbSingleton: test.TbSingleton
    get TbSingleton(): test.TbSingleton  { return this._TbSingleton;}
    private _TbNotIndexList: test.TbNotIndexList
    get TbNotIndexList(): test.TbNotIndexList  { return this._TbNotIndexList;}
    private _TbMultiUnionIndexList: test.TbMultiUnionIndexList
    get TbMultiUnionIndexList(): test.TbMultiUnionIndexList  { return this._TbMultiUnionIndexList;}
    private _TbMultiIndexList: test.TbMultiIndexList
    get TbMultiIndexList(): test.TbMultiIndexList  { return this._TbMultiIndexList;}
    private _TbDataFromMisc: test.TbDataFromMisc
    get TbDataFromMisc(): test.TbDataFromMisc  { return this._TbDataFromMisc;}
    private _TbMultiRowRecord: test.TbMultiRowRecord
    get TbMultiRowRecord(): test.TbMultiRowRecord  { return this._TbMultiRowRecord;}
    private _TbTestMultiColumn: test.TbTestMultiColumn
    get TbTestMultiColumn(): test.TbTestMultiColumn  { return this._TbTestMultiColumn;}
    private _TbMultiRowTitle: test.TbMultiRowTitle
    get TbMultiRowTitle(): test.TbMultiRowTitle  { return this._TbMultiRowTitle;}
    private _TbTestNull: test.TbTestNull
    get TbTestNull(): test.TbTestNull  { return this._TbTestNull;}
    private _TbDemoPrimitive: test.TbDemoPrimitive
    get TbDemoPrimitive(): test.TbDemoPrimitive  { return this._TbDemoPrimitive;}
    private _TbTestString: test.TbTestString
    get TbTestString(): test.TbTestString  { return this._TbTestString;}
    private _TbDemoGroup: test.TbDemoGroup
    get TbDemoGroup(): test.TbDemoGroup  { return this._TbDemoGroup;}
    private _TbDemoGroup_C: test.TbDemoGroup_C
    get TbDemoGroup_C(): test.TbDemoGroup_C  { return this._TbDemoGroup_C;}
    private _TbDemoGroup_S: test.TbDemoGroup_S
    get TbDemoGroup_S(): test.TbDemoGroup_S  { return this._TbDemoGroup_S;}
    private _TbDemoGroup_E: test.TbDemoGroup_E
    get TbDemoGroup_E(): test.TbDemoGroup_E  { return this._TbDemoGroup_E;}
    private _TbTestGlobal: test.TbTestGlobal
    get TbTestGlobal(): test.TbTestGlobal  { return this._TbTestGlobal;}
    private _TbTestBeRef: test.TbTestBeRef
    get TbTestBeRef(): test.TbTestBeRef  { return this._TbTestBeRef;}
    private _TbTestBeRef2: test.TbTestBeRef2
    get TbTestBeRef2(): test.TbTestBeRef2  { return this._TbTestBeRef2;}
    private _TbTestRef: test.TbTestRef
    get TbTestRef(): test.TbTestRef  { return this._TbTestRef;}
    private _TbTestSize: test.TbTestSize
    get TbTestSize(): test.TbTestSize  { return this._TbTestSize;}
    private _TbTestSet: test.TbTestSet
    get TbTestSet(): test.TbTestSet  { return this._TbTestSet;}
    private _TbDetectCsvEncoding: test.TbDetectCsvEncoding
    get TbDetectCsvEncoding(): test.TbDetectCsvEncoding  { return this._TbDetectCsvEncoding;}
    private _TbItem2: test.TbItem2
    get TbItem2(): test.TbItem2  { return this._TbItem2;}
    private _TbDefineFromExcel: test.TbDefineFromExcel
    get TbDefineFromExcel(): test.TbDefineFromExcel  { return this._TbDefineFromExcel;}
    private _TbDefineFromExcelOne: test.TbDefineFromExcelOne
    get TbDefineFromExcelOne(): test.TbDefineFromExcelOne  { return this._TbDefineFromExcelOne;}
    private _TbTestIndex: test.TbTestIndex
    get TbTestIndex(): test.TbTestIndex  { return this._TbTestIndex;}
    private _TbTestMap: test.TbTestMap
    get TbTestMap(): test.TbTestMap  { return this._TbTestMap;}
    private _TbExcelFromJson: test.TbExcelFromJson
    get TbExcelFromJson(): test.TbExcelFromJson  { return this._TbExcelFromJson;}
    private _TbCompositeJsonTable1: test.TbCompositeJsonTable1
    get TbCompositeJsonTable1(): test.TbCompositeJsonTable1  { return this._TbCompositeJsonTable1;}
    private _TbCompositeJsonTable2: test.TbCompositeJsonTable2
    get TbCompositeJsonTable2(): test.TbCompositeJsonTable2  { return this._TbCompositeJsonTable2;}
    private _TbCompositeJsonTable3: test.TbCompositeJsonTable3
    get TbCompositeJsonTable3(): test.TbCompositeJsonTable3  { return this._TbCompositeJsonTable3;}
    private _TbExcelFromJsonMultiRow: test.TbExcelFromJsonMultiRow
    get TbExcelFromJsonMultiRow(): test.TbExcelFromJsonMultiRow  { return this._TbExcelFromJsonMultiRow;}
    private _TbTestSep: test.TbTestSep
    get TbTestSep(): test.TbTestSep  { return this._TbTestSep;}
    private _TbTestScriptableObject: test.TbTestScriptableObject
    get TbTestScriptableObject(): test.TbTestScriptableObject  { return this._TbTestScriptableObject;}
    private _TbTestExternalType: test.TbTestExternalType
    get TbTestExternalType(): test.TbTestExternalType  { return this._TbTestExternalType;}
    private _TbDemoGroupDefineFromExcel: test.TbDemoGroupDefineFromExcel
    get TbDemoGroupDefineFromExcel(): test.TbDemoGroupDefineFromExcel  { return this._TbDemoGroupDefineFromExcel;}
    private _TbDefineFromExcel2: test.TbDefineFromExcel2
    get TbDefineFromExcel2(): test.TbDefineFromExcel2  { return this._TbDefineFromExcel2;}
    private _TbTestExcelBean: test.TbTestExcelBean
    get TbTestExcelBean(): test.TbTestExcelBean  { return this._TbTestExcelBean;}
    private _TbTestDesc: test.TbTestDesc
    get TbTestDesc(): test.TbTestDesc  { return this._TbTestDesc;}

    constructor(loader: JsonLoader) {
        let tables = new Map<string, any>()
        this._TbBlackboard = new ai.TbBlackboard(loader('ai_tbblackboard'))
        tables.set('ai.TbBlackboard', this._TbBlackboard)
        this._TbBehaviorTree = new ai.TbBehaviorTree(loader('ai_tbbehaviortree'))
        tables.set('ai.TbBehaviorTree', this._TbBehaviorTree)
        this._TbClazz = new blueprint.TbClazz(loader('blueprint_tbclazz'))
        tables.set('blueprint.TbClazz', this._TbClazz)
        this._TbDrop = new bonus.TbDrop(loader('bonus_tbdrop'))
        tables.set('bonus.TbDrop', this._TbDrop)
        this._TbGlobalConfig = new common.TbGlobalConfig(loader('common_tbglobalconfig'))
        tables.set('common.TbGlobalConfig', this._TbGlobalConfig)
        this._TbErrorInfo = new error.TbErrorInfo(loader('error_tberrorinfo'))
        tables.set('error.TbErrorInfo', this._TbErrorInfo)
        this._TbCodeInfo = new error.TbCodeInfo(loader('error_tbcodeinfo'))
        tables.set('error.TbCodeInfo', this._TbCodeInfo)
        this._TbItem = new item.TbItem(loader('item_tbitem'))
        tables.set('item.TbItem', this._TbItem)
        this._TbItemFunc = new item.TbItemFunc(loader('item_tbitemfunc'))
        tables.set('item.TbItemFunc', this._TbItemFunc)
        this._TbItemExtra = new item.TbItemExtra(loader('item_tbitemextra'))
        tables.set('item.TbItemExtra', this._TbItemExtra)
        this._TbL10NDemo = new l10n.TbL10NDemo(loader('l10n_tbl10ndemo'))
        tables.set('l10n.TbL10NDemo', this._TbL10NDemo)
        this._TbPatchDemo = new l10n.TbPatchDemo(loader('l10n_tbpatchdemo'))
        tables.set('l10n.TbPatchDemo', this._TbPatchDemo)
        this._TbSystemMail = new mail.TbSystemMail(loader('mail_tbsystemmail'))
        tables.set('mail.TbSystemMail', this._TbSystemMail)
        this._TbGlobalMail = new mail.TbGlobalMail(loader('mail_tbglobalmail'))
        tables.set('mail.TbGlobalMail', this._TbGlobalMail)
        this._TbRoleLevelExpAttr = new role.TbRoleLevelExpAttr(loader('role_tbrolelevelexpattr'))
        tables.set('role.TbRoleLevelExpAttr', this._TbRoleLevelExpAttr)
        this._TbRoleLevelBonusCoefficient = new role.TbRoleLevelBonusCoefficient(loader('role_tbrolelevelbonuscoefficient'))
        tables.set('role.TbRoleLevelBonusCoefficient', this._TbRoleLevelBonusCoefficient)
        this._TbTestTag = new tag.TbTestTag(loader('tag_tbtesttag'))
        tables.set('tag.TbTestTag', this._TbTestTag)
        this._TbFullTypes = new test.TbFullTypes(loader('test_tbfulltypes'))
        tables.set('test.TbFullTypes', this._TbFullTypes)
        this._TbSingleton = new test.TbSingleton(loader('test_tbsingleton'))
        tables.set('test.TbSingleton', this._TbSingleton)
        this._TbNotIndexList = new test.TbNotIndexList(loader('test_tbnotindexlist'))
        tables.set('test.TbNotIndexList', this._TbNotIndexList)
        this._TbMultiUnionIndexList = new test.TbMultiUnionIndexList(loader('test_tbmultiunionindexlist'))
        tables.set('test.TbMultiUnionIndexList', this._TbMultiUnionIndexList)
        this._TbMultiIndexList = new test.TbMultiIndexList(loader('test_tbmultiindexlist'))
        tables.set('test.TbMultiIndexList', this._TbMultiIndexList)
        this._TbDataFromMisc = new test.TbDataFromMisc(loader('test_tbdatafrommisc'))
        tables.set('test.TbDataFromMisc', this._TbDataFromMisc)
        this._TbMultiRowRecord = new test.TbMultiRowRecord(loader('test_tbmultirowrecord'))
        tables.set('test.TbMultiRowRecord', this._TbMultiRowRecord)
        this._TbTestMultiColumn = new test.TbTestMultiColumn(loader('test_tbtestmulticolumn'))
        tables.set('test.TbTestMultiColumn', this._TbTestMultiColumn)
        this._TbMultiRowTitle = new test.TbMultiRowTitle(loader('test_tbmultirowtitle'))
        tables.set('test.TbMultiRowTitle', this._TbMultiRowTitle)
        this._TbTestNull = new test.TbTestNull(loader('test_tbtestnull'))
        tables.set('test.TbTestNull', this._TbTestNull)
        this._TbDemoPrimitive = new test.TbDemoPrimitive(loader('test_tbdemoprimitive'))
        tables.set('test.TbDemoPrimitive', this._TbDemoPrimitive)
        this._TbTestString = new test.TbTestString(loader('test_tbteststring'))
        tables.set('test.TbTestString', this._TbTestString)
        this._TbDemoGroup = new test.TbDemoGroup(loader('test_tbdemogroup'))
        tables.set('test.TbDemoGroup', this._TbDemoGroup)
        this._TbDemoGroup_C = new test.TbDemoGroup_C(loader('test_tbdemogroup_c'))
        tables.set('test.TbDemoGroup_C', this._TbDemoGroup_C)
        this._TbDemoGroup_S = new test.TbDemoGroup_S(loader('test_tbdemogroup_s'))
        tables.set('test.TbDemoGroup_S', this._TbDemoGroup_S)
        this._TbDemoGroup_E = new test.TbDemoGroup_E(loader('test_tbdemogroup_e'))
        tables.set('test.TbDemoGroup_E', this._TbDemoGroup_E)
        this._TbTestGlobal = new test.TbTestGlobal(loader('test_tbtestglobal'))
        tables.set('test.TbTestGlobal', this._TbTestGlobal)
        this._TbTestBeRef = new test.TbTestBeRef(loader('test_tbtestberef'))
        tables.set('test.TbTestBeRef', this._TbTestBeRef)
        this._TbTestBeRef2 = new test.TbTestBeRef2(loader('test_tbtestberef2'))
        tables.set('test.TbTestBeRef2', this._TbTestBeRef2)
        this._TbTestRef = new test.TbTestRef(loader('test_tbtestref'))
        tables.set('test.TbTestRef', this._TbTestRef)
        this._TbTestSize = new test.TbTestSize(loader('test_tbtestsize'))
        tables.set('test.TbTestSize', this._TbTestSize)
        this._TbTestSet = new test.TbTestSet(loader('test_tbtestset'))
        tables.set('test.TbTestSet', this._TbTestSet)
        this._TbDetectCsvEncoding = new test.TbDetectCsvEncoding(loader('test_tbdetectcsvencoding'))
        tables.set('test.TbDetectCsvEncoding', this._TbDetectCsvEncoding)
        this._TbItem2 = new test.TbItem2(loader('test_tbitem2'))
        tables.set('test.TbItem2', this._TbItem2)
        this._TbDefineFromExcel = new test.TbDefineFromExcel(loader('test_tbdefinefromexcel'))
        tables.set('test.TbDefineFromExcel', this._TbDefineFromExcel)
        this._TbDefineFromExcelOne = new test.TbDefineFromExcelOne(loader('test_tbdefinefromexcelone'))
        tables.set('test.TbDefineFromExcelOne', this._TbDefineFromExcelOne)
        this._TbTestIndex = new test.TbTestIndex(loader('test_tbtestindex'))
        tables.set('test.TbTestIndex', this._TbTestIndex)
        this._TbTestMap = new test.TbTestMap(loader('test_tbtestmap'))
        tables.set('test.TbTestMap', this._TbTestMap)
        this._TbExcelFromJson = new test.TbExcelFromJson(loader('test_tbexcelfromjson'))
        tables.set('test.TbExcelFromJson', this._TbExcelFromJson)
        this._TbCompositeJsonTable1 = new test.TbCompositeJsonTable1(loader('test_tbcompositejsontable1'))
        tables.set('test.TbCompositeJsonTable1', this._TbCompositeJsonTable1)
        this._TbCompositeJsonTable2 = new test.TbCompositeJsonTable2(loader('test_tbcompositejsontable2'))
        tables.set('test.TbCompositeJsonTable2', this._TbCompositeJsonTable2)
        this._TbCompositeJsonTable3 = new test.TbCompositeJsonTable3(loader('test_tbcompositejsontable3'))
        tables.set('test.TbCompositeJsonTable3', this._TbCompositeJsonTable3)
        this._TbExcelFromJsonMultiRow = new test.TbExcelFromJsonMultiRow(loader('test_tbexcelfromjsonmultirow'))
        tables.set('test.TbExcelFromJsonMultiRow', this._TbExcelFromJsonMultiRow)
        this._TbTestSep = new test.TbTestSep(loader('test_tbtestsep'))
        tables.set('test.TbTestSep', this._TbTestSep)
        this._TbTestScriptableObject = new test.TbTestScriptableObject(loader('test_tbtestscriptableobject'))
        tables.set('test.TbTestScriptableObject', this._TbTestScriptableObject)
        this._TbTestExternalType = new test.TbTestExternalType(loader('test_tbtestexternaltype'))
        tables.set('test.TbTestExternalType', this._TbTestExternalType)
        this._TbDemoGroupDefineFromExcel = new test.TbDemoGroupDefineFromExcel(loader('test_tbdemogroupdefinefromexcel'))
        tables.set('test.TbDemoGroupDefineFromExcel', this._TbDemoGroupDefineFromExcel)
        this._TbDefineFromExcel2 = new test.TbDefineFromExcel2(loader('test_tbdefinefromexcel2'))
        tables.set('test.TbDefineFromExcel2', this._TbDefineFromExcel2)
        this._TbTestExcelBean = new test.TbTestExcelBean(loader('test_tbtestexcelbean'))
        tables.set('test.TbTestExcelBean', this._TbTestExcelBean)
        this._TbTestDesc = new test.TbTestDesc(loader('test_tbtestdesc'))
        tables.set('test.TbTestDesc', this._TbTestDesc)

        this._TbBlackboard.resolve(tables)
        this._TbBehaviorTree.resolve(tables)
        this._TbClazz.resolve(tables)
        this._TbDrop.resolve(tables)
        this._TbGlobalConfig.resolve(tables)
        this._TbErrorInfo.resolve(tables)
        this._TbCodeInfo.resolve(tables)
        this._TbItem.resolve(tables)
        this._TbItemFunc.resolve(tables)
        this._TbItemExtra.resolve(tables)
        this._TbL10NDemo.resolve(tables)
        this._TbPatchDemo.resolve(tables)
        this._TbSystemMail.resolve(tables)
        this._TbGlobalMail.resolve(tables)
        this._TbRoleLevelExpAttr.resolve(tables)
        this._TbRoleLevelBonusCoefficient.resolve(tables)
        this._TbTestTag.resolve(tables)
        this._TbFullTypes.resolve(tables)
        this._TbSingleton.resolve(tables)
        this._TbNotIndexList.resolve(tables)
        this._TbMultiUnionIndexList.resolve(tables)
        this._TbMultiIndexList.resolve(tables)
        this._TbDataFromMisc.resolve(tables)
        this._TbMultiRowRecord.resolve(tables)
        this._TbTestMultiColumn.resolve(tables)
        this._TbMultiRowTitle.resolve(tables)
        this._TbTestNull.resolve(tables)
        this._TbDemoPrimitive.resolve(tables)
        this._TbTestString.resolve(tables)
        this._TbDemoGroup.resolve(tables)
        this._TbDemoGroup_C.resolve(tables)
        this._TbDemoGroup_S.resolve(tables)
        this._TbDemoGroup_E.resolve(tables)
        this._TbTestGlobal.resolve(tables)
        this._TbTestBeRef.resolve(tables)
        this._TbTestBeRef2.resolve(tables)
        this._TbTestRef.resolve(tables)
        this._TbTestSize.resolve(tables)
        this._TbTestSet.resolve(tables)
        this._TbDetectCsvEncoding.resolve(tables)
        this._TbItem2.resolve(tables)
        this._TbDefineFromExcel.resolve(tables)
        this._TbDefineFromExcelOne.resolve(tables)
        this._TbTestIndex.resolve(tables)
        this._TbTestMap.resolve(tables)
        this._TbExcelFromJson.resolve(tables)
        this._TbCompositeJsonTable1.resolve(tables)
        this._TbCompositeJsonTable2.resolve(tables)
        this._TbCompositeJsonTable3.resolve(tables)
        this._TbExcelFromJsonMultiRow.resolve(tables)
        this._TbTestSep.resolve(tables)
        this._TbTestScriptableObject.resolve(tables)
        this._TbTestExternalType.resolve(tables)
        this._TbDemoGroupDefineFromExcel.resolve(tables)
        this._TbDefineFromExcel2.resolve(tables)
        this._TbTestExcelBean.resolve(tables)
        this._TbTestDesc.resolve(tables)
    }
}
