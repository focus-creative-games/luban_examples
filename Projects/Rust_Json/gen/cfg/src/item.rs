
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use serde::Deserialize;

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EMajorType {
    ///货币
    CURRENCY = 1,
    ///服装
    CLOTH = 2,
    ///任务
    QUEST = 3,
    ///消耗品
    CONSUMABLES = 4,
    ///宝箱
    TREASURE_BOX = 5,
    ///成就和称谓
    ACHIEVEMENT_AND_TITLE = 6,
    ///头像框
    HEAD_FRAME = 7,
    ///语音
    VOICE = 8,
    ///动作
    ACTION = 9,
    ///扩容道具
    EXPANSION = 10,
    ///制作材料
    MATERIAL = 11,
}

impl From<i32> for EMajorType {
    fn from(value: i32) -> Self {
        match value { 
            1 => EMajorType::CURRENCY,
            2 => EMajorType::CLOTH,
            3 => EMajorType::QUEST,
            4 => EMajorType::CONSUMABLES,
            5 => EMajorType::TREASURE_BOX,
            6 => EMajorType::ACHIEVEMENT_AND_TITLE,
            7 => EMajorType::HEAD_FRAME,
            8 => EMajorType::VOICE,
            9 => EMajorType::ACTION,
            10 => EMajorType::EXPANSION,
            11 => EMajorType::MATERIAL,
            _ => panic!("Invalid value for EMajorType:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EMinorType {
    ///钻石
    DIAMOND = 101,
    ///金币
    GOLD = 102,
    ///银币
    SILVER = 103,
    ///经验
    EXP = 104,
    ///能量点
    POWER_POINT = 105,
    ///发型
    HAIR_STYLE = 210,
    ///外套
    COAT = 220,
    ///上衣
    UPPER_JACKET = 230,
    ///裤子
    TROUSERS = 241,
    ///裙子
    SKIRT = 242,
    ///袜子
    SOCKS = 250,
    ///鞋子
    SHOES = 260,
    ///发饰
    HAIR_ACCESSORY = 271,
    ///帽子
    HAT = 272,
    ///耳饰
    EARRING = 273,
    ///颈饰
    NECKLACE = 274,
    ///腕饰
    BRACELET = 275,
    ///发箍
    HAIR_CLASP = 276,
    ///手套
    GLOVE = 277,
    ///手持物
    HANDHELD_OBJECT = 278,
    ///特殊
    SPECIAL = 279,
    ///底妆
    BASE_COSMETIC = 281,
    ///眉妆
    EYEBROW_COSMETIC = 282,
    ///睫毛
    EYELASH = 283,
    ///美瞳
    COSMETIC_CONTACT_LENSES = 284,
    ///唇妆
    LIP_COSMETIC = 285,
    ///肤色
    SKIN_COLOR = 286,
    ///连衣裙
    ONE_PIECE_DRESS = 290,
    ///换装场景
    SWITCH_CLOTHES_SCENE = 291,
    ///任务道具
    QUEST = 301,
    ///投掷物
    CAST = 401,
    ///刀剑
    SWORD = 421,
    ///弓箭
    BOW_ARROW = 422,
    ///法杖
    WANDS = 423,
    ///特殊工具
    SPECIAL_TOOL = 424,
    ///食物
    FOOD = 403,
    ///宝箱
    TREASURE_BOX = 501,
    ///钥匙
    KEY = 502,
    ///多选一宝箱
    MULTI_CHOOSE_TREASURE_BOX = 503,
    ///成就相关
    ACHIEVEMENT = 601,
    ///称谓相关
    TITLE = 602,
    ///头像框
    AVATAR_FRAME = 701,
    ///语音
    VOICE = 801,
    ///特殊待机动作
    IDLE_POSE = 901,
    ///拍照动作
    PHOTO_POSE = 902,
    ///背包
    BAG = 1001,
    ///好友数量
    FRIEND_CAPACITY = 1002,
    ///制作材料
    CONSTRUCTION_MATERIAL = 1101,
    ///设计图纸
    DESIGN_DRAWING = 1102,
}

impl From<i32> for EMinorType {
    fn from(value: i32) -> Self {
        match value { 
            101 => EMinorType::DIAMOND,
            102 => EMinorType::GOLD,
            103 => EMinorType::SILVER,
            104 => EMinorType::EXP,
            105 => EMinorType::POWER_POINT,
            210 => EMinorType::HAIR_STYLE,
            220 => EMinorType::COAT,
            230 => EMinorType::UPPER_JACKET,
            241 => EMinorType::TROUSERS,
            242 => EMinorType::SKIRT,
            250 => EMinorType::SOCKS,
            260 => EMinorType::SHOES,
            271 => EMinorType::HAIR_ACCESSORY,
            272 => EMinorType::HAT,
            273 => EMinorType::EARRING,
            274 => EMinorType::NECKLACE,
            275 => EMinorType::BRACELET,
            276 => EMinorType::HAIR_CLASP,
            277 => EMinorType::GLOVE,
            278 => EMinorType::HANDHELD_OBJECT,
            279 => EMinorType::SPECIAL,
            281 => EMinorType::BASE_COSMETIC,
            282 => EMinorType::EYEBROW_COSMETIC,
            283 => EMinorType::EYELASH,
            284 => EMinorType::COSMETIC_CONTACT_LENSES,
            285 => EMinorType::LIP_COSMETIC,
            286 => EMinorType::SKIN_COLOR,
            290 => EMinorType::ONE_PIECE_DRESS,
            291 => EMinorType::SWITCH_CLOTHES_SCENE,
            301 => EMinorType::QUEST,
            401 => EMinorType::CAST,
            421 => EMinorType::SWORD,
            422 => EMinorType::BOW_ARROW,
            423 => EMinorType::WANDS,
            424 => EMinorType::SPECIAL_TOOL,
            403 => EMinorType::FOOD,
            501 => EMinorType::TREASURE_BOX,
            502 => EMinorType::KEY,
            503 => EMinorType::MULTI_CHOOSE_TREASURE_BOX,
            601 => EMinorType::ACHIEVEMENT,
            602 => EMinorType::TITLE,
            701 => EMinorType::AVATAR_FRAME,
            801 => EMinorType::VOICE,
            901 => EMinorType::IDLE_POSE,
            902 => EMinorType::PHOTO_POSE,
            1001 => EMinorType::BAG,
            1002 => EMinorType::FRIEND_CAPACITY,
            1101 => EMinorType::CONSTRUCTION_MATERIAL,
            1102 => EMinorType::DESIGN_DRAWING,
            _ => panic!("Invalid value for EMinorType:{}", value),
        }
    }
}

///道具品质
#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EItemQuality {
    ///白
    WHITE = 0,
    ///绿
    GREEN = 1,
    ///蓝
    BLUE = 2,
    ///紫
    PURPLE = 3,
    ///金
    GOLDEN = 4,
}

impl From<i32> for EItemQuality {
    fn from(value: i32) -> Self {
        match value { 
            0 => EItemQuality::WHITE,
            1 => EItemQuality::GREEN,
            2 => EItemQuality::BLUE,
            3 => EItemQuality::PURPLE,
            4 => EItemQuality::GOLDEN,
            _ => panic!("Invalid value for EItemQuality:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct Item {
    /// 道具id
    pub id: i32,
    pub name: String,
    pub major_type: crate::item::EMajorType,
    pub minor_type: crate::item::EMinorType,
    pub max_pile_num: i32,
    pub quality: crate::item::EItemQuality,
    pub icon: String,
    pub icon_backgroud: String,
    pub icon_mask: String,
    pub desc: String,
    pub show_order: i32,
}

impl Item{
    pub fn new(json: &serde_json::Value) -> Result<Item, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let major_type = json["major_type"].as_i64().unwrap().into();
        let minor_type = json["minor_type"].as_i64().unwrap().into();
        let max_pile_num = (json["max_pile_num"].as_i64().unwrap() as i32);
        let quality = json["quality"].as_i64().unwrap().into();
        let icon = json["icon"].as_str().unwrap().to_string();
        let icon_backgroud = json["icon_backgroud"].as_str().unwrap().to_string();
        let icon_mask = json["icon_mask"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let show_order = (json["show_order"].as_i64().unwrap() as i32);
        
        Ok(Item { id, name, major_type, minor_type, max_pile_num, quality, icon, icon_backgroud, icon_mask, desc, show_order, })
    }
}


///道具表
#[derive(Debug)]
pub struct TbItem {
    pub data_list: Vec<std::sync::Arc<crate::item::Item>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::item::Item>>,
}

impl TbItem {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbItem>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::item::Item>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::item::Item>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::item::Item::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbItem { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::item::Item>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbItem {
    type Output = std::sync::Arc<crate::item::Item>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


